export declare namespace ej {
  
  export namespace base {
    
    /**
     * Ajax class provides ability to make asynchronous HTTP request to the server
     * ```typescript
     *   var ajax = new Ajax("index.html", "GET", true);
     *   ajax.send().then(
     *               function (value) {
     *                   console.log(value);
     *               },
     *               function (reason) {
     *                   console.log(reason);
     *               });
     * ```
     */
    export class Ajax {
        /**
         * Specifies the URL to which request to be sent.
         * @default null
         */
        url: string;
        /**
         * Specifies which HTTP request method to be used. For ex., GET, POST
         * @default GET
         */
        type: string;
        /**
         * Specifies the data to be sent.
         * @default null
         */
        data: string | Object;
        /**
         * A boolean value indicating whether the request should be sent asynchronous or not.
         * @default true
         */
        mode: boolean;
        /**
         * Specifies the callback for creating the XMLHttpRequest object.
         * @default null
         */
        httpRequest: XMLHttpRequest;
        private options;
        private contentType;
        private dataType;
        /**
         * Constructor for Ajax class
         * @param  {string|Object} options?
         * @param  {string} type?
         * @param  {boolean} async?
         * @returns defaultType
         */
        constructor(options?: string | Object, type?: string, async?: boolean);
        /**
         * Send the request to server.
         * @param {any} data - To send the user data
         * @return {Promise}
         */
        send(data?: string | Object): Promise<Ajax>;
        /**
         * Specifies the callback function to be triggered before sending request to sever.
         * This can be used to modify the XMLHttpRequest object before it is sent.
         * @event
         */
        beforeSend: Function;
        /**
         * Specifies callback function to be triggered after XmlHttpRequest is succeeded.
         * The callback will contain server response as the parameter.
         * @event
         */
        onSuccess: Function;
        /**
         * Triggers when XmlHttpRequest is failed.
         * @event
         */
        onFailure: Function;
        private successHandler(data);
        private failureHandler(reason);
        private stateChange(resolve, reject);
        /**
         * To get the response header from XMLHttpRequest
         * @param  {string} key Key to search in the response header
         * @returns {string}
         */
        getResponseHeader(key: string): string;
    }
    export interface HeaderOptions {
        readyState?: number;
        getResponseHeader?: Function;
        setRequestHeader?: Function;
        overrideMimeType?: Function;
    }
    
    /**
     * Interface for a class Animation
     */
    export interface AnimationModel {
    
        /**
         * Specify the type of animation
         * @default : 'FadeIn';
         */
        name?: ej.base.Effect;
    
        /**
         * Specify the duration to animate
         * @default : 400;
         */
        duration?: number;
    
        /**
         * Specify the animation timing function
         * @default : 'ease';
         */
        timingFunction?: string;
    
        /**
         * Specify the delay to start animation
         * @default : 0;
         */
        delay?: number;
    
        /**
         * Triggers when animation is in-progress
         * @event
         */
        progress?: ej.base.EmitType<AnimationOptions>;
    
        /**
         * Triggers when the animation is started
         * @event
         */
        begin?: ej.base.EmitType<AnimationOptions>;
    
        /**
         * Triggers when animation is completed
         * @event
         */
        end?: ej.base.EmitType<AnimationOptions>;
    
        /**
         * Triggers when animation is failed due to any scripts
         * @event
         */
        fail?: ej.base.EmitType<AnimationOptions>;
    
    }
    
    /**
     * Animation effect names
     */
    export type Effect = 'FadeIn' | 'FadeOut' | 'FadeZoomIn' | 'FadeZoomOut' | 'FlipLeftDownIn' | 'FlipLeftDownOut' | 'FlipLeftUpIn' | 'FlipLeftUpOut' | 'FlipRightDownIn' | 'FlipRightDownOut' | 'FlipRightUpIn' | 'FlipRightUpOut' | 'FlipXDownIn' | 'FlipXDownOut' | 'FlipXUpIn' | 'FlipXUpOut' | 'FlipYLeftIn' | 'FlipYLeftOut' | 'FlipYRightIn' | 'FlipYRightOut' | 'SlideBottomIn' | 'SlideBottomOut' | 'SlideDown' | 'SlideLeft' | 'SlideLeftIn' | 'SlideLeftOut' | 'SlideRight' | 'SlideRightIn' | 'SlideRightOut' | 'SlideTopIn' | 'SlideTopOut' | 'SlideUp' | 'ZoomIn' | 'ZoomOut';
    /**
     * The Animation framework provide options to animate the html DOM elements
     * ```typescript
     *   let animeObject = new Animation({
     *      name: 'SlideLeftIn',
     *      duration: 1000
     *   });
     *   animeObject.animate('#anime1');
     *   animeObject.animate('#anime2', { duration: 500 });
     * ```
     */
    export class Animation extends Base<HTMLElement> implements ej.base.INotifyPropertyChanged {
        /**
         * Specify the type of animation
         * @default : 'FadeIn';
         */
        name: ej.base.Effect;
        /**
         * Specify the duration to animate
         * @default : 400;
         */
        duration: number;
        /**
         * Specify the animation timing function
         * @default : 'ease';
         */
        timingFunction: string;
        /**
         * Specify the delay to start animation
         * @default : 0;
         */
        delay: number;
        /**
         * Triggers when animation is in-progress
         * @event
         */
        progress: ej.base.EmitType<AnimationOptions>;
        /**
         * Triggers when the animation is started
         * @event
         */
        begin: ej.base.EmitType<AnimationOptions>;
        /**
         * Triggers when animation is completed
         * @event
         */
        end: ej.base.EmitType<AnimationOptions>;
        /**
         * Triggers when animation is failed due to any scripts
         * @event
         */
        fail: ej.base.EmitType<AnimationOptions>;
        /**
         * @private
         */
        easing: {
            [key: string]: string;
        };
        constructor(options: AnimationModel);
        /**
         * Applies animation to the current element.
         * @param {string | HTMLElement} element - Element which needs to be animated.
         * @param {AnimationModel} options - Overriding default animation settings.
         * @return {void}
         */
        animate(element: string | HTMLElement, options?: AnimationModel): void;
        /**
         * Stop the animation effect on animated element.
         * @param {HTMLElement} element - Element which needs to be stop the animation.
         * @param {AnimationOptions} model - Handling the animation model at stop function.
         * @return {void}
         */
        static stop(element: HTMLElement, model?: AnimationOptions): void;
        /**
         * Set delay to animation element
         * @param {AnimationModel} model
         * @returns {void}
         */
        private static delayAnimation(model);
        /**
         * Triggers animation
         * @param {AnimationModel} model
         * @returns {void}
         */
        private static applyAnimation(model);
        /**
         * Returns Animation Model
         * @param {AnimationModel} options
         * @returns {AnimationModel}
         */
        private getModel(options);
        /**
         * @private
         */
        onPropertyChanged(newProp: AnimationModel, oldProp: AnimationModel): void;
        /**
         * Returns module name as animation
         * @private
         */
        getModuleName(): string;
        /**
         * @private
         */
        destroy(): void;
    }
    /**
     * Animation event argument for progress event handler
     * @private
     */
    export interface AnimationOptions extends AnimationModel {
        /**
         * Get current time-stamp in progress EventHandler
         */
        timeStamp?: number;
        /**
         * Get current animation element in progress EventHandler
         */
        element?: HTMLElement;
    }
    /**
     * Ripple provides material theme's wave effect when an element is clicked
     * ```html
     * <div id='ripple'></div>
     * <script>
     *   rippleEffect(document.getElementById('ripple'));
     * </script>
     * ```
     * @private
     * @param HTMLElement element - Target element
     * @param RippleOptions rippleOptions - Ripple options .
     */
    export function rippleEffect(element: HTMLElement, rippleOptions?: RippleOptions, done?: Function): () => void;
    /**
     * Ripple method arguments to handle ripple effect
     * @private
     */
    export interface RippleOptions {
        /**
         * Get selector child elements for ripple effect
         */
        selector?: string;
        /**
         * Get ignore elements to prevent ripple effect
         */
        ignore?: string;
        /**
         * Override the enableRipple method
         */
        rippleFlag?: boolean;
        /**
         * Set ripple effect from center position
         */
        isCenterRipple?: boolean;
        /**
         * Set ripple duration
         */
        duration?: number;
    }
    export let isRippleEnabled: boolean;
    /**
     * Animation Module provides support to enable ripple effect functionality to Essential JS 2 components.
     * @param {boolean} isRipple Specifies the boolean value to enable or disable ripple effect.
     * @returns {boolean}
     */
    export function enableRipple(isRipple: boolean): boolean;
    
    export interface DomElements extends HTMLElement {
        ej2_instances: Object[];
    }
    export interface AngularEventEmitter {
        subscribe?: (generatorOrNext?: any, error?: any, complete?: any) => any;
    }
    export type EmitType<T> = AngularEventEmitter & ((arg?: T, ...rest: any[]) => void);
    /**
     * Base library module is common module for Framework modules like touch,keyboard and etc.,
     * @private
     */
    export abstract class Base<ElementType extends HTMLElement> {
        element: ElementType;
        isDestroyed: boolean;
        protected isProtectedOnChange: boolean;
        protected properties: {
            [key: string]: Object;
        };
        protected changedProperties: {
            [key: string]: Object;
        };
        protected oldProperties: {
            [key: string]: Object;
        };
        protected refreshing: boolean;
        protected finalUpdate: Function;
        protected modelObserver: Observer;
        protected childChangedProperties: {
            [key: string]: Object;
        };
        protected abstract getModuleName(): string;
        protected abstract onPropertyChanged(newProperties: Object, oldProperties?: Object): void;
        /** Property base section */
        /**
         * Function used to set bunch of property at a time.
         * @private
         * @param  {Object} prop - JSON object which holds components properties.
         * @param  {boolean} muteOnChange? - Specifies to true when we set properties.
         */
        setProperties(prop: Object, muteOnChange?: boolean): void;
        /**
         * Calls for child element data bind
         * @param {Object} obj
         * @param {Object} parent
         * @returns {void}
         */
        private static callChildDataBind(obj, parent);
        protected clearChanges(): void;
        /**
         * Bind property changes immediately to components
         */
        dataBind(): void;
        protected saveChanges(key: string, newValue: string, oldValue: string): void;
        /** Event Base Section */
        /**
         * Adds the handler to the given event listener.
         * @param {string} eventName - A String that specifies the name of the event
         * @param {Function} listener - Specifies the call to run when the event occurs.
         * @return {void}
         */
        addEventListener(eventName: string, handler: Function): void;
        /**
         * Removes the handler from the given event listener.
         * @param {string} eventName - A String that specifies the name of the event to remove
         * @param {Function} listener - Specifies the function to remove
         * @return {void}
         */
        removeEventListener(eventName: string, handler: Function): void;
        /**
         * Triggers the handlers in the specified event.
         * @private
         * @param {string} eventName - Specifies the event to trigger for the specified component properties.
         * Can be a custom event, or any of the standard events.
         * @param {Event} eventProp - Additional parameters to pass on to the event properties
         * @return {void}
         */
        trigger(eventName: string, eventProp?: Object): void;
        /**
         * Base constructor accept options and element
         */
        constructor(options: Object, element: ElementType | string);
        /**
         * To maintain instance in base class
         */
        protected addInstance(): void;
        /**
         * To remove the instance from the element
         */
        protected destroy(): void;
    }
    
    /**
     * Get configuration details for Browser
     * @private
     */
    export class Browser {
        private static uA;
        private static extractBrowserDetail();
        /**
         * To get events from the browser
         * @param {string} event - type of event triggered.
         * @returns {Boolean}
         */
        private static getEvent(event);
        /**
         * To get the Touch start event from browser
         * @returns {string}
         */
        private static getTouchStartEvent();
        /**
         * To get the Touch end event from browser
         * @returns {string}
         */
        private static getTouchEndEvent();
        /**
         * To get the Touch move event from browser
         * @returns {string}
         */
        private static getTouchMoveEvent();
        /**
         * To get the value based on provided key and regX
         * @param {string} key
         * @param {RegExp} regX
         * @returns {Object}
         */
        private static getValue(key, regX);
        /**
         * Property specifies the userAgent of the browser. Default userAgent value is based on the browser.
         * Also we can set our own userAgent.
         */
        static userAgent: string;
        /**
         * Property is to get the browser information like Name, Version and Language
         * @returns BrowserInfo
         */
        static readonly info: BrowserInfo;
        /**
         * Property is to get whether the userAgent is based IE.
         */
        static readonly isIE: Boolean;
        /**
         * Property is to get whether the browser has touch support.
         */
        static readonly isTouch: Boolean;
        /**
         * Property is to get whether the browser has Pointer support.
         */
        static readonly isPointer: Boolean;
        /**
         * Property is to get whether the browser has MSPointer support.
         */
        static readonly isMSPointer: Boolean;
        /**
         * Property is to get whether the userAgent is device based.
         */
        static readonly isDevice: Boolean;
        /**
         * Property is to get whether the userAgent is IOS.
         */
        static readonly isIos: Boolean;
        /**
         * Property is to get whether the userAgent is Ios7.
         */
        static readonly isIos7: Boolean;
        /**
         * Property is to get whether the userAgent is Android.
         */
        static readonly isAndroid: Boolean;
        /**
         * Property is to identify whether application ran in web view.
         */
        static readonly isWebView: Boolean;
        /**
         * Property is to get whether the userAgent is Windows.
         */
        static readonly isWindows: Boolean;
        /**
         * Property is to get the touch start event. It returns event name based on browser.
         */
        static readonly touchStartEvent: string;
        /**
         * Property is to get the touch move event. It returns event name based on browser.
         */
        static readonly touchMoveEvent: string;
        /**
         * Property is to get the touch end event. It returns event name based on browser.
         */
        static readonly touchEndEvent: string;
    }
    export interface BrowserDetails {
        isAndroid?: Boolean;
        isDevice?: Boolean;
        isIE?: Boolean;
        isIos?: Boolean;
        isIos7?: Boolean;
        isMSPointer?: Boolean;
        isPointer?: Boolean;
        isTouch?: Boolean;
        isWebView?: Boolean;
        isWindows?: Boolean;
        info?: BrowserInfo;
        touchStartEvent?: string;
        touchMoveEvent?: string;
        touchEndEvent?: string;
    }
    export interface BrowserInfo {
        name?: string;
        version?: string;
        culture?: {
            name?: string;
            language?: string;
        };
    }
    
    /**
     * @private
     */
    export class CanvasRenderer {
        private canvasObj;
        /**
         * Specifies root id of the canvas element
         * @default null
         */
        private rootId;
        /**
         * Specifies the height of the canvas element.
         * @default null
         */
        height: number;
        /**
         * Specifies the width of the canvas element.
         * @default null
         */
        width: number;
        /**
         * Specifies the context of the canvas.
         * @default null
         */
        ctx: CanvasRenderingContext2D;
        /**
         * Holds the context of the rendered canvas as string.
         * @default null
         */
        dataUrl: string;
        constructor(rootID: string);
        private getOptionValue<T>(options, key);
        /**
         * To create a Html5 canvas element
         * @param {BaseAttibutes} options - Options to create canvas
         * @return {HTMLCanvasElement}
         */
        createCanvas(options: BaseAttibutes): HTMLCanvasElement;
        /**
         * To set the width and height for the Html5 canvas element
         * @param {number} width - width of the canvas
         * @param {number} height - height of the canvas
         * @return {void}
         */
        setCanvasSize(width: number, height: number): void;
        private setAttributes(options);
        /**
         * To draw a line
         * @param {LineAttributes} options - required options to draw a line on the canvas
         * @return {void}
         */
        drawLine(options: LineAttributes): void;
        /**
         * To draw a rectangle
         * @param {RectAttributes} options - required options to draw a rectangle on the canvas
         * @return {void}
         */
        drawRectangle(options: RectAttributes): void;
        private drawCornerRadius(options);
        /**
         * To draw a path on the canvas
         * @param {PathAttributes} options - options needed to draw path
         * @param {Int32Array} canvasTranslate - Array of numbers to translate the canvas
         * @return {void}
         */
        drawPath(options: PathAttributes, canvasTranslate: Int32Array): void;
        /**
         * To draw a text
         * @param {TextAttributes} options - options required to draw text
         * @param {string} label - Specifies the text which has to be drawn on the canvas
         * @return {void}
         */
        drawText(options: TextAttributes, label: string): void;
        /**
         * To draw circle on the canvas
         * @param {CircleAttributes} options - required options to draw the circle
         * @return {void}
         */
        drawCircle(options: CircleAttributes): void;
        /**
         * To draw polyline
         * @param {PolylineAttributes} options - options needed to draw polyline
         * @return {void}
         */
        drawPolyline(options: PolylineAttributes): void;
        /**
         * To draw an ellipse on the canvas
         * @param {EllipseAttributes} options - options needed to draw ellipse
         * @return {void}
         */
        drawEllipse(options: EllipseAttributes): void;
        /**
         * To draw an image
         * @param {ImageAttributes} options - options required to draw an image on the canvas
         * @return {void}
         */
        drawImage(options: ImageAttributes): void;
        /**
         * To create a linear gradient
         * @param {string[]} colors - Specifies the colors required to create linear gradient
         * @return {string}
         */
        createLinearGradient(colors: GradientColor[]): string;
        /**
         * To create a radial gradient
         * @param {string[]} colors - Specifies the colors required to create linear gradient
         * @return {string}
         */
        createRadialGradient(colors: GradientColor[]): string;
        private setGradientValues(colors, myGradient);
        /**
         * To set the attributes to the element
         * @param {SVGCanvasAttributes} options - Attributes to set for the element
         * @param {HTMLElement} element - The element to which the attributes need to be set
         * @return {HTMLElement}
         */
        setElementAttributes(options: SVGCanvasAttributes, element: HTMLElement): HTMLElement;
        /**
         * To update the values of the canvas element attributes
         * @param {SVGCanvasAttributes} options - Specifies the colors required to create gradient
         * @return {void}
         */
        updateCanvasAttributes(options: SVGCanvasAttributes): void;
    }
    
    /**
     * To detect the changes for inner properties.
     * @private
     */
    export class ChildProperty<T> {
        private parentObj;
        private controlParent;
        private propName;
        private isParentArray;
        protected properties: {
            [key: string]: Object;
        };
        protected changedProperties: {
            [key: string]: Object;
        };
        protected childChangedProperties: {
            [key: string]: Object;
        };
        protected oldProperties: {
            [key: string]: Object;
        };
        protected finalUpdate: Function;
        private callChildDataBind;
        constructor(parent: T, propName: string, defaultValue: Object, isArray?: boolean);
        /**
         * Updates the property changes
         * @param {boolean} val
         * @param {string} propName
         * @returns {void}
         */
        private updateChange(val, propName);
        /**
         * Updates time out duration
         */
        private updateTimeOut();
        /**
         * Clears changed properties
         */
        private clearChanges();
        /**
         * Set property changes
         * @param {Object} prop
         * @param {boolean} muteOnChange
         * {void}
         */
        protected setProperties(prop: Object, muteOnChange: boolean): void;
        /**
         * Binds data
         */
        protected dataBind(): void;
        /**
         * Saves changes to newer values
         * @param {string} key
         * @param {Object} newValue
         * @param {Object} oldValue
         * @returns {void}
         */
        protected saveChanges(key: string, newValue: Object, oldValue: Object): void;
    }
    
    /**
     * Interface for a class Component
     */
    export interface ComponentModel {
    
        /**
         * Enable or disable persisting component's state between page reloads.
         * @default false
         */
        enablePersistence?: boolean;
    
        /**
         * Enable or disable rendering component in right to left direction.
         * @default false
         */
        enableRtl?: boolean;
    
        /**
         * Overrides the global culture and localization value for this component. Default global culture is 'en-US'.
         * @default undefined
         */
        locale?: string;
    
    }
    
    /**
     * Base class for all Essential JavaScript components
     */
    export abstract class Component<ElementType extends HTMLElement> extends Base<ElementType> {
        element: ElementType;
        private detectFunction;
        /**
         * Enable or disable persisting component's state between page reloads.
         * @default false
         */
        enablePersistence: boolean;
        /**
         * Enable or disable rendering component in right to left direction.
         * @default false
         */
        enableRtl: boolean;
        /**
         * Overrides the global culture and localization value for this component. Default global culture is 'en-US'.
         * @default undefined
         */
        locale: string;
        protected needsID: boolean;
        protected moduleLoader: ModuleLoader;
        protected localObserver: Observer;
        protected abstract render(): void;
        protected abstract preRender(): void;
        protected abstract getPersistData(): string;
        protected injectedModules: Function[];
        protected requiredModules(): ej.base.ModuleDeclaration[];
        /**
         * Destroys the sub modules while destroying the widget
         */
        protected destroy(): void;
        /**
         * Applies all the pending property changes and render the component again.
         */
        refresh(): void;
        /**
         * Appends the component within the given HTML element
         * @param {string | HTMLElement} selector - Target element where component needs to be appended.
         */
        appendTo(selector?: string | HTMLElement): void;
        /**
         * When invoked, applies the pending property changes immediately to the component.
         */
        dataBind(): void;
        /**
         * Attach one or more  event handler to the current component context.
         * It is used for internal handling event internally within the component only.
         * @param {BoundOptions[]| string} event - It is  optional type either to  Set the collection of event list or the eventName.
         * @param {Function} handler - optional parameter Specifies the handler to run when the event occurs
         * @param {Object} context - optional parameter Specifies the context to be bind in the handler.
         * @return {void}
         * @private
         */
        on(event: BoundOptions[] | string, handler?: Function, context?: Object): void;
        /**
         * To remove one or more event handler that has been attached with the on() method.
         * @param {BoundOptions[]| string} event - It is  optional type either to  Set the collection of event list or the eventName.
         * @param {Function} handler - optional parameter Specifies the function to run when the event occurs
         * @return {void}
         * @private
         */
        off(event: BoundOptions[] | string, handler?: Function): void;
        /**
         * To notify the handlers in the specified event.
         * @param {string} property - Specifies the event to be notify.
         * @param {Object} argument - Additional parameters to pass while calling the handler.
         * @return {void}
         * @private
         */
        notify(property: string, argument: Object): void;
        /**
         * Get injected modules
         * @private
         */
        getInjectedModules(): Function[];
        /**
         * Dynamically injects the required modules to the component.
         */
        static Inject(...moduleList: Function[]): void;
        /**
         * Initialize the constructor for component base
         */
        constructor(options?: Object, selector?: string | ElementType);
        private injectModules();
        private mergePersistData();
        private setPersistData();
        protected clearTemplate(templateName?: string[]): void;
        protected addOnPersist(options: string[]): string;
        protected getActualProperties<T>(obj: T): T;
        protected ignoreOnPersist(options: string[]): string;
        protected iterateJsonProperties(obj: {
            [key: string]: Object;
        }, ignoreList: string[]): Object;
    }
    
    /**
     * Function to create Html element.
     * @param tagName - Name of the tag, id and class names.
     * @param properties - Object to set properties in the element.
     * @param properties.id - To set the id to the created element.
     * @param properties.className - To add classes to the element.
     * @param properties.innerHTML - To set the innerHTML to element.
     * @param properties.styles - To set the some custom styles to element.
     * @param properties.attrs - To set the attributes to element.
     * @private
     */
    export function createElement(tagName: string, properties?: {
        id?: string;
        className?: string;
        innerHTML?: string;
        styles?: string;
        attrs?: {
            [key: string]: string;
        };
    }): HTMLElement;
    /**
     * The function used to add the classes to array of elements
     * @param  {Element[]|NodeList} elements - An array of elements that need to add a list of classes
     * @param  {string|string[]} classes - String or array of string that need to add an individual element as a class
     * @private
     */
    export function addClass(elements: Element[] | NodeList, classes: string | string[]): Element[] | NodeList;
    /**
     * The function used to add the classes to array of elements
     * @param  {Element[]|NodeList} elements - An array of elements that need to remove a list of classes
     * @param  {string|string[]} classes - String or array of string that need to add an individual element as a class
     * @private
     */
    export function removeClass(elements: Element[] | NodeList, classes: string | string[]): Element[] | NodeList;
    /**
     * The function used to check element is visible or not.
     * @param  {Element|Node} element - An element the need to check visibility
     * @private
     */
    export function isVisible(element: Element | Node): Boolean;
    /**
     * The function used to insert an array of elements into a first of the element.
     * @param  {Element[]|NodeList} fromElements - An array of elements that need to prepend.
     * @param  {Element} toElement - An element that is going to prepend.
     * @private
     */
    export function prepend(fromElements: Element[] | NodeList, toElement: Element): Element[] | NodeList;
    /**
     * The function used to insert an array of elements into last of the element.
     * @param  {Element[]|NodeList} fromElements - An array of elements that need to append.
     * @param  {Element} toElement - An element that is going to prepend.
     * @private
     */
    export function append(fromElements: Element[] | NodeList, toElement: Element): Element[] | NodeList;
    /**
     * The function used to remove the element from the
     * @param  {Element|Node|HTMLElement} element - An element that is going to detach from the Dom
     * @private
     */
    export function detach(element: Element | Node | HTMLElement): Element;
    /**
     * The function used to remove the element from Dom also clear the bounded events
     * @param  {Element|Node|HTMLElement} element - An element remove from the Dom
     * @private
     */
    export function remove(element: Element | Node | HTMLElement): void;
    /**
     * The function helps to set multiple attributes to an element
     * @param  {Element|Node} element - An element that need to set attributes.
     * @param  {{[key:string]:string}} attributes - JSON Object that is going to as attributes.
     * @private
     */
    export function attributes(element: Element | Node, attributes: {
        [key: string]: string;
    }): Element;
    /**
     * The function selects the element from giving context.
     * @param  {string} selector - Selector string need fetch element from the
     * @param  {Document|Element=document} context - It is an optional type, That specifies a Dom context.
     * @private
     */
    export function select(selector: string, context?: Document | Element): Element;
    /**
     * The function selects an array of element from the given context.
     * @param  {string} selector - Selector string need fetch element from the
     * @param  {Document|Element=document} context - It is an optional type, That specifies a Dom context.
     * @private
     */
    export function selectAll(selector: string, context?: Document | Element): HTMLElement[];
    /**
     * Returns single closest parent element based on class selector.
     * @param  {Element} element - An element that need to find the closest element.
     * @param  {string} selector - A classSelector of closest element.
     * @private
     */
    export function closest(element: Element | Node, selector: string): Element;
    /**
     * Returns all sibling elements of the given element.
     * @param  {Element|Node} element - An element that need to get siblings.
     * @private
     */
    export function siblings(element: Element | Node): Element[];
    /**
     * set the value if not exist. Otherwise set the existing value
     * @param  {HTMLElement} element - An element to which we need to set value.
     * @param  {string} property - Property need to get or set.
     * @param  {string} value - value need to set.
     * @private
     */
    export function getAttributeOrDefault(element: HTMLElement, property: string, value: string): string;
    /**
     * Set the style attributes to Html element.
     * @param {HTMLElement} element - Element which we want to set attributes
     * @param {any} attrs - Set the given attributes to element
     * @return {void}
     * @private
     */
    export function setStyleAttribute(element: HTMLElement, attrs: {
        [key: string]: Object;
    }): void;
    /**
     * Method for add and remove classes to a dom element.
     * @param {Element} element - Element for add and remove classes
     * @param {string[]} addClasses - List of classes need to be add to the element
     * @param {string[]} removeClasses - List of classes need to be remove from the element
     * @return {void}
     * @private
     */
    export function classList(element: Element, addClasses: string[], removeClasses: string[]): void;
    /**
     * Method to check whether the element matches the given selector.
     * @param {Element} element - Element to compare with the selector.
     * @param {string} selector - String selector which element will satisfy.
     * @return {void}
     * @private
     */
    export function matches(element: Element, selector: string): boolean;
    
    /**
     * Interface for a class Position
     */
    export interface PositionModel {
    
        /**
         * Specifies the left position of cursor in draggable.
         */
        left?: number;
    
        /**
         * Specifies the left position of cursor in draggable.
         */
        top?: number;
    
    }
    
    /**
     * Interface for a class Draggable
     */
    export interface DraggableModel {
    
        /**
         * Defines the distance between the cursor and the draggable element.
         */
        cursorAt?: PositionModel;
    
        /**
         * If `clone` set to true, drag operations are performed in duplicate element of the draggable element. 
         * @default true
         */
        clone?: boolean;
    
        /**
         * Defines the parent  element in which draggable element movement will be restricted.
         */
        dragArea?: HTMLElement | string;
    
        /**
         * Specifies the callback function for drag event.
         * @event
         */
        drag?: Function;
    
        /**
         * Specifies the callback function for dragStart event.
         * @event
         */
        dragStart?: Function;
    
        /**
         * Specifies the callback function for dragStop event.
         * @event
         */
        dragStop?: Function;
    
        /**
         * Defines the minimum distance draggable element to be moved to trigger the drag operation.
         * @default 1
         */
        distance?: number;
    
        /**
         * Defines the child element selector which will act as drag handle.
         */
        handle?: string;
    
        /**
         * Defines the child element selector which will prevent dragging of element.
         */
        abort?: string;
    
        /**
         * Defines the callback function for customizing the cloned  element.
         */
        helper?: Function;
    
        /**
         * Defines the scope value to group sets of draggable and droppable items. 
         * A draggable with the same scope value will be accepted by the droppable.
         */
        scope?: string;
    
        /**
         * Specifies the dragTarget by which the clone element is positioned if not given current context element will be considered.
         * @private
         */
        dragTarget?: string;
    
        /**
         * Defines the axis to limit the draggable element drag path.The possible axis path values are   
         * * `x` - Allows drag movement in horizontal direction only. 
         * * `y` - Allows drag movement in vertical direction only.
         */
        axis?: DragDirection;
    
        /**
         * Defines the function to change the position value.
         * @private
         */
        queryPositionInfo?: Function;
    
        /**
         * Defines whether the drag clone element will be split form the cursor pointer.
         * @private
         */
        enableTailMode?: boolean;
    
        /**
         * Defines whether to skip the previous drag movement comparison.
         * @private
         */
        skipDistanceCheck?: boolean;
    
        /**
         * @private
         */
        preventDefault?: boolean;
    
    }
    
    /**
     * Specifies the Direction in which drag movement happen.
     */
    export type DragDirection = 'x' | 'y';
    /**
     * Specifies the position coordinates
     */
    export class Position extends ej.base.ChildProperty<Position> {
        /**
         * Specifies the left position of cursor in draggable.
         */
        left: number;
        /**
         * Specifies the left position of cursor in draggable.
         */
        top: number;
    }
    /**
     * Coordinates for element position
     * @private
     */
    export interface Coordinates {
        /**
         * Defines the x Coordinate of page.
         */
        pageX: number;
        /**
         * Defines the y Coordinate of page.
         */
        pageY: number;
        /**
         * Defines the x Coordinate of client.
         */
        clientX: number;
        /**
         * Defines the y Coordinate of client.
         */
        clientY: number;
    }
    /**
     * Interface to specify the drag data in the droppable.
     */
    export interface DropInfo {
        /**
         * Specifies the current draggable element
         */
        draggable?: HTMLElement;
        /**
         * Specifies the current helper element.
         */
        helper?: HTMLElement;
        /**
         * Specifies the drag target element
         */
        draggedElement?: HTMLElement;
    }
    export interface DropObject {
        target: HTMLElement;
        instance: DropOption;
    }
    /**
     * Used to access values
     * @private
     */
    export interface DragPosition {
        left: string;
        top: string;
    }
    /**
     * Used for accessing the interface.
     * @private
     */
    export interface Instance extends HTMLElement {
        /**
         * Specifies current instance collection in element
         */
        ej2_instances: {
            [key: string]: Object;
        }[];
    }
    /**
     * Droppable function to be invoked from draggable
     * @private
     */
    export interface DropOption {
        /**
         * Used to triggers over function while draggable element is over the droppable element.
         */
        intOver: Function;
        /**
         * Used to triggers out function while draggable element is out of the droppable element.
         */
        intOut: Function;
        /**
         * Used to triggers  out function while draggable element is dropped on the droppable element.
         */
        intDrop: Function;
        /**
         * Specifies the information about the drag element.
         */
        dragData: DropInfo;
        /**
         * Specifies the status of the drag of drag stop calling.
         */
        dragStopCalled: boolean;
    }
    /**
     * Drag Event arguments
     */
    export interface DragEventArgs {
        /**
         * Specifies the actual event.
         */
        event?: MouseEvent & TouchEvent;
        /**
         * Specifies the current drag element.
         */
        element?: HTMLElement;
        /**
         * Specifies the current target element.
         */
        target?: HTMLElement;
    }
    /**
     * Draggable Module provides support to enable draggable functionality in Dom Elements.
     * ```html
     * <div id='drag'>Draggable</div>
     * <script>
     * var ele = document.getElementById('drag');
     * var drag:Draggable = new Draggable(ele,{
     *     clone:false,
     *     drag: function(e) {
     *      //drag handler code.
     *      },
     *     handle:'.class'
     * });
     * </script>
     * ```
     */
    export class Draggable extends Base<HTMLElement> implements ej.base.INotifyPropertyChanged {
        /**
         * Defines the distance between the cursor and the draggable element.
         */
        cursorAt: PositionModel;
        /**
         * If `clone` set to true, drag operations are performed in duplicate element of the draggable element.
         * @default true
         */
        clone: boolean;
        /**
         * Defines the parent  element in which draggable element movement will be restricted.
         */
        dragArea: HTMLElement | string;
        /**
         * Specifies the callback function for drag event.
         * @event
         */
        drag: Function;
        /**
         * Specifies the callback function for dragStart event.
         * @event
         */
        dragStart: Function;
        /**
         * Specifies the callback function for dragStop event.
         * @event
         */
        dragStop: Function;
        /**
         * Defines the minimum distance draggable element to be moved to trigger the drag operation.
         * @default 1
         */
        distance: number;
        /**
         * Defines the child element selector which will act as drag handle.
         */
        handle: string;
        /**
         * Defines the child element selector which will prevent dragging of element.
         */
        abort: string;
        /**
         * Defines the callback function for customizing the cloned  element.
         */
        helper: Function;
        /**
         * Defines the scope value to group sets of draggable and droppable items.
         * A draggable with the same scope value will be accepted by the droppable.
         */
        scope: string;
        /**
         * Specifies the dragTarget by which the clone element is positioned if not given current context element will be considered.
         * @private
         */
        dragTarget: string;
        /**
         * Defines the axis to limit the draggable element drag path.The possible axis path values are
         * * `x` - Allows drag movement in horizontal direction only.
         * * `y` - Allows drag movement in vertical direction only.
         */
        axis: DragDirection;
        /**
         * Defines the function to change the position value.
         * @private
         */
        queryPositionInfo: Function;
        /**
         * Defines whether the drag clone element will be split form the cursor pointer.
         * @private
         */
        enableTailMode: boolean;
        /**
         * Defines whether to skip the previous drag movement comparison.
         * @private
         */
        skipDistanceCheck: boolean;
        /**
         * @private
         */
        preventDefault: boolean;
        private target;
        private initialPosition;
        private relativeXPosition;
        private relativeYPosition;
        private margin;
        private offset;
        private position;
        private dragLimit;
        private borderWidth;
        private padding;
        private pageX;
        private diffX;
        private diffY;
        private pageY;
        private helperElement;
        private hoverObject;
        private parentClientRect;
        droppables: {
            [key: string]: DropInfo;
        };
        constructor(element: HTMLElement, options?: DraggableModel);
        protected bind(): void;
        private static getDefaultPosition();
        private toggleEvents(isUnWire?);
        private initialize(evt);
        private intDragStart(evt);
        private getProcessedPositionValue(value);
        private calculateParentPosition(ele);
        private intDrag(evt);
        private getDocumentWidthHeight(str);
        private intDragStop(evt);
        private intDestroy(evt);
        onPropertyChanged(newProp: DraggableModel, oldProp: DraggableModel): void;
        getModuleName(): string;
        private setDragArea();
        private getProperTargetElement(evt);
        private getMousePosition(evt);
        private getCoordinates(evt);
        private getHelperElement(evt);
        private setGlobalDroppables(reset, drag?, helper?);
        private checkTargetElement(evt);
        private getDropInstance(ele);
        destroy(): void;
    }
    
    /**
     * Interface for a class Droppable
     */
    export interface DroppableModel {
    
        /**
         * Defines the selector for draggable element to be accepted by the droppable.
         */
        accept?: string;
    
        /**
         * Defines the scope value to group sets of draggable and droppable items. 
         * A draggable with the same scope value will only be accepted by the droppable.
         */
        scope?: string;
    
        /**
         * Specifies the callback function, which will be triggered while drag element is dropped in droppable.
         * @event
         */
        drop?: (args: DropEventArgs) => void;
    
        /**
         * Specifies the callback function, which will be triggered while drag element is moved over droppable element.
         * @event
         */
        over?: Function;
    
        /**
         * Specifies the callback function, which will be triggered while drag element is moved out of droppable element.
         * @event
         */
        out?: Function;
    
    }
    
    /**
     * Droppable arguments in drop callback.
     * @private
     */
    export interface DropData {
        /**
         * Specifies that current element can be dropped.
         */
        canDrop: boolean;
        /**
         * Specifies target to drop.
         */
        target: HTMLElement;
    }
    export interface DropEvents extends MouseEvent, TouchEvent {
        dropTarget?: HTMLElement;
    }
    /**
     * Interface for drop event args
     */
    export interface DropEventArgs {
        /**
         * Specifies the original mouse or touch  event arguments.
         */
        event?: MouseEvent & TouchEvent;
        /**
         * Specifies the target element.
         */
        target?: HTMLElement;
        /**
         *  Specifies the dropped element.
         */
        droppedElement?: HTMLElement;
        /**
         * Specifies the dragData
         */
        dragData?: DropInfo;
    }
    /**
     * Droppable Module provides support to enable droppable functionality in Dom Elements.
     * ```html
     * <div id='drop'>Droppable</div>
     * <script>
     * let ele:HTMLElement = document.getElementById('drop');
     * var drag:Droppable = new Droppable(ele,{
     *     accept:'.drop',
     *     drop: function(e) {
     *      //drop handler code.
     *     }
     * });
     * </script>
     * ```
     */
    export class Droppable extends Base<HTMLElement> implements ej.base.INotifyPropertyChanged {
        /**
         * Defines the selector for draggable element to be accepted by the droppable.
         */
        accept: string;
        /**
         * Defines the scope value to group sets of draggable and droppable items.
         * A draggable with the same scope value will only be accepted by the droppable.
         */
        scope: string;
        /**
         * Specifies the callback function, which will be triggered while drag element is dropped in droppable.
         * @event
         */
        drop: (args: DropEventArgs) => void;
        /**
         * Specifies the callback function, which will be triggered while drag element is moved over droppable element.
         * @event
         */
        over: Function;
        /**
         * Specifies the callback function, which will be triggered while drag element is moved out of droppable element.
         * @event
         */
        out: Function;
        private mouseOver;
        dragData: {
            [key: string]: DropInfo;
        };
        constructor(element: HTMLElement, options?: DroppableModel);
        protected bind(): void;
        private wireEvents();
        onPropertyChanged(newProp: DroppableModel, oldProp: DroppableModel): void;
        getModuleName(): string;
        private dragStopCalled;
        intOver(event: MouseEvent & TouchEvent, element?: Element): void;
        intOut(event: MouseEvent & TouchEvent, element?: Element): void;
        private intDrop(evt, element?);
        private isDropArea(evt, helper, element?);
        destroy(): void;
    }
    
    /**
     * EventHandler class provides option to add, remove, clear and trigger events to a HTML DOM element
     * @private
     * ```html
     * <div id="Eventdiv">  </div>
     * <script>
     *   let node: HTMLElement = document.querySelector("#Eventdiv");
     *   EventHandler.addEventListener(node, "click", function(){
     *       // click handler function code
     *   });
     *   EventHandler.addEventListener(node, "onmouseover", function(){
     *       // mouseover handler function code
     *   });
     *   EventHandler.removeEventListener(node, "click", function(){
     *       // click handler function code
     *   });
     *   eventObj.clearEvents();
     * </script>
     * ```
     */
    export class EventHandler {
        private static addOrGetEventData(element);
        /**
         * Add an event to the specified DOM element.
         * @param {any} element - Target HTML DOM element
         * @param {string} eventName - A string that specifies the name of the event
         * @param {Function} listener - Specifies the function to run when the event occurs
         * @param {Object} bindTo - A object that binds 'this' variable in the event handler
         * @param {number} debounce - Specifies at what interval given event listener should be triggered.
         * @return {Function}
         */
        static add(element: Element | HTMLElement | Document, eventName: string, listener: Function, bindTo?: Object, intDebounce?: number): Function;
        /**
         * Remove an event listener that has been attached before.
         * @param {any} element - Specifies the target html element to remove the event
         * @param {string} eventName - A string that specifies the name of the event to remove
         * @param {Function} listener - Specifies the function to remove
         * @return {void}
         */
        static remove(element: Element | HTMLElement | Document, eventName: string, listener: Function): void;
        /**
         * Clear all the event listeners that has been previously attached to the element.
         * @param {any} element - Specifies the target html element to clear the events
         * @return {void}
         */
        static clearEvents(element: Element): void;
        /**
         * Trigger particular event of the element.
         * @param {any} element - Specifies the target html element to trigger the events
         * @param {string} eventName - Specifies the event to trigger for the specified element.
         * Can be a custom event, or any of the standard events.
         * @param {any} eventProp - Additional parameters to pass on to the event properties
         * @return {void}
         */
        static trigger(element: HTMLElement, eventName: string, eventProp?: Object): void;
    }
    /**
     * Common Event argument for all base Essential JavaScript 2 Events.
     * @private
     */
    export interface BaseEventArgs {
        /**
         * Specifies name of the event.
         */
        name?: string;
    }
    
    /**
     * Specifies the observer used for external change detection.
     */
    export let onIntlChange: Observer;
    /**
     * Specifies the default rtl status for EJ2 components.
     */
    export let rightToLeft: boolean;
    /**
     * Interface for dateFormatOptions
     * @private
     */
    export interface DateFormatOptions {
        /**
         * Specifies the skeleton for date formatting.
         */
        skeleton?: string;
        /**
         * Specifies the type of date formatting either date, dateTime or time.
         */
        type?: string;
        /**
         * Specifies custom date formatting to be used.
         */
        format?: string;
    }
    /**
     * Interface for numberFormatOptions
     * @private
     */
    export interface NumberFormatOptions {
        /**
         * Specifies minimum fraction digits in formatted value.
         */
        minimumFractionDigits?: number;
        /**
         * Specifies maximum fraction digits in formatted value.
         */
        maximumFractionDigits?: number;
        /**
         * Specifies minimum significant digits in formatted value.
         */
        minimumSignificantDigits?: number;
        /**
         * Specifies maximum significant digits in formatted value.
         */
        maximumSignificantDigits?: number;
        /**
         * Specifies whether to use grouping or not in formatted value,
         */
        useGrouping?: boolean;
        /**
         * Specifies the skeleton for perform formatting.
         */
        skeleton?: string;
        /**
         * Specifies the currency code to be used for formatting.
         */
        currency?: string;
        /**
         * Specifies minimum integer digits in formatted value.
         */
        minimumIntegerDigits?: number;
        /**
         * Specifies custom number format for formatting.
         */
        format?: string;
    }
    /**
     * Specifies the CLDR data loaded for internationalization functionalities.
     * @private
     */
    export let cldrData: Object;
    /**
     * Specifies the default culture value to be considered.
     * @private
     */
    export let defaultCulture: string;
    /**
     * Specifies default currency code to be considered
     * @private
     */
    export let defaultCurrencyCode: string;
    /**
     * Internationalization class provides support to parse and format the number and date object to the desired format.
     * ```typescript
     * // To set the culture globally
     * setCulture('en-GB');
     *
     * // To set currency code globally
     * setCurrencyCode('EUR');
     *
     * //Load cldr data
     * loadCldr(gregorainData);
     * loadCldr(timeZoneData);
     * loadCldr(numbersData);
     * loadCldr(numberSystemData);
     *
     * // To use formatter in component side
     * let Intl:Internationalization = new Internationalization();
     *
     * // Date formatting
     * let dateFormatter: Function = Intl.getDateFormat({skeleton:'long',type:'dateTime'});
     * dateFormatter(new Date('11/2/2016'));
     * dateFormatter(new Date('25/2/2030'));
     * Intl.formatDate(new Date(),{skeleton:'E'});
     *
     * //Number formatting
     * let numberFormatter: Function = Intl.getNumberFormat({skeleton:'C5'})
     * numberFormatter(24563334);
     * Intl.formatNumber(123123,{skeleton:'p2'});
     *
     * // Date parser
     * let dateParser: Function = Intl.getDateParser({skeleton:'short',type:'time'});
     * dateParser('10:30 PM');
     * Intl.parseDate('10',{skeleton:'H'});
     * ```
     */
    export class Internationalization {
        culture: string;
        constructor(cultureName?: string);
        /**
         * Returns the format function for given options.
         * @param {DateFormatOptions} options - Specifies the format options in which the format function will return.
         * @returns {Function}
         */
        getDateFormat(options?: DateFormatOptions): Function;
        /**
         * Returns the format function for given options.
         * @param {NumberFormatOptions} options - Specifies the format options in which the format function will return.
         * @returns {Function}
         */
        getNumberFormat(options?: ej.base.NumberFormatOptions): Function;
        /**
         * Returns the parser function for given options.
         * @param {DateFormatOptions} options - Specifies the format options in which the parser function will return.
         * @returns {Function}
         * @private
         */
        getDateParser(options?: DateFormatOptions): Function;
        /**
         * Returns the parser function for given options.
         * @param {NumberFormatOptions} options - Specifies the format options in which the parser function will return.
         * @returns {Function}
         */
        getNumberParser(options?: ej.base.NumberFormatOptions): Function;
        /**
         * Returns the formatted string based on format options.
         * @param {Number} value - Specifies the number to format.
         * @param {NumberFormatOptions} option - Specifies the format options in which the number will be formatted.
         * @returns {string}
         */
        formatNumber(value: Number, option?: ej.base.NumberFormatOptions): string;
        /**
         * Returns the formatted date string based on format options.
         * @param {Number} value - Specifies the number to format.
         * @param {DateFormatOptions} option - Specifies the format options in which the number will be formatted.
         * @returns {string}
         */
        formatDate(value: Date, option?: DateFormatOptions): string;
        /**
         * Returns the date object for given date string and options.
         * @param {string} value - Specifies the string to parse.
         * @param {DateFormatOptions} option - Specifies the parse options in which the date string will be parsed.
         * @returns {Date}
         */
        parseDate(value: string, option?: DateFormatOptions): Date;
        /**
         * Returns the number object from the given string value and options.
         * @param {string} value - Specifies the string to parse.
         * @param {NumberFormatOptions} option - Specifies the parse options in which the  string number  will be parsed.
         * @returns {number}
         */
        parseNumber(value: string, option?: ej.base.NumberFormatOptions): number;
        /**
         * Returns Native Date Time Pattern
         * @param {DateFormatOptions} option - Specifies the parse options for resultant date time pattern.
         * @param {boolean} isExcelFormat - Specifies format value to be converted to excel pattern.
         * @returns {string}
         * @private
         */
        getDatePattern(option: DateFormatOptions, isExcelFormat?: boolean): string;
        /**
         * Returns Native Number Pattern
         * @param {NumberFormatOptions} option - Specifies the parse options for resultant number pattern.
         * @returns {string}
         * @private
         */
        getNumberPattern(option: ej.base.NumberFormatOptions): string;
        private getCulture();
    }
    /**
     * Set the default culture to all EJ2 components
     * @param {string} cultureName - Specifies the culture name to be set as default culture.
     */
    export function setCulture(cultureName: string): void;
    /**
     * Set the default currency code to all EJ2 components
     * @param {string} currencyCode Specifies the culture name to be set as default culture.
     * @returns {void}
     */
    export function setCurrencyCode(currencyCode: string): void;
    /**
     * Load the CLDR data into context
     * @param {Object[]} obj Specifies the CLDR data's to be used for formatting and parser.
     * @returns {void}
     */
    export function loadCldr(...data: Object[]): void;
    /**
     * To enable or disable RTL functionality for all components globally.
     * @param {boolean} status - Optional argument Specifies the status value to enable or disable rtl option.
     * @returns {void}
     */
    export function enableRtl(status?: boolean): void;
    /**
     * To get the numeric CLDR object for given culture
     * @param {string} locale - Specifies the locale for which numericObject to be returned.
     * @ignore
     * @private
     */
    export function getNumericObject(locale: string, type?: string): Object;
    /**
     * To get the default date CLDR object.
     * @ignore
     * @private
     */
    export function getDefaultDateObject(): Object;
    
    /**
     * Interface for a class KeyboardEvents
     */
    export interface KeyboardEventsModel {
    
        /**
         * Specifies key combination and it respective action name.
         * @default null
         */
        keyConfigs?: { [key: string]: string };
    
        /**
         * Specifies on which event keyboardEvents class should listen for key press. For ex., `keyup`, `keydown` or `keypress`
         * @default keyup
         */
        eventName?: string;
    
        /**
         * Specifies the listener when keyboard actions is performed. 
         * @event
         */
        keyAction?: ej.base.EmitType<ej.base.KeyboardEventArgs>;
    
    }
    
    export interface KeyboardEventArgs extends KeyboardEvent {
        action: string;
    }
    /**
     * KeyboardEvents class enables you to bind key action desired key combinations for ex., Ctrl+A, Delete, Alt+Space etc.
     * ```html
     * <div id='testEle'>  </div>;
     * <script>
     *   let node: HTMLElement = document.querySelector('#testEle');
     *   let kbInstance = new KeyboardEvents({
     *       element: node,
     *       keyConfigs:{ selectAll : 'ctrl+a' },
     *       keyAction: function (e:KeyboardEvent, action:string) {
     *           // handler function code
     *       }
     *   });
     * </script>
     * ```
     */
    export class KeyboardEvents extends Base<HTMLElement> implements ej.base.INotifyPropertyChanged {
        /**
         * Specifies key combination and it respective action name.
         * @default null
         */
        keyConfigs: {
            [key: string]: string;
        };
        /**
         * Specifies on which event keyboardEvents class should listen for key press. For ex., `keyup`, `keydown` or `keypress`
         * @default keyup
         */
        eventName: string;
        /**
         * Specifies the listener when keyboard actions is performed.
         * @event
         */
        keyAction: ej.base.EmitType<ej.base.KeyboardEventArgs>;
        /**
         * Initializes the KeyboardEvents
         * @param {HTMLElement} element
         * @param {KeyboardEventsModel} options
         */
        constructor(element: HTMLElement, options?: KeyboardEventsModel);
        /**
         * Unwire bound events and destroy the instance.
         * @return {void}
         */
        destroy(): void;
        /**
         * Function can be used to specify certain action if a property is changed
         * @param newProp
         * @param oldProp
         * @returns {void}
         * @private
         */
        onPropertyChanged(newProp: KeyboardEventsModel, oldProp?: KeyboardEventsModel): void;
        protected bind(): void;
        /**
         * To get the module name, returns 'keyboard'.
         * @private
         */
        getModuleName(): string;
        /**
         * Wiring event handlers to events
         */
        private wireEvents();
        /**
         * Unwiring event handlers to events
         */
        private unwireEvents();
        /**
         * To handle a key press event returns null
         */
        private keyPressHandler;
        private static configCache;
        /**
         * To get the key configuration data
         * @param {string} config - configuration data
         * returns {KeyData}
         */
        private static getKeyConfigData(config);
        private static getKeyCode(keyVal);
    }
    
    /**
     * L10n modules provides localized text for different culture.
     * ```typescript
     *
     * //load global locale object common for all components.
     * L10n.load({
     *    'fr-BE': {
     *       'button': {
     *            'check': 'vérifié'
     *        }
     *    }
     * });
     * //set globale default locale culture.
     * setCulture('fr-BE');
     * let instance: ej.base.L10n = new L10n('button', {
     *    check: 'checked'
     * });
     * //Get locale text for current property.
     * instance.getConstant('check');
     * //Change locale culture in a component.
     * instance.setLocale('en-US');
     * ```
     */
    export class L10n {
        private static locale;
        private controlName;
        private localeStrings;
        private currentLocale;
        /**
         * Constructor
         */
        constructor(controlName: string, localeStrings: Object, locale?: string);
        /**
         * Sets the locale text
         * @param {string} locale
         * @returns {void}
         */
        setLocale(locale: string): void;
        /**
         * Sets the global locale for all components.
         * @param {Object} localeObject - specifies the localeObject to be set as global locale.
         */
        static load(localeObject: Object): void;
        /**
         * Returns current locale text for the property based on the culture name and control name.
         * @param {string} propertyName - specifies the property for which localize text to be returned.
         * @return string
         */
        getConstant(prop: string): string;
        /**
         * Returns the control constant object for current object and the locale specified.
         * @param {Object} curObject
         * @param {string} locale
         * @returns {Object}
         */
        private intGetControlConstant(curObject, locale);
    }
    
    export interface ModuleDeclaration {
        args: Object[];
        member: string;
        isProperty?: boolean;
    }
    export interface IParent {
        [key: string]: any;
    }
    export class ModuleLoader {
        private parent;
        private loadedModules;
        constructor(parent: IParent);
        /**
         * Inject required modules in component library
         * @return {void}
         * @param {ej.base.ModuleDeclaration[]} requiredModules - Array of modules to be required
         * @param {Function[]} moduleList - Array of modules to be injected from sample side
         */
        inject(requiredModules: ej.base.ModuleDeclaration[], moduleList: Function[]): void;
        /**
         * To remove the created object while destroying the control
         * @return {void}
         */
        clean(): void;
        /**
         * Removes all unused modules
         * @param {ej.base.ModuleDeclaration[]} moduleList
         * @returns {void}
         */
        private clearUnusedModule(moduleList);
        /**
         * To get the name of the member.
         * @param {string} name
         * @returns {string}
         */
        private getMemberName(name);
        /**
         * Returns boolean based on whether the module specified is loaded or not
         * @param {string} modName
         * @returns {boolean}
         */
        private isModuleLoaded(modName);
    }
    
    /**
     * Method used to create property. General syntax below.
     * @param  {T} defaultValue? - Specifies the default value of property.
     * ```
     * @Property('TypeScript')
     * propertyName: Type;
     * ```
     * @private
     */
    export function Property<T>(defaultValue?: T | Object): PropertyDecorator;
    /**
     * Method used to create complex property. General syntax below.
     * @param  {T} defaultValue - Specifies the default value of property.
     * @param  {Function} type - Specifies the class type of complex object.
     * ```
     * @Complex<Type>({},Type)
     * propertyName: Type;
     * ```
     * @private
     */
    export function Complex<T>(defaultValue: T, type: Function): PropertyDecorator;
    /**
     * Method used to create complex Factory property. General syntax below.
     * @param  {Function} defaultType - Specifies the default value of property.
     * @param  {Function} type - Specifies the class factory type of complex object.
     * ```
     * @ComplexFactory(defaultType, factoryFunction)
     * propertyName: Type1 | Type2;
     * ```
     * @private
     */
    export function ComplexFactory(type: Function): PropertyDecorator;
    /**
     * Method used to create complex array property. General syntax below.
     * @param  {T[]} defaultValue - Specifies the default value of property.
     * @param  {Function} type - Specifies the class type of complex object.
     * ```
     * @Collection([], Type);
     * propertyName: Type;
     * ```
     * @private
     */
    export function Collection<T>(defaultValue: T[], type: Function): PropertyDecorator;
    /**
     * Method used to create complex factory array property. General syntax below.
     * @param  {T[]} defaultType - Specifies the default type of property.
     * @param  {Function} type - Specifies the class type of complex object.
     * ```
     * @Collection([], Type);
     * propertyName: Type;
     * ```
     * @private
     */
    export function CollectionFactory(type: Function): PropertyDecorator;
    /**
     * Method used to create event property. General syntax below.
     * @param  {Function} defaultValue? - Specifies the default value of property.
     * @param  {boolean} isComplex? - Specifies the whether it is complex object.
     * ```
     * @Event(()=>{return true;})
     * ```
     * @private
     */
    export function Event(): PropertyDecorator;
    /**
     * NotifyPropertyChanges is triggers the call back when the property has been changed.
     *
     * ```
     *  @NotifyPropertyChanges
     * class DemoClass implements ej.base.INotifyPropertyChanged {
     *
     *     @Property()
     *     property1: string;
     *
     *     dataBind: () => void;
     *
     *     constructor() { }
     *
     *     onPropertyChanged(newProp: any, oldProp: any) {
     *         // Called when property changed
     *     }
     * }
     * ```
     * @private
     */
    export function NotifyPropertyChanges(classConstructor: Function): void;
    /**
     * Interface to notify the changed properties
     */
    export interface INotifyPropertyChanged {
        onPropertyChanged(newProperties: Object, oldProperties?: Object): void;
    }
    /**
     * Method used to create builder for the components
     * @param {any} component -specifies the target component for which builder to be created.
     * @private
     */
    export function CreateBuilder<T>(component: T): Object;
    
    /**
     * Observer is used to perform event handling based the object.
     * ```
     * //Creating observer instance.
     * let observer:Observer = Observer(this);
     * let handler: Function = (a:number, b: number): number => {return a + b; }
     * //add handler to event.
     * observe.on('eventname', handler);
     * //remove handler from event.
     * observe.off('eventname', handler);
     * //notify the handlers in event.
     * observe.notify('eventname');
     * ```
     *
     */
    export interface BoundOptions {
        handler?: Function;
        context?: Object;
        event?: string;
    }
    export class Observer {
        private context;
        private boundedEvents;
        constructor(context?: Object);
        /**
         * To attach handler for given property in current context.
         * @param {string} property - specifies the name of the event.
         * @param {Function} handler - Specifies the handler function to be called while event notified.
         * @param {Object} context - Specifies the context binded to the handler.
         * @return {void}
         */
        on(property: string, handler: Function, context?: Object): void;
        /**
         * To remove handlers from a event attached using on() function.
         * @param {string} eventName - specifies the name of the event.
         * @param {Function} handler - Optional argument specifies the handler function to be called while event notified.
         * @return {void}
         */
        off(property: string, handler?: Function): void;
        /**
         * To notify the handlers in the specified event.
         * @param {string} property - Specifies the event to be notify.
         *  @param {Object} args - Additional parameters to pass while calling the handler.
         * @return {void}
         */
        notify(property: string, argument?: Object): void;
        /**
         * To destroy handlers in the event
         */
        destroy(): void;
        /**
         * Returns if the property exists.
         */
        private notExist(prop);
        /**
         * Returns if the handler is present.
         */
        private isHandlerPresent(boundedEvents, handler);
    }
    
    /**
     * This has the basic properties required for SvgRenderer and CanvasRenderer
     * @private
     */
    export interface BaseAttibutes {
        /**
         * Specifies the ID of an element 
         */
        id?: string;
        /**
         * Specifies the fill color value 
         */
        fill?: string;
        /**
         * Specifies the border color value
         */
        stroke?: string;
        /**
         * Specifies the width of the border
         */
        'stroke-width'?: number;
        /**
         * Specifies the opacity value of an element
         */
        opacity?: number;
        /**
         * Height of the element
         */
        height?: number;
        /**
         * Width of the element
         */
        width?: number;
        /**
         * X value of the element 
         */
        x?: number;
        /**
         * Y value of the element 
         */
        y?: number;
        /**
         * Specifies the dash array value of an element
         */
        'stroke-dasharray'?: string;
        /**
         * Property to specify CSS styles for the elements
         */
        style?: string;
        /**
         * Color of the element 
         */
        color?: string;
        /**
         * Specifies the name of the class
         */
        className?: string;
        /**
         * Specifies the transformation value 
         */
        transform?: string;
        /**
         * Specifies the fill opacity of a shape/element
         */
        'fill-opacity'?: number;
        /**
         * Type of pointer for an element 
         */
        pointer?: string;
        /**
         * Specifies the plot value 
         */
        plot?: string;
        /**
         * Visibility of an element 
         */
        visibility?: string;
        /**
         * Specifies the clip path of an element
         */
        'clip-path'?: string;
    }
    /**
     * This has the properties for a SVG element
     * @private
     */
    export interface SVGAttributes extends BaseAttibutes {
        /**
         * View box property of an element
         */
        viewBox?: string;
        /**
         * Specifies the xmlns link property of a SVG element 
         */
        xmlns?: string;
    }
    /**
     * Properties required to render a circle
     * @private
     */
    export interface CircleAttributes extends BaseAttibutes {
        /**
         * Center x value of a circle
         */
        cx?: number;
        /**
         * Center y value of a circle
         */
        cy?: number;
        /**
         * Radius value of a circle
         */
        r?: number;
    }
    /**
     * Properties required to render a line
     * @private
     */
    export interface LineAttributes extends BaseAttibutes {
        /**
         * Specifies the value of x1
         */
        x1?: number;
        /**
         * Specifies the value of x2
         */
        x2?: number;
        /**
         * Specifies the value of y1
         */
        y1?: number;
        /**
         * Specifies the value of y2
         */
        y2?: number;
    }
    /**
     * Properties required to render a rectangle
     * @private
     */
    export interface RectAttributes extends BaseAttibutes {
        /**
         * Corner radius value of a rectangle
         */
        rx?: number;
    }
    /**
     * Properties required to render path
     * @private
     */
    export interface PathAttributes extends BaseAttibutes {
        /**
         * Specifies the d value of a path
         */
        d?: string;
        /**
         * Inner radius value of a path
         */
        innerR?: number;
        /**
         * Value of cx in path
         */
        cx?: number;
        /**
         * Value of cy in path
         */
        cy?: number;
        /**
         * Radius value of a path
         */
        r?: number;
        /**
         * Specifies the start value
         */
        start?: number;
        /**
         * Specifies the end value
         */
        end?: number;
        /**
         * Specifies the radius value
         */
        radius?: number;
        /**
         * Specifies the direction of path
         */
        counterClockWise?: boolean;
    }
    /**
     * Properties required to render a polyline
     * @private
     */
    export interface PolylineAttributes extends BaseAttibutes {
        /**
         * Points required to draw a polyline
         */
        points?: string;
    }
    /**
     * Properties required to render ellipse
     * @private
     */
    export interface EllipseAttributes extends CircleAttributes {
        /**
         * Specifies the rx value
         */
        rx?: number;
        /**
         * Specifies the ry value
         */
        ry?: number;
    }
    /**
     * Properties required to render a pattern
     * @private
     */
    export interface PatternAttributes extends BaseAttibutes {
        /**
         * Units to render a pattern
         */
        patternUnits?: string;
    }
    /**
     * Properties required to render an image
     * @private
     */
    export interface ImageAttributes extends BaseAttibutes {
        /**
         * Specifies the link to render it as image
         */
        href?: string;
        /**
         * Ratio value to render an image
         */
        preserveAspectRatio?: string;
    }
    /**
     * Properties required to render text
     * @private
     */
    export interface TextAttributes extends BaseAttibutes {
        /**
         * Size of the text
         */
        'font-size'?: string;
        /**
         * Font family of the text
         */
        'font-family'?: string;
        /**
         * Font style of the text
         */
        'font-style'?: string;
        /**
         * Weight of the text
         */
        'font-weight'?: string;
        /**
         * Specifies the text anchor value
         */
        'text-anchor'?: string;
        /**
         * Specifies the baseline value
         */
        'baseline'?: string;
        /**
         * Angle of rotation
         */
        'labelRotation'?: number;
    }
    /**
     * Properties required to render radial gradient
     * @private
     */
    export interface RadialGradient {
        /**
         * Specifies the id of the radial gradient
         */
        id?: string;
        /**
         * Specifies the cx value
         */
        cx?: string;
        /**
         * Specifies the cy value
         */
        cy?: string;
        /**
         * Specifies the radius value
         */
        r?: string;
        /**
         * Specifies the fx value
         */
        fx?: string;
        /**
         * Specifies the fy value
         */
        fy?: string;
    }
    /**
     * Properties required to render linear gradient
     * @private
     */
    export interface LinearGradient {
        /**
         * Id of the linear gradient
         */
        id?: string;
        /**
         * Specifies the x1 value
         */
        x1?: string;
        /**
         * Specifies the x2 value
         */
        x2?: string;
        /**
         * Specifies the y1 value
         */
        y1?: string;
        /**
         * Specifies the y2 value
         */
        y2?: string;
    }
    /**
     * Properties required to render a circle
     */
    export interface SVGCanvasAttributes {
        /**
         * To specify a new property
         */
        [key: string]: string;
    }
    /**
     * Properties required to render a gradient
     * @private
     */
    export interface GradientColor {
        /**
         * Specifies the color value of the gradient
         */
        color?: string;
        /**
         * Specifies the colorstop value of the gradient
         */
        colorStop?: string;
    }
    
    export class SvgRenderer {
        private svgLink;
        private svgObj;
        private rootId;
        /**
         * Specifies the height of the canvas element.
         * @default null
         */
        height: number;
        /**
         * Specifies the width of the canvas element.
         * @default null
         */
        width: number;
        constructor(rootID: string);
        private getOptionValue<T>(options, key);
        /**
         * To create a Html5 SVG element
         * @param {SVGAttributes} options - Options to create SVG
         * @return {Element}
         */
        createSvg(options: SVGAttributes): Element;
        private setSVGSize(width, height);
        /**
         * To draw a path
         * @param {PathAttributes} options - Options to draw a path in SVG
         * @return {Element}
         */
        drawPath(options: PathAttributes): Element;
        /**
         * To draw a line
         * @param {LineAttributes} options - Options to draw a line in SVG
         * @return {Element}
         */
        drawLine(options: LineAttributes): Element;
        /**
         * To draw a rectangle
         * @param {BaseAttibutes} options - Required options to draw a rectangle in SVG
         * @return {Element}
         */
        drawRectangle(options: RectAttributes): Element;
        /**
         * To draw a circle
         * @param {CircleAttributes} options - Required options to draw a circle in SVG
         * @return {Element}
         */
        drawCircle(options: CircleAttributes): Element;
        /**
         * To draw a polyline
         * @param {PolylineAttributes} options - Options required to draw a polyline
         * @return {Element}
         */
        drawPolyline(options: PolylineAttributes): Element;
        /**
         * To draw an ellipse
         * @param {EllipseAttributes} options - Options required to draw an ellipse
         * @return {Element}
         */
        drawEllipse(options: EllipseAttributes): Element;
        /**
         * To draw a polygon
         * @param {PolylineAttributes} options - Options needed to draw a polygon in SVG
         * @return {Element}
         */
        drawPolygon(options: PolylineAttributes): Element;
        /**
         * To draw an image
         * @param {ImageAttributes} options - Required options to draw an image in SVG
         * @return {Element}
         */
        drawImage(options: ImageAttributes): Element;
        /**
         * To draw a text
         * @param {TextAttributes} options - Options needed to draw a text in SVG
         * @return {Element}
         */
        createText(options: TextAttributes, label: string): Element;
        /**
         * To create a tSpan
         * @param {TextAttributes} options - Options to create tSpan
         * @param {string} label - The text content which is to be rendered in the tSpan
         * @return {Element}
         */
        createTSpan(options: TextAttributes, label: string): Element;
        /**
         * To create a title
         * @param {string} text - The text content which is to be rendered in the title
         * @return {Element}
         */
        createTitle(text: string): Element;
        /**
         * To create defs element in SVG
         * @return {Element}
         */
        createDefs(): Element;
        /**
         * To create clip path in SVG
         * @param {BaseAttibutes} options - Options needed to create clip path
         * @return {Element}
         */
        createClipPath(options: BaseAttibutes): Element;
        /**
         * To create foreign object in SVG
         * @param {BaseAttibutes} options - Options needed to create foreign object
         * @return {Element}
         */
        createForeignObject(options: BaseAttibutes): Element;
        /**
         * To create group element in SVG
         * @param {BaseAttibutes} options - Options needed to create group
         * @return {Element}
         */
        createGroup(options: BaseAttibutes): Element;
        /**
         * To create pattern in SVG
         * @param {PatternAttributes} options - Required options to create pattern in SVG
         * @param {string} type - Specifies the name of the pattern
         * @return {Element}
         */
        createPattern(options: PatternAttributes, element: string): Element;
        /**
         * To create radial gradient in SVG
         * @param {string[]} colors - Specifies the colors required to create radial gradient
         * @param {string[]} colorStop - Specifies the colorstop required to create radial gradient
         * @param {string} name - Specifies the name of the gradient
         * @param {RadialGradient} options - value for radial gradient
         * @return {string}
         */
        createRadialGradient(colors: GradientColor[], name: string, options: RadialGradient): string;
        /**
         * To create linear gradient in SVG
         * @param {string[]} colors - Array of string specifies the values for color
         * @param {string[]} colors - Array of string specifies the values for colorStop
         * @param {string} name - Specifies the name of the gradient
         * @param {LinearGradient} options - Specifies the options for gradient
         * @return {string}
         */
        createLinearGradient(colors: GradientColor[], name: string, options: LinearGradient): string;
        /**
         * To render the gradient element in SVG
         * @param {string} gradientType - Specifies the type of the gradient
         * @param {RadialGradient | LinearGradient} options - Options required to render a gradient
         * @param {string[]} colors - Array of string specifies the values for color
         * @param {string[]} colorStop - Array of string specifies the values for colorStop
         * @return {Element}
         */
        drawGradient(gradientType: string, options: RadialGradient | LinearGradient, colors: GradientColor[]): Element;
        /**
         * To render a clip path
         * @param {BaseAttibutes} options - Options required to render a clip path
         * @return {Element}
         */
        drawClipPath(options: BaseAttibutes): Element;
        /**
         * To create circular clip path in SVG
         * @param {CircleAttributes} options - Options required to create circular clip path
         * @return {Element}
         */
        drawCircularClipPath(options: CircleAttributes): Element;
        /**
         * To set the attributes to the element
         * @param {SVGCanvasAttributes} options - Attributes to set for the element
         * @param {Element} element - The element to which the attributes need to be set
         * @return {Element}
         */
        setElementAttributes(options: SVGCanvasAttributes, element: Element): Element;
    }
    
    /**
     * Interface for Template Engine.
     */
    export interface ITemplateEngine {
        compile: (templateString: string, helper?: Object) => (data: Object | JSON) => string;
    }
    /**
     * Compile the template string into template function.
     * @param  {string} templateString - The template string which is going to convert.
     * @param  {Object} helper? - Helper functions as an object.
     * @private
     */
    export function compile(templateString: string, helper?: Object): (data: Object | JSON, component?: any, propName?: any) => HTMLCollection;
    /**
     * Set your custom template engine for template rendering.
     * @param  {ITemplateEngine} classObj - Class object for custom template.
     * @private
     */
    export function setTemplateEngine(classObj: ITemplateEngine): void;
    /**
     * Get current template engine for template rendering.
     * @param  {ITemplateEngine} classObj - Class object for custom template.
     * @private
     */
    export function getTemplateEngine(): (template: string, helper?: Object) => (data: Object | JSON) => string;
    
    /**
     * The function to set regular expression for template expression string.
     * @param  {RegExp} value - Value expression.
     * @private
     */
    export function expression(value?: RegExp): RegExp;
    /**
     * Compile the template string into template function.
     * @param  {string} template - The template string which is going to convert.
     * @param  {Object} helper? - Helper functions as an object.
     * @private
     */
    export function compile(template: string, helper?: Object): () => string;
    
    /**
     * Interface for a class SwipeSettings
     * @private
     */
    export interface SwipeSettingsModel {
    
        /**
         * Property specifies minimum distance of swipe moved.
         */
        swipeThresholdDistance?: number;
    
    }
    
    /**
     * Interface for a class Touch
     */
    export interface TouchModel {
    
        /**
         * Specifies the callback function for tap event.
         * @event
         */
        tap?: ej.base.EmitType<TapEventArgs>;
    
        /**
         * Specifies the callback function for tapHold event.
         * @event
         */
        tapHold?: ej.base.EmitType<TapEventArgs>;
    
        /**
         * Specifies the callback function for swipe event.
         * @event
         */
        swipe?: ej.base.EmitType<SwipeEventArgs>;
    
        /**
         * Specifies the callback function for scroll event.
         * @event
         */
        scroll?: ej.base.EmitType<ScrollEventArgs>;
    
        /**
         * Specifies the time delay for tap.
         * @default 350
         */
        tapThreshold?: number;
    
        /**
         * Specifies the time delay for tap hold.
         * @default 750
         */
        tapHoldThreshold?: number;
    
        /**
         * Customize the swipe event configuration.
         * @default { swipeThresholdDistance: 50 }
         */
        swipeSettings?: SwipeSettingsModel;
    
    }
    
    /**
     * SwipeSettings is a framework module that provides support to handle swipe event like swipe up, swipe right, etc..,
     * @private
     */
    export class SwipeSettings extends ej.base.ChildProperty<SwipeSettings> {
        /**
         * Property specifies minimum distance of swipe moved.
         */
        swipeThresholdDistance: number;
    }
    /**
     * Touch class provides support to handle the touch event like tap, double tap, tap hold, etc..,
     * ```typescript
     *    let node: HTMLElement;
     * let touchObj: Touch = new Touch({
     *    element: node,
     *    tap: function (e) {
     *        // tap handler function code
     *    }
     *    tapHold: function (e) {
     *        // tap hold handler function code
     *    }
     *    scroll: function (e) {
     *        // scroll handler function code
     *    }
     *    swipe: function (e) {
     *        // swipe handler function code
     *    }
     * });
     * ```
     */
    export class Touch extends Base<HTMLElement> implements ej.base.INotifyPropertyChanged {
        private isTouchMoved;
        private startPoint;
        private movedPoint;
        private endPoint;
        private startEventData;
        private lastTapTime;
        private lastMovedPoint;
        private scrollDirection;
        private hScrollLocked;
        private vScrollLocked;
        private defaultArgs;
        private distanceX;
        private distanceY;
        private movedDirection;
        private tStampStart;
        private touchAction;
        private timeOutTap;
        private modeClear;
        private timeOutTapHold;
        /**
         * Specifies the callback function for tap event.
         * @event
         */
        tap: ej.base.EmitType<TapEventArgs>;
        /**
         * Specifies the callback function for tapHold event.
         * @event
         */
        tapHold: ej.base.EmitType<TapEventArgs>;
        /**
         * Specifies the callback function for swipe event.
         * @event
         */
        swipe: ej.base.EmitType<SwipeEventArgs>;
        /**
         * Specifies the callback function for scroll event.
         * @event
         */
        scroll: ej.base.EmitType<ScrollEventArgs>;
        /**
         * Specifies the time delay for tap.
         * @default 350
         */
        tapThreshold: number;
        /**
         * Specifies the time delay for tap hold.
         * @default 750
         */
        tapHoldThreshold: number;
        /**
         * Customize the swipe event configuration.
         * @default { swipeThresholdDistance: 50 }
         */
        swipeSettings: SwipeSettingsModel;
        private tapCount;
        constructor(element: HTMLElement, options?: TouchModel);
        /**
         * @private
         * @param newProp
         * @param oldProp
         */
        onPropertyChanged(newProp: TouchModel, oldProp: TouchModel): void;
        protected bind(): void;
        /**
         * To destroy the touch instance.
         * @return {void}
         */
        destroy(): void;
        private wireEvents();
        private unwireEvents();
        /**
         * Returns module name as touch
         * @returns {string}
         * @private
         */
        getModuleName(): string;
        /**
         * Returns if the HTML element is Scrollable.
         * @param {HTMLElement} element - HTML Element to check if Scrollable.
         * @returns {boolean}
         */
        private isScrollable(element);
        private startEvent;
        private moveEvent;
        private tapHoldEvent(evt);
        private endEvent;
        private calcPoints(evt);
        private calcScrollPoints(evt);
        private getVelocity(pnt);
        private checkSwipe(ele, flag);
    }
    /**
     * The argument type of `Tap` Event
     * @private
     */
    export interface TapEventArgs extends ej.base.BaseEventArgs {
        /**
         * Original native event Object.
         */
        originalEvent: TouchEventArgs | MouseEventArgs;
        /**
         * Tap Count.
         */
        tapCount?: number;
    }
    /**
     * The argument type of `Scroll` Event
     * @private
     */
    export interface ScrollEventArgs extends ej.base.BaseEventArgs {
        /**
         * Event argument for start event.
         */
        startEvents: TouchEventArgs | MouseEventArgs;
        /**
         * Original native event object for scroll.
         */
        originalEvent: TouchEventArgs | MouseEventArgs;
        /**
         * X position when scroll started.
         */
        startX: number;
        /**
         * Y position when scroll started.
         */
        startY: number;
        /**
         * The direction scroll.
         */
        scrollDirection: string;
        /**
         * The total traveled distance from X position
         */
        distanceX: number;
        /**
         * The total traveled distance from Y position
         */
        distanceY: number;
        /**
         * The velocity of scroll.
         */
        velocity: number;
    }
    /**
     * The argument type of `Swipe` Event
     * @private
     */
    export interface SwipeEventArgs extends ej.base.BaseEventArgs {
        /**
         * Event argument for start event.
         */
        startEvents: TouchEventArgs | MouseEventArgs;
        /**
         * Original native event object  for swipe.
         */
        originalEvent: TouchEventArgs | MouseEventArgs;
        /**
         * X position when swipe started.
         */
        startX: number;
        /**
         * Y position when swipe started.
         */
        startY: number;
        /**
         * The direction swipe.
         */
        swipeDirection: string;
        /**
         * The total traveled distance from X position
         */
        distanceX: number;
        /**
         * The total traveled distance from Y position
         */
        distanceY: number;
        /**
         * The velocity of swipe.
         */
        velocity: number;
    }
    export interface TouchEventArgs extends MouseEvent {
        /**
         * A TouchList with touched points.
         */
        changedTouches: MouseEventArgs[] | TouchEventArgs[];
        /**
         * Cancel the default action.
         */
        preventDefault(): void;
        /**
         * The horizontal coordinate point of client area.
         */
        clientX: number;
        /**
         * The vertical coordinate point of client area.
         */
        clientY: number;
    }
    export interface MouseEventArgs extends MouseEvent {
        /**
         * A TouchList with touched points.
         */
        changedTouches: MouseEventArgs[] | TouchEventArgs[];
        /**
         * Cancel the default action.
         */
        preventDefault(): void;
        /**
         * The horizontal coordinate point of client area.
         */
        clientX: number;
        /**
         * The vertical coordinate point of client area.
         */
        clientY: number;
    }
    
    /**
     * Common utility methods
     */
    export interface IKeyValue extends CSSStyleDeclaration {
        [key: string]: any;
    }
    /**
     * Create Instance from constructor function with desired parameters.
     * @param {Function} classFunction - Class function to which need to create instance
     * @param {any[]} params - Parameters need to passed while creating instance
     * @return {any}
     * @private
     */
    export function createInstance(classFunction: Function, params: any[]): any;
    /**
     * To run a callback function immediately after the browser has completed other operations.
     * @param {Function} handler - callback function to be triggered.
     * @return {Function}
     * @private
     */
    export function setImmediate(handler: Function): Function;
    /**
     * To get nameSpace value from the desired object.
     * @param {string} nameSpace - String value to the get the inner object
     * @param {any} obj - Object to get the inner object value.
     * @return {any}
     * @private
     */
    export function getValue(nameSpace: string, obj: any): any;
    /**
     * To set value for the nameSpace in desired object.
     * @param {string} nameSpace - String value to the get the inner object
     * @param {any} value - Value that you need to set.
     * @param {any} obj - Object to get the inner object value.
     * @return {void}
     * @private
     */
    export function setValue(nameSpace: string, value: any, obj: any): any;
    /**
     * Delete an item from Object
     * @param {any} obj - Object in which we need to delete an item.
     * @param {string} params - String value to the get the inner object
     * @return {void}
     * @private
     */
    export function deleteObject(obj: any, key: string): void;
    /**
     * Check weather the given argument is only object.
     * @param {any} obj - Object which is need to check.
     * @return {boolean}
     * @private
     */
    export function isObject(obj: any): boolean;
    /**
     * To get enum value by giving the string.
     * @param {any} enumObject - Enum object.
     * @param {string} enumValue - Enum value to be searched
     * @return {any}
     * @private
     */
    export function getEnumValue(enumObject: any, enumValue: string | number): any;
    /**
     * Merge the source object into destination object.
     * @param {any} source - source object which is going to merge with destination object
     * @param {any} destination - object need to be merged
     * @return {void}
     * @private
     */
    export function merge(source: Object, destination: Object): void;
    /**
     * Extend the two object with newer one.
     * @param {any} copied - Resultant object after merged
     * @param {Object} first - First object need to merge
     * @param {Object} second - Second object need to merge
     * @return {Object}
     * @private
     */
    export function extend(copied: Object, first: Object, second?: Object, deep?: boolean): Object;
    /**
     * To check whether the object is null or undefined.
     * @param {Object} value - To check the object is null or undefined
     * @return {boolean}
     * @private
     */
    export function isNullOrUndefined(value: Object): boolean;
    /**
     * To check whether the object is undefined.
     * @param {Object} value - To check the object is undefined
     * @return {boolean}
     * @private
     */
    export function isUndefined(value: Object): boolean;
    /**
     * To return the generated unique name
     * @param {string} definedName - To concatenate the unique id to provided name
     * @return {string}
     * @private
     */
    export function getUniqueID(definedName?: string): string;
    /**
     * It limits the rate at which a function can fire. The function will fire only once every provided second instead of as quickly.
     * @param {Function} eventFunction - Specifies the function to run when the event occurs
     * @param {number} delay - A number that specifies the milliseconds for function delay call option
     * @return {Function}
     * @private
     */
    export function debounce(eventFunction: Function, delay: number): Function;
    /**
     * To convert the object to string for query url
     * @param  {Object} data
     * @returns string
     * @private
     */
    export function queryParams(data: any): string;
    /**
     * To check whether the given array contains object.
     * @param {T[]} value- Specifies the T type array to be checked.
     * @private
     */
    export function isObjectArray<T>(value: T[]): boolean;
    /**
     * To check whether the  child element is descendant to parent element or parent and child are same element.
     * @param{Element} - Specifies the child element to compare with parent.
     * @param{Element} - Specifies the parent element.
     * @return boolean
     * @private
     */
    export function compareElementParent(child: Element, parent: Element): boolean;
    /**
     * To throw custom error message.
     * @param{string} - Specifies the error message to be thrown.
     * @private
     */
    export function throwError(message: string): void;
    /**
     * This function is used to print given element
     * @param{Element} element - Specifies the print content element.
     * @param{Window} printWindow - Specifies the print window.
     * @private
     */
    export function print(element: Element, printWindow?: Window): Window;
    /**
     * Function to normalize the units applied to the element.
     * @param  {number|string} value
     * @return {string} result
     * @private
     */
    export function formatUnit(value: number | string): string;
    /**
     * Function to fetch the Instances of a HTML element for the given component.
     * @param {string | HTMLElement} element
     * @param {any} component
     * @return {Object} inst
     * @private
     */
    export function getInstance(element: string | HTMLElement, component: any): Object;
    /**
     * Function to add instances for the given element.
     * @param {string | HTMLElement} element
     * @param {Object} instance
     * @return {void}
     * @private
     */
    export function addInstance(element: string | HTMLElement, instance: Object): void;
    
    export const basicPatterns: string[];
    /**
     * Interface for Date Format Options Module.
     * @private
     */
    export interface FormatOptions {
        month?: Object;
        weekday?: Object;
        pattern?: string;
        designator?: Object;
        timeZone?: any;
        era?: Object;
        hour12?: boolean;
        numMapper?: NumberMapper;
        dateSeperator?: string;
    }
    export const datePartMatcher: {
        [key: string]: Object;
    };
    /**
     * Date Format is a framework provides support for date formatting.
     * @private
     */
    export class DateFormat {
        /**
         * Returns the formatter function for given skeleton.
         * @param {string} -  Specifies the culture name to be which formatting.
         * @param {DateFormatOptions} - Specific the format in which date  will format.
         * @param {cldr} - Specifies the global cldr data collection.
         * @return Function.
         */
        static dateFormat(culture: string, option: DateFormatOptions, cldr: Object): Function;
        /**
         * Returns formatted date string based on options passed.
         * @param {Date} value
         * @param {FormatOptions} options
         */
        private static intDateFormatter(value, options);
        /**
         * Returns two digit numbers for given value and length
         */
        private static checkTwodigitNumber(val, len);
        /**
         * Returns the value of the Time Zone.
         * @param {number} tVal
         * @param {string} pattern
         * @private
         */
        static getTimeZoneValue(tVal: number, pattern: string): string;
    }
    
    /**
     * Date Parser.
     * @private
     */
    export class DateParser {
        /**
         * Returns the parser function for given skeleton.
         * @param {string} -  Specifies the culture name to be which formatting.
         * @param {DateFormatOptions} - Specific the format in which string date  will be parsed.
         * @param {cldr} - Specifies the global cldr data collection.
         *  @return Function.
         */
        static dateParser(culture: string, option: DateFormatOptions, cldr: Object): Function;
        /**
         * Returns date object for provided date options
         * @param {DateParts} options
         * @param {Date} value
         * @returns {Date}
         */
        private static getDateObject(options, value?);
        /**
         * Returns date parsing options for provided value along with parse and numeric options
         * @param {string} value
         * @param {ParseOptions} parseOptions
         * @param {NumericOptions} num
         * @returns {DateParts}
         */
        private static internalDateParse(value, parseOptions, num);
        /**
         * Returns parsed number for provided Numeric string and Numeric Options
         * @param {string} value
         * @param {NumericOptions} option
         * @returns {number}
         */
        private static internalNumberParser(value, option);
        /**
         * Returns parsed time zone RegExp for provided hour format and time zone
         * @param {string} hourFormat
         * @param {base.TimeZoneOptions} tZone
         * @param {string} nRegex
         * @returns {string}
         */
        private static parseTimeZoneRegx(hourFormat, tZone, nRegex);
        /**
         * Returns zone based value.
         * @param {boolean} flag
         * @param {string} val1
         * @param {string} val2
         * @param {NumericOptions} num
         * @returns {number}
         */
        private static getZoneValue(flag, val1, val2, num);
    }
    
    /**
     * Date base common constants and function for date parser and formatter.
     */
    export namespace IntlBase {
        const negativeDataRegex: RegExp;
        const customRegex: RegExp;
        const latnParseRegex: RegExp;
        const defaultCurrency: string;
        interface NumericSkeleton {
            type?: string;
            isAccount?: boolean;
            fractionDigits?: number;
        }
        interface GenericFormatOptions {
            nData?: NegativeData;
            pData?: NegativeData;
            zeroData?: NegativeData;
        }
        interface GroupSize {
            primary?: number;
            secondary?: number;
        }
        interface NegativeData extends FormatParts {
            nlead?: string;
            nend?: string;
            groupPattern?: string;
            minimumFraction?: number;
            maximumFraction?: number;
        }
        const formatRegex: RegExp;
        const dateParseRegex: RegExp;
        const basicPatterns: string[];
        interface Dependables {
            parserObject?: Object;
            dateObject?: Object;
            numericObject?: Object;
        }
        interface TimeZoneOptions {
            hourFormat?: string;
            gmtFormat?: string;
            gmtZeroFormat?: string;
        }
        const defaultObject: Object;
        const monthIndex: Object;
        /**
         *
         */
        const month: string;
        const days: string;
        /**
         * Default numerber Object
         */
        const patternMatcher: {
            [key: string]: Object;
        };
        /**
         * Returns the resultant pattern based on the skeleton, dateObject and the type provided
         * @private
         * @param {string} skeleton
         * @param {Object} dateObject
         * @param {string} type
         * @returns {string}
         */
        function getResultantPattern(skeleton: string, dateObject: Object, type: string): string;
        /**
         * Returns the dependable object for provided cldr data and culture
         * @private
         * @param {Object} cldr
         * @param {string} culture
         * @param {boolean} isNumber
         * @returns {Dependables}
         */
        function getDependables(cldr: Object, culture: string, isNumber?: boolean): Dependables;
        /**
         * Returns the symbol pattern for provided parameters
         * @private
         * @param {string} type
         * @param {string} numSystem
         * @param {Object} obj
         * @param {boolean} isAccount
         * @returns {string}
         */
        function getSymbolPattern(type: string, numSystem: string, obj: Object, isAccount: boolean): string;
        /**
         * Returns proper numeric skeleton
         * @private
         * @param {string} skeleton
         * @returns {NumericSkeleton}
         */
        function getProperNumericSkeleton(skeleton: string): NumericSkeleton;
        /**
         * Returns format data for number formatting like minimum fraction, maximum fraction, etc..,
         * @private
         * @param {string} pattern
         * @param {boolean} needFraction
         * @param {string} cSymbol
         * @param {boolean} fractionOnly
         * @returns {NegativeData}
         */
        function getFormatData(pattern: string, needFraction: boolean, cSymbol: string, fractionOnly?: boolean): NegativeData;
        /**
         * Returns currency symbol based on currency code
         * @private
         * @param {Object} numericObject
         * @param {string} currencyCode
         * @returns {string}
         */
        function getCurrencySymbol(numericObject: Object, currencyCode: string): string;
        /**
         * Returns formatting options for custom number format
         * @private
         * @param {string} format
         * @param {CommonOptions} dOptions
         * @param {Dependables} obj
         * @returns {GenericFormatOptions}
         */
        function customFormat(format: string, dOptions: CommonOptions, obj: Dependables): GenericFormatOptions;
        /**
         * Returns formatting options for currency or percent type
         * @private
         * @param {string[]} parts
         * @param {string} actual
         * @param {string} symbol
         * @returns {NegativeData}
         */
        function isCurrencyPercent(parts: string[], actual: string, symbol: string): NegativeData;
        /**
         * Returns culture based date separator
         * @private
         * @param {Object} dateObj
         * @returns {string}
         */
        function getDateSeparator(dateObj: Object): string;
        /**
         * Returns Native Date Time pattern
         * @private
         * @param {string} culture
         * @param {DateFormatOptions} options
         * @param {Object} cldr
         * @returns {string}
         */
        function getActualDateTimeFormat(culture: string, options: DateFormatOptions, cldr?: Object, isExcelFormat?: boolean): string;
        /**
         * Returns Native Number pattern
         * @private
         * @param {string} culture
         * @param {NumberFormatOptions} options
         * @param {Object} cldr
         * @returns {string}
         */
        function getActualNumberFormat(culture: string, options: ej.base.NumberFormatOptions, cldr?: Object): string;
    }
    
    /**
     * Interface for default formatting options
     * @private
     */
    export interface FormatParts extends NumberFormatOptions {
        groupOne?: boolean;
        isPercent?: boolean;
        isCurrency?: boolean;
        isNegative?: boolean;
        groupData?: GroupDetails;
        groupSeparator?: string;
    }
    /**
     * Interface for common formatting options
     */
    export interface CommonOptions {
        numberMapper?: NumberMapper;
        currencySymbol?: string;
        percentSymbol?: string;
        minusSymbol?: string;
    }
    /**
     * Interface for grouping process
     */
    export interface GroupDetails {
        primary?: number;
        secondary?: number;
    }
    /**
     * Module for number formatting.
     * @private
     */
    export class NumberFormat {
        /**
         * Returns the formatter function for given skeleton.
         * @param {string} culture -  Specifies the culture name to be which formatting.
         * @param {NumberFormatOptions} option - Specific the format in which number  will format.
         * @param {Object} object- Specifies the global cldr data collection.
         * @return Function.
         */
        static numberFormatter(culture: string, option: ej.base.NumberFormatOptions, cldr: Object): Function;
        /**
         * Returns grouping details for the pattern provided
         * @param {string} pattern
         * @returns {GroupDetails}
         */
        static getGroupingDetails(pattern: string): GroupDetails;
        /**
         * Returns if the provided integer range is valid.
         * @param {number} val1
         * @param {number} val2
         * @param {boolean} checkbothExist
         * @param {boolean} isFraction
         * @returns {boolean}
         */
        private static checkValueRange(val1, val2, checkbothExist, isFraction?);
        /**
         * Check if the provided fraction range is valid
         * @param {number} val
         * @param {string} text
         * @param {boolean} isFraction
         * @returns {void}
         */
        private static checkRange(val, text, isFraction?);
        /**
         * Returns formatted numeric string for provided formatting options
         * @param {number} value
         * @param {base.GenericFormatOptions} fOptions
         * @param {CommonOptions} dOptions
         * @returns {string}
         */
        private static intNumberFormatter(value, fOptions, dOptions);
        /**
         * Returns significant digits processed numeric string
         * @param {number} value
         * @param {number} min
         * @param {number} max
         * @returns {string}
         */
        private static processSignificantDigits(value, min, max);
        /**
         * Returns grouped numeric string
         * @param {string} val
         * @param {number} level1
         * @param {string} sep
         * @param {string} decimalSymbol
         * @param {number} level2
         * @returns {string}
         */
        private static groupNumbers(val, level1, sep, decimalSymbol, level2?);
        /**
         * Returns fraction processed numeric string
         * @param {number} value
         * @param {number} min
         * @param {number} max
         * @returns {string}
         */
        private static processFraction(value, min, max);
        /**
         * Returns integer processed numeric string
         * @param {string} value
         * @param {number} min
         * @returns {string}
         */
        private static processMinimumIntegers(value, min);
    }
    
    /**
     * interface for Numeric Formatting Parts
     */
    export interface NumericParts {
        symbolRegex?: RegExp;
        nData?: any;
        pData?: any;
        infinity?: string;
        type?: string;
        fractionDigits?: number;
        isAccount?: boolean;
        custom?: boolean;
    }
    /**
     * Module for Number Parser.
     * @private
     */
    export class NumberParser {
        /**
         * Returns the parser function for given skeleton.
         * @param {string} -  Specifies the culture name to be which formatting.
         * @param {NumberFormatOptions} - Specific the format in which number  will parsed.
         * @param {cldr} - Specifies the global cldr data collection.
         * @return Function.
         */
        static numberParser(culture: string, option: ej.base.NumberFormatOptions, cldr: Object): Function;
        /**
         * Returns parsed number for the provided formatting options
         * @param {string} value
         * @param {NumericParts} options
         * @param {NumericOptions} numOptions
         * @returns {number}
         */
        private static getParsedNumber(value, options, numOptions);
    }
    
    /**
     * Interface for numeric Options
     */
    export interface NumericOptions {
        numericPair?: Object;
        numericRegex?: string;
        numberParseRegex?: RegExp;
        symbolNumberSystem?: Object;
        symbolMatch?: Object;
        numberSystem?: string;
    }
    /**
     * Interface for numeric object
     */
    export interface NumericObject {
        obj?: Object;
        nSystem?: string;
    }
    /**
     * Interface for number mapper
     */
    export interface NumberMapper {
        mapper?: Object;
        timeSeparator?: string;
        numberSymbols?: Object;
        numberSystem?: string;
    }
    /**
     * Interface for parser base
     * @private
     */
    export class ParserBase {
        static nPair: string;
        static nRegex: string;
        static numberingSystems: Object;
        /**
         * Returns the cldr object for the culture specifies
         * @param {Object} obj - Specifies the object from which culture object to be acquired.
         * @param {string} cName - Specifies the culture name.
         * @returns {Object}
         */
        static getMainObject(obj: Object, cName: string): Object;
        /**
         * Returns the numbering system object from given cldr data.
         * @param {Object} obj - Specifies the object from which number system is acquired.
         * @returns {Object}
         */
        static getNumberingSystem(obj: Object): Object;
        /**
         * Returns the reverse of given object keys or keys specified.
         * @param {Object} prop - Specifies the object to be reversed.
         * @param {number[]} keys - Optional parameter specifies the custom keyList for reversal.
         * @returns {Object}
         */
        static reverseObject(prop: Object, keys?: number[]): Object;
        /**
         * Returns the symbol regex by skipping the escape sequence.
         * @param {string[]} props - Specifies the array values to be skipped.
         * @returns {RegExp}
         */
        static getSymbolRegex(props: string[]): RegExp;
        private static getSymbolMatch(prop);
        /**
         * Returns regex string for provided value
         * @param {string} val
         * @returns {string}
         */
        private static constructRegex(val);
        /**
         * Returns the replaced value of matching regex and obj mapper.
         * @param {string} value - Specifies the  values to be replaced.
         * @param {RegExp} regex - Specifies the  regex to search.
         * @param {Object} obj - Specifies the  object matcher to be replace value parts.
         * @returns {string}
         */
        static convertValueParts(value: string, regex: RegExp, obj: Object): string;
        /**
         * Returns default numbering system object for formatting from cldr data
         * @param {Object} obj
         * @returns {NumericObject}
         */
        static getDefaultNumberingSystem(obj: Object): NumericObject;
        /**
         * Returns the replaced value of matching regex and obj mapper.
         */
        static getCurrentNumericOptions(curObj: Object, numberSystem: Object, needSymbols?: boolean): Object;
        /**
         * Returns number mapper object for the provided cldr data
         * @param {Object} curObj
         * @param {Object} numberSystem
         * @param {boolean} isNumber
         * @returns {NumberMapper}
         */
        static getNumberMapper(curObj: Object, numberSystem: Object, isNumber?: boolean): NumberMapper;
    }
    
  }
  export namespace buttons {
    
    /**
     * Interface for a class Button
     */
    export interface ButtonModel extends ej.base.ComponentModel{
    
        /**
         * Positions the icon before/after the text content in the Button.
         * The possible values are:
         * * Left: The icon will be positioned to the left of the text content.
         * * Right: The icon will be positioned to the right of the text content.
         * @default "left"
         */
        iconPosition?: IconPosition;
    
        /**
         * Defines class/multiple classes separated by a space for the Button that is used to include an icon.
         * Buttons can also include font icon and sprite image.
         * @default ""
         */
        iconCss?: string;
    
        /**
         * Specifies a value that indicates whether the Button is `disabled` or not.
         * @default false.
         */
        disabled?: boolean;
    
        /**
         * Allows the appearance of the Button to be enhanced and visually appealing when set to `true`.
         * @default false
         */
        isPrimary?: boolean;
    
        /**
         * Defines class/multiple classes separated by a space in the Button element. The Button types, styles, and
         * size can be defined by using [`this`](http://ej2.syncfusion.com/documentation/button/howto.html).
         * @default ""
         */
        cssClass?: string;
    
        /**
         * Defines the `content` of the Button element that can either be a text or HTML elements.
         * @default ""
         */
        content?: string;
    
        /**
         * Makes the Button toggle, when set to `true`. When you click it, the state changes from normal to active.
         * @default false
         */
        isToggle?: boolean;
    
    }
    
    export type IconPosition = 'Left' | 'Right';
    /**
     * The Button is a graphical user interface element that triggers an event on its click action. It can contain a text, an image, or both.
     * ```html
     * <button id="button">Button</button>
     * ```
     * ```typescript
     * <script>
     * var btnObj = new Button();
     * btnObj.appendTo("#button");
     * </script>
     * ```
     */
    export class Button extends ej.base.Component<HTMLButtonElement> implements ej.base.INotifyPropertyChanged {
        /**
         * Positions the icon before/after the text content in the Button.
         * The possible values are:
         * * Left: The icon will be positioned to the left of the text content.
         * * Right: The icon will be positioned to the right of the text content.
         * @default "left"
         */
        iconPosition: IconPosition;
        /**
         * Defines class/multiple classes separated by a space for the Button that is used to include an icon.
         * Buttons can also include font icon and sprite image.
         * @default ""
         */
        iconCss: string;
        /**
         * Specifies a value that indicates whether the Button is `disabled` or not.
         * @default false.
         */
        disabled: boolean;
        /**
         * Allows the appearance of the Button to be enhanced and visually appealing when set to `true`.
         * @default false
         */
        isPrimary: boolean;
        /**
         * Defines class/multiple classes separated by a space in the Button element. The Button types, styles, and
         * size can be defined by using [`this`](http://ej2.syncfusion.com/documentation/button/howto.html).
         * @default ""
         */
        cssClass: string;
        /**
         * Defines the `content` of the Button element that can either be a text or HTML elements.
         * @default ""
         */
        content: string;
        /**
         * Makes the Button toggle, when set to `true`. When you click it, the state changes from normal to active.
         * @default false
         */
        isToggle: boolean;
        /**
         * Constructor for creating the widget
         * @param  {ButtonModel} options?
         * @param  {string|HTMLButtonElement} element?
         */
        constructor(options?: ej.buttons.ButtonModel, element?: string | HTMLButtonElement);
        protected preRender(): void;
        /**
         * Initialize the control rendering
         * @returns void
         * @private
         */
        render(): void;
        private initialize();
        private controlStatus(disabled);
        private setIconCss();
        protected wireEvents(): void;
        protected unWireEvents(): void;
        private btnClickHandler();
        /**
         * Destroys the widget.
         * @returns void
         */
        destroy(): void;
        /**
         * Get component name.
         * @returns string
         * @private
         */
        getModuleName(): string;
        /**
         * Get the properties to be maintained in the persisted state.
         * @returns string
         */
        getPersistData(): string;
        /**
         * Called internally if any of the property value changed.
         * @param  {Button} newProp
         * @param  {Button} oldProp
         * @returns void
         * @private
         */
        onPropertyChanged(newProp: ej.buttons.Button, oldProp: ej.buttons.Button): void;
    }
    
    /**
     * Interface for a class CheckBox
     */
    export interface CheckBoxModel extends ej.base.ComponentModel{
    
        /**
         * Triggers when the CheckBox state has been changed by user interaction.
         * @event
         */
        change?: ej.base.EmitType<ChangeEventArgs>;
    
        /**
         * Specifies a value that indicates whether the CheckBox is `checked` or not.
         * When set to `true`, the CheckBox will be in `checked` state.
         * @default false
         */
        checked?: boolean;
    
        /**
         * Defines class/multiple classes separated by a space in the CheckBox element.
         * You can add custom styles to the CheckBox by using this property.
         * @default ''
         */
        cssClass?: string;
    
        /**
         * Specifies a value that indicates whether the CheckBox is `disabled` or not.
         * When set to `true`, the CheckBox will be in `disabled` state.
         * @default false
         */
        disabled?: boolean;
    
        /**
         * Specifies a value that indicates whether the CheckBox is in `indeterminate` state or not.
         * When set to `true`, the CheckBox will be in `indeterminate` state.
         * @default false
         */
        indeterminate?: boolean;
    
        /**
         * Defines the caption for the CheckBox, that describes the purpose of the CheckBox.
         * @default ''
         */
        label?: string;
    
        /**
         * Positions label `before`/`after` the CheckBox.
         * The possible values are:
         * * Before - The label is positioned to left of the CheckBox.
         * * After - The label is positioned to right of the CheckBox.
         * @default 'After'
         */
        labelPosition?: LabelPosition;
    
        /**
         * Defines `name` attribute for the CheckBox.
         * It is used to reference form data (CheckBox value) after a form is submitted.
         * @default ''
         */
        name?: string;
    
        /**
         * Defines `value` attribute for the CheckBox.
         * It is a form data passed to the server when submitting the form.
         * @default ''
         */
        value?: string;
    
    }
    
    export type LabelPosition = 'After' | 'Before';
    /**
     * The CheckBox is a graphical user interface element that allows you to select one or more options from the choices.
     * It contains checked, unchecked, and indeterminate states.
     * ```html
     * <input type="checkbox" id="checkbox"/>
     * <script>
     * var checkboxObj = new CheckBox({ label: "Default" });
     * checkboxObj.appendTo("#checkbox");
     * </script>
     * ```
     */
    export class CheckBox extends ej.base.Component<HTMLInputElement> implements ej.base.INotifyPropertyChanged {
        private tagName;
        private isKeyPressed;
        private keyboardModule;
        /**
         * Triggers when the CheckBox state has been changed by user interaction.
         * @event
         */
        change: ej.base.EmitType<ChangeEventArgs>;
        /**
         * Specifies a value that indicates whether the CheckBox is `checked` or not.
         * When set to `true`, the CheckBox will be in `checked` state.
         * @default false
         */
        checked: boolean;
        /**
         * Defines class/multiple classes separated by a space in the CheckBox element.
         * You can add custom styles to the CheckBox by using this property.
         * @default ''
         */
        cssClass: string;
        /**
         * Specifies a value that indicates whether the CheckBox is `disabled` or not.
         * When set to `true`, the CheckBox will be in `disabled` state.
         * @default false
         */
        disabled: boolean;
        /**
         * Specifies a value that indicates whether the CheckBox is in `indeterminate` state or not.
         * When set to `true`, the CheckBox will be in `indeterminate` state.
         * @default false
         */
        indeterminate: boolean;
        /**
         * Defines the caption for the CheckBox, that describes the purpose of the CheckBox.
         * @default ''
         */
        label: string;
        /**
         * Positions label `before`/`after` the CheckBox.
         * The possible values are:
         * * Before - The label is positioned to left of the CheckBox.
         * * After - The label is positioned to right of the CheckBox.
         * @default 'After'
         */
        labelPosition: LabelPosition;
        /**
         * Defines `name` attribute for the CheckBox.
         * It is used to reference form data (CheckBox value) after a form is submitted.
         * @default ''
         */
        name: string;
        /**
         * Defines `value` attribute for the CheckBox.
         * It is a form data passed to the server when submitting the form.
         * @default ''
         */
        value: string;
        /**
         * Constructor for creating the widget
         * @private
         */
        constructor(options?: CheckBoxModel, element?: string | HTMLInputElement);
        private changeState(state?);
        private clickHandler(event);
        /**
         * Destroys the widget.
         * @returns void
         */
        destroy(): void;
        private focusHandler();
        private focusOutHandler();
        /**
         * Gets the module name.
         * @private
         */
        protected getModuleName(): string;
        /**
         * Gets the properties to be maintained in the persistence state.
         * @private
         */
        getPersistData(): string;
        private getWrapper();
        private initialize();
        private initWrapper();
        private keyDownHandler();
        private labelMouseHandler(e);
        private mouseDownHandler();
        /**
         * Called internally if any of the property value changes.
         * @private
         */
        onPropertyChanged(newProp: CheckBoxModel, oldProp: CheckBoxModel): void;
        /**
         * Initialize Angular, React and Unique ID support.
         * @private
         */
        protected preRender(): void;
        /**
         * Initialize the control rendering
         * @private
         */
        protected render(): void;
        private setDisabled();
        private setText(text);
        protected unWireEvents(): void;
        protected wireEvents(): void;
    }
    export interface ChangeEventArgs extends ej.base.BaseEventArgs {
        /** Returns the event parameters of the CheckBox. */
        event?: Event;
        /** Returns the checked value of the CheckBox. */
        checked?: boolean;
    }
    
    /**
     * Initialize wrapper element for angular.
     * @private
     */
    export function wrapperInitialize(tag: string, type: string, element: HTMLInputElement, WRAPPER: string): HTMLInputElement;
    export function getTextNode(element: HTMLElement): Node;
    /**
     * Creates CheckBox component UI with theming and ripple support.
     * @private
     */
    export function createCheckBox(enableRipple?: boolean, options?: CheckBoxUtilModel): Element;
    export function rippleMouseHandler(e: MouseEvent, rippleSpan: Element): void;
    export interface CheckBoxUtilModel {
        checked?: boolean;
        label?: string;
        enableRtl?: boolean;
        cssClass?: string;
    }
    
    /**
     * Interface for a class RadioButton
     */
    export interface RadioButtonModel extends ej.base.ComponentModel{
    
        /**
         * Event trigger when the RadioButton state has been changed by user interaction.
         * @event
         */
        change?: ej.base.EmitType<ChangeArgs>;
    
        /**
         * Specifies a value that indicates whether the RadioButton is `checked` or not.
         * When set to `true`, the RadioButton will be in `checked` state.
         * @default false
         */
        checked?: boolean;
    
        /**
         * Defines class/multiple classes separated by a space in the RadioButton element.
         * You can add custom styles to the RadioButton by using this property.
         * @default ''
         */
        cssClass?: string;
    
        /**
         * Specifies a value that indicates whether the RadioButton is `disabled` or not.
         * When set to `true`, the RadioButton will be in `disabled` state.
         * @default false
         */
        disabled?: boolean;
    
        /**
         * Defines the caption for the RadioButton, that describes the purpose of the RadioButton.
         * @default ''
         */
        label?: string;
    
        /**
         * Positions label `before`/`after` the RadioButton.
         * The possible values are:
         * * Before: The label is positioned to left of the RadioButton.
         * * After: The label is positioned to right of the RadioButton.
         * @default 'After'
         */
        labelPosition?: RadioLabelPosition;
    
        /**
         * Defines `name` attribute for the RadioButton.
         * It is used to reference form data (RadioButton value) after a form is submitted.
         * @default ''
         */
        name?: string;
    
        /**
         * Defines `value` attribute for the RadioButton.
         * It is a form data passed to the server when submitting the form.
         * @default ''
         */
        value?: string;
    
    }
    
    export type RadioLabelPosition = 'After' | 'Before';
    /**
     * The RadioButton is a graphical user interface element that allows you to select one option from the choices.
     * It contains checked and unchecked states.
     * ```html
     * <input type="radio" id="radio"/>
     * <script>
     * var radioObj = new RadioButton({ label: "Default" });
     * radioObj.appendTo("#radio");
     * </script>
     * ```
     */
    export class RadioButton extends ej.base.Component<HTMLInputElement> implements ej.base.INotifyPropertyChanged {
        private tagName;
        private isKeyPressed;
        /**
         * Event trigger when the RadioButton state has been changed by user interaction.
         * @event
         */
        change: ej.base.EmitType<ChangeArgs>;
        /**
         * Specifies a value that indicates whether the RadioButton is `checked` or not.
         * When set to `true`, the RadioButton will be in `checked` state.
         * @default false
         */
        checked: boolean;
        /**
         * Defines class/multiple classes separated by a space in the RadioButton element.
         * You can add custom styles to the RadioButton by using this property.
         * @default ''
         */
        cssClass: string;
        /**
         * Specifies a value that indicates whether the RadioButton is `disabled` or not.
         * When set to `true`, the RadioButton will be in `disabled` state.
         * @default false
         */
        disabled: boolean;
        /**
         * Defines the caption for the RadioButton, that describes the purpose of the RadioButton.
         * @default ''
         */
        label: string;
        /**
         * Positions label `before`/`after` the RadioButton.
         * The possible values are:
         * * Before: The label is positioned to left of the RadioButton.
         * * After: The label is positioned to right of the RadioButton.
         * @default 'After'
         */
        labelPosition: RadioLabelPosition;
        /**
         * Defines `name` attribute for the RadioButton.
         * It is used to reference form data (RadioButton value) after a form is submitted.
         * @default ''
         */
        name: string;
        /**
         * Defines `value` attribute for the RadioButton.
         * It is a form data passed to the server when submitting the form.
         * @default ''
         */
        value: string;
        /**
         * Constructor for creating the widget
         * @private
         */
        constructor(options?: RadioButtonModel, element?: string | HTMLInputElement);
        private changeHandler(event);
        private updateChange(state);
        /**
         * Destroys the widget.
         * @returns void
         */
        destroy(): void;
        private focusHandler();
        private focusOutHandler();
        protected getModuleName(): string;
        /**
         * Gets the properties to be maintained in the persistence state.
         * @private
         */
        getPersistData(): string;
        private getLabel();
        private initialize();
        private initWrapper();
        private keyDownHandler();
        private labelRippleHandler(e);
        private mouseDownHandler();
        /**
         * Called internally if any of the property value changes.
         * @private
         */
        onPropertyChanged(newProp: RadioButtonModel, oldProp: RadioButtonModel): void;
        /**
         * Initialize checked Property, Angular and React and Unique ID support.
         * @private
         */
        protected preRender(): void;
        /**
         * Initialize the control rendering
         * @private
         */
        protected render(): void;
        private setDisabled();
        private setText(text);
        protected unWireEvents(): void;
        protected wireEvents(): void;
    }
    export interface ChangeArgs extends ej.base.BaseEventArgs {
        /** Returns the value of the RadioButton. */
        value?: string;
        /** Returns the event parameters of the RadioButton. */
        event?: Event;
    }
    
  }
  export namespace calendars {
    
    /**
     * Interface for a class Calendar
     */
    export interface CalendarModel extends ej.base.ComponentModel{
    
        /**
         * Gets or sets the selected date of the Calendar.
         * @default null
         */
        value?: Date;
    
        /**
         * Gets or sets the minimum date that can be selected in the Calendar.
         * @default new Date(1900, 00, 01)
         */
        min?: Date;
    
        /**
         * Gets or sets the maximum date that can be selected in the Calendar.
         * @default new Date(2099, 11, 31)
         */
        max?: Date;
    
        /**
         * Gets or sets the Calendar's first day of the week. By default, the first day of the week will be based on the current culture.
         * @default 0
         */
        firstDayOfWeek?: number;
    
        /**
         * Specifies the initial view of the Calendar when it is opened.
         * With the help of this property, initial view can be changed to year or decade view.
         * @default month
         */
        start?: ej.calendars.CalendarView;
    
        /**
         * Sets the maximum level of view (month, year, decade) in the Calendar.
         * Depth view should be smaller than the start view to restrict its view navigation.
         * @default month
         */
        depth?: ej.calendars.CalendarView;
    
        /**
         * Determines whether the week number of the Calendar is to be displayed or not.
         * The week number is displayed in every week row.
         * @default false
         */
        weekNumber?: boolean;
    
        /**
         * Specifies whether the today button is displayed or not.
         * @default true
         */
        showTodayButton?: boolean;
    
        /**
         * Triggers when Calendar is created.
         * @event 
         */
        created?: ej.base.EmitType<Object>;
    
        /**
         * Triggers when Calendar is destroyed.
         * @event 
         */
        destroyed?: ej.base.EmitType<Object>;
    
        /**
         * Triggers when the Calendar value is changed.
         * @event  
         */
        change?: ej.base.EmitType<ChangedEventArgs>;
    
        /**
         * Triggers when the Calendar is navigated to another level or within the same level of view.
         * @event
         */
        navigated?: ej.base.EmitType<NavigatedEventArgs>;
    
        /**
         * Triggers when each day cell of the Calendar is rendered.
         * @event
         */
        renderDayCell?: ej.base.EmitType<RenderDayCellEventArgs>;
    
    }
    
    /**
     * Specifies the view of the calendar.
     */
    export type CalendarView = 'Month' | 'Year' | 'Decade';
    /**
     * Represents the Calendar component that allows the user to select a date.
     * ```html
     * <div id="calendar"/>
     * ```
     * ```typescript
     * <script>
     *   var calendarObj = new Calendar({ value: new Date() });
     *   calendarObj.appendTo("#calendar");
     * </script>
     * ```
     */
    export class Calendar extends ej.base.Component<HTMLElement> implements ej.base.INotifyPropertyChanged {
        protected headerElement: HTMLElement;
        protected contentElement: HTMLElement;
        protected table: HTMLElement;
        protected tableHeadElement: HTMLElement;
        protected tableBodyElement: Element;
        protected nextIcon: HTMLElement;
        protected previousIcon: HTMLElement;
        protected headerTitleElement: HTMLElement;
        protected todayElement: HTMLElement;
        protected footer: HTMLElement;
        protected keyboardModule: ej.base.KeyboardEvents;
        protected globalize: ej.base.Internationalization;
        protected currentDate: Date;
        protected changedArgs: ChangedEventArgs;
        protected navigatedArgs: NavigatedEventArgs;
        private renderDaycellArg;
        private effect;
        protected previousDate: Date;
        protected changeHandler: Function;
        protected navigateHandler: Function;
        protected navigatePreviousHandler: Function;
        protected navigateNextHandler: Function;
        private l10;
        protected todayDisabled: boolean;
        protected todayDate: Date;
        protected calendarElement: HTMLElement;
        protected keyConfigs: {
            [key: string]: string;
        };
        /**
         * Gets or sets the selected date of the Calendar.
         * @default null
         */
        value: Date;
        /**
         * Gets or sets the minimum date that can be selected in the Calendar.
         * @default new Date(1900, 00, 01)
         */
        min: Date;
        /**
         * Gets or sets the maximum date that can be selected in the Calendar.
         * @default new Date(2099, 11, 31)
         */
        max: Date;
        /**
         * Gets or sets the Calendar's first day of the week. By default, the first day of the week will be based on the current culture.
         * @default 0
         */
        firstDayOfWeek: number;
        /**
         * Specifies the initial view of the Calendar when it is opened.
         * With the help of this property, initial view can be changed to year or decade view.
         * @default month
         */
        start: ej.calendars.CalendarView;
        /**
         * Sets the maximum level of view (month, year, decade) in the Calendar.
         * Depth view should be smaller than the start view to restrict its view navigation.
         * @default month
         */
        depth: ej.calendars.CalendarView;
        /**
         * Determines whether the week number of the Calendar is to be displayed or not.
         * The week number is displayed in every week row.
         * @default false
         */
        weekNumber: boolean;
        /**
         * Specifies whether the today button is displayed or not.
         * @default true
         */
        showTodayButton: boolean;
        /**
         * Triggers when Calendar is created.
         * @event
         */
        created: ej.base.EmitType<Object>;
        /**
         * Triggers when Calendar is destroyed.
         * @event
         */
        destroyed: ej.base.EmitType<Object>;
        /**
         * Triggers when the Calendar value is changed.
         * @event
         */
        change: ej.base.EmitType<ChangedEventArgs>;
        /**
         * Triggers when the Calendar is navigated to another level or within the same level of view.
         * @event
         */
        navigated: ej.base.EmitType<NavigatedEventArgs>;
        /**
         * Triggers when each day cell of the Calendar is rendered.
         * @event
         */
        renderDayCell: ej.base.EmitType<RenderDayCellEventArgs>;
        /**
         * Initialized new instance of Calendar Class.
         * Constructor for creating the widget
         * @param  {CalendarModel} options?
         * @param  {string|HTMLElement} element?
         */
        constructor(options?: CalendarModel, element?: string | HTMLElement);
        /**
         * To Initialize the control rendering.
         * @returns void
         * @private
         */
        protected render(): void;
        protected processDate(): void;
        private validateDate();
        private minMaxUpdate();
        protected header(): void;
        protected content(): void;
        private getCultureValues();
        private contentHdr();
        private contentBody();
        private updateFooter();
        private contentFooter();
        protected wireEvents(): void;
        protected todayButtonClick(): void;
        protected keyActionHandle(e: ej.base.KeyboardEventArgs): void;
        protected KeyboardNavigate(number: number, currentView: number, e: KeyboardEvent, max: Date, min: Date): void;
        /**
         * Initialize the event handler
         * @private
         */
        protected preRender(): void;
        private minMaxDate(localDate);
        protected renderMonths(e?: Event): void;
        private renderDays(currentDate, e?);
        private renderYears(e?);
        private renderDecades(e?);
        private dayCell(localDate);
        protected firstDay(date: Date): Date;
        protected lastDay(date: Date): Date;
        protected checkDateValue(value: Date): Date;
        private findlastDay(date);
        private removeTheadEle();
        private renderTemplate(elements, numCells, classNm, e?);
        private clickHandler(e);
        private contentClick(e, view, ele);
        private switchView(view, e?);
        /**
         * To get component name
         * @private
         */
        protected getModuleName(): string;
        /**
         * Gets the properties to be maintained upon browser refresh.
         * @returns string
         */
        getPersistData(): string;
        /**
         * Called internally if any of the property value changed.
         * returns void
         * @private
         */
        onPropertyChanged(newProp: CalendarModel, oldProp: CalendarModel): void;
        private setvalue();
        private titleUpdate(date, view);
        protected setActiveDescendant(): string;
        private iconHandler();
        /**
         * Destroys the widget.
         * @returns void
         */
        destroy(): void;
        private title(e?);
        private getViewNumber(stringVal);
        private navTitle(e?);
        private previous();
        protected navigatePrevious(e: MouseEvent | KeyboardEvent): void;
        private next();
        protected navigateNext(eve: MouseEvent | KeyboardEvent): void;
        /**
         * This method is used to navigate to the month/year/decade view of the Calendar.
         * @param  {string} view - Specifies the view of the Calendar.
         * @param  {Date} date - Specifies the focused date in a view.
         * @returns void
         */
        navigateTo(view: ej.calendars.CalendarView, date: Date): void;
        /**
         * Gets the current view of the Calendar.
         * @returns string
         */
        currentView(): string;
        private getDateVal(date);
        private getCultureObjects(ld, c);
        private getWeek(d);
        private setTime(date, time);
        protected addMonths(date: Date, i: number): void;
        protected addYears(date: Date, i: number): void;
        protected getIdValue(e: MouseEvent, element: Element): Date;
        private selectDate(e, date, element);
        private setAriaActivedescendant();
        protected previousIconHandler(disabled: boolean): void;
        protected renderDayCellEvent(args: RenderDayCellEventArgs): void;
        protected navigatedEvent(eve: MouseEvent | KeyboardEvent): void;
        private triggerNavigate(event);
        protected changeEvent(e: Event): void;
        private triggerChange(e);
        protected nextIconHandler(disabled: boolean): void;
        private compare(startDate, endDate, modifier);
        protected isMinMaxRange(date: Date): boolean;
        private compareYear(start, end);
        private compareDecade(start, end);
        private shiftArray(array, i);
        protected addDay(date: Date, i: number, e: KeyboardEvent, max: Date, min: Date): void;
        private findNextTD(date, column, max, min);
        private getMaxDays(d);
        private setDateDecade(date, year);
        private setDateYear(date, value);
        private compareMonth(start, end);
    }
    export interface RenderDayCellEventArgs extends ej.base.BaseEventArgs {
        /** Specifies whether to disable the current date or not. */
        isDisabled?: boolean;
        /** Specifies the day cell element. */
        element?: HTMLElement;
        /** Defines the current date of the Calendar. */
        date?: Date;
        /** Defines whether the current date is out of range (less than min or greater than max) or not. */
        isOutOfRange?: boolean;
    }
    export interface ChangedEventArgs extends ej.base.BaseEventArgs {
        /** Defines the selected date of the Calendar. */
        value?: Date;
        /** Defines the event of the Calendar. */
        event?: KeyboardEvent | MouseEvent;
    }
    export interface NavigatedEventArgs extends ej.base.BaseEventArgs {
        /** Defines the current view of the Calendar. */
        view?: string;
        /** Defines the focused date in a view. */
        date?: Date;
        /** Defines the event of the Calendar. */
        event?: KeyboardEvent | MouseEvent;
    }
    
    /**
     * Interface for a class DatePicker
     */
    export interface DatePickerModel extends CalendarModel{
    
        /**
         * Specifies the width of the DatePicker component.
         * @default null
         */
        width?: number | string;
    
        /**
         * Specifies the root CSS class of the DatePicker that allows to
         * customize the appearance by overriding the styles.
         * @default null
         */
        cssClass?: string;
    
        /**
         * Specifies the component to act as strict. So that, it allows to enter only a valid date value within a specified range or else it 
         * will resets to previous value. By default, strictMode is in false.
         * @default false
         */
        strictMode?: boolean;
    
        /**
         * Specifies the format of the value that to be displayed in component. By default, the format is
         * based on the culture. 
         * @default null
         */
        format?: string;
    
        /**
         * Specifies the component to be disabled or not.
         * @default true
         */
        enabled?: boolean;
    
        /**
         * Specifies whether to show or hide the clear Icon
         * @default false
         */
        showClearButton?: boolean;
    
        /**
         * specifies the z-index value of the datePicker popup element.
         * @default 1000
         */
        zIndex?: number;
    
        /**
         * Specifies the component in readonly state. 
         * @default false
         */
        readonly?: boolean;
    
        /**
         * Specifies the placeholder text that displayed in textbox.
         * @default null
         */
        placeholder?: string;
    
        /**
         * Specifies the placeholder text to be floated.
         * @default Auto
         */
        floatLabelType?: any;
    
        /**
         * Triggers when the popup gets open.
         * @event 
         */
        open?: ej.base.EmitType<PreventableEventArgs | PopupObjectArgs>;
    
        /**
         * Triggers when the popup gets close.
         * @event 
         */
        close?: ej.base.EmitType<PreventableEventArgs | PopupObjectArgs>;
    
        /**
         * Triggers when the control loses the focus.
         * @event 
         */
        blur?: ej.base.EmitType<Object>;
    
        /**
         *  Triggers when the control gets focus.
         * @event 
         */
        focus?: ej.base.EmitType<Object>;
    
        /**
         * Triggers when the component is created.
         * @event 
         */
        created?: ej.base.EmitType<Object>;
    
        /**
         * Triggers when the component is destroyed.
         * @event 
         */
        destroyed?: ej.base.EmitType<Object>;
    
    }
    
    /**
     * Represents the DatePicker component that allows user to select
     * or enter a date value.
     * ```html
     * <input id="datepicker"/>
     * ````
     * ````typescript
     * <script>
     *   var datePickerObject = new DatePicker({ value: new Date() });
     *   datePickerObject.appendTo("#datepicker");
     * </script>
     * ```
     */
    export class DatePicker extends Calendar implements ej.inputs.IInput {
        private popupObj;
        protected inputWrapper: ej.inputs.InputObject;
        private modal;
        protected inputElement: HTMLInputElement;
        protected popupWrapper: HTMLElement;
        protected changedArgs: ChangedEventArgs;
        protected previousDate: Date;
        private keyboardModules;
        private calendarKeyboardModules;
        private previousEleValue;
        private ngTag;
        protected dateTimeFormat: string;
        private inputEleCopy;
        protected l10n: ej.base.L10n;
        private preventArgs;
        private isDateIconClicked;
        private index;
        protected keyConfigs: {
            [key: string]: string;
        };
        protected calendarKeyConfigs: {
            [key: string]: string;
        };
        /**
         * Specifies the width of the DatePicker component.
         * @default null
         */
        width: number | string;
        /**
         * Specifies the root CSS class of the DatePicker that allows to
         * customize the appearance by overriding the styles.
         * @default null
         */
        cssClass: string;
        /**
         * Specifies the component to act as strict. So that, it allows to enter only a valid date value within a specified range or else it
         * will resets to previous value. By default, strictMode is in false.
         * @default false
         */
        strictMode: boolean;
        /**
         * Specifies the format of the value that to be displayed in component. By default, the format is
         * based on the culture.
         * @default null
         */
        format: string;
        /**
         * Specifies the component to be disabled or not.
         * @default true
         */
        enabled: boolean;
        /**
         * Specifies whether to show or hide the clear Icon
         * @default false
         */
        showClearButton: boolean;
        /**
         * specifies the z-index value of the datePicker popup element.
         * @default 1000
         */
        zIndex: number;
        /**
         * Specifies the component in readonly state.
         * @default false
         */
        readonly: boolean;
        /**
         * Specifies the placeholder text that displayed in textbox.
         * @default null
         */
        placeholder: string;
        /**
         * Specifies the placeholder text to be floated.
         * @default Auto
         */
        floatLabelType: ej.inputs.FloatLabelType;
        /**
         * Triggers when the popup gets open.
         * @event
         */
        open: ej.base.EmitType<PreventableEventArgs | PopupObjectArgs>;
        /**
         * Triggers when the popup gets close.
         * @event
         */
        close: ej.base.EmitType<PreventableEventArgs | PopupObjectArgs>;
        /**
         * Triggers when the control loses the focus.
         * @event
         */
        blur: ej.base.EmitType<Object>;
        /**
         *  Triggers when the control gets focus.
         * @event
         */
        focus: ej.base.EmitType<Object>;
        /**
         * Triggers when the component is created.
         * @event
         */
        created: ej.base.EmitType<Object>;
        /**
         * Triggers when the component is destroyed.
         * @event
         */
        destroyed: ej.base.EmitType<Object>;
        /**
         * Constructor for creating the widget.
         */
        constructor(options?: ej.calendars.DatePickerModel, element?: string | HTMLInputElement);
        /**
         * To Initialize the control rendering.
         * @return void
         * @private
         */
        render(): void;
        private initialize();
        private createInput();
        protected updateInput(): void;
        protected bindEvents(): void;
        private bindClearEvent();
        protected resetHandler(e?: MouseEvent): void;
        private clear(event);
        private dateIconHandler(e?);
        private CalendarKeyActionHandle(e);
        private inputFocusHandler();
        private inputBlurHandler();
        private documentHandler(e);
        protected inputKeyActionHandle(e: ej.base.KeyboardEventArgs): void;
        protected strictModeUpdate(): void;
        private createCalendar();
        private modelHeader();
        private changeTrigger();
        protected navigatedEvent(): void;
        protected changeEvent(e?: MouseEvent): void;
        protected selectCalendar(e?: Event): void;
        protected isCalendar(): boolean;
        protected setWidth(width: number | string): void;
        /**
         * Shows the Calendar.
         * @returns void
         */
        show(): void;
        /**
         * Hide the Calendar.
         * @returns void
         */
        hide(): void;
        /**
         * Sets the focus to widget for interaction.
         * @returns void
         */
        focusIn(triggerEvent?: boolean): void;
        /**
         * Remove the focus from widget, if the widget is in focus state.
         * @returns void
         */
        focusOut(): void;
        /**
         * Gets the current view of the DatePicker.
         * @returns string
         */
        currentView(): string;
        /**
         * This method used to navigate to the month/year/decade view of the DatePicker.
         * @param  {string} view - Specifies the view of the calendar.
         * @param  {Date} date - Specifies the focused date in a view.
         * @returns void
         */
        navigateTo(view: ej.calendars.CalendarView, date: Date): void;
        /**
         * To destroy the widget.
         * @returns void
         */
        destroy(): void;
        /**
         * Initialize the event handler
         * @private
         */
        protected preRender(): void;
        private checkHtmlAttributes();
        /**
         * To get component name.
         * @private
         */
        protected getModuleName(): string;
        private disabledDates();
        private setAriaAttributes();
        protected errorClass(): void;
        /**
         * Called internally if any of the property value changed.
         * returns void
         * @private
         */
        onPropertyChanged(newProp: ej.calendars.DatePickerModel, oldProp: ej.calendars.DatePickerModel): void;
    }
    export interface PopupObjectArgs {
        /** Defines the DatePicker popup element. */
        popup: ej.popups.Popup;
    }
    export interface PreventableEventArgs {
        /** Prevents the default action */
        preventDefault?: Function;
    }
    
    /**
     * Interface for a class Presets
     */
    export interface PresetsModel {
    
        /**
         * Defines the label string of the preset range. 
         */
        label?: string;
    
        /**
         * Defines the start date of the preset range 
         */
        start?: Date;
    
        /**
         * Defines the end date of the preset range 
         */
        end?: Date;
    
    }
    
    /**
     * Interface for a class DateRangePicker
     */
    export interface DateRangePickerModel extends CalendarModel{
    
        /**
         * Gets or sets the start date of the date range selection.
         * @default null
         */
        startDate?: Date;
    
        /**
         * Gets or sets the end date of the date range selection.
         * @default null
         */
        endDate?: Date;
    
        /**
         * Set the predefined ranges which let the user pick required range easily in a component.
         * @default null
         */
        presets?: PresetsModel[];
    
        /**
         * Specifies the width of the DateRangePicker component.
         * @default ''
         */
        width?: number | string;
    
        /**
         * specifies the z-index value of the dateRangePicker popup element.
         * @default 1000
         */
        zIndex?: number;
    
        /**
         * Specifies whether to show or hide the clear Icon
         * @default false
         */
        showClearButton?: boolean;
    
        /**
         *  Sets the root CSS class to the DateRangePicker which allows you to customize the appearance.
         * @default ''    
         */
        cssClass?: string;
    
        /**
         * Sets or gets the string that used between the start and end date string. 
         * @default '-'
         */
        separator?: string;
    
        /**
         *  Specifies the minimum span that can be allowed in date range selection.
         * @default null    
         */
        minDays?: number;
    
        /**
         *  Specifies the maximum span that can be allowed in a date range selection.
         * @default null
         */
        maxDays?: number;
    
        /**
         * Specifies the component to act as strict which allows entering only a valid date range in a DateRangePicker.
         * @default false
         */
        strictMode?: boolean;
    
        /**
         * Sets or gets the required date format to the start and end date string.
         * @default null
         */
        format?: string;
    
        /**
         * Specifies the component to be disabled which prevents the DateRangePicker from user interactions. 
         * @default true
         */
        enabled?: boolean;
    
        /**
         * Denies the editing the ranges in the DateRangePicker component. 
         * @default false
         */
        readonly?: boolean;
    
        /**
         * Specifies the placeholder text that need to be displayed in the DateRangePicker component.
         * @default ''
         */
        placeholder?: string;
    
        /**
         * Specifies the initial view of the Calendar when it is opened.
         * With the help of this property, initial view can be changed to year or decade view.
         * @default month
         * @hidden
         */
        start?: ej.calendars.CalendarView;
    
        /**
         * Sets the maximum level of view (month, year, decade) in the Calendar.
         * Depth view should be smaller than the start view to restrict its view navigation.
         * @default month
         * @hidden
         */
        depth?: ej.calendars.CalendarView;
    
        /**
         * Gets or sets the selected date of the Calendar
         * @default null
         * @hidden
         */
        value?: Date;
    
        /**
         * Triggers when the DateRangePicker is created
         * @event 
         */
        created?: ej.base.EmitType<Object>;
    
        /**
         * Triggers when the DateRangePicker is destroyed.
         * @event 
         */
        destroyed?: ej.base.EmitType<Object>;
    
        /**
         * Triggers when the DateRangePicker is opened.
         * @event 
         */
        open?: ej.base.EmitType<Object>;
    
        /**
         * Triggers when the DateRangePicker is closed.
         * @event 
         */
        close?: ej.base.EmitType<Object>;
    
        /**
         * Triggers when the date range value is changed in DateRangePicker.
         * @event 
         */
        change?: ej.base.EmitType<Object>;
    
        /**
         * Triggers when the Calendar is navigated to another level or within the same level of view.
         * @event
         * @hidden
         */
        navigated?: ej.base.EmitType<NavigatedEventArgs>;
    
        /**
         * Triggers on selecting the start and end date.
         * @event 
         */
        select?: ej.base.EmitType<Object>;
    
    }
    
    export class Presets extends ej.base.ChildProperty<Presets> {
        /**
         * Defines the label string of the preset range.
         */
        label: string;
        /**
         * Defines the start date of the preset range
         */
        start: Date;
        /**
         * Defines the end date of the preset range
         */
        end: Date;
    }
    export interface RangeEventArgs extends ej.base.BaseEventArgs {
        /** Defines the value string in the input element */
        value: string;
        /** Defines the start date  */
        startDate: Date;
        /** Defines the end date  */
        endDate: Date;
        /** Defines the day span between the range */
        daySpan: number;
    }
    export interface RangePopupEventArgs extends ej.base.BaseEventArgs {
        /** Defines the range string in the input element */
        date: string;
        /** Defines the DateRangePicker model */
        model: DateRangePickerModel;
        /** Defines the popup element */
        popup: ej.popups.Popup;
    }
    /**
     * Represents the DateRangePicker component that allows user to select the date range from the calendar
     * or entering the range through the input element.
     * ```html
     * <input id="daterangepicker"/>
     * ```
     * ```typescript
     * <script>
     *   var dateRangePickerObj = new DateRangePicker({ startDate: new Date("05/07/2017"), endDate: new Date("10/07/2017") });
     *   dateRangePickerObj.appendTo("#daterangepicker");
     * </script>
     * ```
     */
    export class DateRangePicker extends Calendar {
        private popupObj;
        private inputWrapper;
        private popupWrapper;
        private rightCalendar;
        private leftCalendar;
        private deviceCalendar;
        private leftCalCurrentDate;
        private rightCalCurrentDate;
        private leftCalPrevIcon;
        private leftCalNextIcon;
        private rightCalPrevIcon;
        private rightCalNextIcon;
        private inputKeyboardModule;
        protected leftKeyboardModule: ej.base.KeyboardEvents;
        protected rightKeyboardModule: ej.base.KeyboardEvents;
        private previousStartValue;
        private previousEndValue;
        private applyButton;
        private cancelButton;
        private startButton;
        private endButton;
        private cloneElement;
        private l10n;
        private isCustomRange;
        private isCustomWindow;
        private presetsItem;
        private liCollections;
        private activeIndex;
        private presetElement;
        private previousEleValue;
        private targetElement;
        private isTab;
        private disabledDayCnt;
        private angularTag;
        private inputElement;
        private modal;
        private isKeyPopup;
        private dateDisabled;
        private navNextFunction;
        private navPrevFunction;
        private deviceNavNextFunction;
        private deviceNavPrevFunction;
        private isRangeIconClicked;
        private isMaxDaysClicked;
        private popupKeyboardModule;
        private presetKeyboardModule;
        private btnKeyboardModule;
        private virtualRenderCellArgs;
        private disabledDays;
        private isMobile;
        private presetKeyConfig;
        private keyInputConfigs;
        private defaultConstant;
        /**
         * Gets or sets the start date of the date range selection.
         * @default null
         */
        startDate: Date;
        /**
         * Gets or sets the end date of the date range selection.
         * @default null
         */
        endDate: Date;
        /**
         * Set the predefined ranges which let the user pick required range easily in a component.
         * @default null
         */
        presets: PresetsModel[];
        /**
         * Specifies the width of the DateRangePicker component.
         * @default ''
         */
        width: number | string;
        /**
         * specifies the z-index value of the dateRangePicker popup element.
         * @default 1000
         */
        zIndex: number;
        /**
         * Specifies whether to show or hide the clear Icon
         * @default false
         */
        showClearButton: boolean;
        /**
         *  Sets the root CSS class to the DateRangePicker which allows you to customize the appearance.
         * @default ''
         */
        cssClass: string;
        /**
         * Sets or gets the string that used between the start and end date string.
         * @default '-'
         */
        separator: string;
        /**
         *  Specifies the minimum span that can be allowed in date range selection.
         * @default null
         */
        minDays: number;
        /**
         *  Specifies the maximum span that can be allowed in a date range selection.
         * @default null
         */
        maxDays: number;
        /**
         * Specifies the component to act as strict which allows entering only a valid date range in a DateRangePicker.
         * @default false
         */
        strictMode: boolean;
        /**
         * Sets or gets the required date format to the start and end date string.
         * @default null
         */
        format: string;
        /**
         * Specifies the component to be disabled which prevents the DateRangePicker from user interactions.
         * @default true
         */
        enabled: boolean;
        /**
         * Denies the editing the ranges in the DateRangePicker component.
         * @default false
         */
        readonly: boolean;
        /**
         * Specifies the placeholder text that need to be displayed in the DateRangePicker component.
         * @default ''
         */
        placeholder: string;
        /**
         * Specifies the initial view of the Calendar when it is opened.
         * With the help of this property, initial view can be changed to year or decade view.
         * @default month
         * @hidden
         */
        start: ej.calendars.CalendarView;
        /**
         * Sets the maximum level of view (month, year, decade) in the Calendar.
         * Depth view should be smaller than the start view to restrict its view navigation.
         * @default month
         * @hidden
         */
        depth: ej.calendars.CalendarView;
        /**
         * Gets or sets the selected date of the Calendar
         * @default null
         * @hidden
         */
        value: Date;
        /**
         * Triggers when the DateRangePicker is created
         * @event
         */
        created: ej.base.EmitType<Object>;
        /**
         * Triggers when the DateRangePicker is destroyed.
         * @event
         */
        destroyed: ej.base.EmitType<Object>;
        /**
         * Triggers when the DateRangePicker is opened.
         * @event
         */
        open: ej.base.EmitType<Object>;
        /**
         * Triggers when the DateRangePicker is closed.
         * @event
         */
        close: ej.base.EmitType<Object>;
        /**
         * Triggers when the date range value is changed in DateRangePicker.
         * @event
         */
        change: ej.base.EmitType<Object>;
        /**
         * Triggers when the Calendar is navigated to another level or within the same level of view.
         * @event
         * @hidden
         */
        navigated: ej.base.EmitType<NavigatedEventArgs>;
        /**
         * Triggers on selecting the start and end date.
         * @event
         */
        select: ej.base.EmitType<Object>;
        /**
         * Constructor for creating the widget
         */
        constructor(options?: DateRangePickerModel, element?: string | HTMLInputElement);
        /**
         * To Initialize the control rendering.
         * @return void
         * @private
         */
        protected render(): void;
        /**
         * Initialize the event handler
         * @returns void
         * @private
         */
        protected preRender(): void;
        private initProperty();
        private initialize();
        private processPresets();
        protected bindEvents(): void;
        private bindClearEvent();
        protected resetHandler(e: MouseEvent): void;
        private clear();
        private rangeIconHandler(e);
        private checkHtmlAttributes();
        private createPopup();
        private renderControl();
        private clearCalendarEvents();
        private updateNavIcons();
        private calendarIconEvent();
        private bindCalendarEvents();
        private calendarIconRipple();
        private deviceCalendarEvent();
        private deviceNavNext(e);
        private deviceNavPrevious(e);
        private updateDeviceCalendar(calendar);
        private deviceHeaderClick(event);
        private inputBlurHandler();
        private clearRange();
        private errorClass();
        private keyCalendarUpdate(isLeftCalendar, ele);
        private navInCalendar(e, isLeftCalendar, leftLimit, rightLimit, ele);
        private keyInputHandler(e);
        private keyNavigation(calendar, e);
        private inputHandler(e);
        private bindCalendarCellEvents(calendar?);
        private removeFocusedDate();
        private hoverSelection(event, element);
        private updateRange(elementCollection);
        private checkMinMaxDays();
        private rangeArgs();
        private otherMonthSelect(ele, isStartDate, sameDate?);
        private selectRange(event, element);
        private selectableDates();
        private updateMinMaxDays(calendar);
        private removeClassDisabled();
        private updateHeader();
        private removeSelection();
        private addSelectedAttributes(ele, date, isStartDate, sameDate?);
        private removeSelectedAttributes();
        private updateCalendarElement(calendar);
        private navPreviousMonth(event);
        private deviceNavigation(ele?);
        private updateControl(calendar);
        private navNextMonth(event);
        private compareMonths(start, end);
        private isPopupOpen();
        private createHeader();
        private disableInput();
        private validateMinMax();
        private validateDates();
        private validateRangeStrict();
        private validateRange();
        private validateMinMaxDays();
        private renderCalendar();
        private isSameMonth(start, end);
        private selectNextMonth();
        private selectStartMonth();
        private createCalendar();
        private createControl();
        private cancelFunction(eve?);
        private deviceHeaderUpdate();
        private applyFunction(eve?);
        private onMouseClick(event, item?);
        private onMouseOver(event);
        private onMouseLeave(event);
        private setListSelection(li, event);
        private removeListSelection();
        private applyPresetRange(values);
        private renderCustomPopup();
        private listRippleEffect();
        private createPresets();
        private wireListEvents();
        private unWireListEvents();
        private renderPopup();
        private calendarFocus();
        private presetHeight();
        private presetKeyActionHandler(e);
        private listMoveDown(e);
        private listMoveUp(e);
        private getHoverLI();
        private getActiveLI();
        private popupKeyBoardHandler();
        private setScrollPosition();
        private popupKeyActionHandle(e);
        private iconBlurHandler();
        private removeIconTabindex();
        private addIconTabindex();
        private documentHandler(e);
        private createInput();
        private refreshControl();
        private updateInput();
        private isDateDisabled(date);
        private disabledDateRender();
        private virtualRenderCellEvent(args);
        private disabledDates();
        private changeTrigger();
        /**
         * This method is used to navigate to the month/year/decade view of the Calendar.
         * @param  {string} view - Specifies the view of the Calendar.
         * @param  {Date} date - Specifies the focused date in a view.
         * @returns void
         * @hidden
         */
        navigateTo(view: ej.calendars.CalendarView, value: Date): void;
        /**
         * To destroy the widget.
         * @returns void
         */
        destroy(): void;
        /**
         * To get component name
         * @returns string
         * @private
         */
        protected getModuleName(): string;
        /**
         * Return the properties that are maintained upon browser refresh.
         * @returns string
         */
        getPersistData(): string;
        /**
         * Return the selected range and day span in the DateRangePicker.
         * @returns Object
         */
        getSelectedRange(): Object;
        /**
         * To open the Popup container in the DateRangePicker component.
         * @returns void
         */
        show(element?: HTMLElement): void;
        /**
         * To close the Popup container in the DateRangePicker component.
         * @returns void
         */
        hide(): void;
        private setLocale();
        /**
         * Called internally if any of the property value changed.
         * returns void
         * @private
         */
        onPropertyChanged(newProp: DateRangePickerModel, oldProp: DateRangePickerModel): void;
    }
    
    /**
     * Interface for a class DateTimePicker
     */
    export interface DateTimePickerModel extends DatePickerModel{
    
        /**
         * Specifies the format of the time value that to be displayed in time popup list.
         * @default null
         */
        timeFormat?: string;
    
        /**
         * Specifies the time interval between the two adjacent time values in the time popup list . 
         * @default 30
         */
        step?: number;
    
        /**
         * specifies the z-index value of the popup element.
         * @default 1000
         */
        zIndex?: number;
    
        /**
         * Specifies whether to show or hide the clear icon in textbox.
         * @default false
         */
        showClearButton?: boolean;
    
        /**
         * Specifies the placeholder text that to be is displayed in textbox.
         * @default null
         */
        placeholder?: string;
    
        /**
         * Specifies the component whether to act as strict or not. So that, it allows to enter only a valid datetime value
         * or else it will resets to previous value. By default, strictMode is in false.
         * @default false
         */
        strictMode?: boolean;
    
        /**
         * Triggers when popup is opened.
         * @event 
         */
        open?: ej.base.EmitType<Object>;
    
        /**
         * Triggers when popup is closed.
         * @event 
         */
        close?: ej.base.EmitType<Object>;
    
        /**
         * Triggers when input loses the focus.
         * @event 
         */
        blur?: ej.base.EmitType<Object>;
    
        /**
         * Triggers when input gets focus.
         * @event 
         */
        focus?: ej.base.EmitType<Object>;
    
        /**
         * Triggers when DateTimePicker is created.
         * @event 
         */
        created?: ej.base.EmitType<Object>;
    
        /**
         * Triggers when DateTimePicker is destroyed.
         * @event 
         */
        destroyed?: ej.base.EmitType<Object>;
    
    }
    
    /**
     * Represents the DateTimePicker component that allows user to select
     * or enter a date time value.
     * ```html
     * <input id="dateTimePicker"/>
     * ````
     * ````typescript
     * <script>
     *   var dateTimePickerObject = new DateTimePicker({ value: new Date() });
     *   dateTimePickerObject.appendTo("#dateTimePicker");
     * </script>
     * ```
     */
    export class DateTimePicker extends DatePicker {
        private timeIcon;
        private cloneElement;
        private dateTimeWrapper;
        private rippleFn;
        private listWrapper;
        private liCollections;
        private timeCollections;
        private listTag;
        private selectedElement;
        private containerStyle;
        private popupObject;
        protected timeModal: HTMLElement;
        private isNavigate;
        private timeValue;
        protected l10n: ej.base.L10n;
        private keyboardHandler;
        protected inputEvent: ej.base.KeyboardEvents;
        private activeIndex;
        private valueWithMinutes;
        private previousDateTime;
        private initValue;
        private isValidState;
        protected timekeyConfigure: {
            [key: string]: string;
        };
        /**
         * Specifies the format of the time value that to be displayed in time popup list.
         * @default null
         */
        timeFormat: string;
        /**
         * Specifies the time interval between the two adjacent time values in the time popup list .
         * @default 30
         */
        step: number;
        /**
         * specifies the z-index value of the popup element.
         * @default 1000
         */
        zIndex: number;
        /**
         * Specifies whether to show or hide the clear icon in textbox.
         * @default false
         */
        showClearButton: boolean;
        /**
         * Specifies the placeholder text that to be is displayed in textbox.
         * @default null
         */
        placeholder: string;
        /**
         * Specifies the component whether to act as strict or not. So that, it allows to enter only a valid datetime value
         * or else it will resets to previous value. By default, strictMode is in false.
         * @default false
         */
        strictMode: boolean;
        /**
         * Triggers when popup is opened.
         * @event
         */
        open: ej.base.EmitType<Object>;
        /**
         * Triggers when popup is closed.
         * @event
         */
        close: ej.base.EmitType<Object>;
        /**
         * Triggers when input loses the focus.
         * @event
         */
        blur: ej.base.EmitType<Object>;
        /**
         * Triggers when input gets focus.
         * @event
         */
        focus: ej.base.EmitType<Object>;
        /**
         * Triggers when DateTimePicker is created.
         * @event
         */
        created: ej.base.EmitType<Object>;
        /**
         * Triggers when DateTimePicker is destroyed.
         * @event
         */
        destroyed: ej.base.EmitType<Object>;
        /**
         * Constructor for creating the widget
         */
        constructor(options?: DateTimePickerModel, element?: string | HTMLInputElement);
        /**
         * Sets the focus to widget for interaction.
         * @returns void
         */
        focusIn(): void;
        /**
         * Remove the focus from widget, if the widget is in focus state.
         * @returns void
         */
        focusOut(): void;
        /**
         * To destroy the widget.
         * @returns void
         */
        destroy(): void;
        /**
         * To Initialize the control rendering.
         * @return void
         * @private
         */
        render(): void;
        private setValue();
        private validateMinMaxRange(value);
        private checkValidState(value);
        private checkErrorState();
        private validateValue(value);
        private disablePopupButton(isDisable);
        private getFormattedValue(value);
        private isDateObject(value);
        private createInputElement();
        private renderTimeIcon();
        private bindInputEvents();
        private unBindInputEvents();
        private cldrTimeFormat();
        private cldrDateTimeFormat();
        private getCldrFormat(type);
        private isNullOrEmpty(value);
        protected getCultureTimeObject(ld: Object, c: string): Object;
        private timeHandler(e?);
        private dateHandler(e?);
        show(type?: string): void;
        toggle(): void;
        private listCreation();
        private popupCreation(type);
        private openPopup();
        private documentClickHandler(event);
        private isTimePopupOpen();
        private isDatePopupOpen();
        private renderPopup();
        private setPopupWidth();
        protected wireTimeListEvents(): void;
        protected unWireTimeListEvents(): void;
        private onMouseOver(event);
        private onMouseLeave();
        private setTimeHover(li, className);
        protected getPopupHeight(): number;
        protected changeEvent(): void;
        private updateValue();
        private setTimeScrollPosition();
        private setInputValue(type);
        private getFullDateTime();
        private combineDateTime(value);
        private onMouseClick(event);
        private setSelection(li, event);
        private setTimeActiveClass();
        private setTimeActiveDescendant();
        protected addTimeSelection(): void;
        protected removeTimeSelection(): void;
        protected removeTimeHover(className: string): void;
        protected getTimeHoverItem(className: string): Element[];
        protected isValidLI(li: Element | HTMLElement): boolean;
        private calculateStartEnd(value, range, method);
        private startTime(date);
        private endTime(date);
        hide(): void;
        private closePopup();
        protected preRender(): void;
        protected getProperty(date: DateTimePickerModel, val: string): void;
        protected checkAttributes(): void;
        private getTimeActiveElement();
        protected createDateObj(val: Date | string): Date;
        private getDateObject(text);
        protected findNextTimeElement(event: ej.base.KeyboardEventArgs): void;
        protected setTimeValue(date: Date, value: Date): Date;
        protected timeElementValue(value: Date): Date;
        protected timeKeyHandler(event: ej.base.KeyboardEventArgs): void;
        protected TimeKeyActionHandle(event: ej.base.KeyboardEventArgs): void;
        protected inputKeyAction(event: ej.base.KeyboardEventArgs): void;
        onPropertyChanged(newProp: DateTimePickerModel, oldProp: DateTimePickerModel): void;
        /**
         * To get component name.
         * @private
         */
        protected getModuleName(): string;
    }
    
    /**
     * Interface for a class TimePicker
     */
    export interface TimePickerModel extends ej.base.ComponentModel{
    
        /**
         * Gets or sets the width of the TimePicker component. The width of the popup is based on the width of the component.
         * @default '100%'
         */
        width?: string | number;
    
        /**
         * Specifies the root CSS class of the TimePicker that allows to
         * customize the appearance by overriding the styles.
         * @default null
         */
        cssClass?: string;
    
        /**
         * Specifies the component to act as strict so that, it allows to enter only a valid time value within a specified range or else 
         * resets to previous value. By default, strictMode is in false.
         * @default false
         */
        strictMode?: boolean;
    
        /**
         * Specifies the format of value that is to be displayed in component. By default, the format is
         * based on the culture. 
         * @default null
         */
        format?: string;
    
        /**
         * Specifies whether the component to be disabled or not.
         * @default true
         */
        enabled?: boolean;
    
        /**
         * Specifies the component in readonly state. 
         * @default false
         */
        readonly?: boolean;
    
        /**
         * Specifies the placeholder text to be floated.
         */
        floatLabelType?: ej.inputs.FloatLabelType;
    
        /**
         * Specifies the placeholder text that is displayed in textbox.
         * @default null
         */
        placeholder?: string;
    
        /**
         * specifies the z-index value of the timePicker popup element.
         * @default 1000
         */
        zIndex?: number;
    
        /**
         * Specifies whether to show or hide the clear Icon
         * @default false
         */
        showClearButton?: boolean;
    
        /**
         * Specifies the time interval between the two adjacent time values in the popup list . 
         * @default 30
         */
        step?: number;
    
        /**
         * Specifies the scroll bar position if there is no value is selected in the popup list or
         *  the given value is not present in the popup list. 
         * @default null
         */
        scrollTo?: Date;
    
        /**
         * Gets or sets the value of the component. The value is parsed based on the format. 
         * @default null
         */
        value?: Date;
    
        /**
         * Gets or sets the minimum time value that can be allowed to select in TimePicker.
         * @default 00:00
         */
        min?: Date;
    
        /**
         * Gets or sets the maximum time value that can be allowed to select in TimePicker.
         * @default 00:00
         */
        max?: Date;
    
        /**
         * Specifies the component to be rendered in right-to-left direction.
         * @default false
         */
        enableRtl?: boolean;
    
        /**
         * Triggers when the value is changed.
         * @event  
         */
        change?: ej.base.EmitType<ChangeEventArgs>;
    
        /**
         * Triggers when the component is created.
         * @event
         */
        created?: ej.base.EmitType<Object>;
    
        /**
         * Triggers when the component is destroyed.
         * @event
         */
        destroyed?: ej.base.EmitType<Object>;
    
        /**
         * Triggers when the popup is opened.
         * @event
         */
        open?: ej.base.EmitType<PopupEventArgs>;
    
        /**
         * Triggers while rendering the each popup list item.
         * @event
         */
        itemRender?: ej.base.EmitType<ItemEventArgs>;
    
        /**
         * Triggers when the popup is closed.
         * @event
         */
        close?: ej.base.EmitType<PopupEventArgs>;
    
        /**
         * Triggers when the control loses the focus.
         * @event
         */
        blur?: ej.base.EmitType<Object>;
    
        /**
         * Triggers when the control gets focused.
         * @event
         */
        focus?: ej.base.EmitType<Object>;
    
    }
    
    export interface ChangeEventArgs {
        /** Defines the boolean that returns true when the value is changed by user interaction, otherwise returns false. */
        isInteracted: boolean;
        /** Defines the selected time value of the TimePicker. */
        value: Date;
        /** Defines the selected time value as string. */
        text: string;
        /** Defines the type of the event. */
        e: ej.base.KeyboardEventArgs | FocusEvent | MouseEvent;
    }
    /**
     * Interface for before list item render .
     * @private
     */
    export interface ItemEventArgs extends ej.base.BaseEventArgs {
        /** Defines the created LI element. */
        element: HTMLElement;
        /** Defines the displayed text value in a popup list. */
        text: string;
        /** Defines the Date object of displayed text in a popup list. */
        value: Date;
        /** Specifies whether to disable the current time value or not. */
        isDisabled: Boolean;
    }
    export interface CursorPositionDetails {
        /** Defines the text selection starting position. */
        start: number;
        /** Defines the text selection end position. */
        end: number;
    }
    export interface MeridianText {
        /** Defines the culture specific meridian text for AM. */
        am: string;
        /** Defines the culture specific meridian text for PM. */
        pm: string;
    }
    export interface PopupEventArgs {
        /** Defines the TimePicker popup element. */
        popup: ej.popups.Popup;
    }
    export namespace TimePickerBase {
        function createListItems(min: Date, max: Date, globalize: ej.base.Internationalization, timeFormat: string, step: number): {
            collection: number[];
            list: HTMLElement;
        };
    }
    /**
     * TimePicker is an intuitive interface component which provides an options to select a time value
     * from popup list or to set a desired time value.
     * ```
     * <input id='timepicker' type='text'/>
     * <script>
     *   var timePickerObj = new TimePicker({ value: new Date() });
     *   timePickerObj.appendTo('#timepicker');
     * </script>
     * ```
     */
    export class TimePicker extends ej.base.Component<HTMLElement> implements ej.inputs.IInput {
        private inputWrapper;
        private popupWrapper;
        private cloneElement;
        private listWrapper;
        private listTag;
        private selectedElement;
        private liCollections;
        protected inputElement: HTMLInputElement;
        private popupObj;
        protected inputEvent: ej.base.KeyboardEvents;
        protected globalize: ej.base.Internationalization;
        private defaultCulture;
        private containerStyle;
        private rippleFn;
        private l10n;
        private cursorDetails;
        private activeIndex;
        private timeCollections;
        private isNavigate;
        private disableItemCollection;
        protected isPreventBlur: boolean;
        private isTextSelected;
        private prevValue;
        private inputStyle;
        private angularTag;
        private valueWithMinutes;
        private prevDate;
        private initValue;
        private initMin;
        private initMax;
        private isIconClicked;
        protected keyConfigure: {
            [key: string]: string;
        };
        /**
         * Gets or sets the width of the TimePicker component. The width of the popup is based on the width of the component.
         * @default '100%'
         */
        width: string | number;
        /**
         * Specifies the root CSS class of the TimePicker that allows to
         * customize the appearance by overriding the styles.
         * @default null
         */
        cssClass: string;
        /**
         * Specifies the component to act as strict so that, it allows to enter only a valid time value within a specified range or else
         * resets to previous value. By default, strictMode is in false.
         * @default false
         */
        strictMode: boolean;
        /**
         * Specifies the format of value that is to be displayed in component. By default, the format is
         * based on the culture.
         * @default null
         */
        format: string;
        /**
         * Specifies whether the component to be disabled or not.
         * @default true
         */
        enabled: boolean;
        /**
         * Specifies the component in readonly state.
         * @default false
         */
        readonly: boolean;
        /**
         * Specifies the placeholder text to be floated.
         */
        floatLabelType: ej.inputs.FloatLabelType;
        /**
         * Specifies the placeholder text that is displayed in textbox.
         * @default null
         */
        placeholder: string;
        /**
         * specifies the z-index value of the timePicker popup element.
         * @default 1000
         */
        zIndex: number;
        /**
         * Specifies whether to show or hide the clear Icon
         * @default false
         */
        showClearButton: boolean;
        /**
         * Specifies the time interval between the two adjacent time values in the popup list .
         * @default 30
         */
        step: number;
        /**
         * Specifies the scroll bar position if there is no value is selected in the popup list or
         *  the given value is not present in the popup list.
         * @default null
         */
        scrollTo: Date;
        /**
         * Gets or sets the value of the component. The value is parsed based on the format.
         * @default null
         */
        value: Date;
        /**
         * Gets or sets the minimum time value that can be allowed to select in TimePicker.
         * @default 00:00
         */
        min: Date;
        /**
         * Gets or sets the maximum time value that can be allowed to select in TimePicker.
         * @default 00:00
         */
        max: Date;
        /**
         * Specifies the component to be rendered in right-to-left direction.
         * @default false
         */
        enableRtl: boolean;
        /**
         * Triggers when the value is changed.
         * @event
         */
        change: ej.base.EmitType<ChangeEventArgs>;
        /**
         * Triggers when the component is created.
         * @event
         */
        created: ej.base.EmitType<Object>;
        /**
         * Triggers when the component is destroyed.
         * @event
         */
        destroyed: ej.base.EmitType<Object>;
        /**
         * Triggers when the popup is opened.
         * @event
         */
        open: ej.base.EmitType<PopupEventArgs>;
        /**
         * Triggers while rendering the each popup list item.
         * @event
         */
        itemRender: ej.base.EmitType<ItemEventArgs>;
        /**
         * Triggers when the popup is closed.
         * @event
         */
        close: ej.base.EmitType<PopupEventArgs>;
        /**
         * Triggers when the control loses the focus.
         * @event
         */
        blur: ej.base.EmitType<Object>;
        /**
         * Triggers when the control gets focused.
         * @event
         */
        focus: ej.base.EmitType<Object>;
        /**
         * Constructor for creating the widget
         */
        constructor(options?: TimePickerModel, element?: string | HTMLInputElement);
        /**
         * Initialize the event handler
         * @private
         */
        protected preRender(): void;
        protected render(): void;
        private validateDisable();
        private initialize();
        private checkDateValue(value);
        private createInputElement();
        destroy(): void;
        private popupCreation();
        protected getPopupHeight(): number;
        private generateList();
        private popupCalculation();
        private isEmptyList();
        private renderPopup();
        private getFormattedValue(value);
        private getDateObject(text);
        private checkErrorState(val);
        private validateInterval();
        private disableTimeIcon();
        private disableElement(element);
        private enableElement(element);
        private selectInputText();
        private getMeridianText();
        private getCursorSelection();
        private getActiveElement();
        private isNullOrEmpty(value);
        private setWidth();
        private setScrollPosition();
        private findScrollTop(element);
        private setScrollTo();
        private getText();
        private getValue(value);
        private cldrDateFormat();
        private cldrTimeFormat();
        private dateToNumeric();
        private getExactDateTime(value);
        private setValue(value);
        private updatePlaceHolder();
        private popupHandler(e);
        private mouseDownHandler();
        private mouseUpHandler(event);
        private focusSelection();
        private inputHandler(event);
        private onMouseClick(event);
        private closePopup(delay?);
        private checkValueChange(event, isNavigation);
        private onMouseOver(event);
        private setHover(li, className);
        private setSelection(li, event);
        private onMouseLeave();
        private scrollHandler();
        private setMinMax(minVal, maxVal);
        protected validateMinMax(dateVal: Date | string, minVal: Date, maxVal: Date): Date | string;
        private valueIsDisable(value);
        protected validateState(val: string | Date): boolean;
        protected strictOperation(minimum: Date, maximum: Date, dateVal: Date | string, val: Date): Date | string;
        protected bindEvents(): void;
        protected unBindEvents(): void;
        private bindClearEvent();
        protected clearHandler(e: MouseEvent): void;
        private clear(event);
        protected setZIndex(): void;
        protected checkAttributes(): void;
        protected setCurrentDate(value: Date): Date;
        protected getSeparator(): string;
        protected getTextFormat(): number;
        protected updateValue(value: string | Date, event: ej.base.KeyboardEventArgs | FocusEvent): void;
        protected previousState(date: Date): string;
        protected resetState(): void;
        protected objToString(val: Date): string;
        protected checkValue(value: string | Date): string;
        protected validateValue(date: Date, value: string | Date): string;
        protected findNextElement(event: ej.base.KeyboardEventArgs): void;
        protected elementValue(value: Date): void;
        private validLiElement(index, backward?);
        protected keyHandler(event: ej.base.KeyboardEventArgs): void;
        protected setPopupPosition(): number;
        protected getCultureTimeObject(ld: Object, c: string): Object;
        protected getCultureDateObject(ld: Object, c: string): Object;
        protected wireListEvents(): void;
        protected unWireListEvents(): void;
        protected valueProcess(event: ej.base.KeyboardEventArgs | FocusEvent | MouseEvent, value: Date): void;
        protected changeEvent(event: ej.base.KeyboardEventArgs | FocusEvent | MouseEvent): void;
        protected updateInput(isUpdate: boolean, date: Date): void;
        protected setActiveDescendant(): void;
        protected removeSelection(): void;
        protected removeHover(className: string): void;
        protected getHoverItem(className: string): Element[];
        private setActiveClass();
        protected addSelection(): void;
        protected isValidLI(li: Element | HTMLElement): boolean;
        protected createDateObj(val: Date | string): Date;
        protected TimeParse(today: string, val: Date | string): Date;
        protected createListItems(): void;
        private documentClickHandler(event);
        protected setEnableRtl(): void;
        protected setEnable(): void;
        protected getProperty(date: TimePickerModel, val: string): void;
        /**
         * Focuses out the TimePicker textbox element.
         * @returns void
         */
        focusOut(): void;
        private isPopupOpen();
        /**
         * Focused the TimePicker textbox element.
         * @returns void
         */
        focusIn(e?: MouseEvent): void;
        /**
         * Hides the TimePicker popup.
         * @returns void
         */
        hide(): void;
        /**
         * Opens the popup to show the list items.
         * @returns void
         */
        show(): void;
        /**
         * Gets the properties to be maintained upon browser refresh.
         * @returns string
         */
        getPersistData(): string;
        /**
         * To get component name
         * @private
         */
        protected getModuleName(): string;
        /**
         * Called internally if any of the property value changed.
         * returns void
         * @private
         */
        onPropertyChanged(newProp: TimePickerModel, oldProp: TimePickerModel): void;
    }
    
  }
  export namespace charts {
    
    /**
     * Interface for a class AccumulationChart
     */
    export interface AccumulationChartModel extends ej.base.ComponentModel{
    
        /**
         * The width of the chart as a string in order to provide input as both like '100px' or '100%'.
         * If specified as '100%, chart will render to the full width of its parent element.
         * @default null
         */
    
        width?: string;
    
        /**
         * The height of the chart as a string in order to provide input as both like '100px' or '100%'.
         * If specified as '100%, chart will render to the full height of its parent element.
         * @default null
         */
    
        height?: string;
    
        /**
         * Title for accumulation chart
         * @default null
         */
        title?: string;
    
        /**
         * Options for customizing the `title` of accumulation chart.
         */
    
        titleStyle?: FontModel;
    
        /**
         * Options for customizing the legend of accumulation chart.
         */
        legendSettings?: LegendSettingsModel;
    
        /**
         * Options for customizing the tooltip of accumulation chart.
         */
    
        tooltip?:  TooltipSettingsModel;
    
        /**
         * Specifies whether point has to get selected or not. Takes value either 'None 'or 'Point'
         * @default None
         */
        selectionMode?: AccumulationSelectionMode;
    
        /**
         * If set true, enables the multi selection in accumulation chart. It requires `selectionMode` to be `Point`.
         * @default false
         */
        isMultiSelect?: boolean;
    
        /**
         * Specifies the point indexes to be selected while loading a accumulation chart.
         * It requires `selectionMode` to be `Point`.
         * ```html
         * <div id='Pie'></div>
         * ```
         * ```typescript
         * let pie: AccumulationChart = new AccumulationChart({
         * ...
         *   selectionMode: 'Point',
         *   selectedDataIndexes: [ { series: 0, point: 1},
         *                          { series: 2, point: 3} ],
         * ...
         * });
         * pie.appendTo('#Pie');
         * ```
         * @default []
         */
        selectedDataIndexes?: IndexesModel[];
    
        /**
         *  Options to customize the left, right, top and bottom margins of accumulation chart.
         */
    
        margin?: MarginModel;
    
        /**
         * If set true, labels for the point will be placed smartly without overlapping.
         * @default true
         */
        enableSmartLabels?: boolean;
    
        /**
         * Options for customizing the color and width of the chart border.
         */
    
        border?: BorderModel;
    
        /**
         * The background color of the chart, which accepts value in hex, rgba as a valid CSS color string.
         * @default null
         */
        background?: string;
    
        /**
         * The configuration for series in accumulation chart.
         */
    
        series?: AccumulationSeriesModel[];
    
        /**
         * The configuration for annotation in chart.
         */
    
        annotations?: AccumulationAnnotationSettingsModel[];
    
        /**
         * Specifies the theme for accumulation chart.
         * @default 'Material'
         */
        theme?: AccumulationTheme;
    
        /**
         * Triggers after accumulation chart loaded.
         * @event
         */
        loaded?: ej.base.EmitType<IAccLoadedEventArgs>;
    
        /**
         * Triggers before accumulation chart load.
         * @event
         */
        load?: ej.base.EmitType<IAccLoadedEventArgs>;
    
        /**
         * Triggers before the series gets rendered.
         * @event
         */
        seriesRender?: ej.base.EmitType<IAccSeriesRenderEventArgs>;
    
        /**
         * Triggers before the legend gets rendered.
         * @event
         */
        legendRender?: ej.base.EmitType<ILegendRenderEventArgs>;
    
        /**
         * Triggers before the data label for series gets rendered.
         * @event
         */
        textRender?: ej.base.EmitType<IAccTextRenderEventArgs>;
    
        /**
         * Triggers before the tooltip for series gets rendered.
         * @event
         */
        tooltipRender?: ej.base.EmitType<IAccTooltipRenderEventArgs>;
    
        /**
         * Triggers before each points for series gets rendered.
         * @event
         */
    
        pointRender?: ej.base.EmitType<IAccPointRenderEventArgs>;
    
        /**
         * Triggers before the annotation gets rendered.
         * @event
         */
    
        annotationRender?: ej.base.EmitType<IAnnotationRenderEventArgs>;
    
        /**
         * Triggers before the prints gets started.
         * @event
         */
    
        beforePrint?: ej.base.EmitType<IPrintEventArgs>;
    
        /**
         * Triggers on hovering the accumulation chart.
         * @event
         */
    
        chartMouseMove?: ej.base.EmitType<IMouseEventArgs>;
    
        /**
         * Triggers on clicking the accumulation chart.
         * @event
         */
    
        chartMouseClick?: ej.base.EmitType<IMouseEventArgs>;
    
        /**
         * Triggers on point click.
         * @event
         */
    
        pointClick?: ej.base.EmitType<IPointEventArgs>;
    
        /**
         * Triggers on point move.
         * @event
         */
    
        pointMove?: ej.base.EmitType<IPointEventArgs>;
    
        /**
         * Triggers after animation gets completed for series.
         * @event
         */
        animationComplete?: ej.base.EmitType<IAccAnimationCompleteEventArgs>;
    
        /**
         * Triggers on mouse down.
         * @event
         */
    
        chartMouseDown?: ej.base.EmitType<IMouseEventArgs>;
    
        /**
         * Triggers while cursor leaves the accumulation chart.
         * @event
         */
    
        chartMouseLeave?: ej.base.EmitType<IMouseEventArgs>;
    
        /**
         * Triggers on mouse up.
         * @event
         */
    
        chartMouseUp?: ej.base.EmitType<IMouseEventArgs>;
    
        /**
         * Triggers after window resize.
         * @event
         */
    
        resized?: ej.base.EmitType<IAccResizeEventArgs>;
    
        /**
         * Defines the currencyCode format of the accumulation chart
         * @private
         */
    
        currencyCode?: string;
    
    }
    /**
     * AccumulationChart file
     */
    
    /**
     * Represents the AccumulationChart control.
     * ```html
     * <div id="accumulation"/>
     * <script>
     *   var accObj = new AccumulationChart({ });
     *   accObj.appendTo("#accumulation");
     * </script>
     * ```
     */
    export class AccumulationChart extends ej.base.Component<HTMLElement> implements ej.base.INotifyPropertyChanged {
        /**
         * `accBaseModue` is used to define the common functionalities of accumulation series
         * @private
         */
        accBaseModule: AccumulationBase;
        /**
         * `pieSeriesModule` is used to render pie series.
         * @private
         */
        pieSeriesModule: PieSeries;
        /**
         * `funnelSeriesModule` is used to render funnel series.
         * @private
         */
        funnelSeriesModule: FunnelSeries;
        /**
         * `pyramidSeriesModule` is used to render funnel series.
         * @private
         */
        pyramidSeriesModule: PyramidSeries;
        /**
         * `accumulationLegendModule` is used to manipulate and add legend in accumulation chart.
         */
        accumulationLegendModule: AccumulationLegend;
        /**
         * `accumulationDataLabelModule` is used to manipulate and add dataLabel in accumulation chart.
         */
        accumulationDataLabelModule: AccumulationDataLabel;
        /**
         * `accumulationTooltipModule` is used to manipulate and add tooltip in accumulation chart.
         */
        accumulationTooltipModule: AccumulationTooltip;
        /**
         * `accumulationSelectionModule` is used to manipulate and add selection in accumulation chart.
         */
        accumulationSelectionModule: AccumulationSelection;
        /**
         * `annotationModule` is used to manipulate and add annotation in chart.
         */
        annotationModule: AccumulationAnnotation;
        /**
         * The width of the chart as a string in order to provide input as both like '100px' or '100%'.
         * If specified as '100%, chart will render to the full width of its parent element.
         * @default null
         */
        width: string;
        /**
         * The height of the chart as a string in order to provide input as both like '100px' or '100%'.
         * If specified as '100%, chart will render to the full height of its parent element.
         * @default null
         */
        height: string;
        /**
         * Title for accumulation chart
         * @default null
         */
        title: string;
        /**
         * Options for customizing the `title` of accumulation chart.
         */
        titleStyle: FontModel;
        /**
         * Options for customizing the legend of accumulation chart.
         */
        legendSettings: LegendSettingsModel;
        /**
         * Options for customizing the tooltip of accumulation chart.
         */
        tooltip: TooltipSettingsModel;
        /**
         * Specifies whether point has to get selected or not. Takes value either 'None 'or 'Point'
         * @default None
         */
        selectionMode: AccumulationSelectionMode;
        /**
         * If set true, enables the multi selection in accumulation chart. It requires `selectionMode` to be `Point`.
         * @default false
         */
        isMultiSelect: boolean;
        /**
         * Specifies the point indexes to be selected while loading a accumulation chart.
         * It requires `selectionMode` to be `Point`.
         * ```html
         * <div id='Pie'></div>
         * ```
         * ```typescript
         * let pie: AccumulationChart = new AccumulationChart({
         * ...
         *   selectionMode: 'Point',
         *   selectedDataIndexes: [ { series: 0, point: 1},
         *                          { series: 2, point: 3} ],
         * ...
         * });
         * pie.appendTo('#Pie');
         * ```
         * @default []
         */
        selectedDataIndexes: IndexesModel[];
        /**
         *  Options to customize the left, right, top and bottom margins of accumulation chart.
         */
        margin: MarginModel;
        /**
         * If set true, labels for the point will be placed smartly without overlapping.
         * @default true
         */
        enableSmartLabels: boolean;
        /**
         * Options for customizing the color and width of the chart border.
         */
        border: BorderModel;
        /**
         * The background color of the chart, which accepts value in hex, rgba as a valid CSS color string.
         * @default null
         */
        background: string;
        /**
         * The configuration for series in accumulation chart.
         */
        series: AccumulationSeriesModel[];
        /**
         * The configuration for annotation in chart.
         */
        annotations: AccumulationAnnotationSettingsModel[];
        /**
         * Specifies the theme for accumulation chart.
         * @default 'Material'
         */
        theme: AccumulationTheme;
        /**
         * Triggers after accumulation chart loaded.
         * @event
         */
        loaded: ej.base.EmitType<IAccLoadedEventArgs>;
        /**
         * Triggers before accumulation chart load.
         * @event
         */
        load: ej.base.EmitType<IAccLoadedEventArgs>;
        /**
         * Triggers before the series gets rendered.
         * @event
         */
        seriesRender: ej.base.EmitType<IAccSeriesRenderEventArgs>;
        /**
         * Triggers before the legend gets rendered.
         * @event
         */
        legendRender: ej.base.EmitType<ILegendRenderEventArgs>;
        /**
         * Triggers before the data label for series gets rendered.
         * @event
         */
        textRender: ej.base.EmitType<IAccTextRenderEventArgs>;
        /**
         * Triggers before the tooltip for series gets rendered.
         * @event
         */
        tooltipRender: ej.base.EmitType<IAccTooltipRenderEventArgs>;
        /**
         * Triggers before each points for series gets rendered.
         * @event
         */
        pointRender: ej.base.EmitType<IAccPointRenderEventArgs>;
        /**
         * Triggers before the annotation gets rendered.
         * @event
         */
        annotationRender: ej.base.EmitType<IAnnotationRenderEventArgs>;
        /**
         * Triggers before the prints gets started.
         * @event
         */
        beforePrint: ej.base.EmitType<IPrintEventArgs>;
        /**
         * Triggers on hovering the accumulation chart.
         * @event
         */
        chartMouseMove: ej.base.EmitType<IMouseEventArgs>;
        /**
         * Triggers on clicking the accumulation chart.
         * @event
         */
        chartMouseClick: ej.base.EmitType<IMouseEventArgs>;
        /**
         * Triggers on point click.
         * @event
         */
        pointClick: ej.base.EmitType<IPointEventArgs>;
        /**
         * Triggers on point move.
         * @event
         */
        pointMove: ej.base.EmitType<IPointEventArgs>;
        /**
         * Triggers after animation gets completed for series.
         * @event
         */
        animationComplete: ej.base.EmitType<IAccAnimationCompleteEventArgs>;
        /**
         * Triggers on mouse down.
         * @event
         */
        chartMouseDown: ej.base.EmitType<IMouseEventArgs>;
        /**
         * Triggers while cursor leaves the accumulation chart.
         * @event
         */
        chartMouseLeave: ej.base.EmitType<IMouseEventArgs>;
        /**
         * Triggers on mouse up.
         * @event
         */
        chartMouseUp: ej.base.EmitType<IMouseEventArgs>;
        /**
         * Triggers after window resize.
         * @event
         */
        resized: ej.base.EmitType<IAccResizeEventArgs>;
        /**
         * Defines the currencyCode format of the accumulation chart
         * @private
         */
        private currencyCode;
        /** @private */
        svgObject: Element;
        /** @private */
        initialClipRect: Rect;
        /** @private */
        availableSize: Size;
        /** @private */
        renderer: ej.base.SvgRenderer;
        /** @private */
        intl: ej.base.Internationalization;
        /** @private */
        visibleSeries: AccumulationSeries[];
        /** @private */
        seriesCounts: number;
        /** @private explode radius internal property */
        explodeDistance: number;
        /** @private Mouse position x */
        mouseX: number;
        /** @private Mouse position y */
        mouseY: number;
        private resizeTo;
        /** @private */
        center: ChartLocation;
        /** @private */
        readonly type: AccumulationType;
        /** @private */
        isTouch: boolean;
        /** @private */
        animateSeries: boolean;
        private titleCollection;
        /** @private */
        themeStyle: IThemeStyle;
        /**
         * Constructor for creating the AccumulationChart widget
         * @private
         */
        constructor(options?: AccumulationChartModel, element?: string | HTMLElement);
        /**
         *  To create svg object, renderer and binding events for the container.
         */
        protected preRender(): void;
        /**
         * Themeing for chart goes here
         */
        private setTheme();
        /**
         * To render the accumulation chart elements
         */
        protected render(): void;
        /**
         * Method to unbind events for accumulation chart
         */
        private unWireEvents();
        /**
         * Method to bind events for the accumulation chart
         */
        private wireEvents();
        /**
         * Method to set mouse x, y from events
         */
        private setMouseXY(e);
        /**
         * Handles the mouse end.
         * @return {boolean}
         * @private
         */
        accumulationMouseEnd(e: PointerEvent): boolean;
        /**
         * Handles the mouse start.
         * @return {boolean}
         * @private
         */
        accumulationMouseStart(e: PointerEvent): boolean;
        /**
         * Handles the accumulation chart resize.
         * @return {boolean}
         * @private
         */
        accumulationResize(e: Event): boolean;
        /**
         * Handles the export method for chart control.
         */
        export(type: ExportType, fileName: string, orientation?: ej.pdfexport.PdfPageOrientation): void;
        /**
         * Handles the print method for accumulation chart control.
         */
        print(id?: string[] | string | Element): void;
        /**
         * Applying styles for accumulation chart element
         */
        private setStyle(element);
        /**
         * Method to set the annotation content dynamically for accumulation.
         */
        setAnnotationValue(annotationIndex: number, content: string): void;
        /**
         * Handles the mouse move on accumulation chart.
         * @return {boolean}
         * @private
         */
        accumulationMouseMove(e: PointerEvent): boolean;
        titleTooltip(event: Event, x: number, y: number, isTouch?: boolean): void;
        /**
         * Handles the mouse click on accumulation chart.
         * @return {boolean}
         * @private
         */
        accumulationOnMouseClick(e: PointerEvent): boolean;
        private triggerPointEvent(event, element);
        /**
         * Handles the mouse right click on accumulation chart.
         * @return {boolean}
         * @private
         */
        accumulationRightClick(event: MouseEvent | PointerEvent): boolean;
        /**
         * Handles the mouse leave on accumulation chart.
         * @return {boolean}
         * @private
         */
        accumulationMouseLeave(e: PointerEvent): boolean;
        /**
         * Method to set culture for chart
         */
        private setCulture();
        /**
         * Method to create SVG element for accumulation chart.
         */
        private createPieSvg();
        /**
         * To Remove the SVG from accumulation chart.
         * @return {boolean}
         * @private
         */
        removeSvg(): void;
        /**
         * Method to create the secondary element for tooltip, datalabel and annotaitons.
         */
        private createSecondaryElement();
        /**
         * Method to find visible series based on series types
         */
        private calculateVisibleSeries();
        /**
         * To find points from dataSource
         */
        private processData();
        /**
         * To refresh the accumulation chart
         * @private
         */
        refreshChart(): void;
        /**
         * Method to find groupped points
         */
        private doGrouppingProcess();
        /**
         * Method to calculate bounds for accumulation chart
         */
        private calculateBounds();
        private calculateLegendBounds();
        /**
         * To render elements for accumulation chart
         * @private
         */
        renderElements(): void;
        /**
         * To set the left and top position for data label template for center aligned chart
         */
        private setSecondaryElementPosition();
        /**
         * To render the annotaitions for accumulation series.
         */
        private renderAnnotation();
        /**
         * Method to process the explode in accumulation chart
         */
        private processExplode();
        /**
         * Method to render series for accumulation chart
         */
        private renderSeries();
        /**
         * Method to render border for accumulation chart
         */
        private renderBorder();
        /**
         * Method to render legend for accumulation chart
         */
        private renderLegend();
        /**
         * To process the selection in accumulation chart
         */
        private processSelection();
        /**
         * To render title for accumulation chart
         */
        private renderTitle();
        /**
         * To get the series parent element
         * @private
         */
        getSeriesElement(): Element;
        /**
         * To refresh the all visible series points
         * @private
         */
        refreshSeries(): void;
        /**
         * To refresh points label region and visible
         * @private
         */
        refreshPoints(points: AccPoints[]): void;
        /**
         * To get Module name
         *  @private
         */
        getModuleName(): string;
        /**
         * To destroy the accumulationcharts
         * @private
         */
        destroy(): void;
        /**
         * To provide the array of modules needed for control rendering
         * @return {ej.base.ModuleDeclaration[]}
         * @private
         */
        requiredModules(): ej.base.ModuleDeclaration[];
        /**
         * To find datalabel visibility in series
         */
        private findDatalabelVisibility();
        /**
         * Get the properties to be maintained in the persisted state.
         * @private
         */
        getPersistData(): string;
        /**
         * Called internally if any of the property value changed.
         * @private
         */
        onPropertyChanged(newProp: AccumulationChartModel, oldProp: AccumulationChartModel): void;
    }
    
    /**
     * AccumulationChart annotation properties
     */
    
    /**
     * `AccumulationAnnotation` module handles the annotation for accumulation chart.
     */
    export class AccumulationAnnotation extends AnnotationBase {
        private pie;
        private annotations;
        private parentElement;
        /**
         * Constructor for accumulation chart annotation.
         * @private.
         */
        constructor(control: AccumulationChart, annotations: AccumulationAnnotationSettings[]);
        /**
         * Method to render the annotation for accumulation chart
         * @param element
         */
        renderAnnotations(element: Element): void;
        /**
         * Get module name.
         */
        protected getModuleName(): string;
        /**
         * To destroy the annotation.
         * @return {void}
         * @private
         */
        destroy(control: AccumulationChart): void;
    }
    
    /**
     * Interface for a class AccumulationAnnotationSettings
     */
    export interface AccumulationAnnotationSettingsModel {
    
        /**
         * Content of the annotation, which accepts the id of the custom element.
         * @default null
         */
        content?: string;
    
        /**
         * if set coordinateUnit as `Pixel` X specifies the axis value
         * else is specifies pixel or percentage of coordinate
         * @default 0
         */
        x?: string | Date | number;
    
        /**
         * if set coordinateUnit as `Pixel` Y specifies the axis value
         * else is specifies pixel or percentage of coordinate
         * @default 0
         */
        y?: string | number;
    
        /**
         * Specifies the coordinate units of the annotation. They are
         * * Pixel - Annotation renders based on x and y pixel value.
         * * Point - Annotation renders based on x and y axis value.
         * @default 'Pixel'
         */
    
        coordinateUnits?: Units;
    
        /**
         * Specifies the regions of the annotation. They are
         * * Chart - Annotation renders based on chart coordinates.
         * * Series - Annotation renders based on series coordinates.
         * @default 'Chart'
         */
    
        region?: Regions;
    
        /**
         * Specifies the position of the annotation. They are
         * * Top - Align the annotation element as top side.
         * * Bottom - Align the annotation element as bottom side.
         * * Middle - Align the annotation element as mid point.
         * @default 'Middle'
         */
    
        verticalAlignment?: Position;
    
        /**
         * Specifies the alignment of the annotation. They are
         * * Near - Align the annotation element as top side.
         * * Far - Align the annotation element as bottom side.
         * * Center - Align the annotation element as mid point.
         * @default 'Center'
         */
    
        horizontalAlignment?: Alignment;
    
        /**
         * Information about annotation for assistive technology.
         * @default null
         */
        description?: string;
    
    }
    
    /**
     * Interface for a class AccumulationDataLabelSettings
     */
    export interface AccumulationDataLabelSettingsModel {
    
        /**
         * If set true, data label for series gets render.
         * @default false
         */
    
        visible?: boolean;
    
        /**
         * The DataSource field which contains the data label value.
         * @default null
         */
    
        name?: string;
    
        /**
         * The background color of the data label, which accepts value in hex, rgba as a valid CSS color string.
         * @default 'transparent'
         */
    
        fill?: string;
    
        /**
         * Specifies the position of data label. They are.
         * * Outside - Places label outside the point.
         * * Inside - Places label inside the point.
         * @default 'Inside'
         */
    
        position?: AccumulationLabelPosition;
    
        /**
         * The roundedCornerX for the data label. It requires `border` values not to be null.
         * @default 5
         */
        rx?: number;
    
        /**
         * The roundedCornerY for the data label. It requires `border` values not to be null.
         * @default 5
         */
        ry?: number;
    
        /**
         * Option for customizing the border lines.
         */
    
        border?: BorderModel;
    
        /**
         * Option for customizing the data label text.
         */
    
        font?: FontModel;
    
        /**
         * Options for customize the connector line in series.
         * This property is applicable for Pie, Funnel and Pyramid series.
         * The default connector length for Pie series is '4%'. For other series, it is null.
         */
        connectorStyle?: ConnectorModel;
    
        /**
         * Custom template to format the data label content. Use ${point.x} and ${point.y} as a placeholder
         * text to display the corresponding data point.
         * @default null
         */
    
        template?: string;
    
    }
    
    /**
     * Interface for a class AccPoints
     */
    export interface AccPointsModel {
    
    }
    
    /**
     * Interface for a class AccumulationSeries
     */
    export interface AccumulationSeriesModel {
    
        /**
         * Specifies the dataSource for the series. It can be an array of JSON objects or an instance of DataManager.
         * ```html
         * <div id='Pie'></div> 
         * ```
         * ```typescript
         * let dataManager: ej.data.DataManager = new DataManager({
         *         url: 'http://mvc.syncfusion.com/Services/Northwnd.svc/Tasks/'
         * });
         * let query: ej.data.Query = new Query().take(50).where('Estimate', 'greaterThan', 0, false);
         * let pie: AccumulationChart = new AccumulationChart({
         * ...
         *     series: [{
         *        dataSource: dataManager,
         *        xName: 'Id',
         *        yName: 'Estimate',
         *        query: query
         *    }],
         * ...
         * });
         * pie.appendTo('#Pie');
         * ```
         * @default ''
         */
    
        dataSource?: Object | ej.data.DataManager;
    
        /**
         * Specifies Query to select data from dataSource. This property is applicable only when the dataSource is `ej.DataManager`.
         * @default null
         */
        query?: ej.data.Query;
    
        /**
         * The DataSource field which contains the x value.
         * @default ''
         */
    
        xName?: string;
    
        /**
         * Specifies the series name
         * @default ''
         */
    
        name?: string;
    
        /**
         * The DataSource field which contains the y value.
         * @default ''
         */
    
        yName?: string;
    
        /**
         * Specifies the series visibility.
         * @default true
         */
    
        visible?: boolean;
    
        /**
         * Options for customizing the border of the series.
         */
    
        border?: BorderModel;
    
        /**
         * Options for customizing the animation for series.
         */
    
        animation?: AnimationModel;
    
        /**
         * The shape of the legend. Each series has its own legend shape. They are
         * * Circle - Renders a circle.
         * * Rectangle - Renders a rectangle.
         * * Triangle - Renders a triangle.
         * * Diamond - Renders a diamond.
         * * Cross - Renders a cross.
         * * HorizontalLine - Renders a horizontalLine.
         * * VerticalLine - Renders a verticalLine.
         * * Pentagon - Renders a pentagon.
         * * InvertedTriangle - Renders a invertedTriangle.
         * * SeriesType -Render a legend shape based on series type. 
         * @default 'SeriesType'
         */
    
        legendShape?: LegendShape;
    
        /**
         * The DataSource field that contains the color value of point
         * It is applicable for series
         * @default ''
         */
    
        pointColorMapping?: string;
    
        /**
         * Custom style for the selected series or points.
         * @default null
         */
        selectionStyle?: string;
    
        /**
         * AccumulationSeries y values less than groupTo are combined into single slice named others
         * @default null
         */
        groupTo?: string;
    
        /**
         * The data label for the series.
         */
        dataLabel?: AccumulationDataLabelSettingsModel;
    
        /**
         * Palette for series points.
         * @default []
         */
        palettes?: string[];
    
        /**
         * Start angle for a series.
         * @default 0
         */
        startAngle?: number;
    
        /**
         * End angle for a series.
         * @default 360
         */
        endAngle?: number;
    
        /**
         * Radius of the pie series and its values in percentage.
         * @default '80%'
         */
        radius?: string;
    
        /**
         * When the innerRadius value is greater than 0 percentage, a donut will appear in pie series. It takes values only in percentage.
         * @default '0'
         */
        innerRadius?: string;
    
        /**
         * Specify the type of the series in accumulation chart. 
         * @default 'Pie'
         */
        type?: AccumulationType;
    
        /**
         * To enable or disable tooltip for a series.
         * @default true
         */
        enableTooltip?: boolean;
    
        /**
         * If set true, series points will be exploded on mouse click or touch.
         * @default false
         */
        explode?: boolean;
    
        /**
         * Distance of the point from the center, which takes values in both pixels and percentage. 
         * @default '30%'
         */
        explodeOffset?: string;
    
        /**
         * If set true, all the points in the series will get exploded on load.
         * @default false
         */
        explodeAll?: boolean;
    
        /**
         * Index of the point, to be exploded on load. 
         * @default null
         */
        explodeIndex?: number;
    
        /**
         * options to customize the empty points in series
         */
        emptyPointSettings?: EmptyPointSettingsModel;
    
        /**
         * Defines the distance between the segments of a funnel/pyramid series. The range will be from 0 to 1
         * @default 0
         */
        gapRatio?: number;
    
        /**
         * Defines the width of the funnel/pyramid with respect to the chart area
         * @default '80%'
         */
        width?: string;
    
        /**
         * Defines the height of the funnel/pyramid with respect to the chart area
         * @default '80%'
         */
        height?: string;
    
        /**
         * Defines the width of the funnel neck with respect to the chart area
         * @default '20%'
         */
        neckWidth?: string;
    
        /**
         * Defines the height of the funnel neck with respect to the chart area
         * @default '20%'
         */
        neckHeight?: string;
    
        /**
         * Defines how the values have to be reflected, whether through height/surface of the segments
         * @default 'Linear'
         */
        pyramidMode?: PyramidModes;
    
        /**
         * The opacity of the series.
         * @default 1.
         */
        opacity?: number;
    
    }
    /**
     * AccumulationChart base file
     */
    
    /**
     * Annotation for accumulation series
     */
    export class AccumulationAnnotationSettings extends ej.base.ChildProperty<AccumulationAnnotationSettings> {
        /**
         * Content of the annotation, which accepts the id of the custom element.
         * @default null
         */
        content: string;
        /**
         * if set coordinateUnit as `Pixel` X specifies the axis value
         * else is specifies pixel or percentage of coordinate
         * @default 0
         */
        x: string | Date | number;
        /**
         * if set coordinateUnit as `Pixel` Y specifies the axis value
         * else is specifies pixel or percentage of coordinate
         * @default 0
         */
        y: string | number;
        /**
         * Specifies the coordinate units of the annotation. They are
         * * Pixel - Annotation renders based on x and y pixel value.
         * * Point - Annotation renders based on x and y axis value.
         * @default 'Pixel'
         */
        coordinateUnits: Units;
        /**
         * Specifies the regions of the annotation. They are
         * * Chart - Annotation renders based on chart coordinates.
         * * Series - Annotation renders based on series coordinates.
         * @default 'Chart'
         */
        region: Regions;
        /**
         * Specifies the position of the annotation. They are
         * * Top - Align the annotation element as top side.
         * * Bottom - Align the annotation element as bottom side.
         * * Middle - Align the annotation element as mid point.
         * @default 'Middle'
         */
        verticalAlignment: Position;
        /**
         * Specifies the alignment of the annotation. They are
         * * Near - Align the annotation element as top side.
         * * Far - Align the annotation element as bottom side.
         * * Center - Align the annotation element as mid point.
         * @default 'Center'
         */
        horizontalAlignment: Alignment;
        /**
         * Information about annotation for assistive technology.
         * @default null
         */
        description: string;
    }
    /**
     * Configures the dataLabel in accumulation chart.
     */
    export class AccumulationDataLabelSettings extends ej.base.ChildProperty<AccumulationDataLabelSettings> {
        /**
         * If set true, data label for series gets render.
         * @default false
         */
        visible: boolean;
        /**
         * The DataSource field which contains the data label value.
         * @default null
         */
        name: string;
        /**
         * The background color of the data label, which accepts value in hex, rgba as a valid CSS color string.
         * @default 'transparent'
         */
        fill: string;
        /**
         * Specifies the position of data label. They are.
         * * Outside - Places label outside the point.
         * * Inside - Places label inside the point.
         * @default 'Inside'
         */
        position: AccumulationLabelPosition;
        /**
         * The roundedCornerX for the data label. It requires `border` values not to be null.
         * @default 5
         */
        rx: number;
        /**
         * The roundedCornerY for the data label. It requires `border` values not to be null.
         * @default 5
         */
        ry: number;
        /**
         * Option for customizing the border lines.
         */
        border: BorderModel;
        /**
         * Option for customizing the data label text.
         */
        font: FontModel;
        /**
         * Options for customize the connector line in series.
         * This property is applicable for Pie, Funnel and Pyramid series.
         * The default connector length for Pie series is '4%'. For other series, it is null.
         */
        connectorStyle: ConnectorModel;
        /**
         * Custom template to format the data label content. Use ${point.x} and ${point.y} as a placeholder
         * text to display the corresponding data point.
         * @default null
         */
        template: string;
    }
    /**
     * Points model for the series.
     */
    export class AccPoints {
        x: Object;
        y: number;
        visible: boolean;
        text: string;
        originalText: string;
        /** @private */
        label: string;
        color: string;
        symbolLocation: ChartLocation;
        index: number;
        /** @private */
        midAngle: number;
        /** @private */
        endAngle: number;
        /** @private */
        labelAngle: number;
        /** @private */
        region: Rect;
        /** @private */
        labelRegion: Rect;
        /** @private */
        labelVisible: boolean;
        /** @private */
        labelPosition: AccumulationLabelPosition;
        /** @private */
        yRatio: number;
        /** @private */
        heightRatio: number;
        /** @private */
        labelOffset: ChartLocation;
        regions: Rect[];
    }
    /**
     *  Configures the series in accumulation chart.
     */
    export class AccumulationSeries extends ej.base.ChildProperty<AccumulationSeries> {
        /**
         * Specifies the dataSource for the series. It can be an array of JSON objects or an instance of DataManager.
         * ```html
         * <div id='Pie'></div>
         * ```
         * ```typescript
         * let dataManager: ej.data.DataManager = new DataManager({
         *         url: 'http://mvc.syncfusion.com/Services/Northwnd.svc/Tasks/'
         * });
         * let query: ej.data.Query = new Query().take(50).where('Estimate', 'greaterThan', 0, false);
         * let pie: AccumulationChart = new AccumulationChart({
         * ...
         *     series: [{
         *        dataSource: dataManager,
         *        xName: 'Id',
         *        yName: 'Estimate',
         *        query: query
         *    }],
         * ...
         * });
         * pie.appendTo('#Pie');
         * ```
         * @default ''
         */
        dataSource: Object | ej.data.DataManager;
        /**
         * Specifies Query to select data from dataSource. This property is applicable only when the dataSource is `ej.DataManager`.
         * @default null
         */
        query: ej.data.Query;
        /**
         * The DataSource field which contains the x value.
         * @default ''
         */
        xName: string;
        /**
         * Specifies the series name
         * @default ''
         */
        name: string;
        /**
         * The DataSource field which contains the y value.
         * @default ''
         */
        yName: string;
        /**
         * Specifies the series visibility.
         * @default true
         */
        visible: boolean;
        /**
         * Options for customizing the border of the series.
         */
        border: BorderModel;
        /**
         * Options for customizing the animation for series.
         */
        animation: AnimationModel;
        /**
         * The shape of the legend. Each series has its own legend shape. They are
         * * Circle - Renders a circle.
         * * Rectangle - Renders a rectangle.
         * * Triangle - Renders a triangle.
         * * Diamond - Renders a diamond.
         * * Cross - Renders a cross.
         * * HorizontalLine - Renders a horizontalLine.
         * * VerticalLine - Renders a verticalLine.
         * * Pentagon - Renders a pentagon.
         * * InvertedTriangle - Renders a invertedTriangle.
         * * SeriesType -Render a legend shape based on series type.
         * @default 'SeriesType'
         */
        legendShape: LegendShape;
        /**
         * The DataSource field that contains the color value of point
         * It is applicable for series
         * @default ''
         */
        pointColorMapping: string;
        /**
         * Custom style for the selected series or points.
         * @default null
         */
        selectionStyle: string;
        /**
         * AccumulationSeries y values less than groupTo are combined into single slice named others
         * @default null
         */
        groupTo: string;
        /**
         * The data label for the series.
         */
        dataLabel: AccumulationDataLabelSettingsModel;
        /**
         * Palette for series points.
         * @default []
         */
        palettes: string[];
        /**
         * Start angle for a series.
         * @default 0
         */
        startAngle: number;
        /**
         * End angle for a series.
         * @default 360
         */
        endAngle: number;
        /**
         * Radius of the pie series and its values in percentage.
         * @default '80%'
         */
        radius: string;
        /**
         * When the innerRadius value is greater than 0 percentage, a donut will appear in pie series. It takes values only in percentage.
         * @default '0'
         */
        innerRadius: string;
        /**
         * Specify the type of the series in accumulation chart.
         * @default 'Pie'
         */
        type: AccumulationType;
        /**
         * To enable or disable tooltip for a series.
         * @default true
         */
        enableTooltip: boolean;
        /**
         * If set true, series points will be exploded on mouse click or touch.
         * @default false
         */
        explode: boolean;
        /**
         * Distance of the point from the center, which takes values in both pixels and percentage.
         * @default '30%'
         */
        explodeOffset: string;
        /**
         * If set true, all the points in the series will get exploded on load.
         * @default false
         */
        explodeAll: boolean;
        /**
         * Index of the point, to be exploded on load.
         * @default null
         */
        explodeIndex: number;
        /**
         * options to customize the empty points in series
         */
        emptyPointSettings: EmptyPointSettingsModel;
        /**
         * Defines the distance between the segments of a funnel/pyramid series. The range will be from 0 to 1
         * @default 0
         */
        gapRatio: number;
        /**
         * Defines the width of the funnel/pyramid with respect to the chart area
         * @default '80%'
         */
        width: string;
        /**
         * Defines the height of the funnel/pyramid with respect to the chart area
         * @default '80%'
         */
        height: string;
        /**
         * Defines the width of the funnel neck with respect to the chart area
         * @default '20%'
         */
        neckWidth: string;
        /**
         * Defines the height of the funnel neck with respect to the chart area
         * @default '20%'
         */
        neckHeight: string;
        /**
         * Defines how the values have to be reflected, whether through height/surface of the segments
         * @default 'Linear'
         */
        pyramidMode: PyramidModes;
        /**
         * The opacity of the series.
         * @default 1.
         */
        opacity: number;
        /** @private */
        points: AccPoints[];
        /** @private */
        dataModule: Data;
        /** @private */
        sumOfPoints: number;
        /** @private */
        index: number;
        private sumOfClub;
        /** @private */
        resultData: Object;
        /** @private */
        lastGroupTo: string;
        /** @private */
        isRectSeries: boolean;
        /** @private */
        clipRect: Rect;
        /**
         * To find the max bounds of the data label to place smart legend
         *  @private
         */
        labelBound: Rect;
        /**
         * To find the max bounds of the accumulation segment to place smart legend
         *  @private
         */
        accumulationBound: Rect;
        /**
         * Defines the funnel size
         * @private
         */
        triangleSize: Size;
        /**
         * Defines the size of the funnel neck
         * @private
         */
        neckSize: Size;
        /** @private To refresh the Datamanager for series */
        refreshDataManager(accumulation: AccumulationChart): void;
        /**
         * To get points on dataManager is success
         * @private
         */
        dataManagerSuccess(e: {
            result: Object;
            count: number;
        }, accumulation: AccumulationChart): void;
        /** @private To find points from result data */
        getPoints(result: Object, accumulation: AccumulationChart): void;
        /**
         * Method to set point index and color
         */
        private pushPoints(point, colors);
        /**
         * Method to find club point
         */
        private isClub(point, clubValue);
        /**
         * Method to find sum of points in the series
         */
        private findSumOfPoints(result);
        /**
         * Method to set points x, y and text from data source
         */
        private setPoints(data, i, colors);
        /**
         * Method render the series elements for accumulation chart
         * @private
         */
        renderSeries(accumulation: AccumulationChart): void;
        /**
         * Method render the points elements for accumulation chart series.
         */
        private renderPoints(accumulation, seriesGroup);
        /**
         * Method render the datalabel elements for accumulation chart.
         */
        private renderDataLabel(accumulation, datalabelGroup);
        /**
         * To find maximum bounds for smart legend placing
         * @private
         */
        findMaxBounds(totalbound: Rect, bound: Rect): void;
        /**
         * To set empty point value for null points
         * @private
         */
        setAccEmptyPoint(point: AccPoints, i: number, data: Object, colors: string[]): void;
        /**
         * To find point is empty
         */
        private isEmpty(point);
    }
    /**
     * method to get series from index
     * @private
     */
    export function getSeriesFromIndex(index: number, visibleSeries: AccumulationSeries[]): AccumulationSeries;
    /**
     * method to get point from index
     * @private
     */
    export function pointByIndex(index: number, points: AccPoints[]): AccPoints;
    
    /**
     * Accumulation charts Enum file
     */
    /**
     * Defines the Accumulation Chart series type.
     */
    export type AccumulationType = 'Pie' | 'Funnel' | 'Pyramid';
    /**
     * Defines the AccumulationLabelPosition. They are
     * * Inside - Define the data label position for the accumulation series Inside.
     * * Outside - Define the data label position for the accumulation series Outside.
     * *
     */
    export type AccumulationLabelPosition = 'Inside' | 'Outside';
    /**
     * Defines the ConnectorType. They are
     * * Line - Accumulation series Connector line type as Straight line.
     * * Curve - Accumulation series Connector line type as Curved line.
     * *
     */
    export type ConnectorType = 'Line' | 'Curve';
    /**
     * Defines the SelectionMode, They are.
     * * none - Disable the selection.
     * * point - To select a point.
     */
    export type AccumulationSelectionMode = 'None' | 'Point';
    /**
     * Defines Theme of the accumulation chart. They are
     * * Material - Render a accumulation chart with Material theme.
     * * Fabric - Render a accumulation chart with fabric theme.
     */
    export type AccumulationTheme = 'Material' | 'Fabric' | 'Bootstrap' | 'Highcontrast';
    /**
     * Defines the empty point mode of the chart.
     * * Zero - Used to display empty points as zero.
     * * Drop - Used to ignore the empty point while rendering.
     * * Average - Used to display empty points as previous and next point average.
     */
    export type AccEmptyPointMode = 'Zero' | 'Drop' | 'Average';
    /**
     * Defines the mode of the pyramid
     * * Linear - Height of the pyramid segments reflects the values
     * * Surface - Surface/Area of the  pyramid segments reflects the values
     */
    export type PyramidModes = 'Linear' | 'Surface';
    
    /**
     * Interface for Accumulation chart
     */
    
    /**
     * Accumulation Chart SeriesRender event arguments.
     */
    export interface IAccSeriesRenderEventArgs {
        /** Defines the current series */
        series: AccumulationSeries;
        /** Defines the current data object */
        data: Object;
        /** Defines the current series name */
        name: string;
    }
    /**
     * Accumulation Chart TextRender event arguments.
     */
    export interface IAccTextRenderEventArgs extends IChartEventArgs {
        /** Defines the current series */
        series: AccumulationSeriesModel;
        /** Defines the current point */
        point: AccPoints;
        /** Defines the current text */
        text: string;
        /** Defines the current fill color */
        color: string;
        /** Defines the current label border */
        border: BorderModel;
        /** Defines the current text template */
        template: string;
    }
    /**
     * Accumulation Chart TooltipRender event arguments.
     */
    export interface IAccTooltipRenderEventArgs extends IChartEventArgs {
        /** Defines the current tooltip content */
        content?: string | HTMLElement;
        /** Defines the current tooltip text style */
        textStyle?: FontModel;
        /** Defines the current tooltip series */
        series: AccumulationSeries;
        /** Defines the current tooltip point */
        point: AccPoints;
    }
    /**
     * Accumulation Chart AnimationComplete event arguments.
     */
    export interface IAccAnimationCompleteEventArgs extends IChartEventArgs {
        /** Defines the current animation series */
        series: AccumulationSeries;
        /** Defines the accumulation chart instance */
        accumulation: AccumulationChart;
    }
    /**
     * Accumulation Chart PointRender event arguments.
     */
    export interface IAccPointRenderEventArgs extends IChartEventArgs {
        /** Defines the current series of the point */
        series: AccumulationSeries;
        /** Defines the current point */
        point: AccPoints;
        /** Defines the current point fill color */
        fill: string;
        /** Defines the current point border color */
        border: BorderModel;
        /** Defines the current point height */
        height?: number;
        /** Defines the current point width */
        width?: number;
    }
    /**
     * Accumulation Chart Load or Loaded event arguments.
     */
    export interface IAccLoadedEventArgs extends IChartEventArgs {
        /** Defines the accumulation chart instance */
        accumulation: AccumulationChart;
    }
    /**
     * Accumulation Chart Resize event arguments.
     */
    export interface IAccResizeEventArgs {
        /** Defines the name of the Event */
        name: string;
        /** Defines the previous size of the accumulation chart */
        previousSize: Size;
        /** Defines the current size of the accumulation chart */
        currentSize: Size;
        /** Defines the accumulation chart instance */
        accumulation: AccumulationChart;
    }
    
    /**
     * Accumulation Base used to do some base calculation for accumulation chart.
     */
    export class AccumulationBase {
        /** @private */
        constructor(accumulation: AccumulationChart);
        private pieCenter;
        /**
         * Gets the center of the pie
         * @private
         */
        /**
         * Sets the center of the pie
         * @private
         */
        center: ChartLocation;
        private pieRadius;
        /**
         * Gets the radius of the pie
         * @private
         */
        /**
         * Sets the radius of the pie
         * @private
         */
        radius: number;
        private pieLabelRadius;
        /**
         * Gets the label radius of the pie
         * @private
         */
        /**
         * Sets the label radius of the pie
         * @private
         */
        labelRadius: number;
        /** @private */
        protected accumulation: AccumulationChart;
        /**
         * Checks whether the series is circular or not
         * @private
         */
        protected isCircular(): boolean;
        /**
         * To process the explode on accumulation chart loading
         * @private
         */
        processExplode(event: Event): void;
        /**
         * To invoke the explode on accumulation chart loading
         * @private
         */
        invokeExplode(): void;
        /**
         * To deExplode all points in the series
         */
        private deExplodeAll(index);
        /**
         * To explode point by index
         * @private
         */
        explodePoints(index: number, chart: AccumulationChart, explode?: boolean): void;
        /**
         * To check point is exploded by id
         */
        private isExplode(id);
        /**
         * To deExplode the point by index
         */
        private deExplodeSlice(index, sliceId, center);
        /**
         * To translate the point elements by index and position
         */
        private setTranslate(index, sliceId, position);
        /**
         * To translate the point element by id and position
         */
        private setElementTransform(id, position);
        /**
         * To translate the point elements by index position
         */
        private explodeSlice(index, translate, sliceId, center);
    }
    
    /**
     * AccumulationDataLabel module used to render `dataLabel`.
     */
    export class AccumulationDataLabel extends AccumulationBase {
        /** @private */
        titleRect: Rect;
        /** @private */
        areaRect: Rect;
        /** @private */
        clearTooltip: number;
        private id;
        marginValue: number;
        constructor(accumulation: AccumulationChart);
        /**
         * Method to get datalabel text location.
         * @private
         */
        getDataLabelPosition(point: AccPoints, dataLabel: AccumulationDataLabelSettingsModel, textSize: Size, points: AccPoints[], parent: Element, id: string): void;
        /**
         * Method to get datalabel bound.
         */
        private getLabelRegion(point, position, textSize, labelRadius, margin, endAngle?);
        /**
         * Method to get datalabel smart position.
         */
        private getSmartLabel(point, dataLabel, textSize, points, parent, id);
        /**
         * To find trimmed datalabel tooltip needed.
         * @return {void}
         * @private
         */
        move(e: Event, x: number, y: number, isTouch?: boolean): void;
        /**
         * To find previous valid label point
         */
        private findPreviousPoint(points, index, position);
        /**
         * To find current point datalabel is overlapping with other points
         */
        private isOverlapping(currentPoint, points);
        /**
         * To get text trimmed while exceeds the accumulation chart area.
         */
        private textTrimming(point, rect, font, position);
        /**
         * To set point label visible and region to disable.
         */
        private setPointVisibileFalse(point);
        /**
         * To set datalabel angle position for outside labels
         */
        private setOuterSmartLabel(previousPoint, point, border, labelRadius, textsize, margin);
        /**
         * Sets smart label positions for funnel and pyramid series
         */
        private setSmartLabelForSegments(point, prevPoint, distance, textSize, margin);
        /**
         * To find connector line overlapping.
         */
        private isConnectorLineOverlapping(point, previous);
        /**
         * To find two rectangle intersect
         */
        private isLineRectangleIntersect(line1, line2, rect);
        /**
         * To find two line intersect
         */
        private isLinesIntersect(point1, point2, point11, point12);
        /**
         * To get two rectangle overlapping angles.
         */
        private getOverlappedAngle(first, second, angle, padding);
        /**
         * To get connector line path
         */
        private getConnectorPath(label, point, dataLabel, end?);
        /**
         * Finds the curved path for funnel/pyramid data label connectors
         */
        private getPolyLinePath(start, end);
        /**
         * Finds the bezier point for funnel/pyramid data label connectors
         */
        private getBezierPoint(t, controlPoints, index, count);
        /**
         * To get label edges based on the center and label rect position.
         */
        private getEdgeOfLabel(labelshape, angle, middle, border?);
        /**
         * Finds the distance between the label position and the edge/center of the funnel/pyramid
         */
        private getLabelDistance(point, dataLabel);
        /**
         * Finds the label position / beginning of the connector(ouside funnel labels)
         */
        private getLabelLocation(point, position?);
        /**
         * Finds the beginning of connector line
         */
        private getConnectorStartPoint(point, connector);
        /**
         * To find area rect based on margin, available size.
         * @private
         */
        findAreaRect(): void;
        /**
         * To render the data labels from series points.
         */
        renderDataLabel(point: AccPoints, dataLabel: AccumulationDataLabelSettingsModel, parent: Element, points: AccPoints[], series: number, templateElement?: HTMLElement): void;
        /**
         * To find the template element size
         * @param element
         * @param point
         * @param argsData
         */
        private getTemplateSize(element, point, argsData);
        /**
         * To set the template element style
         * @param childElement
         * @param point
         * @param parent
         * @param labelColor
         * @param fill
         */
        private setTemplateStyle(childElement, point, parent, labelColor, fill);
        /**
         * To find saturated color for datalabel
         */
        private getSaturatedColor(point, color);
        /**
         * Animates the data label template.
         * @return {void}.
         * @private
         */
        doTemplateAnimation(accumulation: AccumulationChart, element: Element): void;
        /**
         * To find background color for the datalabel
         */
        private getLabelBackground(point);
        /**
         * To correct the padding between datalabel regions.
         */
        private correctLabelRegion(labelRegion, textSize, padding?);
        /**
         * To get the dataLabel module name
         */
        protected getModuleName(): string;
        /**
         * To destroy the data label.
         * @return {void}
         * @private
         */
        destroy(accumulation: AccumulationChart): void;
    }
    
    /**
     * Defines the behavior of a funnel series
     */
    
    /**
     * FunnelSeries module used to render `Funnel` Series.
     */
    export class FunnelSeries extends TriangularBase {
        /**
         * Defines the path of a funnel segment
         */
        private getSegmentData(point, series, chart);
        /**
         * Renders a funnel segment
         * @private
         */
        renderPoint(point: AccPoints, series: AccumulationSeries, chart: AccumulationChart, options: PathOption): void;
        /**
         * To get the module name of the funnel series.
         */
        protected getModuleName(): string;
        /**
         * To destroy the funnel series.
         * @return {void}
         * @private
         */
        destroy(accumulation: AccumulationChart): void;
    }
    
    /**
     * AccumulationLegend module used to render `Legend` for Accumulation chart.
     */
    export class AccumulationLegend extends BaseLegend {
        titleRect: Rect;
        private totalRowCount;
        private maxColumnWidth;
        /**
         * Constructor for Accumulation Legend.
         * @param chart
         */
        constructor(chart: AccumulationChart);
        /**
         * Get the legend options.
         * @return {void}
         * @private
         */
        getLegendOptions(chart: AccumulationChart, series: AccumulationSeries[]): void;
        /**
         * To find legend bounds for accumulation chart.
         * @private
         */
        getLegendBounds(availableSize: Size, legendBounds: Rect, legend: LegendSettingsModel): void;
        /**
         * To find maximum column size for legend
         */
        private getMaxColumn(columns, width, padding, rowWidth);
        /**
         * To find available width from legend x position.
         */
        private getAvailWidth(tx, width, legendX);
        /**
         * To find legend rendering locations from legend options.
         * @private
         */
        getRenderPoint(legendOption: LegendOptions, start: ChartLocation, textPadding: number, prevLegend: LegendOptions, rect: Rect, count: number, firstLegend: number): void;
        /**
         * finding the smart legend place according to positions.
         * @return {void}
         * @private
         */
        getSmartLegendLocation(labelBound: Rect, legendBound: Rect, margin: MarginModel): void;
        /**
         * To get title rect.
         */
        private getTitleRect(accumulation);
        /**
         * To get legend by index
         */
        private legendByIndex(index, legendCollections);
        /**
         * To show or hide the legend on clicking the legend.
         * @return {void}
         */
        click(event: Event): void;
        /**
         * Get module name
         */
        protected getModuleName(): string;
        /**
         * To destroy the Legend.
         * @return {void}
         * @private
         */
        destroy(chart: AccumulationChart): void;
    }
    
    /**
     * PieBase class used to do pie base calculations.
     */
    export class PieBase extends AccumulationBase {
        protected startAngle: number;
        protected totalAngle: number;
        protected innerRadius: number;
        center: ChartLocation;
        radius: number;
        labelRadius: number;
        /**
         * To initialize the property values.
         * @private
         */
        initProperties(chart: AccumulationChart, series: AccumulationSeries): void;
        /**
         * To find the center of the accumulation.
         * @private
         */
        findCenter(accumulation: AccumulationChart, series: AccumulationSeries): void;
        /**
         * To find angles from series.
         */
        private initAngles(series);
        /**
         * To calculate data-label bound
         * @private
         */
        defaultLabelBound(series: AccumulationSeries, visible: boolean, position: AccumulationLabelPosition): void;
        /**
         * To calculate series bound
         * @private
         */
        getSeriesBound(series: AccumulationSeries): Rect;
        /**
         * To get rect location size from angle
         */
        private getRectFromAngle(angle);
        /**
         * To get path arc direction
         */
        protected getPathArc(center: ChartLocation, start: number, end: number, radius: number, innerRadius: number): string;
        /**
         * To get pie direction
         */
        protected getPiePath(center: ChartLocation, start: ChartLocation, end: ChartLocation, radius: number, clockWise: number): string;
        /**
         * To get doughnut direction
         */
        protected getDoughnutPath(center: ChartLocation, start: ChartLocation, end: ChartLocation, radius: number, innerStart: ChartLocation, innerEnd: ChartLocation, innerRadius: number, clockWise: number): string;
        /**
         * Method to start animation for pie series.
         */
        protected doAnimation(slice: Element, series: AccumulationSeries): void;
    }
    
    /**
     * AccumulationChart series file
     */
    
    /**
     * PieSeries module used to render `Pie` Series.
     */
    export class PieSeries extends PieBase {
        /**
         * To get path option, degree, symbolLocation from the point.
         * @private
         */
        renderPoint(point: AccPoints, series: AccumulationSeries, chart: AccumulationChart, option: PathOption): PathOption;
        /**
         * To get path option from the point.
         */
        private getPathOption(point, degree);
        /**
         * To animate the pie series.
         * @private
         */
        animateSeries(accumulation: AccumulationChart, option: AnimationModel, series: AccumulationSeries, slice: Element): void;
        /**
         * To get the module name of the Pie series.
         */
        protected getModuleName(): string;
        /**
         * To destroy the pie series.
         * @return {void}
         * @private
         */
        destroy(accumulation: AccumulationChart): void;
    }
    
    /**
     * Defines the behavior of a pyramid series
     */
    
    /**
     * PyramidSeries module used to render `Pyramid` Series.
     */
    export class PyramidSeries extends TriangularBase {
        /**
         * Defines the path of a pyramid segment
         */
        private getSegmentData(point, series, chart);
        /**
         * Initializes the size of the pyramid segments
         * @private
         */
        protected initializeSizeRatio(points: AccPoints[], series: AccumulationSeries): void;
        /**
         * Defines the size of the pyramid segments, the surface of that will reflect the values
         */
        private calculateSurfaceSegments(series);
        /**
         * Finds the height of pyramid segment
         */
        private getSurfaceHeight(y, surface);
        /**
         * Solves quadratic equation
         */
        private solveQuadraticEquation(a, b, c);
        /**
         * Renders a pyramid segment
         */
        private renderPoint(point, series, chart, options);
        /**
         * To get the module name of the Pyramid series.
         */
        protected getModuleName(): string;
        /**
         * To destroy the pyramid series
         * @return {void}
         * @private
         */
        destroy(accumulation: AccumulationChart): void;
    }
    
    /**
     * Defines the common behavior of funnel and pyramid series
     */
    
    /**
     * TriangularBase is used to calculate base functions for funnel/pyramid series.
     */
    export class TriangularBase extends AccumulationBase {
        /**
         * Initializes the properties of funnel/pyramid series
         * @private
         */
        initProperties(chart: AccumulationChart, series: AccumulationSeries): void;
        /**
         * Initializes the size of the pyramid/funnel segments
         * @private
         */
        protected initializeSizeRatio(points: AccPoints[], series: AccumulationSeries, reverse?: boolean): void;
        /**
         * Marks the label location from the set of points that forms a pyramid/funnel segment
         * @private
         */
        protected setLabelLocation(series: AccumulationSeries, point: AccPoints, points: ChartLocation[]): void;
        /**
         * Finds the path to connect the list of points
         * @private
         */
        protected findPath(locations: ChartLocation[]): string;
        /**
         * To calculate data-label bounds
         * @private
         */
        defaultLabelBound(series: AccumulationSeries, visible: boolean, position: AccumulationLabelPosition, chart: AccumulationChart): void;
    }
    
    /**
     * `AccumulationSelection` module handles the selection for accumulation chart.
     * @private
     */
    export class AccumulationSelection extends BaseSelection {
        private renderer;
        /** @private */
        rectPoints: Rect;
        selectedDataIndexes: Indexes[];
        private series;
        constructor(accumulation: AccumulationChart);
        /**
         * To initialize the private variables
         */
        private initPrivateVariables(accumulation);
        /**
         * Invoke selection for rendered chart.
         * @param  {AccumulationChart} chart - Define the chart to invoke the selection.
         * @return {void}
         */
        invokeSelection(accumulation: AccumulationChart): void;
        /**
         * To get series selection style by series.
         */
        private generateStyle(series);
        /**
         * To get elements by index, series
         */
        private findElements(accumulation, series, index);
        /**
         * To get series point element by index
         */
        private getElementByIndex(index);
        /**
         * To calculate selected elements on mouse click or touch
         * @private
         */
        calculateSelectedElements(accumulation: AccumulationChart, event: Event): void;
        /**
         * To perform the selection process based on index and element.
         */
        private performSelection(index, accumulation, element?);
        /**
         * To select the element by index. Adding or removing selection style class name.
         */
        private selection(accumulation, index, selectedElements);
        /**
         * To redraw the selection process on accumulation chart refresh.
         * @private
         */
        redrawSelection(accumulation: AccumulationChart, oldMode: AccumulationSelectionMode): void;
        /**
         * To remove the selected elements style classes by indexes.
         */
        private removeSelectedElements(accumulation, indexes);
        /**
         * To perform the selection for legend elements.
         * @private
         */
        legendSelection(accumulation: AccumulationChart, series: number, pointIndex: number): void;
        /**
         * To select the element by selected data indexes.
         */
        private selectDataIndex(indexes, accumulation);
        /**
         * To remove the selection styles for multi selection process.
         */
        private removeMultiSelectEelments(accumulation, index, currentIndex, seriesCollection);
        /**
         * To apply the opacity effect for accumulation chart series elements.
         */
        private blurEffect(pieId, visibleSeries);
        /**
         * To check selection elements by style class name.
         */
        private checkSelectionElements(element, className, visibility);
        /**
         * To apply selection style for elements.
         */
        private applyStyles(elements, index);
        /**
         * To get selection style class name by id
         */
        private getSelectionClass(id);
        /**
         * To remove selection style for elements.
         */
        private removeStyles(elements, index);
        /**
         * To apply or remove selected elements index.
         */
        private addOrRemoveIndex(indexes, index, add?);
        /**
         * To check two index, point and series are equal
         */
        private checkEquals(first, second);
        /**
         * To check selected points are visibility
         */
        private checkPointVisibility(selectedDataIndexes);
        /**
         * Get module name.
         */
        getModuleName(): string;
        /**
         * To destroy the selection.
         * @return {void}
         * @private
         */
        destroy(accumulation: AccumulationChart): void;
    }
    
    /**
     * `AccumulationTooltip` module is used to render tooltip for accumulation chart.
     */
    export class AccumulationTooltip extends BaseTooltip {
        accumulation: AccumulationChart;
        constructor(accumulation: AccumulationChart);
        /**
         * @hidden
         */
        private addEventListener();
        private mouseLeaveHandler(e);
        private mouseUpHandler(e);
        private mouseMoveHandler(e);
        /**
         * Renders the tooltip.
         * @param  {PointerEvent} event - Mouse move event.
         * @return {void}
         */
        tooltip(event: PointerEvent | TouchEvent): void;
        private renderSeriesTooltip(e, chart, isFirst, tooltipDiv);
        private drawMarker(isBottom, size);
        private getPieData(e, chart, x, y);
        /**
         * To get series from index
         */
        private getSeriesFromIndex(index, visibleSeries);
        private getTemplateText(data);
        private getTooltipText(data, tooltip);
        private findHeader(data);
        private parseTemplate(point, series, format);
        /**
         * Removes the tooltip on mouse leave.
         * @return {void}
         * @private
         */
        removeTooltip(duration: number): void;
        /**
         * Get module name
         */
        protected getModuleName(): string;
        /**
         * To destroy the Tooltip.
         * @return {void}
         * @private
         */
        destroy(chart: AccumulationChart): void;
    }
    
    /**
     * Interface for a class CrosshairSettings
     */
    export interface CrosshairSettingsModel {
    
        /**
         * If set to true, crosshair line becomes visible.
         * @default false
         */
        enable?: boolean;
    
        /**
         * Options to customize the crosshair line.
         */
        line?: BorderModel;
    
        /**
         * Specifies the line type. Horizontal mode enables the horizontal line and Vertical mode enables the vertical line. They are,
         * * None: Hides both vertical and horizontal crosshair lines.
         * * Both: Shows both vertical and horizontal crosshair lines.
         * * Vertical: Shows the vertical line.
         * * Horizontal: Shows the horizontal line.
         * @default Both
         */
        lineType?: LineType;
    
    }
    
    /**
     * Interface for a class ZoomSettings
     */
    export interface ZoomSettingsModel {
    
        /**
         * If set to true, chart can be zoomed by a rectangular selecting region on the plot area.
         * @default false
         */
    
        enableSelectionZooming?: boolean;
    
        /**
         * If  to true, chart can be pinched to zoom in / zoom out.
         * @default false
         */
    
        enablePinchZooming?: boolean;
    
        /**
         * If set to true, chart can be zoomed by using mouse wheel.
         * @default false
         */
    
        enableMouseWheelZooming?: boolean;
    
        /**
         * If set to true, zooming will be performed on mouse up. It requires `enableSelectionZooming` to be true.
         * ```html 
         * <div id='Chart'></div>
         * ```
         * ```typescript
         * let chart: Chart = new Chart({
         * ...
         *    zoomSettings: {
         *      enableSelectionZooming: true,
         *      enableDeferredZooming: false
         *    }
         * ...
         * });
         * chart.appendTo('#Chart');
         * ```
         * @default true
         */
    
        enableDeferredZooming?: boolean;
    
        /**
         * Specifies whether to allow zooming vertically or horizontally or in both ways.They are,
         * * x,y: Chart can be zoomed both vertically and horizontally.
         * * x: Chart can be zoomed horizontally.
         * * y: Chart can be zoomed  vertically.
         *  It requires `enableSelectionZooming` to be true.
         * ```html 
         * <div id='Chart'></div>
         * ```
         * ```typescript
         * let chart: Chart = new Chart({
         * ...
         *    zoomSettings: {
         *      enableSelectionZooming: true,
         *      mode: 'XY'
         *    }
         * ...
         * });
         * chart.appendTo('#Chart');
         * ```
         * @default 'XY'
         */
        mode?: ZoomMode;
    
        /**
         * Specifies the toolkit options for the zooming as follows:
         * * Zoom
         * * ZoomIn
         * * ZoomOut
         * * Pan
         * * Reset
         * @default '["Zoom", "ZoomIn", "ZoomOut", "Pan", "Reset"]' 
         */
    
        toolbarItems?: ToolbarItems[];
    
        /**
         * Specifies whether chart needs to be panned by default.
         * @default false.
         */
    
        enablePan?: boolean;
    
    }
    
    /**
     * Interface for a class Chart
     */
    export interface ChartModel extends ej.base.ComponentModel{
    
        /**
         * The width of the chart as a string accepts input as both like '100px' or '100%'.
         * If specified as '100%, chart renders to the full width of its parent element.
         * @default null
         */
    
        width?: string;
    
        /**
         * The height of the chart as a string accepts input both as '100px' or '100%'.
         * If specified as '100%, chart renders to the full height of its parent element.
         * @default null
         */
    
        height?: string;
    
        /**
         * Title of the chart
         * @default ''
         */
    
        title?: string;
    
        /**
         * Options for customizing the title of the Chart.
         */
    
        titleStyle?: FontModel;
    
        /**
         *  Options to customize left, right, top and bottom margins of the chart.
         */
    
        margin?: MarginModel;
    
        /**
         * Options for customizing the color and width of the chart border.
         */
    
        border?: BorderModel;
    
        /**
         * The background color of the chart that accepts value in hex and rgba as a valid CSS color string.
         * @default null
         */
        background?: string;
    
        /**
         * Options for configuring the border and background of the chart area.
         */
    
        chartArea?: ChartAreaModel;
    
        /**
         * Options to configure the horizontal axis.
         */
    
        primaryXAxis?: AxisModel;
    
        /**
         * Options to configure the vertical axis.
         */
    
        primaryYAxis?: AxisModel;
    
        /**
         * Options to split Chart into multiple plotting areas horizontally.
         * Each object in the collection represents a plotting area in the Chart.
         */
    
        rows?: RowModel[];
    
        /**
         * Options to split chart into multiple plotting areas vertically.
         * Each object in the collection represents a plotting area in the chart.
         */
    
        columns?: ColumnModel[];
    
        /**
         * Secondary axis collection for the chart.
         */
    
        axes?: AxisModel[];
    
        /**
         * The configuration for series in the chart.
         */
    
        series?: SeriesModel[];
    
        /**
         * The configuration for annotation in chart.
         */
    
        annotations?: ChartAnnotationSettingsModel[];
    
        /**
         * Palette for the chart series.
         * @default []
         */
        palettes?: string[];
    
        /**
         * Specifies the theme for the chart.
         * @default 'Material'
         */
        theme?: ChartTheme;
    
        /**
         * Options for customizing the tooltip of the chart.
         */
    
        tooltip?: TooltipSettingsModel;
    
        /**
         * Options for customizing the crosshair of the chart.
         */
        crosshair?: CrosshairSettingsModel;
    
        /**
         * Options for customizing the legend of the chart.
         */
        legendSettings?: LegendSettingsModel;
    
        /**
         * Options to enable the zooming feature in the chart.
         */
        zoomSettings?: ZoomSettingsModel;
    
        /**
         * Specifies whether series or data point has to be selected. They are,
         * * none: Disables the selection.
         * * series: selects a series.
         * * point: selects a point.
         * * cluster: selects a cluster of point
         * * dragXY: selects points by dragging with respect to both horizontal and vertical axes
         * * dragX: selects points by dragging with respect to horizontal axis.
         * * dragY: selects points by dragging with respect to vertical axis.
         * @default None
         */
        selectionMode?: SelectionMode;
    
        /**
         * If set true, enables the multi selection in chart. It requires `selectionMode` to be `Point` | `Series` | or `Cluster`.
         * @default false
         */
        isMultiSelect?: boolean;
    
        /**
         * Specifies the point indexes to be selected while loading a chart.
         * It requires `selectionMode` to be `Point` | `Series` | or `Cluster`.
         * ```html
         * <div id='Chart'></div>
         * ```
         * ```typescript
         * let chart: Chart = new Chart({
         * ...
         *   selectionMode: 'Point',
         *   selectedDataIndexes: [ { series: 0, point: 1},
         *                          { series: 2, point: 3} ],
         * ...
         * });
         * chart.appendTo('#Chart');
         * ```
         * @default []
         */
        selectedDataIndexes?: IndexesModel[];
    
        /**
         * Specifies whether a grouping separator should be used for a number.
         * @default false
         */
        useGroupingSeparator?: boolean;
    
        /**
         * It specifies whether the chart should be render in transposed manner or not.
         * @default false
         */
        isTransposed?: boolean;
    
        /**
         * Defines the collection of technical indicators, that are used in financial markets
         */
        indicators?: TechnicalIndicatorModel[];
    
        /**
         * Description for chart.
         * @default null
         */
        description?: string;
    
        /**
         * TabIndex value for the chart.
         * @default 1
         */
        tabIndex?: number;
    
        /**
         * To enable the side by side placing the points for column type series.
         * @default true
         */
        enableSideBySidePlacement?: boolean;
    
        /**
         * Triggers before the annotation gets rendered.
         * @event
         */
    
        annotationRender?: ej.base.EmitType<IAnnotationRenderEventArgs>;
    
        /**
         * Triggers before the prints gets started.
         * @event
         */
    
        beforePrint?: ej.base.EmitType<IPrintEventArgs>;
    
        /**
         * Triggers after chart load.
         * @event
         */
        loaded?: ej.base.EmitType<ILoadedEventArgs>;
    
        /**
         * Triggers before chart load.
         * @event
         */
        load?: ej.base.EmitType<ILoadedEventArgs>;
    
        /**
         * Triggers after animation is completed for the series.
         * @event
         */
        animationComplete?: ej.base.EmitType<IAnimationCompleteEventArgs>;
    
        /**
         * Triggers before the legend is rendered.
         * @event
         */
        legendRender?: ej.base.EmitType<ILegendRenderEventArgs>;
    
        /**
         * Triggers before the data label for series is rendered.
         * @event
         */
    
        textRender?: ej.base.EmitType<ITextRenderEventArgs>;
    
        /**
         * Triggers before each points for the series is rendered.
         * @event
         */
    
        pointRender?: ej.base.EmitType<IPointRenderEventArgs>;
    
        /**
         * Triggers before the series is rendered.
         * @event
         */
    
        seriesRender?: ej.base.EmitType<ISeriesRenderEventArgs>;
    
        /**
         * Triggers before each axis label is rendered.
         * @event
         */
        axisLabelRender?: ej.base.EmitType<IAxisLabelRenderEventArgs>;
    
        /**
         * Triggers before each axis range is rendered.
         * @event
         */
        axisRangeCalculated?: ej.base.EmitType<IAxisRangeCalculatedEventArgs>;
    
        /**
         * Triggers before each axis multi label is rendered.
         * @event
         */
        axisMultiLabelRender?: ej.base.EmitType<IAxisMultiLabelRenderEventArgs>;
    
        /**
         * Triggers before the tooltip for series is rendered.
         * @event
         */
    
        tooltipRender?: ej.base.EmitType<ITooltipRenderEventArgs>;
    
        /**
         * Triggers on hovering the chart.
         * @event
         */
    
        chartMouseMove?: ej.base.EmitType<IMouseEventArgs>;
    
        /**
         * Triggers on clicking the chart.
         * @event
         */
    
        chartMouseClick?: ej.base.EmitType<IMouseEventArgs>;
    
        /**
         * Triggers on point click.
         * @event
         */
    
        pointClick?: ej.base.EmitType<IPointEventArgs>;
    
        /**
         * Triggers on point move.
         * @event
         */
    
        pointMove?: ej.base.EmitType<IPointEventArgs>;
    
        /**
         * Triggers when cursor leaves the chart.
         * @event
         */
    
        chartMouseLeave?: ej.base.EmitType<IMouseEventArgs>;
    
        /**
         * Triggers on mouse down.
         * @event
         */
    
        chartMouseDown?: ej.base.EmitType<IMouseEventArgs>;
    
        /**
         * Triggers on mouse up.
         * @event
         */
    
        chartMouseUp?: ej.base.EmitType<IMouseEventArgs>;
    
        /**
         * Triggers after the drag selection is completed.
         * @event
         */
    
        dragComplete?: ej.base.EmitType<IDragCompleteEventArgs>;
    
        /**
         * Triggers after the zoom selection is completed.
         * @event
         */
    
        zoomComplete?: ej.base.EmitType<IZoomCompleteEventArgs>;
    
        /**
         * Defines the currencyCode format of the chart
         * @private
         */
        currencyCode?: string;
    
    }
    
    /**
     * Configures the crosshair in the chart.
     */
    export class CrosshairSettings extends ej.base.ChildProperty<CrosshairSettings> {
        /**
         * If set to true, crosshair line becomes visible.
         * @default false
         */
        enable: boolean;
        /**
         * Options to customize the crosshair line.
         */
        line: BorderModel;
        /**
         * Specifies the line type. Horizontal mode enables the horizontal line and Vertical mode enables the vertical line. They are,
         * * None: Hides both vertical and horizontal crosshair lines.
         * * Both: Shows both vertical and horizontal crosshair lines.
         * * Vertical: Shows the vertical line.
         * * Horizontal: Shows the horizontal line.
         * @default Both
         */
        lineType: LineType;
    }
    /**
     * Configures the zooming behavior for the chart.
     */
    export class ZoomSettings extends ej.base.ChildProperty<ZoomSettings> {
        /**
         * If set to true, chart can be zoomed by a rectangular selecting region on the plot area.
         * @default false
         */
        enableSelectionZooming: boolean;
        /**
         * If  to true, chart can be pinched to zoom in / zoom out.
         * @default false
         */
        enablePinchZooming: boolean;
        /**
         * If set to true, chart can be zoomed by using mouse wheel.
         * @default false
         */
        enableMouseWheelZooming: boolean;
        /**
         * If set to true, zooming will be performed on mouse up. It requires `enableSelectionZooming` to be true.
         * ```html
         * <div id='Chart'></div>
         * ```
         * ```typescript
         * let chart: Chart = new Chart({
         * ...
         *    zoomSettings: {
         *      enableSelectionZooming: true,
         *      enableDeferredZooming: false
         *    }
         * ...
         * });
         * chart.appendTo('#Chart');
         * ```
         * @default true
         */
        enableDeferredZooming: boolean;
        /**
         * Specifies whether to allow zooming vertically or horizontally or in both ways.They are,
         * * x,y: Chart can be zoomed both vertically and horizontally.
         * * x: Chart can be zoomed horizontally.
         * * y: Chart can be zoomed  vertically.
         *  It requires `enableSelectionZooming` to be true.
         * ```html
         * <div id='Chart'></div>
         * ```
         * ```typescript
         * let chart: Chart = new Chart({
         * ...
         *    zoomSettings: {
         *      enableSelectionZooming: true,
         *      mode: 'XY'
         *    }
         * ...
         * });
         * chart.appendTo('#Chart');
         * ```
         * @default 'XY'
         */
        mode: ZoomMode;
        /**
         * Specifies the toolkit options for the zooming as follows:
         * * Zoom
         * * ZoomIn
         * * ZoomOut
         * * Pan
         * * Reset
         * @default '["Zoom", "ZoomIn", "ZoomOut", "Pan", "Reset"]'
         */
        toolbarItems: ToolbarItems[];
        /**
         * Specifies whether chart needs to be panned by default.
         * @default false.
         */
        enablePan: boolean;
    }
    /**
     * Represents the Chart control.
     * ```html
     * <div id="chart"/>
     * <script>
     *   var chartObj = new Chart({ isResponsive : true });
     *   chartObj.appendTo("#chart");
     * </script>
     * ```
     */
    export class Chart extends ej.base.Component<HTMLElement> implements ej.base.INotifyPropertyChanged {
        /**
         * `lineSeriesModule` is used to add line series to the chart.
         */
        lineSeriesModule: LineSeries;
        /**
         * `multiColoredLineSeriesModule` is used to add multi colored line series to the chart.
         */
        multiColoredLineSeriesModule: MultiColoredLineSeries;
        /**
         * `multiColoredAreaSeriesModule` is used to add multi colored area series to the chart.
         */
        multiColoredAreaSeriesModule: MultiColoredAreaSeries;
        /**
         * `columnSeriesModule` is used to add column series to the chart.
         */
        columnSeriesModule: ColumnSeries;
        /**
         * `areaSeriesModule` is used to add area series in the chart.
         */
        areaSeriesModule: AreaSeries;
        /**
         * `barSeriesModule` is used to add bar series to the chart.
         */
        barSeriesModule: BarSeries;
        /**
         * `stackingColumnSeriesModule` is used to add stacking column series in the chart.
         */
        stackingColumnSeriesModule: StackingColumnSeries;
        /**
         * `stackingAreaSeriesModule` is used to add stacking area series to the chart.
         */
        stackingAreaSeriesModule: StackingAreaSeries;
        /**
         * 'CandleSeriesModule' is used to add candle series in the chart.
         */
        candleSeriesModule: CandleSeries;
        /**
         * `stackingBarSeriesModule` is used to add stacking bar series to the chart.
         */
        stackingBarSeriesModule: StackingBarSeries;
        /**
         * `stepLineSeriesModule` is used to add step line series to the chart.
         */
        stepLineSeriesModule: StepLineSeries;
        /**
         * `stepAreaSeriesModule` is used to add step area series to the chart.
         */
        stepAreaSeriesModule: StepAreaSeries;
        /**
         * `polarSeriesModule` is used to add polar series in the chart.
         */
        polarSeriesModule: PolarSeries;
        /**
         *  `radarSeriesModule` is used to add radar series in the chart.
         */
        radarSeriesModule: RadarSeries;
        /**
         * `splineSeriesModule` is used to add spline series to the chart.
         */
        splineSeriesModule: SplineSeries;
        /**
         * `splineAreaSeriesModule` is used to add spline area series to the chart.
         */
        splineAreaSeriesModule: SplineAreaSeries;
        /**
         * `scatterSeriesModule` is used to add scatter series to the chart.
         */
        scatterSeriesModule: ScatterSeries;
        /**
         * `boxAndWhiskerSeriesModule` is used to add line series to the chart.
         */
        boxAndWhiskerSeriesModule: BoxAndWhiskerSeries;
        /**
         * `rangeColumnSeriesModule` is used to add rangeColumn series to the chart.
         */
        rangeColumnSeriesModule: RangeColumnSeries;
        /**
         * hiloSeriesModule is used to add hilo series in chart
         */
        hiloSeriesModule: HiloSeries;
        /**
         * hiloOpenCloseSeriesModule is used to add hilo series in chart
         */
        hiloOpenCloseSeriesModule: HiloOpenCloseSeries;
        /**
         * `waterfallSeries` is used to add waterfall series in chart.
         */
        waterfallSeriesModule: WaterfallSeries;
        /**
         * `bubbleSeries` is used to add bubble series in chart.
         */
        bubbleSeriesModule: BubbleSeries;
        /**
         * `rangeAreaSeriesModule` is used to add rangeArea series in chart.
         */
        rangeAreaSeriesModule: RangeAreaSeries;
        /**
         * `tooltipModule` is used to manipulate and add tooltip to the series.
         */
        tooltipModule: ej.popups.Tooltip;
        /**
         * `crosshairModule` is used to manipulate and add crosshair to the chart.
         */
        crosshairModule: Crosshair;
        /**
         * `errorBarModule` is used to manipulate and add errorBar for series.
         */
        errorBarModule: ErrorBar;
        /**
         * `dataLabelModule` is used to manipulate and add data label to the series.
         */
        dataLabelModule: DataLabel;
        /**
         * `datetimeModule` is used to manipulate and add dateTime axis to the chart.
         */
        dateTimeModule: DateTime;
        /**
         * `categoryModule` is used to manipulate and add category axis to the chart.
         */
        categoryModule: Category;
        /**
         * `dateTimeCategoryModule` is used to manipulate date time and category axis
         */
        dateTimeCategoryModule: DateTimeCategory;
        /**
         * `logarithmicModule` is used to manipulate and add log axis to the chart.
         */
        logarithmicModule: Logarithmic;
        /**
         * `legendModule` is used to manipulate and add legend to the chart.
         */
        legendModule: Legend;
        /**
         * `zoomModule` is used to manipulate and add zooming to the chart.
         */
        zoomModule: Zoom;
        /**
         * `selectionModule` is used to manipulate and add selection to the chart.
         */
        selectionModule: Selection;
        /**
         * `annotationModule` is used to manipulate and add annotation in chart.
         */
        annotationModule: ChartAnnotation;
        /**
         * `stripLineModule` is used to manipulate and add stripLine in chart.
         */
        stripLineModule: StripLine;
        /**
         * `multiLevelLabelModule` is used to manipulate and add multiLevelLabel in chart.
         */
        multiLevelLabelModule: MultiLevelLabel;
        /**
         * 'TrendlineModule' is used to predict the market trend using trendlines
         */
        trendLineModule: Trendlines;
        /**
         * `sMAIndicatorModule` is used to predict the market trend using SMA approach
         */
        sMAIndicatorModule: SmaIndicator;
        /**
         * `eMAIndicatorModule` is used to predict the market trend using EMA approach
         */
        eMAIndicatorModule: EmaIndicator;
        /**
         * `tMAIndicatorModule` is used to predict the market trend using TMA approach
         */
        tMAIndicatorModule: TmaIndicator;
        /**
         * `accumulationDistributionIndicatorModule` is used to predict the market trend using Accumulation Distribution approach
         */
        accumulationDistributionIndicatorModule: AccumulationDistributionIndicator;
        /**
         * `atrIndicatorModule` is used to predict the market trend using ATR approach
         */
        atrIndicatorModule: AtrIndicator;
        /**
         * `rSIIndicatorModule` is used to predict the market trend using RSI approach
         */
        rsiIndicatorModule: RsiIndicator;
        /**
         * `macdIndicatorModule` is used to predict the market trend using Macd approach
         */
        macdIndicatorModule: MacdIndicator;
        /**
         * `stochasticIndicatorModule` is used to predict the market trend using Stochastic approach
         */
        stochasticIndicatorModule: StochasticIndicator;
        /**
         * `momentumIndicatorModule` is used to predict the market trend using Momentum approach
         */
        momentumIndicatorModule: MomentumIndicator;
        /**
         * `bollingerBandsModule` is used to predict the market trend using Bollinger approach
         */
        bollingerBandsModule: BollingerBands;
        /**
         * The width of the chart as a string accepts input as both like '100px' or '100%'.
         * If specified as '100%, chart renders to the full width of its parent element.
         * @default null
         */
        width: string;
        /**
         * The height of the chart as a string accepts input both as '100px' or '100%'.
         * If specified as '100%, chart renders to the full height of its parent element.
         * @default null
         */
        height: string;
        /**
         * Title of the chart
         * @default ''
         */
        title: string;
        /**
         * Options for customizing the title of the Chart.
         */
        titleStyle: FontModel;
        /**
         *  Options to customize left, right, top and bottom margins of the chart.
         */
        margin: MarginModel;
        /**
         * Options for customizing the color and width of the chart border.
         */
        border: BorderModel;
        /**
         * The background color of the chart that accepts value in hex and rgba as a valid CSS color string.
         * @default null
         */
        background: string;
        /**
         * Options for configuring the border and background of the chart area.
         */
        chartArea: ChartAreaModel;
        /**
         * Options to configure the horizontal axis.
         */
        primaryXAxis: AxisModel;
        /**
         * Options to configure the vertical axis.
         */
        primaryYAxis: AxisModel;
        /**
         * Options to split Chart into multiple plotting areas horizontally.
         * Each object in the collection represents a plotting area in the Chart.
         */
        rows: RowModel[];
        /**
         * Options to split chart into multiple plotting areas vertically.
         * Each object in the collection represents a plotting area in the chart.
         */
        columns: ColumnModel[];
        /**
         * Secondary axis collection for the chart.
         */
        axes: AxisModel[];
        /**
         * The configuration for series in the chart.
         */
        series: SeriesModel[];
        /**
         * The configuration for annotation in chart.
         */
        annotations: ChartAnnotationSettingsModel[];
        /**
         * Palette for the chart series.
         * @default []
         */
        palettes: string[];
        /**
         * Specifies the theme for the chart.
         * @default 'Material'
         */
        theme: ChartTheme;
        /**
         * Options for customizing the tooltip of the chart.
         */
        tooltip: TooltipSettingsModel;
        /**
         * Options for customizing the crosshair of the chart.
         */
        crosshair: CrosshairSettingsModel;
        /**
         * Options for customizing the legend of the chart.
         */
        legendSettings: LegendSettingsModel;
        /**
         * Options to enable the zooming feature in the chart.
         */
        zoomSettings: ZoomSettingsModel;
        /**
         * Specifies whether series or data point has to be selected. They are,
         * * none: Disables the selection.
         * * series: selects a series.
         * * point: selects a point.
         * * cluster: selects a cluster of point
         * * dragXY: selects points by dragging with respect to both horizontal and vertical axes
         * * dragX: selects points by dragging with respect to horizontal axis.
         * * dragY: selects points by dragging with respect to vertical axis.
         * @default None
         */
        selectionMode: SelectionMode;
        /**
         * If set true, enables the multi selection in chart. It requires `selectionMode` to be `Point` | `Series` | or `Cluster`.
         * @default false
         */
        isMultiSelect: boolean;
        /**
         * Specifies the point indexes to be selected while loading a chart.
         * It requires `selectionMode` to be `Point` | `Series` | or `Cluster`.
         * ```html
         * <div id='Chart'></div>
         * ```
         * ```typescript
         * let chart: Chart = new Chart({
         * ...
         *   selectionMode: 'Point',
         *   selectedDataIndexes: [ { series: 0, point: 1},
         *                          { series: 2, point: 3} ],
         * ...
         * });
         * chart.appendTo('#Chart');
         * ```
         * @default []
         */
        selectedDataIndexes: IndexesModel[];
        /**
         * Specifies whether a grouping separator should be used for a number.
         * @default false
         */
        useGroupingSeparator: boolean;
        /**
         * It specifies whether the chart should be render in transposed manner or not.
         * @default false
         */
        isTransposed: boolean;
        /**
         * Defines the collection of technical indicators, that are used in financial markets
         */
        indicators: TechnicalIndicatorModel[];
        /**
         * Description for chart.
         * @default null
         */
        description: string;
        /**
         * TabIndex value for the chart.
         * @default 1
         */
        tabIndex: number;
        /**
         * To enable the side by side placing the points for column type series.
         * @default true
         */
        enableSideBySidePlacement: boolean;
        /**
         * Triggers before the annotation gets rendered.
         * @event
         */
        annotationRender: ej.base.EmitType<IAnnotationRenderEventArgs>;
        /**
         * Triggers before the prints gets started.
         * @event
         */
        beforePrint: ej.base.EmitType<IPrintEventArgs>;
        /**
         * Triggers after chart load.
         * @event
         */
        loaded: ej.base.EmitType<ILoadedEventArgs>;
        /**
         * Triggers before chart load.
         * @event
         */
        load: ej.base.EmitType<ILoadedEventArgs>;
        /**
         * Triggers after animation is completed for the series.
         * @event
         */
        animationComplete: ej.base.EmitType<IAnimationCompleteEventArgs>;
        /**
         * Triggers before the legend is rendered.
         * @event
         */
        legendRender: ej.base.EmitType<ILegendRenderEventArgs>;
        /**
         * Triggers before the data label for series is rendered.
         * @event
         */
        textRender: ej.base.EmitType<ITextRenderEventArgs>;
        /**
         * Triggers before each points for the series is rendered.
         * @event
         */
        pointRender: ej.base.EmitType<IPointRenderEventArgs>;
        /**
         * Triggers before the series is rendered.
         * @event
         */
        seriesRender: ej.base.EmitType<ISeriesRenderEventArgs>;
        /**
         * Triggers before each axis label is rendered.
         * @event
         */
        axisLabelRender: ej.base.EmitType<IAxisLabelRenderEventArgs>;
        /**
         * Triggers before each axis range is rendered.
         * @event
         */
        axisRangeCalculated: ej.base.EmitType<IAxisRangeCalculatedEventArgs>;
        /**
         * Triggers before each axis multi label is rendered.
         * @event
         */
        axisMultiLabelRender: ej.base.EmitType<IAxisMultiLabelRenderEventArgs>;
        /**
         * Triggers before the tooltip for series is rendered.
         * @event
         */
        tooltipRender: ej.base.EmitType<ITooltipRenderEventArgs>;
        /**
         * Triggers on hovering the chart.
         * @event
         */
        chartMouseMove: ej.base.EmitType<IMouseEventArgs>;
        /**
         * Triggers on clicking the chart.
         * @event
         */
        chartMouseClick: ej.base.EmitType<IMouseEventArgs>;
        /**
         * Triggers on point click.
         * @event
         */
        pointClick: ej.base.EmitType<IPointEventArgs>;
        /**
         * Triggers on point move.
         * @event
         */
        pointMove: ej.base.EmitType<IPointEventArgs>;
        /**
         * Triggers when cursor leaves the chart.
         * @event
         */
        chartMouseLeave: ej.base.EmitType<IMouseEventArgs>;
        /**
         * Triggers on mouse down.
         * @event
         */
        chartMouseDown: ej.base.EmitType<IMouseEventArgs>;
        /**
         * Triggers on mouse up.
         * @event
         */
        chartMouseUp: ej.base.EmitType<IMouseEventArgs>;
        /**
         * Triggers after the drag selection is completed.
         * @event
         */
        dragComplete: ej.base.EmitType<IDragCompleteEventArgs>;
        /**
         * Triggers after the zoom selection is completed.
         * @event
         */
        zoomComplete: ej.base.EmitType<IZoomCompleteEventArgs>;
        /**
         * Defines the currencyCode format of the chart
         * @private
         */
        private currencyCode;
        private htmlObject;
        private getElement;
        private elementSize;
        private isLegend;
        /**
         * localization object
         * @private
         */
        localeObject: ej.base.L10n;
        /**
         * It contains default values of localization values
         */
        private defaultLocalConstants;
        /**
         * Gets the current visible axis of the Chart.
         * @hidden
         */
        axisCollections: Axis[];
        /**
         * Gets the current visible series of the Chart.
         * @hidden
         */
        visibleSeries: Series[];
        /**
         * Render panel for chart.
         * @hidden
         */
        chartAxisLayoutPanel: CartesianAxisLayoutPanel | PolarRadarPanel;
        /**
         * Gets all the horizontal axis of the Chart.
         * @hidden
         */
        horizontalAxes: Axis[];
        /**
         * Gets all the vertical axis of the Chart.
         * @hidden
         */
        verticalAxes: Axis[];
        /**
         * Gets the inverted chart.
         * @hidden
         */
        requireInvertedAxis: boolean;
        /** @private */
        svgObject: Element;
        /** @private */
        isTouch: boolean;
        /** @private */
        renderer: ej.base.SvgRenderer;
        /** @private */
        initialClipRect: Rect;
        /** @private */
        seriesElements: Element;
        /** @private */
        indicatorElements: Element;
        /** @private */
        trendLineElements: Element;
        /** @private */
        visibleSeriesCount: number;
        /** @private */
        intl: ej.base.Internationalization;
        /** @private */
        dataLabelCollections: Rect[];
        /** @private */
        dataLabelElements: Element;
        /** @private */
        mouseX: number;
        /** @private */
        mouseY: number;
        /** @private */
        animateSeries: boolean;
        /** @private */
        availableSize: Size;
        /** @private */
        delayRedraw: boolean;
        /** @private */
        isDoubleTap: boolean;
        /** @private */
        mouseDownX: number;
        /** @private */
        mouseDownY: number;
        /** @private */
        previousMouseMoveX: number;
        /** @private */
        previousMouseMoveY: number;
        /** @private */
        private threshold;
        /** @private */
        isChartDrag: boolean;
        private resizeTo;
        /** @private */
        disableTrackTooltip: boolean;
        /** @private */
        startMove: boolean;
        /** @private */
        yAxisElements: Element;
        /** @private */
        radius: number;
        /** @private */
        chartAreaType: string;
        /**
         * `markerModule` is used to manipulate and add marker to the series.
         * @private
         */
        markerRender: Marker;
        private titleCollection;
        /** @private */
        themeStyle: IThemeStyle;
        /**
         * Constructor for creating the widget
         * @hidden
         */
        constructor(options?: ChartModel, element?: string | HTMLElement);
        /**
         * Initialize the event handler.
         */
        protected preRender(): void;
        private initPrivateVariable();
        /**
         * To Initialize the control rendering.
         */
        protected render(): void;
        /**
         * Gets the localized label by locale keyword.
         * @param  {string} key
         * @return {string}
         */
        getLocalizedLabel(key: string): string;
        /**
         * Refresh the chart bounds.
         * @private
         */
        refreshBound(): void;
        private renderElements();
        /**
         * To render the legend
         */
        private renderAxes();
        /**
         * To render the legend
         */
        private renderLegend();
        /**
         * To set the left and top position for data label template for center aligned chart
         */
        private setSecondaryElementPosition();
        private initializeModuleElements();
        private hasTrendlines();
        private renderSeriesElements(axisElement);
        private renderSeries();
        private initializeIndicator();
        private initializeTrendLine();
        private appendElementsAfterSeries(axisElement);
        private applyZoomkit();
        private renderAnnotation();
        private performSelection();
        private processData();
        private initializeDataModule(series);
        private calculateBounds();
        /**
         * Handles the print method for chart control.
         */
        print(id?: string[] | string | Element): void;
        /**
         * Handles the export method for chart control.
         * @param type
         * @param fileName
         */
        export(type: ExportType, fileName: string, orientation?: ej.pdfexport.PdfPageOrientation): void;
        /**
         * Defines the trendline initialization
         */
        private initTrendLines();
        private calculateAreaType();
        private calculateVisibleAxis();
        private initAxis(series, axis, isSeries);
        private initTechnicalIndicators();
        /** @private */
        refreshTechnicalIndicator(series: SeriesBase): void;
        private calculateVisibleSeries();
        private renderTitle();
        private renderBorder();
        private renderAreaBorder();
        /**
         * To add series for the chart
         * @param {SeriesModel[]} seriesCollection - Defines the series collection to be added in chart.
         * @return {void}.
         */
        addSeries(seriesCollection: SeriesModel[]): void;
        /**
         * To Remove series for the chart
         * @param index - Defines the series index to be remove in chart series
         * @return {void}
         */
        removeSeries(index: number): void;
        /**
         * To destroy the widget
         * @method destroy
         * @return {void}.
         * @member of Chart
         */
        destroy(): void;
        /**
         * Get component name
         */
        getModuleName(): string;
        /**
         * Get the properties to be maintained in the persisted state.
         * @private
         */
        getPersistData(): string;
        /**
         * Method to create SVG element.
         */
        private createChartSvg();
        /**
         * Method to bind events for chart
         */
        private unWireEvents();
        private wireEvents();
        private chartRightClick(event);
        private setStyle(element);
        /**
         * Finds the orientation.
         * @return {boolean}
         * @private
         */
        isOrientation(): boolean;
        /**
         * Handles the long press on chart.
         * @return {boolean}
         * @private
         */
        longPress(e?: ej.base.TapEventArgs): boolean;
        /**
         * To find mouse x, y for aligned chart element svg position
         */
        private setMouseXY(pageX, pageY);
        /**
         * Handles the chart resize.
         * @return {boolean}
         * @private
         */
        chartResize(e: Event): boolean;
        /**
         * Handles the mouse move.
         * @return {boolean}
         * @private
         */
        mouseMove(e: PointerEvent): boolean;
        /**
         * Handles the mouse leave.
         * @return {boolean}
         * @private
         */
        mouseLeave(e: PointerEvent): boolean;
        /**
         * Handles the mouse leave on chart.
         * @return {boolean}
         * @private
         */
        chartOnMouseLeave(e: PointerEvent | TouchEvent): boolean;
        /**
         * Handles the mouse click on chart.
         * @return {boolean}
         * @private
         */
        chartOnMouseClick(e: PointerEvent | TouchEvent): boolean;
        private triggerPointEvent(event);
        /**
         * Handles the mouse move on chart.
         * @return {boolean}
         * @private
         */
        chartOnMouseMove(e: PointerEvent | TouchEvent): boolean;
        private titleTooltip(event, x, y, isTouch?);
        private axisTooltip(event, x, y, isTouch?);
        private findAxisLabel(text);
        /**
         * Handles the mouse down on chart.
         * @return {boolean}
         * @private
         */
        chartOnMouseDown(e: PointerEvent): boolean;
        /**
         * Handles the mouse up.
         * @return {boolean}
         * @private
         */
        mouseEnd(e: PointerEvent): boolean;
        /**
         * Handles the mouse up.
         * @return {boolean}
         * @private
         */
        chartOnMouseUp(e: PointerEvent | TouchEvent): boolean;
        /**
         * Method to set culture for chart
         */
        private setCulture();
        /**
         * Method to set the annotation content dynamically for chart.
         */
        setAnnotationValue(annotationIndex: number, content: string): void;
        /**
         * Method to set locale constants
         */
        private setLocaleConstants();
        /**
         * Themeing for chart goes here
         */
        private setTheme();
        /**
         * To provide the array of modules needed for control rendering
         * @return {ej.base.ModuleDeclaration[]}
         * @private
         */
        requiredModules(): ej.base.ModuleDeclaration[];
        private findAxisModule(modules);
        private findIndicatorModules(modules);
        private findTrendLineModules(modules);
        private findStriplineVisibility(striplines);
        /**
         * To Remove the SVG.
         * @return {boolean}
         * @private
         */
        removeSvg(): void;
        private refreshDefinition(definitions);
        /**
         * Refresh the axis default value.
         * @return {boolean}
         * @private
         */
        refreshAxis(): void;
        private axisChange(axis);
        /**
         * Called internally if any of the property value changed.
         * @private
         */
        onPropertyChanged(newProp: ChartModel, oldProp: ChartModel): void;
    }
    
    /**
     * `ChartAnnotation` module handles the annotation for chart.
     */
    export class ChartAnnotation extends AnnotationBase {
        private chart;
        private annotations;
        private parentElement;
        /**
         * Constructor for chart annotation.
         * @private.
         */
        constructor(control: Chart, annotations: ChartAnnotationSettings[]);
        /**
         * Method to render the annotation for chart
         * @param element
         * @private
         */
        renderAnnotations(element: Element): void;
        /**
         * To destroy the annotation.
         * @return {void}
         * @private
         */
        destroy(control: Chart): void;
        /**
         * Get module name.
         */
        protected getModuleName(): string;
    }
    
    /**
     * Common axis classes
     * @private
     */
    export class NiceInterval extends Double {
        /**
         * Method to calculate numeric datetime interval
         */
        calculateDateTimeNiceInterval(axis: Axis, size: Size, start: number, end: number): number;
        /**
         * To get the skeleton for the DateTime axis.
         * @return {string}
         *  @private
         */
        getSkeleton(axis: Axis): string;
    }
    
    /**
     * Interface for a class Row
     */
    export interface RowModel {
    
        /**
         * The height of the row as a string accept input both as '100px' and '100%'.
         * If specified as '100%, row renders to the full height of its chart.
         * @default '100%'
         */
    
        height?: string;
    
        /**
         * Options to customize the border of the rows.
         */
    
        border?: BorderModel;
    
    }
    
    /**
     * Interface for a class Column
     */
    export interface ColumnModel {
    
        /**
         * The width of the column as a string accepts input both as like '100px' or '100%'.
         * If specified as '100%, column renders to the full width of its chart.
         * @default '100%'
         */
    
        width?: string;
    
        /**
         * Options to customize the border of the columns.
         */
    
        border?: BorderModel;
    
    }
    
    /**
     * Interface for a class MajorGridLines
     */
    export interface MajorGridLinesModel {
    
        /**
         * The width of the line in pixels.
         * @default 1
         */
    
        width?: number;
    
        /**
         * The dash array of the grid lines.
         * @default ''
         */
    
        dashArray?: string;
    
        /**
         * The color of the major grid line that accepts value in hex and rgba as a valid CSS color string.
         * @default null
         */
    
        color?: string;
    
    }
    
    /**
     * Interface for a class MinorGridLines
     */
    export interface MinorGridLinesModel {
    
        /**
         * The width of the line in pixels.
         * @default 0.7
         */
    
        width?: number;
    
        /**
         * The dash array of grid lines.
         * @default ''
         */
    
        dashArray?: string;
    
        /**
         * The color of the minor grid line that accepts value in hex and rgba as a valid CSS color string.
         * @default null
         */
    
        color?: string;
    
    }
    
    /**
     * Interface for a class AxisLine
     */
    export interface AxisLineModel {
    
        /**
         * The width of the line in pixels.
         * @default 1
         */
    
        width?: number;
    
        /**
         * The dash array of the axis line.
         * @default ''
         */
    
        dashArray?: string;
    
        /**
         * The color of the axis line that accepts value in hex and rgba as a valid CSS color string.
         * @default null
         */
    
        color?: string;
    
    }
    
    /**
     * Interface for a class MajorTickLines
     */
    export interface MajorTickLinesModel {
    
        /**
         * The width of the tick lines in pixels.
         * @default 1
         */
    
        width?: number;
    
        /**
         * The height of the ticks in pixels.
         * @default 5
         */
    
        height?: number;
    
        /**
         * The color of the major tick line that accepts value in hex and rgba as a valid CSS color string.
         * @default null
         */
    
        color?: string;
    
    }
    
    /**
     * Interface for a class MinorTickLines
     */
    export interface MinorTickLinesModel {
    
        /**
         * The width of the tick line in pixels.
         * @default 0.7
         */
    
        width?: number;
    
        /**
         * The height of the ticks in pixels.
         * @default 5
         */
    
        height?: number;
    
        /**
         * The color of the minor tick line that accepts value in hex and rgba as a valid CSS color string.
         * @default null
         */
    
        color?: string;
    
    }
    
    /**
     * Interface for a class CrosshairTooltip
     */
    export interface CrosshairTooltipModel {
    
        /**
         * If set to true, crosshair ToolTip will be visible.
         *  @default false
         */
    
        enable?: Boolean;
    
        /**
         * The fill color of the ToolTip accepts value in hex and rgba as a valid CSS color string.
         * @default null
         */
    
        fill?: string;
    
        /**
         * Options to customize the crosshair ToolTip text.
         */
    
        textStyle?: FontModel;
    
    }
    
    /**
     * Interface for a class Axis
     */
    export interface AxisModel {
    
        /**
         * Options to customize the axis label.
         */
    
        labelStyle?: FontModel;
    
        /**
         * Options to customize the crosshair ToolTip.
         */
    
        crosshairTooltip?: CrosshairTooltipModel;
    
        /**
         * Specifies the title of an axis.
         * @default ''
         */
    
        title?: string;
    
        /**
         * Options for customizing the axis title.
         */
    
        titleStyle?: FontModel;
    
        /**
         * Used to format the axis label that accepts any global string format like 'C', 'n1', 'P' etc.
         * It also accepts placeholder like '{value}°C' in which value represent the axis label, e.g, 20°C.
         * @default ''
         */
    
        labelFormat?: string;
    
        /**
         * Specifies the skeleton format in which the dateTime format will process.
         * @default ''
         */
    
        skeleton?: string;
    
        /**
         * It specifies the type of format to be used in dateTime format process.
         * @default 'DateTime'
         */
    
        skeletonType?: SkeletonType;
    
        /**
         * Left and right padding for the plot area in pixels.
         * @default 0
         */
    
        plotOffset?: number;
    
        /**
         * Specifies indexed category  axis.
         * @default false
         */
    
        isIndexed?: boolean;
    
        /**
         * The base value for logarithmic axis. It requires `valueType` to be `Logarithmic`.
         * @default 10
         */
        logBase?: number;
    
        /**
         * Specifies the index of the column where the axis is associated,
         * when the chart area is divided into multiple plot areas by using `columns`.
         * ```html 
         * <div id='Chart'></div>
         * ```
         * ```typescript
         * let chart: Chart = new Chart({
         * ...
         *     columns: [{ width: '50%' },
         *               { width: '50%' }],
         *     axes: [{
         *                name: 'xAxis 1',
         *                columnIndex: 1,
         *     }],
         * ... 
         * });
         * chart.appendTo('#Chart');
         * ```
         * @default 0
         */
    
        columnIndex?: number;
    
        /**
         * Specifies the index of the row where the axis is associated, when the chart area is divided into multiple plot areas by using `rows`.
         * ```html 
         * <div id='Chart'></div>
         * ```
         * ```typescript
         * let chart: Chart = new Chart({
         * ...
         *     rows: [{ height: '50%' },
         *            { height: '50%' }],
         *     axes: [{
         *                name: 'yAxis 1',
         *                rowIndex: 1,
         *      }],
         * ...
         * });
         * chart.appendTo('#Chart');
         * ```
         * @default 0
         */
    
        rowIndex?: number;
    
        /**
         * Specifies the number of `columns` or `rows` an axis has to span horizontally or vertically.
         * @default 1
         */
    
        span?: number;
    
        /**
         * With this property, you can request axis to calculate intervals approximately equal to your specified interval.
         * @default null
         */
    
        desiredIntervals?: number;
    
        /**
         * The maximum number of label count per 100 pixels with respect to the axis length.
         * @default 3
         */
    
        maximumLabels?: number;
    
        /**
         * The axis is scaled by this factor. When zoomFactor is 0.5, the chart is scaled by 200% along this axis. Value ranges from 0 to 1.
         * @default 1
         */
    
        zoomFactor?: number;
    
        /**
         * Position of the zoomed axis. Value ranges from 0 to 1.
         * @default 0
         */
    
        zoomPosition?: number;
    
        /**
         * If set to true, the axis will render at the opposite side of its default position.
         * @default false
         */
    
        opposedPosition?: boolean;
    
        /**
         * If set to true, axis interval will be calculated automatically with respect to the zoomed range.
         * @default true
         */
    
        enableAutoIntervalOnZooming?: boolean;
    
        /**
         * Specifies the padding for the axis range in terms of interval.They are,
         * * none: Padding cannot be applied to the axis.
         * * normal: Padding is applied to the axis based on the range calculation.
         * * additional: Interval of the axis is added as padding to the minimum and maximum values of the range.
         * * round: Axis range is rounded to the nearest possible value divided by the interval.
         * @default 'Auto'
         */
    
        rangePadding?: ChartRangePadding;
    
        /**
         * Specifies the type of data the axis is handling.
         * * Double:  Renders a numeric axis.
         * * DateTime: Renders a dateTime axis.
         * * Category: Renders a category axis.
         * * Logarithmic: Renders a log axis.
         * @default 'Double'
         */
    
        valueType?: ValueType;
    
        /**
         * Specifies the position of labels at the edge of the axis.They are,
         * * None: No action will be performed.
         * * Hide: Edge label will be hidden.
         * * Shift: Shifts the edge labels.
         * @default 'None'
         */
    
        edgeLabelPlacement?: EdgeLabelPlacement;
    
        /**
         * Specifies the types like `Years`, `Months`, `Days`, `Hours`, `Minutes`, `Seconds` in date time axis.They are,
         * * Auto: Defines the interval of the axis based on data.
         * * Years: Defines the interval of the axis in years.
         * * Months: Defines the interval of the axis in months.
         * * Days: Defines the interval of the axis in days.
         * * Hours: Defines the interval of the axis in hours.
         * * Minutes: Defines the interval of the axis in minutes.
         * @default 'Auto'
         */
    
        intervalType?: IntervalType;
    
        /**
         * Specifies the placement of a label for category axis. They are,
         * * betweenTicks: Renders the label between the ticks.
         * * onTicks: Renders the label on the ticks.
         * @default 'BetweenTicks'
         */
    
        labelPlacement?: LabelPlacement;
    
        /**
         * Specifies the placement of a ticks to the axis line. They are,
         * * inside: Renders the ticks inside to the axis line.
         * * outside: Renders the ticks outside to the axis line.
         * @default 'Outside'
         */
    
        tickPosition?: AxisPosition;
    
        /**
         * Specifies the placement of a labels to the axis line. They are,
         * * inside: Renders the labels inside to the axis line.
         * * outside: Renders the labels outside to the axis line.
         * @default 'Outside'
         */
    
        labelPosition?: AxisPosition;
    
        /**
         * Unique identifier of an axis.
         * To associate an axis with the series, set this name to the xAxisName/yAxisName properties of the series.
         * @default ''
         */
    
        name?: string;
    
        /**
         * If set to true, axis label will be visible.
         * @default true
         */
    
        visible?: boolean;
    
        /**
         * Specifies the number of minor ticks per interval.
         * @default 0
         */
    
        minorTicksPerInterval?: number;
    
        /**
         * The angle to which the axis label gets rotated.
         * @default 0
         */
    
        labelRotation?: number;
    
        /**
         * Specifies the value at which the axis line has to be intersect with the vertical axis or vice versa.
         * @default null
         */
    
        crossesAt?: Object;
    
        /**
         * Specifies whether axis elements like axis labels, axis title, etc has to be crossed with axis line
         * @default true
         */
    
        placeNextToAxisLine?: boolean;
    
        /**
         * Specifies axis name with which the axis line has to be crossed
         * @default null
         */
    
        crossesInAxis?: string;
    
        /**
         * Specifies the minimum range of an axis.
         * @default null
         */
    
        minimum?: Object;
    
        /**
         * Specifies the maximum range of an axis.
         * @default null
         */
    
        maximum?: Object;
    
        /**
         * Specifies the interval for an axis.
         * @default null
         */
    
        interval?: number;
    
        /**
         * Options for customizing major tick lines.
         */
    
        majorTickLines?: MajorTickLinesModel;
    
        /**
         * Options for customizing minor tick lines.
         */
    
        minorTickLines?: MinorTickLinesModel;
    
        /**
         * Options for customizing major grid lines.
         */
    
        majorGridLines?: MajorGridLinesModel;
    
        /**
         * Options for customizing minor grid lines.
         */
    
        minorGridLines?: MinorGridLinesModel;
    
        /**
         * Options for customizing axis lines.
         */
    
        lineStyle?: AxisLineModel;
    
        /**
         * Specifies the actions like `Hide`, `Rotate45`, and `Rotate90` when the axis labels intersect with each other.They are,
         * * None: Shows all the labels.
         * * Hide: Hides the label when it intersects.
         * * Rotate45: Rotates the label to 45 degree when it intersects.
         * * Rotate90: Rotates the label to 90 degree when it intersects.
         * @default Hide
         */
    
        labelIntersectAction?: LabelIntersectAction;
    
        /**
         * It specifies whether the axis to be rendered in inversed manner or not.
         * @default false
         */
        isInversed?: boolean;
    
        /**
         * The polar radar radius position.
         * @default 100
         */
    
        coefficient?: number;
    
        /**
         * The start angle for the series.
         * @default 0
         */
    
        startAngle?: number;
    
        /**
         * Description for axis and its element.
         * @default null
         */
        description?: string;
    
        /**
         * TabIndex value for the axis.
         * @default 2
         */
        tabIndex?: number;
    
        /**
         * Specifies the stripLine collection for the axis
         */
        stripLines?: StripLineSettingsModel[];
    
        /**
         * Specifies the multi level labels collection for the axis
         */
        multiLevelLabels?: MultiLevelLabelsModel[];
    
        /**
         * Border of the multi level labels.
         */
        border?: LabelBorderModel;
    
    }
    
    /**
     * Interface for a class VisibleLabels
     * @private
     */
    export interface VisibleLabelsModel {
    
    }
    
    /**
     * Configures the `rows` of the chart.
     */
    export class Row extends ej.base.ChildProperty<Row> {
        /**
         * The height of the row as a string accept input both as '100px' and '100%'.
         * If specified as '100%, row renders to the full height of its chart.
         * @default '100%'
         */
        height: string;
        /**
         * Options to customize the border of the rows.
         */
        border: BorderModel;
        /** @private */
        axes: Axis[];
        /** @private */
        computedHeight: number;
        /** @private */
        computedTop: number;
        /** @private */
        nearSizes: number[];
        /** @private */
        farSizes: number[];
        /**
         * Measure the row size
         * @return {void}
         * @private
         */
        computeSize(axis: Axis, clipRect: Rect): void;
    }
    /**
     * Configures the `columns` of the chart.
     */
    export class Column extends ej.base.ChildProperty<Column> {
        /**
         * The width of the column as a string accepts input both as like '100px' or '100%'.
         * If specified as '100%, column renders to the full width of its chart.
         * @default '100%'
         */
        width: string;
        /**
         * Options to customize the border of the columns.
         */
        border: BorderModel;
        /** @private */
        axes: Axis[];
        /** @private */
        computedWidth: number;
        /** @private */
        computedLeft: number;
        /** @private */
        nearSizes: number[];
        /** @private */
        farSizes: number[];
        /** @private */
        private padding;
        /**
         * Measure the column size
         * @return {void}
         * @private
         */
        computeSize(axis: Axis, clipRect: Rect): void;
    }
    /**
     * Configures the major grid lines in the `axis`.
     */
    export class MajorGridLines extends ej.base.ChildProperty<MajorGridLines> {
        /**
         * The width of the line in pixels.
         * @default 1
         */
        width: number;
        /**
         * The dash array of the grid lines.
         * @default ''
         */
        dashArray: string;
        /**
         * The color of the major grid line that accepts value in hex and rgba as a valid CSS color string.
         * @default null
         */
        color: string;
    }
    /**
     * Configures the minor grid lines in the `axis`.
     */
    export class MinorGridLines extends ej.base.ChildProperty<MinorGridLines> {
        /**
         * The width of the line in pixels.
         * @default 0.7
         */
        width: number;
        /**
         * The dash array of grid lines.
         * @default ''
         */
        dashArray: string;
        /**
         * The color of the minor grid line that accepts value in hex and rgba as a valid CSS color string.
         * @default null
         */
        color: string;
    }
    /**
     * Configures the axis line of a chart.
     */
    export class AxisLine extends ej.base.ChildProperty<AxisLine> {
        /**
         * The width of the line in pixels.
         * @default 1
         */
        width: number;
        /**
         * The dash array of the axis line.
         * @default ''
         */
        dashArray: string;
        /**
         * The color of the axis line that accepts value in hex and rgba as a valid CSS color string.
         * @default null
         */
        color: string;
    }
    /**
     * Configures the major tick lines.
     */
    export class MajorTickLines extends ej.base.ChildProperty<MajorTickLines> {
        /**
         * The width of the tick lines in pixels.
         * @default 1
         */
        width: number;
        /**
         * The height of the ticks in pixels.
         * @default 5
         */
        height: number;
        /**
         * The color of the major tick line that accepts value in hex and rgba as a valid CSS color string.
         * @default null
         */
        color: string;
    }
    /**
     * Configures the minor tick lines.
     */
    export class MinorTickLines extends ej.base.ChildProperty<MinorTickLines> {
        /**
         * The width of the tick line in pixels.
         * @default 0.7
         */
        width: number;
        /**
         * The height of the ticks in pixels.
         * @default 5
         */
        height: number;
        /**
         * The color of the minor tick line that accepts value in hex and rgba as a valid CSS color string.
         * @default null
         */
        color: string;
    }
    /**
     * Configures the crosshair ToolTip.
     */
    export class CrosshairTooltip extends ej.base.ChildProperty<CrosshairTooltip> {
        /**
         * If set to true, crosshair ToolTip will be visible.
         *  @default false
         */
        enable: Boolean;
        /**
         * The fill color of the ToolTip accepts value in hex and rgba as a valid CSS color string.
         * @default null
         */
        fill: string;
        /**
         * Options to customize the crosshair ToolTip text.
         */
        textStyle: FontModel;
    }
    /**
     * Configures the axes in the chart.
     */
    export class Axis extends ej.base.ChildProperty<Axis> {
        /**
         * Options to customize the axis label.
         */
        labelStyle: FontModel;
        /**
         * Options to customize the crosshair ToolTip.
         */
        crosshairTooltip: CrosshairTooltipModel;
        /**
         * Specifies the title of an axis.
         * @default ''
         */
        title: string;
        /**
         * Options for customizing the axis title.
         */
        titleStyle: FontModel;
        /**
         * Used to format the axis label that accepts any global string format like 'C', 'n1', 'P' etc.
         * It also accepts placeholder like '{value}°C' in which value represent the axis label, e.g, 20°C.
         * @default ''
         */
        labelFormat: string;
        /**
         * Specifies the skeleton format in which the dateTime format will process.
         * @default ''
         */
        skeleton: string;
        /**
         * It specifies the type of format to be used in dateTime format process.
         * @default 'DateTime'
         */
        skeletonType: SkeletonType;
        /**
         * Left and right padding for the plot area in pixels.
         * @default 0
         */
        plotOffset: number;
        /**
         * Specifies indexed category  axis.
         * @default false
         */
        isIndexed: boolean;
        /**
         * The base value for logarithmic axis. It requires `valueType` to be `Logarithmic`.
         * @default 10
         */
        logBase: number;
        /**
         * Specifies the index of the column where the axis is associated,
         * when the chart area is divided into multiple plot areas by using `columns`.
         * ```html
         * <div id='Chart'></div>
         * ```
         * ```typescript
         * let chart: Chart = new Chart({
         * ...
         *     columns: [{ width: '50%' },
         *               { width: '50%' }],
         *     axes: [{
         *                name: 'xAxis 1',
         *                columnIndex: 1,
         *     }],
         * ...
         * });
         * chart.appendTo('#Chart');
         * ```
         * @default 0
         */
        columnIndex: number;
        /**
         * Specifies the index of the row where the axis is associated, when the chart area is divided into multiple plot areas by using `rows`.
         * ```html
         * <div id='Chart'></div>
         * ```
         * ```typescript
         * let chart: Chart = new Chart({
         * ...
         *     rows: [{ height: '50%' },
         *            { height: '50%' }],
         *     axes: [{
         *                name: 'yAxis 1',
         *                rowIndex: 1,
         *      }],
         * ...
         * });
         * chart.appendTo('#Chart');
         * ```
         * @default 0
         */
        rowIndex: number;
        /**
         * Specifies the number of `columns` or `rows` an axis has to span horizontally or vertically.
         * @default 1
         */
        span: number;
        /**
         * With this property, you can request axis to calculate intervals approximately equal to your specified interval.
         * @default null
         */
        desiredIntervals: number;
        /**
         * The maximum number of label count per 100 pixels with respect to the axis length.
         * @default 3
         */
        maximumLabels: number;
        /**
         * The axis is scaled by this factor. When zoomFactor is 0.5, the chart is scaled by 200% along this axis. Value ranges from 0 to 1.
         * @default 1
         */
        zoomFactor: number;
        /**
         * Position of the zoomed axis. Value ranges from 0 to 1.
         * @default 0
         */
        zoomPosition: number;
        /**
         * If set to true, the axis will render at the opposite side of its default position.
         * @default false
         */
        opposedPosition: boolean;
        /**
         * If set to true, axis interval will be calculated automatically with respect to the zoomed range.
         * @default true
         */
        enableAutoIntervalOnZooming: boolean;
        /**
         * Specifies the padding for the axis range in terms of interval.They are,
         * * none: Padding cannot be applied to the axis.
         * * normal: Padding is applied to the axis based on the range calculation.
         * * additional: Interval of the axis is added as padding to the minimum and maximum values of the range.
         * * round: Axis range is rounded to the nearest possible value divided by the interval.
         * @default 'Auto'
         */
        rangePadding: ChartRangePadding;
        /**
         * Specifies the type of data the axis is handling.
         * * Double:  Renders a numeric axis.
         * * DateTime: Renders a dateTime axis.
         * * Category: Renders a category axis.
         * * Logarithmic: Renders a log axis.
         * @default 'Double'
         */
        valueType: ValueType;
        /**
         * Specifies the position of labels at the edge of the axis.They are,
         * * None: No action will be performed.
         * * Hide: Edge label will be hidden.
         * * Shift: Shifts the edge labels.
         * @default 'None'
         */
        edgeLabelPlacement: EdgeLabelPlacement;
        /**
         * Specifies the types like `Years`, `Months`, `Days`, `Hours`, `Minutes`, `Seconds` in date time axis.They are,
         * * Auto: Defines the interval of the axis based on data.
         * * Years: Defines the interval of the axis in years.
         * * Months: Defines the interval of the axis in months.
         * * Days: Defines the interval of the axis in days.
         * * Hours: Defines the interval of the axis in hours.
         * * Minutes: Defines the interval of the axis in minutes.
         * @default 'Auto'
         */
        intervalType: IntervalType;
        /**
         * Specifies the placement of a label for category axis. They are,
         * * betweenTicks: Renders the label between the ticks.
         * * onTicks: Renders the label on the ticks.
         * @default 'BetweenTicks'
         */
        labelPlacement: LabelPlacement;
        /**
         * Specifies the placement of a ticks to the axis line. They are,
         * * inside: Renders the ticks inside to the axis line.
         * * outside: Renders the ticks outside to the axis line.
         * @default 'Outside'
         */
        tickPosition: AxisPosition;
        /**
         * Specifies the placement of a labels to the axis line. They are,
         * * inside: Renders the labels inside to the axis line.
         * * outside: Renders the labels outside to the axis line.
         * @default 'Outside'
         */
        labelPosition: AxisPosition;
        /**
         * Unique identifier of an axis.
         * To associate an axis with the series, set this name to the xAxisName/yAxisName properties of the series.
         * @default ''
         */
        name: string;
        /**
         * If set to true, axis label will be visible.
         * @default true
         */
        visible: boolean;
        /**
         * Specifies the number of minor ticks per interval.
         * @default 0
         */
        minorTicksPerInterval: number;
        /**
         * The angle to which the axis label gets rotated.
         * @default 0
         */
        labelRotation: number;
        /**
         * Specifies the value at which the axis line has to be intersect with the vertical axis or vice versa.
         * @default null
         */
        crossesAt: Object;
        /**
         * Specifies whether axis elements like axis labels, axis title, etc has to be crossed with axis line
         * @default true
         */
        placeNextToAxisLine: boolean;
        /**
         * Specifies axis name with which the axis line has to be crossed
         * @default null
         */
        crossesInAxis: string;
        /**
         * Specifies the minimum range of an axis.
         * @default null
         */
        minimum: Object;
        /**
         * Specifies the maximum range of an axis.
         * @default null
         */
        maximum: Object;
        /**
         * Specifies the interval for an axis.
         * @default null
         */
        interval: number;
        /**
         * Options for customizing major tick lines.
         */
        majorTickLines: MajorTickLinesModel;
        /**
         * Options for customizing minor tick lines.
         */
        minorTickLines: MinorTickLinesModel;
        /**
         * Options for customizing major grid lines.
         */
        majorGridLines: MajorGridLinesModel;
        /**
         * Options for customizing minor grid lines.
         */
        minorGridLines: MinorGridLinesModel;
        /**
         * Options for customizing axis lines.
         */
        lineStyle: AxisLineModel;
        /**
         * Specifies the actions like `Hide`, `Rotate45`, and `Rotate90` when the axis labels intersect with each other.They are,
         * * None: Shows all the labels.
         * * Hide: Hides the label when it intersects.
         * * Rotate45: Rotates the label to 45 degree when it intersects.
         * * Rotate90: Rotates the label to 90 degree when it intersects.
         * @default Hide
         */
        labelIntersectAction: LabelIntersectAction;
        /**
         * It specifies whether the axis to be rendered in inversed manner or not.
         * @default false
         */
        isInversed: boolean;
        /**
         * The polar radar radius position.
         * @default 100
         */
        coefficient: number;
        /**
         * The start angle for the series.
         * @default 0
         */
        startAngle: number;
        /**
         * Description for axis and its element.
         * @default null
         */
        description: string;
        /**
         * TabIndex value for the axis.
         * @default 2
         */
        tabIndex: number;
        /**
         * Specifies the stripLine collection for the axis
         */
        stripLines: StripLineSettingsModel[];
        /**
         * Specifies the multi level labels collection for the axis
         */
        multiLevelLabels: MultiLevelLabelsModel[];
        /**
         * Border of the multi level labels.
         */
        border: LabelBorderModel;
        /** @private */
        visibleRange: VisibleRangeModel;
        /** @private */
        visibleLabels: VisibleLabels[];
        /** @private */
        actualRange: VisibleRangeModel;
        /** @private */
        series: Series[];
        /** @private */
        doubleRange: DoubleRange;
        /** @private */
        maxLabelSize: Size;
        /** @private */
        rotatedLabel: string;
        /** @private */
        rect: Rect;
        /** @private */
        axisBottomLine: BorderModel;
        /** @private */
        orientation: Orientation;
        /** @private */
        intervalDivs: number[];
        /** @private */
        actualIntervalType: IntervalType;
        /** @private */
        labels: string[];
        /** @private */
        format: Function;
        /** @private */
        baseModule: Double | DateTime | Category | DateTimeCategory;
        /** @private */
        startLabel: string;
        /** @private */
        endLabel: string;
        /** @private */
        angle: number;
        /** @private */
        dateTimeInterval: number;
        /** @private */
        isStack100: boolean;
        /** @private */
        crossInAxis: this;
        /** @private */
        crossAt: number;
        /** @private */
        updatedRect: Rect;
        /** @private */
        multiLevelLabelHeight: number;
        /**
         * The function used to find tick size.
         * @return {number}
         * @private
         */
        findTickSize(crossAxis: Axis): number;
        /**
         * The function used to find axis position.
         * @return {number}
         * @private
         */
        isInside(range: VisibleRangeModel): boolean;
        /**
         * The function used to find label Size.
         * @return {number}
         * @private
         */
        findLabelSize(crossAxis: Axis, innerPadding: number): number;
        /**
         * The function used to find axis position.
         * @return {number}
         * @private
         */
        updateCrossValue(chart: Chart): void;
        private findDifference(crossAxis);
        /**
         * The function used to find whether the range is set.
         * @return {boolean}
         * @private
         */
        setRange(): boolean;
        /**
         * Calculate visible range for axis.
         * @return {void}
         * @private
         */
        calculateVisibleRange(size: Size): void;
        /**
         * Calculate desired interval for the axis.
         * @return {void}
         * @private
         */
        getActualDesiredIntervalsCount(availableSize: Size): number;
        /**
         * Triggers the event.
         * @return {void}
         * @private
         */
        triggerLabelRender(chart: Chart, tempInterval: number, text: string, labelStyle: FontModel): void;
        /**
         * Triggers the event.
         * @return {void}
         * @private
         */
        triggerRangeRender(chart: Chart, minimum: number, maximum: number, interval: number): void;
        /**
         * Calculate padding for the axis.
         * @return {string}
         * @private
         */
        getRangePadding(chart: Chart): string;
        /**
         * Calculate maximum label width for the axis.
         * @return {void}
         * @private
         */
        getMaxLabelWidth(chart: Chart): void;
        /**
         * Finds the multiple rows for axis.
         * @return {void}
         */
        private findMultiRows(length, currentX, currentLabel);
        /**
         * Finds the default module for axis.
         * @return {void}
         * @private
         */
        getModule(chart: Chart): void;
    }
    /** @private */
    export interface VisibleRangeModel {
        min?: number;
        max?: number;
        interval?: number;
        delta?: number;
    }
    /** @private */
    export class VisibleLabels {
        text: string | string[];
        value: number;
        labelStyle: FontModel;
        size: Size;
        index: number;
        originalText: string;
        constructor(text: string | string[], value: number, labelStyle: FontModel, size?: Size, index?: number);
    }
    
    export class CartesianAxisLayoutPanel {
        private chart;
        private initialClipRect;
        private htmlObject;
        private element;
        private padding;
        /** @private */
        leftSize: number;
        /** @private */
        rightSize: number;
        /** @private */
        topSize: number;
        /** @private */
        bottomSize: number;
        /** @private */
        seriesClipRect: Rect;
        /** @private */
        constructor(chartModule?: Chart);
        /**
         * Measure the axis size.
         * @return {void}
         * @private
         */
        measureAxis(rect: Rect): void;
        private measureRowAxis(chart, rect);
        private measureColumnAxis(chart, rect);
        /**
         * Measure the column and row in chart.
         * @return {void}
         * @private
         */
        measureDefinition(definition: Row | Column, chart: Chart, size: Size, clipRect: Rect): void;
        /**
         * Measure the axis.
         * @return {void}
         * @private
         */
        private calculateAxisSize(rect);
        /**
         * Measure the axis.
         * @return {void}
         * @private
         */
        measure(): void;
        private crossAt(chart);
        private updateCrossAt(axis, crossAt);
        private pushAxis(definition, axis);
        private arrangeAxis(definition);
        private getActualColumn(axis);
        private getActualRow(axis);
        /**
         * Measure the row size.
         * @return {void}
         */
        private calculateRowSize(rect);
        /**
         * Measure the row size.
         * @return {void}
         */
        private calculateColumnSize(rect);
        /**
         * To render the axis element.
         * @return {void}
         * @private
         */
        renderAxes(): Element;
        private findAxisPosition(axis);
        private drawBottomLine(definition, index, isRow);
        private drawAxisLine(axis, index, plotX, plotY, parent, rect);
        private drawYAxisGridLine(axis, index, parent, rect);
        private isBorder(axis, index, value);
        /**
         * To render the axis label.
         * @return {void}
         * @private
         */
        drawYAxisLabels(axis: Axis, index: number, parent: Element, rect: Rect): void;
        /**
         * To render the axis label border.
         * @return {void}
         * @private
         */
        private drawYAxisBorder(axis, index, parent, rect);
        private drawYAxisTitle(axis, index, parent, rect);
        private drawXAxisGridLine(axis, index, parent, rect);
        private drawAxisMinorLine(axis, tempInterval, minorGird, minorTick, rect, labelIndex);
        private findLogNumeric(axis, logPosition, logInterval, value, labelIndex);
        /**
         * To render the axis label.
         * @return {void}
         * @private
         */
        drawXAxisLabels(axis: Axis, index: number, parent: Element, rect: Rect): void;
        /**
         * To render the axis label border.
         * @return {void}
         * @private
         */
        private drawXAxisBorder(axis, index, parent, axisRect);
        /**
         * To create border element for axis.
         * @return {void}
         * @private
         */
        private createAxisBorderElement(axis, index, labelBorder, parent);
        private findAxisLabel(axis, label, width);
        private drawXAxisTitle(axis, index, parent, rect);
        private renderTickLine(axis, index, majorTick, minorTick, parent);
        private renderGridLine(axis, index, majorGrid, minorGird);
        private findParentNode(chart, label, axis, index);
        private createZoomingLabel(chart, labelElement, axis, index, rect);
    }
    
    /**
     * `Category` module is used to render category axis.
     */
    export class Category extends NiceInterval {
        /**
         * Constructor for the category module.
         * @private
         */
        constructor(chart: Chart);
        /**
         * The function to calculate the range and labels for the axis.
         * @return {void}
         */
        calculateRangeAndInterval(size: Size, axis: Axis): void;
        /**
         * Actual Range for the axis.
         * @private
         */
        protected getActualRange(axis: Axis, size: Size): void;
        /**
         * Padding for the axis.
         * @private
         */
        protected applyRangePadding(axis: Axis, size: Size): void;
        /**
         * Calculate label for the axis.
         * @private
         */
        protected calculateVisibleLabels(axis: Axis): void;
        /**
         * Get module name
         */
        protected getModuleName(): string;
        /**
         * To destroy the category axis.
         * @return {void}
         * @private
         */
        destroy(chart: Chart): void;
    }
    
    /**
     * `DateTime` module is used to render datetime axis.
     */
    export class DateTime extends NiceInterval {
        private start;
        private end;
        /**
         * Constructor for the dateTime module.
         * @private
         */
        constructor(chart: Chart);
        /**
         * The function to calculate the range and labels for the axis.
         * @return {void}
         */
        calculateRangeAndInterval(size: Size, axis: Axis): void;
        /**
         * Actual Range for the axis.
         * @private
         */
        protected getActualRange(axis: Axis, size: Size): void;
        /**
         * Apply padding for the range.
         * @private
         */
        protected applyRangePadding(axis: Axis, size: Size): void;
        private getYear(minimum, maximum, rangePadding, interval);
        private getMonth(minimum, maximum, rangePadding, interval);
        private getDay(minimum, maximum, rangePadding, interval);
        private getHour(minimum, maximum, rangePadding, interval);
        /**
         * Calculate visible range for axis.
         * @private
         */
        protected calculateVisibleRange(size: Size, axis: Axis): void;
        /**
         * Calculate visible labels for the axis.
         * @private
         */
        protected calculateVisibleLabels(axis: Axis): void;
        /** @private */
        increaseDateTimeInterval(axis: Axis, value: number, interval: number): Date;
        private alignRangeStart(axis, sDate, intervalSize, intervalType);
        /**
         * Get module name
         */
        protected getModuleName(): string;
        /**
         * To destroy the category axis.
         * @return {void}
         * @private
         */
        destroy(chart: Chart): void;
    }
    
    /**
     * Category module is used to render category axis.
     */
    export class DateTimeCategory extends Category {
        private axisSize;
        /**
         * Constructor for the category module.
         * @private
         */
        constructor(chart: Chart);
        /**
         * The function to calculate the range and labels for the axis.
         * @return {void}
         * @private
         */
        calculateRangeAndInterval(size: Size, axis: Axis): void;
        /**
         * Calculate label for the axis.
         * @private
         */
        protected calculateVisibleLabels(axis: Axis): void;
        /**
         * get same interval
         */
        private sameInterval(currentDate, previousDate, type, index);
        /**
         * Get module name
         */
        protected getModuleName(): string;
        /**
         * To destroy the category axis.
         * @return {void}
         * @private
         */
        destroy(chart: Chart): void;
    }
    
    /**
     * Numeric module is used to render numeric axis.
     */
    export class Double {
        /** @private */
        chart: Chart;
        /** @private */
        min: Object;
        /** @private */
        max: Object;
        private paddingInterval;
        /**
         * Constructor for the dateTime module.
         * @private
         */
        constructor(chart: Chart);
        /**
         * Numeric Nice Interval for the axis.
         * @private
         */
        protected calculateNumericNiceInterval(axis: Axis, delta: number, size: Size): number;
        /**
         * Actual Range for the axis.
         * @private
         */
        protected getActualRange(axis: Axis, size: Size): void;
        /**
         * Range for the axis.
         * @private
         */
        protected initializeDoubleRange(axis: Axis): void;
        /**
         * The function to calculate the range and labels for the axis.
         * @return {void}
         * @private
         */
        calculateRangeAndInterval(size: Size, axis: Axis): void;
        /**
         * Calculate Range for the axis.
         * @private
         */
        protected calculateRange(axis: Axis, size: Size): void;
        private findMinMax(min, max);
        /**
         * Apply padding for the range.
         * @private
         */
        protected applyRangePadding(axis: Axis, size: Size): void;
        private updateActualRange(axis, minimum, maximum, interval);
        private findAdditional(axis, start, end, interval);
        private findNormal(axis, start, end, interval, size);
        /**
         * Calculate visible range for axis.
         * @private
         */
        protected calculateVisibleRange(size: Size, axis: Axis): void;
        /**
         * Calculate label for the axis.
         * @private
         */
        protected calculateVisibleLabels(axis: Axis, chart: Chart): void;
        /**
         * Format of the axis label.
         * @private
         */
        protected getFormat(axis: Axis): string;
        /**
         * Formatted the axis label.
         * @private
         */
        protected formatValue(axis: Axis, isCustom: boolean, format: string, tempInterval: number): string;
    }
    
    /**
     * `Logarithmic` module is used to render log axis.
     */
    export class Logarithmic extends Double {
        /**
         * Constructor for the logerithmic module.
         * @private
         */
        constructor(chart: Chart);
        /**
         * The method to calculate the range and labels for the axis.
         * @return {void}
         */
        calculateRangeAndInterval(size: Size, axis: Axis): void;
        /**
         * Calculates actual range for the axis.
         * @private
         */
        protected getActualRange(axis: Axis, size: Size): void;
        /**
         * Calculates visible range for the axis.
         * @private
         */
        protected calculateVisibleRange(size: Size, axis: Axis): void;
        /**
         * Calculates log iInteval for the axis.
         * @private
         */
        protected calculateLogNiceInterval(delta: number, size: Size, axis: Axis): number;
        /**
         * Calculates labels for the axis.
         * @private
         */
        protected calculateVisibleLabels(axis: Axis, chart: Chart): void;
        /**
         * Get module name
         */
        protected getModuleName(): string;
        /**
         * To destroy the category axis.
         * @return {void}
         * @private
         */
        destroy(chart: Chart): void;
    }
    
    /**
     * MultiLevel Labels src
     */
    
    /**
     * `MultiLevelLabel` module is used to render the multi level label in chart.
     */
    export class MultiLevelLabel {
        /** @private */
        chart: Chart;
        /** @private */
        xAxisPrevHeight: number[];
        /** @private */
        xAxisMultiLabelHeight: number[];
        /** @private */
        yAxisPrevHeight: number[];
        /** @private */
        yAxisMultiLabelHeight: number[];
        /** @private */
        multiElements: Element;
        /**
         * Constructor for the logerithmic module.
         * @private
         */
        constructor(chart: Chart);
        /**
         * Finds multilevel label height
         * @return {void}
         */
        getMultilevelLabelsHeight(axis: Axis): void;
        /**
         * render x axis multi level labels
         * @private
         * @return {void}
         */
        renderXAxisMultiLevelLabels(axis: Axis, index: number, parent: Element, axisRect: Rect): void;
        /**
         * render x axis multi level labels border
         * @private
         * @return {void}
         */
        private renderXAxisLabelBorder(labelIndex, gap, axis, startX, startY, labelSize, textOptions, axisRect, alignment, path, isOutside, opposedPosition);
        /**
         * render y axis multi level labels
         * @private
         * @return {void}
         */
        renderYAxisMultiLevelLabels(axis: Axis, index: number, parent: Element, rect: Rect): void;
        /**
         * render y axis multi level labels border
         * @private
         * @return {void}
         */
        private renderYAxisLabelBorder(labelIndex, gap, axis, endY, startX, startY, labelSize, textOptions, rect, alignment, path, isOutside, opposedPosition);
        /**
         * create cliprect
         * @return {void}
         * @private
         */
        createClipRect(x: number, y: number, height: number, width: number, clipId: string, axisId: string): void;
        /**
         * create borer element
         * @return {void}
         * @private
         */
        createBorderElement(borderIndex: number, axisIndex: number, axis: Axis, path: string): void;
        /**
         * Triggers the event.
         * @return {void}
         * @private
         */
        triggerMultiLabelRender(axis: Axis, text: string, textStyle: FontModel, textAlignment: Alignment): IAxisMultiLabelRenderEventArgs;
        /**
         * To get the module name for `MultiLevelLabel`.
         * @private
         */
        getModuleName(): string;
        /**
         * To destroy the `MultiLevelLabel` module.
         * @private
         */
        destroy(): void;
    }
    
    export class PolarRadarPanel extends LineBase {
        private initialClipRect;
        private htmlObject;
        private element;
        private centerX;
        private centerY;
        private startAngle;
        /** @private */
        seriesClipRect: Rect;
        /**
         * Measure the polar radar axis size.
         * @return {void}
         * @private
         */
        measureAxis(rect: Rect): void;
        private measureRowAxis(chart, rect);
        private measureColumnAxis(chart, rect);
        /**
         * Measure the column and row in chart.
         * @return {void}
         * @private
         */
        measureDefinition(definition: Row | Column, chart: Chart, size: Size, clipRect: Rect): void;
        /**
         * Measure the axis.
         * @return {void}
         * @private
         */
        private calculateAxisSize();
        /**
         * Measure the axis.
         * @return {void}
         * @private
         */
        measure(): void;
        /**
         * Measure the row size.
         * @return {void}
         */
        private calculateRowSize(rect);
        /**
         * Measure the row size.
         * @return {void}
         */
        private calculateColumnSize(rect);
        /**
         * To render the axis element.
         * @return {void}
         * @private
         */
        renderAxes(): Element;
        private drawYAxisLine(axis, index, plotX, plotY);
        drawYAxisLabels(axis: Axis, index: number): void;
        private drawYAxisGridLine(axis, index);
        private drawXAxisGridLine(axis, index);
        private drawAxisMinorLine(axis, tempInterval, minorGird, minorTick);
        /**
         * To render the axis label.
         * @return {void}
         * @private
         */
        drawXAxisLabels(axis: Axis, index: number): void;
        private renderTickLine(axis, index, majorTickLine, minorTickLine?);
        private renderGridLine(axis, index, majorGrid, minorGird);
    }
    
    /**
     * `StripLine` module is used to render the stripLine in chart.
     */
    export class StripLine {
        private measureStripLine(axis, stripline, seriesClipRect);
        /**
         * To get from to value from start, end, size, start from axis
         */
        private getFromTovalue(start, end, size, startFromAxis, axis);
        private getToValue(to, from, size, axis, end);
        private findValue(value, axis);
        /**
         * To render striplines based start and end.
         * @private
         * @param chart
         * @param position
         * @param axes
         */
        renderStripLine(chart: Chart, position: ZIndex, axes: Axis[]): void;
        private renderRectangle(stripline, rect, id, parent, chart);
        private renderText(stripline, rect, id, parent, chart, axis);
        private invertAlignment(anchor);
        private factor(anchor);
        private getTextStart(xy, size, textAlignment);
        /**
         * To get the module name for `StripLine`.
         * @private
         */
        getModuleName(): string;
        /**
         * To destroy the `StripLine` module.
         * @private
         */
        destroy(): void;
    }
    
    /**
     * `Legend` module is used to render legend for the chart.
     */
    export class Legend extends BaseLegend {
        constructor(chart: Chart);
        /**
         * Binding events for legend module.
         */
        private addEventListener();
        /**
         * UnBinding events for legend module.
         */
        private removeEventListener();
        /**
         * To handle mosue move for legend module
         */
        private mouseMove(e);
        /**
         * To handle mosue end for legend module
         */
        private mouseEnd(e);
        /**
         * Get the legend options.
         * @return {void}
         * @private
         */
        getLegendOptions(visibleSeriesCollection: Series[], chart: Chart): void;
        /** @private */
        getLegendBounds(availableSize: Size, legendBounds: Rect, legend: LegendSettingsModel): void;
        /** @private */
        getRenderPoint(legendOption: LegendOptions, start: ChartLocation, textPadding: number, prevLegend: LegendOptions, rect: Rect, count: number, firstLegend: number): void;
        /** @private */
        LegendClick(seriesIndex: number): void;
        private refreshSeries(seriesCollection);
        /**
         * To show the tooltip for the trimmed text in legend.
         * @return {void}
         */
        click(event: Event): void;
        /**
         * Get module name
         */
        protected getModuleName(): string;
        /**
         * To destroy the Legend.
         * @return {void}
         * @private
         */
        destroy(chart: Chart): void;
    }
    
    /**
     * Interface for a class ChartAnnotationSettings
     */
    export interface ChartAnnotationSettingsModel {
    
        /**
         * if set coordinateUnit as `Pixel` X specifies the axis value
         * else is specifies pixel or percentage of coordinate
         * @default 0
         */
        x?: string | Date | number;
    
        /**
         * if set coordinateUnit as `Pixel` Y specifies the axis value
         * else is specifies pixel or percentage of coordinate
         * @default 0
         */
        y?: string | number;
    
        /**
         * Content of the annotation, which accepts the id of the custom element.
         * @default null
         */
        content?: string;
    
        /**
         * Specifies the alignment of the annotation. They are
         * * Near - Align the annotation element as left side.
         * * Far - Align the annotation element as right side.
         * * Center - Align the annotation element as mid point.
         * @default 'Center'
         */
    
        horizontalAlignment?: Alignment;
    
        /**
         * Specifies the coordinate units of the annotation. They are
         * * Pixel - Annotation renders based on x and y pixel value.
         * * Point - Annotation renders based on x and y axis value.
         * @default 'Pixel'
         */
    
        coordinateUnits?: Units;
    
        /**
         * Specifies the regions of the annotation. They are
         * * Chart - Annotation renders based on chart coordinates.
         * * Series - Annotation renders based on series coordinates.
         * @default 'Chart'
         */
    
        region?: Regions;
    
        /**
         * Specifies the position of the annotation. They are
         * * Top - Align the annotation element as top side.
         * * Bottom - Align the annotation element as bottom side.
         * * Middle - Align the annotation element as mid point.
         * @default 'Middle'
         */
    
        verticalAlignment?: Position;
    
        /**
         * The name of horizontal axis associated with the annotation.
         * It requires `axes` of chart.
         * @default null
         */
    
        xAxisName?: string;
    
        /**
         * The name of vertical axis associated with the annotation.
         * It requires `axes` of chart.
         * @default null
         */
    
        yAxisName?: string;
    
        /**
         * Information about annotation for assistive technology.
         * @default null
         */
        description?: string;
    
    }
    
    /**
     * Interface for a class LabelBorder
     */
    export interface LabelBorderModel {
    
        /**
         * The color of the border that accepts value in hex and rgba as a valid CSS color string.
         * @default ''
         */
        color?: string;
    
        /**
         * The width of the border in pixels.
         * @default 1
         */
        width?: number;
    
        /**
         * Border type for labels
         * * Rectangle 
         * * Without Top Border
         * * Without Top and BottomBorder
         * * Without Border
         * * Brace
         * * CurlyBrace
         * @default 'Rectangle'
         */
        type?: BorderType;
    
    }
    
    /**
     * Interface for a class MultiLevelCategories
     */
    export interface MultiLevelCategoriesModel {
    
        /**
         * Start value of the multi level labels
         * @default null
         */
        start?: number | Date | string;
    
        /**
         * End value of the multi level labels
         * @default null
         */
        end?: number | Date | string;
    
        /**
         * multi level labels text.
         * @default ''
         */
        text?: string;
    
        /**
         * Maximum width of the text for multi level labels.
         * @default null
         */
        maximumTextWidth?: number;
    
    }
    
    /**
     * Interface for a class StripLineSettings
     */
    export interface StripLineSettingsModel {
    
        /**
         * If set true, strip line for axis renders.
         * @default true
         */
        visible?: boolean;
    
        /**
         *  If set true, strip line get render from axis origin.
         *  @default false
         */
        startFromAxis?: boolean;
    
        /**
         * Start value of the strip line.
         * @default null
         */
        start?: number | Date | string;
    
        /**
         * End value of the strip line.
         * @default null
         */
        end?: number | Date | string;
    
        /**
         * Size of the strip line, when it starts from the origin.
         * @default null
         */
        size?: number;
    
        /**
         * Color of the strip line.
         * @default '#808080'
         */
        color?: string;
    
        /**
         * Border of the strip line.
         */
        border?: BorderModel;
    
        /**
         * Strip line text.
         * @default ''
         */
        text?: string;
    
        /**
         * The angle to which the strip line text gets rotated.
         * @default null
         */
        rotation?: number;
    
        /**
         * Defines the position of the strip line text horizontally. They are, 
         * * Start: Places the strip line text at the start.
         * * Middle: Places the strip line text in the middle.
         * * End: Places the strip line text at the end.
         * @default 'Middle'
         */
        horizontalAlignment?: Anchor;
    
        /**
         * Defines the position of the strip line text vertically. They are, 
         * * Start: Places the strip line text at the start.
         * * Middle: Places the strip line text in the middle.
         * * End: Places the strip line text at the end.
         * @default 'Middle'
         */
        verticalAlignment?: Anchor;
    
        /**
         * Options to customize the strip line text.
         */
        textStyle?: FontModel;
    
        /**
         * Specifies the order of the strip line. They are,
         * * Behind: Places the strip line behind the series elements.
         * * Over: Places the strip line over the series elements.
         * @default 'Behind'
         */
        zIndex?: ZIndex;
    
        /**
         * Strip line Opacity
         * @default 1
         */
        opacity?: number;
    
    }
    
    /**
     * Interface for a class MultiLevelLabels
     */
    export interface MultiLevelLabelsModel {
    
        /**
         * Defines the position of the multi level labels. They are, 
         * * Near: Places the multi level labels at Near.
         * * Center: Places the multi level labels at Center.
         * * Far: Places the multi level labels at Far.
         * @default 'Center'
         */
        alignment?: Alignment;
    
        /**
         * Defines the textOverFlow for multi level labels. They are, 
         * * Trim: Trim textOverflow for multi level labels.
         * * Wrap: Wrap textOverflow for multi level labels.
         * * none: None textOverflow for multi level labels.
         * @default 'Wrap'
         */
        overflow?: TextOverflow;
    
        /**
         * Options to customize the multi level labels.
         */
        textStyle?: FontModel;
    
        /**
         * Border of the multi level labels.
         */
        border?: LabelBorderModel;
    
        /**
         * multi level categories for multi level labels.
         */
        categories?: MultiLevelCategoriesModel[];
    
    }
    
    /**
     * Configures the Annotation for chart.
     */
    export class ChartAnnotationSettings extends ej.base.ChildProperty<ChartAnnotationSettings> {
        /**
         * if set coordinateUnit as `Pixel` X specifies the axis value
         * else is specifies pixel or percentage of coordinate
         * @default 0
         */
        x: string | Date | number;
        /**
         * if set coordinateUnit as `Pixel` Y specifies the axis value
         * else is specifies pixel or percentage of coordinate
         * @default 0
         */
        y: string | number;
        /**
         * Content of the annotation, which accepts the id of the custom element.
         * @default null
         */
        content: string;
        /**
         * Specifies the alignment of the annotation. They are
         * * Near - Align the annotation element as left side.
         * * Far - Align the annotation element as right side.
         * * Center - Align the annotation element as mid point.
         * @default 'Center'
         */
        horizontalAlignment: Alignment;
        /**
         * Specifies the coordinate units of the annotation. They are
         * * Pixel - Annotation renders based on x and y pixel value.
         * * Point - Annotation renders based on x and y axis value.
         * @default 'Pixel'
         */
        coordinateUnits: Units;
        /**
         * Specifies the regions of the annotation. They are
         * * Chart - Annotation renders based on chart coordinates.
         * * Series - Annotation renders based on series coordinates.
         * @default 'Chart'
         */
        region: Regions;
        /**
         * Specifies the position of the annotation. They are
         * * Top - Align the annotation element as top side.
         * * Bottom - Align the annotation element as bottom side.
         * * Middle - Align the annotation element as mid point.
         * @default 'Middle'
         */
        verticalAlignment: Position;
        /**
         * The name of horizontal axis associated with the annotation.
         * It requires `axes` of chart.
         * @default null
         */
        xAxisName: string;
        /**
         * The name of vertical axis associated with the annotation.
         * It requires `axes` of chart.
         * @default null
         */
        yAxisName: string;
        /**
         * Information about annotation for assistive technology.
         * @default null
         */
        description: string;
    }
    /**
     * label border properties.
     */
    export class LabelBorder extends ej.base.ChildProperty<LabelBorder> {
        /**
         * The color of the border that accepts value in hex and rgba as a valid CSS color string.
         * @default ''
         */
        color: string;
        /**
         * The width of the border in pixels.
         * @default 1
         */
        width: number;
        /**
         * Border type for labels
         * * Rectangle
         * * Without Top Border
         * * Without Top and BottomBorder
         * * Without Border
         * * Brace
         * * CurlyBrace
         * @default 'Rectangle'
         */
        type: BorderType;
    }
    /**
     * categories for multi level labels
     */
    export class MultiLevelCategories extends ej.base.ChildProperty<MultiLevelCategories> {
        /**
         * Start value of the multi level labels
         * @default null
         */
        start: number | Date | string;
        /**
         * End value of the multi level labels
         * @default null
         */
        end: number | Date | string;
        /**
         * multi level labels text.
         * @default ''
         */
        text: string;
        /**
         * Maximum width of the text for multi level labels.
         * @default null
         */
        maximumTextWidth: number;
    }
    /**
     * Strip line properties
     */
    export class StripLineSettings extends ej.base.ChildProperty<StripLineSettings> {
        /**
         * If set true, strip line for axis renders.
         * @default true
         */
        visible: boolean;
        /**
         *  If set true, strip line get render from axis origin.
         *  @default false
         */
        startFromAxis: boolean;
        /**
         * Start value of the strip line.
         * @default null
         */
        start: number | Date | string;
        /**
         * End value of the strip line.
         * @default null
         */
        end: number | Date | string;
        /**
         * Size of the strip line, when it starts from the origin.
         * @default null
         */
        size: number;
        /**
         * Color of the strip line.
         * @default '#808080'
         */
        color: string;
        /**
         * Border of the strip line.
         */
        border: BorderModel;
        /**
         * Strip line text.
         * @default ''
         */
        text: string;
        /**
         * The angle to which the strip line text gets rotated.
         * @default null
         */
        rotation: number;
        /**
         * Defines the position of the strip line text horizontally. They are,
         * * Start: Places the strip line text at the start.
         * * Middle: Places the strip line text in the middle.
         * * End: Places the strip line text at the end.
         * @default 'Middle'
         */
        horizontalAlignment: Anchor;
        /**
         * Defines the position of the strip line text vertically. They are,
         * * Start: Places the strip line text at the start.
         * * Middle: Places the strip line text in the middle.
         * * End: Places the strip line text at the end.
         * @default 'Middle'
         */
        verticalAlignment: Anchor;
        /**
         * Options to customize the strip line text.
         */
        textStyle: FontModel;
        /**
         * Specifies the order of the strip line. They are,
         * * Behind: Places the strip line behind the series elements.
         * * Over: Places the strip line over the series elements.
         * @default 'Behind'
         */
        zIndex: ZIndex;
        /**
         * Strip line Opacity
         * @default 1
         */
        opacity: number;
    }
    /**
     * MultiLevelLabels properties
     */
    export class MultiLevelLabels extends ej.base.ChildProperty<MultiLevelLabels[]> {
        /**
         * Defines the position of the multi level labels. They are,
         * * Near: Places the multi level labels at Near.
         * * Center: Places the multi level labels at Center.
         * * Far: Places the multi level labels at Far.
         * @default 'Center'
         */
        alignment: Alignment;
        /**
         * Defines the textOverFlow for multi level labels. They are,
         * * Trim: Trim textOverflow for multi level labels.
         * * Wrap: Wrap textOverflow for multi level labels.
         * * none: None textOverflow for multi level labels.
         * @default 'Wrap'
         */
        overflow: TextOverflow;
        /**
         * Options to customize the multi level labels.
         */
        textStyle: FontModel;
        /**
         * Border of the multi level labels.
         */
        border: LabelBorderModel;
        /**
         * multi level categories for multi level labels.
         */
        categories: MultiLevelCategoriesModel[];
    }
    
    /**
     * `AreaSeries` module is used to render the area series.
     */
    export class AreaSeries extends MultiColoredSeries {
        /**
         * Render Area series.
         * @return {void}
         * @private
         */
        render(series: Series, xAxis: Axis, yAxis: Axis, isInverted: boolean): void;
        /**
         * To destroy the area series.
         * @return {void}
         * @private
         */
        destroy(chart: Chart): void;
        /**
         * Get module name
         */
        protected getModuleName(): string;
        /**
         * Animates the series.
         * @param  {Series} series - Defines the series to animate.
         * @return {void}
         */
        doAnimation(series: Series): void;
    }
    
    /**
     * `BarSeries` module is used to render the bar series.
     */
    export class BarSeries extends ColumnBase {
        /**
         * Render Bar series.
         * @return {void}
         * @private
         */
        render(series: Series): void;
        /**
         * Animates the series.
         * @param  {Series} series - Defines the series to animate.
         * @return {void}
         */
        doAnimation(series: Series): void;
        /**
         * To destroy the bar series.
         * @return {void}
         * @private
         */
        protected destroy(chart: Chart): void;
        /**
         * Get module name
         */
        protected getModuleName(): string;
    }
    
    /**
     * `BoxAndWhiskerSeries` module is used to render the box and whisker series.
     */
    export class BoxAndWhiskerSeries extends ColumnBase {
        /**
         * Render BoxAndWhisker series.
         * @return {void}
         * @private
         */
        render(series: Series, xAxis: Axis, yAxis: Axis, isInverted: boolean): void;
        /**
         * update the tip region fo box plot
         * @param series
         * @param point
         * @param sideBySideInfo
         */
        private updateTipRegion(series, point, sideBySideInfo);
        /**
         * Update tip size to tip regions
         * @param series
         * @param point
         * @param region
         * @param isInverted
         */
        private updateTipSize(series, point, region, isInverted);
        /**
         * Calculation for path direction performed here
         * @param point
         * @param series
         * @param median
         * @param average
         */
        getPathString(point: Points, series: Series, median: ChartLocation, average: ChartLocation): string;
        /**
         * Rendering for box and whisker append here.
         * @param series
         * @param point
         * @param rect
         * @param argsData
         * @param direction
         */
        renderBoxAndWhisker(series: Series, point: Points, rect: Rect, argsData: IPointRenderEventArgs, direction: string): void;
        /**
         * To find the box plot values
         * @param yValues
         * @param point
         * @param mode
         */
        findBoxPlotValues(yValues: number[], point: Points, mode: BoxPlotMode): void;
        /**
         * to find the exclusive quartile values
         * @param yValues
         * @param count
         * @param percentile
         */
        private getExclusiveQuartileValue(yValues, count, percentile);
        /**
         * to find the inclusive quartile values
         * @param yValues
         * @param count
         * @param percentile
         */
        private getInclusiveQuartileValue(yValues, count, percentile);
        /**
         * To find the quartile values
         * @param yValues
         * @param count
         * @param lowerQuartile
         * @param upperQuartile
         */
        private getQuartileValues(yValues, count, quartile);
        /**
         * To find the min, max and outlier values
         * @param yValues
         * @param lowerQuartile
         * @param upperQuartile
         * @param minimum
         * @param maximum
         * @param outliers
         */
        private getMinMaxOutlier(yValues, count, quartile);
        /**
         * Animates the series.
         * @param  {Series} series - Defines the series to animate.
         * @return {void}
         */
        doAnimation(series: Series): void;
        /**
         * Get module name.
         */
        protected getModuleName(): string;
        /**
         * To destroy the candle series.
         * @return {void}
         * @private
         */
        destroy(chart: Chart): void;
    }
    
    /**
     * `BubbleSeries` module is used to render the bubble series.
     */
    export class BubbleSeries {
        /**
         * Render the Bubble series.
         * @return {void}
         * @private
         */
        render(series: Series, xAxis: Axis, yAxis: Axis, isInverted: boolean): void;
        /**
         * To destroy the Bubble.
         * @return {void}
         * @private
         */
        destroy(chart: Chart): void;
        /**
         * Get module name.
         */
        protected getModuleName(): string;
        /**
         * Animates the series.
         * @param  {Series} series - Defines the series to animate.
         * @return {void}
         */
        doAnimation(series: Series): void;
    }
    
    /**
     * `CandleSeries` module is used to render the candle series.
     */
    export class CandleSeries extends ColumnBase {
        /**
         * Render Candle series.
         * @return {void}
         * @private
         */
        render(series: Series): void;
        /**
         * Trigger point rendering event
         */
        protected triggerPointRenderEvent(series: Series, point: Points): IPointRenderEventArgs;
        /**
         * Find the color of the candle
         * @param series
         * @private
         */
        private getCandleColor(point, series);
        /**
         * Finds the path of the candle shape
         * @param Series
         * @private
         */
        getPathString(topRect: Rect, midRect: Rect, series: Series): string;
        /**
         * Draws the candle shape
         * @param series
         * @private
         */
        drawCandle(series: Series, point: Points, rect: Rect, argsData: IPointRenderEventArgs, direction: string): void;
        /**
         * Animates the series.
         * @param  {Series} series - Defines the series to animate.
         * @return {void}
         */
        doAnimation(series: Series): void;
        /**
         * Get module name.
         */
        protected getModuleName(): string;
        /**
         * To destroy the candle series.
         * @return {void}
         * @private
         */
        destroy(chart: Chart): void;
    }
    
    /**
     * Interface for a class DataLabelSettings
     */
    export interface DataLabelSettingsModel {
    
        /**
         * If set true, data label for series renders.
         * @default false
         */
    
        visible?: boolean;
    
        /**
         * The DataSource field that contains the data label value.
         * @default null
         */
    
        name?: string;
    
        /**
         * The background color of the data label accepts value in hex and rgba as a valid CSS color string.
         * @default 'transparent'
         */
    
        fill?: string;
    
        /**
         * The opacity for the background.
         * @default 1
         */
    
        opacity?: number;
    
        /**
         * Specifies the position of the data label. They are,
         * * Outer: Positions the label outside the point.
         * * top: Positions the label on top of the point.
         * * Bottom: Positions the label at the bottom of the point.
         * * Middle: Positions the label to the middle of the point.
         * * Auto: Positions the label based on series.
         * @default 'Auto'
         */
    
        position?: LabelPosition;
    
        /**
         * The roundedCornerX for the data label. It requires `border` values not to be null.
         * @default 5
         */
        rx?: number;
    
        /**
         * The roundedCornerY for the data label. It requires `border` values not to be null.
         * @default 5
         */
        ry?: number;
    
        /**
         * Specifies the alignment for data Label. They are,
         * * Near: Aligns the label to the left of the point.
         * * Center: Aligns the label to the center of the point.
         * * Far: Aligns the label to the right of the point.
         * @default 'Center'
         */
        alignment?: Alignment;
    
        /**
         * Option for customizing the border lines.
         */
    
        border?: BorderModel;
    
        /**
         * Margin configuration for the data label.
         */
    
        margin?: MarginModel;
    
        /**
         * Option for customizing the data label text.
         */
    
        font?: FontModel;
    
        /**
         * Custom template to show the data label. Use ${point.x} and ${point.y} as a placeholder
         * text to display the corresponding data point.
         * @default null
         */
    
        template?: string;
    
    }
    
    /**
     * Interface for a class MarkerSettings
     */
    export interface MarkerSettingsModel {
    
        /**
         * If set to true the marker for series is rendered. This is applicable only for line and area type series.
         * @default false
         */
    
        visible?: boolean;
    
        /**
         * The different shape of a marker:
         * * Circle
         * * Rectangle
         * * Triangle
         * * Diamond
         * * HorizontalLine
         * * VerticalLine
         * * Pentagon
         * * InvertedTriangle
         * * Image
         * @default 'Circle'
         */
    
        shape?: ChartShape;
    
        /**
         * The URL for the Image that is to be displayed as a marker.  It requires marker `shape` value to be an `Image`.
         * @default ''
         */
    
        imageUrl?: string;
    
        /**
         * The height of the marker in pixels.
         * @default 5
         */
    
        height?: number;
    
        /**
         * The width of the marker in pixels.
         * @default 5
         */
    
        width?: number;
    
        /**
         * Options for customizing the border of a marker.
         */
    
        border?: BorderModel;
    
        /**
         *  The fill color of the marker that accepts value in hex and rgba as a valid CSS color string. By default, it will take series' color.
         * @default null
         */
    
        fill?: string;
    
        /**
         * The opacity of the marker.
         * @default 1
         */
    
        opacity?: number;
    
        /**
         * The data label for the series.
         */
    
        dataLabel?: DataLabelSettingsModel;
    
    }
    
    /**
     * Interface for a class Points
     * @private
     */
    export interface PointsModel {
    
    }
    
    /**
     * Interface for a class Trendline
     */
    export interface TrendlineModel {
    
        /**
         * Defines the name of trendline
         * @default ''
         */
        name?: string;
    
        /**
         * Defines the type of the trendline
         * @default 'Linear'
         */
        type?: TrendlineTypes;
    
        /**
         * Defines the period, the price changes over which will be considered to predict moving average trend line
         * @default 2
         */
        period?: number;
    
        /**
         * Defines the polynomial order of the polynomial trendline
         * @default 2
         */
        polynomialOrder?: number;
    
        /**
         * Defines the period, by which the trend has to backward forecast
         * @default 0
         */
        backwardForecast?: number;
    
        /**
         * Defines the period, by which the trend has to forward forecast
         * @default 0
         */
        forwardForecast?: number;
    
        /**
         * Options to customize the animation for trendlines
         */
        animation?: AnimationModel;
    
        /**
         * Options to customize the marker for trendlines
         */
        marker?: MarkerSettingsModel;
    
        /**
         * Enables/disables tooltip for trendlines
         * @default true
         */
        enableTooltip?: boolean;
    
        /**
         * Defines the intercept of the trendline
         * @default null
         */
        intercept?: number;
    
        /**
         * Defines the fill color of trendline
         * @default ''
         */
        fill?: string;
    
        /**
         * Defines the width of the trendline
         * @default 1
         */
        width?: number;
    
        /**
         * Sets the legend shape of the trendline
         * @default 'SeriesType'
         */
        legendShape?: LegendShape;
    
    }
    
    /**
     * Interface for a class ErrorBarCapSettings
     */
    export interface ErrorBarCapSettingsModel {
    
        /**
         * The width of the error bar in pixels.
         * @default 1
         */
    
        width?: number;
    
        /**
         * The length of the error bar in pixels.
         * @default 10
         */
    
        length?: number;
    
        /**
         *  The stroke color of the cap, which accepts value in hex, rgba as a valid CSS color string.
         * @default null
         */
    
        color?: string;
    
        /**
         * The opacity of the cap.
         * @default 1
         */
    
        opacity?: number;
    
    }
    
    /**
     * Interface for a class ChartSegment
     */
    export interface ChartSegmentModel {
    
        /**
         * Defines the starting point of region.
         * @default null
         */
    
        value?: Object;
    
        /**
         * Defines the color of a region.
         * @default null
         */
    
        color?: string;
    
        /**
         * Defines the pattern of dashes and gaps to stroke.
         * @default '0'
         */
    
        dashArray?: string;
    
    }
    
    /**
     * Interface for a class ErrorBarSettings
     * @private
     */
    export interface ErrorBarSettingsModel {
    
        /**
         * If set true, error bar for data gets rendered.
         * @default false
         */
    
        visible?: boolean;
    
        /**
         * The type of the error bar . They are
         * * Fixed -  Renders a fixed type error bar.
         * * Percentage - Renders a percentage type error bar.
         * * StandardDeviation - Renders a standard deviation type error bar.
         * * StandardError -Renders a standard error type error bar.
         * * Custom -Renders a custom type error bar.
         * @default 'Fixed'
         */
    
        type?: ErrorBarType;
    
        /**
         * The direction of the error bar . They are
         * * both -  Renders both direction of error bar.
         * * minus - Renders minus direction of error bar.
         * * plus - Renders plus direction error bar.
         * @default 'Both'
         */
    
        direction?: ErrorBarDirection;
    
        /**
         * The mode of the error bar . They are
         * * Vertical -  Renders a vertical error bar.
         * * Horizontal - Renders a horizontal error bar.
         * * Both - Renders both side error bar.
         * @default 'Vertical'
         */
    
        mode?: ErrorBarMode;
    
        /**
         *  The color for stroke of the error bar, which accepts value in hex, rgba as a valid CSS color string.
         * @default null
         */
    
        color?: string;
    
        /**
         * The vertical error of the error bar.
         * @default 1
         */
    
        verticalError?: number;
    
        /**
         * The stroke width of the error bar..
         * @default 1
         */
    
        width?: number;
    
        /**
         * The horizontal error of the error bar.
         * @default 1
         */
    
        horizontalError?: number;
    
        /**
         * The vertical positive error of the error bar.
         * @default 3
         */
    
        verticalPositiveError?: number;
    
        /**
         * The vertical negative error of the error bar.
         * @default 3
         */
    
        verticalNegativeError?: number;
    
        /**
         * The horizontal positive error of the error bar.
         * @default 1
         */
    
        horizontalPositiveError?: number;
    
        /**
         * The horizontal negative error of the error bar.
         * @default 1
         */
    
        horizontalNegativeError?: number;
    
        /**
         * Options for customizing the cap of the error bar.
         */
        errorBarCap?: ErrorBarCapSettingsModel;
    
    }
    
    /**
     * Interface for a class SeriesBase
     */
    export interface SeriesBaseModel {
    
        /**
         * The DataSource field that contains the x value.
         * It is applicable for series and technical indicators
         * @default ''
         */
    
        xName?: string;
    
        /**
         * The DataSource field that contains the high value of y
         * It is applicable for series and technical indicators
         * @default ''
         */
    
        high?: string;
    
        /**
         * The DataSource field that contains the low value of y
         * It is applicable for series and technical indicators
         * @default ''
         */
    
        low?: string;
    
        /**
         * The DataSource field that contains the open value of y
         * It is applicable for series and technical indicators
         * @default ''
         */
    
        open?: string;
    
        /**
         * The DataSource field that contains the close value of y
         * It is applicable for series and technical indicators
         * @default ''
         */
    
        close?: string;
    
        /**
         * Defines the data source field that contains the volume value in candle charts
         * It is applicable for financial series and technical indicators
         * @default ''
         */
    
        volume?: string;
    
        /**
         * The DataSource field that contains the color value of point
         * It is applicable for series
         * @default ''
         */
    
        pointColorMapping?: string;
    
        /**
         * The name of the horizontal axis associated with the series. It requires `axes` of the chart.
         * It is applicable for series and technical indicators
         * ```html
         * <div id='Chart'></div>
         * ```
         * ```typescript
         * let chart: Chart = new Chart({
         * ...
         *     columns: [{ width: '50%' },
         *               { width: '50%' }],
         *     axes: [{
         *                name: 'xAxis 1',
         *                columnIndex: 1,
         *            }],
         *     series: [{
         *                dataSource: data,
         *                xName: 'x', yName: 'y',
         *                xAxisName: 'xAxis 1',
         *     }],
         * });
         * chart.appendTo('#Chart');
         * ```
         * @default null
         */
    
        xAxisName?: string;
    
        /**
         * The name of the vertical axis associated with the series. It requires `axes` of the chart.
         * It is applicable for series and technical indicators
         * ```html
         * <div id='Chart'></div>
         * ```
         * ```typescript
         * let chart: Chart = new Chart({
         * ...
         *     rows: [{ height: '50%' },
         *            { height: '50%' }],
         *     axes: [{
         *                name: 'yAxis 1',
         *                rowIndex: 1,
         *            }],
         *     series: [{
         *                dataSource: data,
         *                xName: 'x', yName: 'y',
         *                yAxisName: 'yAxis 1'
         *     }],
         * });
         * chart.appendTo('#Chart');
         * ```
         * @default null
         */
    
        yAxisName?: string;
    
        /**
         * Options to customizing animation for the series.
         */
    
        animation?: AnimationModel;
    
        /**
         * The fill color for the series that accepts value in hex and rgba as a valid CSS color string.
         * It also represents the color of the signal lines in technical indicators.
         * For technical indicators, the default value is 'blue' and for series, it has null.
         * @default null
         */
    
        fill?: string;
    
        /**
         * The stroke width for the series that is applicable only for `Line` type series.
         * It also represents the stroke width of the signal lines in technical indicators.
         * @default 1
         */
    
        width?: number;
    
        /**
         * Defines the pattern of dashes and gaps to stroke the lines in `Line` type series.
         * @default '0'
         */
    
        dashArray?: string;
    
        /**
         * Specifies the DataSource for the series. It can be an array of JSON objects or an instance of DataManager.
         * ```html
         * <div id='Chart'></div>
         * ```
         * ```typescript
         * let dataManager: ej.data.DataManager = new DataManager({
         *         url: 'http://mvc.syncfusion.com/Services/Northwnd.svc/Tasks/'
         * });
         * let query: ej.data.Query = new Query().take(50).where('Estimate', 'greaterThan', 0, false);
         * let chart: Chart = new Chart({
         * ...
         *     series: [{
         *        dataSource: dataManager,
         *        xName: 'Id',
         *        yName: 'Estimate',
         *        query: query
         *    }],
         * ...
         * });
         * chart.appendTo('#Chart');
         * ```
         * @default ''
         */
    
        dataSource?: Object | ej.data.DataManager;
    
        /**
         * Specifies query to select data from DataSource. This property is applicable only when the DataSource is `ej.DataManager`.
         * @default null
         */
        query?: ej.data.Query;
    
        /**
         * Defines the collection of regions that helps to differentiate a line series.
         */
        segments?: ChartSegmentModel[];
    
        /**
         * Defines the axis, based on which the line series will be split.
         */
        segmentAxis?: Segment;
    
    }
    
    /**
     * Interface for a class Series
     */
    export interface SeriesModel extends SeriesBaseModel{
    
        /**
         * The name of the series visible in legend.
         * @default ''
         */
    
        name?: string;
    
        /**
         * The DataSource field that contains the y value.
         * @default ''
         */
    
        yName?: string;
    
        /**
         * Type of series to be drawn in radar or polar series. They are
         *  'Line'
         *  'Column'
         *  'Area'
         *  'Scatter'
         *  'Spline'
         *  'StackingColumn'
         *  'StackingArea'
         *  'RangeColumn'
         *  'SplineArea'
         * @default 'Line'
         */
        drawType?: ChartDrawType;
    
        /**
         * Specifies whether to join start and end point of a line/area series used in polar/radar chart to form a closed path.
         * @default true
         */
        isClosed?: boolean;
    
        /**
         * This property is used in financial charts to visualize the price movements in stock.
         * It defines the color of the candle/point, when the opening price is less than the closing price.
         * @default '#2ecd71'
         */
    
        bearFillColor?: string;
    
        /**
         * This property is used in financial charts to visualize the price movements in stock.
         * It defines the color of the candle/point, when the opening price is higher than the closing price.
         * @default '#e74c3d'
         */
    
        bullFillColor?: string;
    
        /**
         * This property is applicable for candle series.
         * It enables/disables to visually compare the current values with the previous values in stock.
         * @default false
         */
        enableSolidCandles?: boolean;
    
        /**
         * The DataSource field that contains the size value of y
         * @default ''
         */
    
        size?: string;
    
        /**
         * This property allows grouping series in `stacked column / bar` charts.
         * Any string value can be provided to the stackingGroup property.
         * If any two or above series have the same value, those series will be grouped together.
         * @default ''
         */
    
        stackingGroup?: string;
    
        /**
         * Specifies the visibility of series.
         * @default true
         */
    
        visible?: boolean;
    
        /**
         * Options to customizing the border of the series. This is applicable only for `Column` and `Bar` type series.
         */
    
        border?: BorderModel;
    
        /**
         * The opacity of the series.
         * @default 1
         */
        opacity?: number;
    
        /**
         * The type of the series are
         * * Line
         * * Column
         * * Area
         * * Bar
         * * StackingColumn
         * * StackingArea
         * * StackingBar
         * * StepLine
         * * StepArea
         * * Scatter
         * * Spline
         * * StackingColumn100
         * * StackingBar100
         * * StackingArea100
         * * RangeColumn
         * * Hilo
         * * HiloOpenClose
         * * Waterfall
         * * RangeArea 
         * * Bubble
         * * Candle 
         * * Polar 
         * * Radar 
         * * BoxAndWhisker
         * @default 'Line'
         */
    
        type?: ChartSeriesType;
    
        /**
         * Options for displaying and customizing error bar for individual point in a series.
         */
        errorBar?: ErrorBarSettingsModel;
    
        /**
         * Options for displaying and customizing markers for individual points in a series.
         */
        marker?: MarkerSettingsModel;
    
        /**
         * Defines the collection of trendlines that are used to predict the trend
         */
        trendlines?: TrendlineModel[];
    
        /**
         * If set true, the Tooltip for series will be visible.
         * @default true
         */
        enableTooltip?: boolean;
    
        /**
         * The shape of the legend. Each series has its own legend shape. They are,
         * * Circle
         * * Rectangle
         * * Triangle
         * * Diamond
         * * Cross
         * * HorizontalLine
         * * VerticalLine
         * * Pentagon
         * * InvertedTriangle
         * * SeriesType
         * @default 'SeriesType'
         */
    
        legendShape?: LegendShape;
    
        /**
         * Custom style for the selected series or points.
         * @default null
         */
        selectionStyle?: string;
    
        /**
         * Minimum radius
         * @default 1
         */
        minRadius?: number;
    
        /**
         * Maximum radius
         * @default 3
         */
        maxRadius?: number;
    
        /**
         * Defines type of spline to be rendered.
         * @default 'Natural'
         */
        splineType?: SplineType;
    
        /**
         * It defines tension of cardinal spline types
         * @default 0.5
         */
        cardinalSplineTension?: number;
    
        /**
         * options to customize the empty points in series
         */
        emptyPointSettings?: EmptyPointSettingsModel;
    
        /**
         * If set true, the mean value for box and whisker will be visible.
         * @default true
         */
        showMean?: boolean;
    
        /**
         * The mode of the box and whisker char series. They are,
         * Exclusive
         * Inclusive
         * Normal
         * @default 'Normal'
         */
        boxPlotMode?: BoxPlotMode;
    
        /**
         * To render the column series points with particular column width.
         * @default 0.7
         */
        columnWidth?: number;
    
        /**
         * To render the column series points with particular column spacing. It takes value from 0 - 1.
         * @default 0
         */
        columnSpacing?: number;
    
        /**
         * Defines the visual representation of the negative changes in waterfall charts.
         * @default '#C64E4A'
         */
        negativeFillColor?: string;
    
        /**
         * Defines the visual representation of the summaries in waterfall charts.
         * @default '#4E81BC'
         */
        summaryFillColor?: string;
    
        /**
         * Defines the collection of indexes of the intermediate summary columns in waterfall charts.
         * @default []
         */
        intermediateSumIndexes?: number[];
    
        /**
         * Defines the collection of indexes of the overall summary columns in waterfall charts.
         * @default []
         */
        sumIndexes?: number[];
    
        /**
         * Defines the appearance of line connecting adjacent points in waterfall charts.
         */
    
        connector?: ConnectorModel;
    
        /**
         * To render the column series points with particular rounded corner.
         */
        cornerRadius?: CornerRadiusModel;
    
    }
    
    /**
     * Configures the data label in the series.
     */
    export class DataLabelSettings extends ej.base.ChildProperty<DataLabelSettings> {
        /**
         * If set true, data label for series renders.
         * @default false
         */
        visible: boolean;
        /**
         * The DataSource field that contains the data label value.
         * @default null
         */
        name: string;
        /**
         * The background color of the data label accepts value in hex and rgba as a valid CSS color string.
         * @default 'transparent'
         */
        fill: string;
        /**
         * The opacity for the background.
         * @default 1
         */
        opacity: number;
        /**
         * Specifies the position of the data label. They are,
         * * Outer: Positions the label outside the point.
         * * top: Positions the label on top of the point.
         * * Bottom: Positions the label at the bottom of the point.
         * * Middle: Positions the label to the middle of the point.
         * * Auto: Positions the label based on series.
         * @default 'Auto'
         */
        position: LabelPosition;
        /**
         * The roundedCornerX for the data label. It requires `border` values not to be null.
         * @default 5
         */
        rx: number;
        /**
         * The roundedCornerY for the data label. It requires `border` values not to be null.
         * @default 5
         */
        ry: number;
        /**
         * Specifies the alignment for data Label. They are,
         * * Near: Aligns the label to the left of the point.
         * * Center: Aligns the label to the center of the point.
         * * Far: Aligns the label to the right of the point.
         * @default 'Center'
         */
        alignment: Alignment;
        /**
         * Option for customizing the border lines.
         */
        border: BorderModel;
        /**
         * Margin configuration for the data label.
         */
        margin: MarginModel;
        /**
         * Option for customizing the data label text.
         */
        font: FontModel;
        /**
         * Custom template to show the data label. Use ${point.x} and ${point.y} as a placeholder
         * text to display the corresponding data point.
         * @default null
         */
        template: string;
    }
    /**
     *  Configures the marker in the series.
     */
    export class MarkerSettings extends ej.base.ChildProperty<MarkerSettings> {
        /**
         * If set to true the marker for series is rendered. This is applicable only for line and area type series.
         * @default false
         */
        visible: boolean;
        /**
         * The different shape of a marker:
         * * Circle
         * * Rectangle
         * * Triangle
         * * Diamond
         * * HorizontalLine
         * * VerticalLine
         * * Pentagon
         * * InvertedTriangle
         * * Image
         * @default 'Circle'
         */
        shape: ChartShape;
        /**
         * The URL for the Image that is to be displayed as a marker.  It requires marker `shape` value to be an `Image`.
         * @default ''
         */
        imageUrl: string;
        /**
         * The height of the marker in pixels.
         * @default 5
         */
        height: number;
        /**
         * The width of the marker in pixels.
         * @default 5
         */
        width: number;
        /**
         * Options for customizing the border of a marker.
         */
        border: BorderModel;
        /**
         *  The fill color of the marker that accepts value in hex and rgba as a valid CSS color string. By default, it will take series' color.
         * @default null
         */
        fill: string;
        /**
         * The opacity of the marker.
         * @default 1
         */
        opacity: number;
        /**
         * The data label for the series.
         */
        dataLabel: DataLabelSettingsModel;
    }
    /**
     * Points model for the series.
     * @private
     */
    export class Points {
        x: Object;
        y: Object;
        visible: boolean;
        text: string;
        color: string;
        open: Object;
        close: Object;
        symbolLocations: ChartLocation[];
        xValue: number;
        yValue: number;
        index: number;
        regions: Rect[];
        percent: string;
        high: Object;
        low: Object;
        volume: Object;
        size: Object;
        isEmpty: boolean;
        regionData: PolarArc;
        minimum: number;
        maximum: number;
        upperQuartile: number;
        lowerQuartile: number;
        median: number;
        outliers: number[];
        average: number;
        error: number;
        interior: string;
        marker: MarkerSettingsModel;
    }
    /**
     * Defines the behavior of the Trendlines
     */
    export class Trendline extends ej.base.ChildProperty<Trendline> {
        /**
         * Defines the name of trendline
         * @default ''
         */
        name: string;
        /**
         * Defines the type of the trendline
         * @default 'Linear'
         */
        type: TrendlineTypes;
        /**
         * Defines the period, the price changes over which will be considered to predict moving average trend line
         * @default 2
         */
        period: number;
        /**
         * Defines the polynomial order of the polynomial trendline
         * @default 2
         */
        polynomialOrder: number;
        /**
         * Defines the period, by which the trend has to backward forecast
         * @default 0
         */
        backwardForecast: number;
        /**
         * Defines the period, by which the trend has to forward forecast
         * @default 0
         */
        forwardForecast: number;
        /**
         * Options to customize the animation for trendlines
         */
        animation: AnimationModel;
        /**
         * Options to customize the marker for trendlines
         */
        marker: MarkerSettingsModel;
        /**
         * Enables/disables tooltip for trendlines
         * @default true
         */
        enableTooltip: boolean;
        /**
         * Defines the intercept of the trendline
         * @default null
         */
        intercept: number;
        /**
         * Defines the fill color of trendline
         * @default ''
         */
        fill: string;
        /**
         * Defines the width of the trendline
         * @default 1
         */
        width: number;
        /**
         * Sets the legend shape of the trendline
         * @default 'SeriesType'
         */
        legendShape: LegendShape;
        /** @private */
        targetSeries: Series;
        /** @private */
        trendLineElement: Element;
        /** @private */
        points: Points[];
        /** @private */
        clipRectElement: Element;
        /** @private */
        clipRect: Rect;
        /** @private */
        polynomialSlopes: number[];
        /** @private */
        sourceIndex: number;
        /** @private */
        index: number;
        /** @private */
        setDataSource(series: Series, chart: Chart): void;
    }
    /**
     * Configures Error bar in series.
     */
    export class ErrorBarCapSettings extends ej.base.ChildProperty<ErrorBarCapSettings> {
        /**
         * The width of the error bar in pixels.
         * @default 1
         */
        width: number;
        /**
         * The length of the error bar in pixels.
         * @default 10
         */
        length: number;
        /**
         *  The stroke color of the cap, which accepts value in hex, rgba as a valid CSS color string.
         * @default null
         */
        color: string;
        /**
         * The opacity of the cap.
         * @default 1
         */
        opacity: number;
    }
    export class ChartSegment extends ej.base.ChildProperty<ChartSegment> {
        /**
         * Defines the starting point of region.
         * @default null
         */
        value: Object;
        /**
         * Defines the color of a region.
         * @default null
         */
        color: string;
        /**
         * Defines the pattern of dashes and gaps to stroke.
         * @default '0'
         */
        dashArray: string;
        /** @private */
        startValue: number;
        /** @private */
        endValue: number;
    }
    export class ErrorBarSettings extends ej.base.ChildProperty<ErrorBarSettings> {
        /**
         * If set true, error bar for data gets rendered.
         * @default false
         */
        visible: boolean;
        /**
         * The type of the error bar . They are
         * * Fixed -  Renders a fixed type error bar.
         * * Percentage - Renders a percentage type error bar.
         * * StandardDeviation - Renders a standard deviation type error bar.
         * * StandardError -Renders a standard error type error bar.
         * * Custom -Renders a custom type error bar.
         * @default 'Fixed'
         */
        type: ErrorBarType;
        /**
         * The direction of the error bar . They are
         * * both -  Renders both direction of error bar.
         * * minus - Renders minus direction of error bar.
         * * plus - Renders plus direction error bar.
         * @default 'Both'
         */
        direction: ErrorBarDirection;
        /**
         * The mode of the error bar . They are
         * * Vertical -  Renders a vertical error bar.
         * * Horizontal - Renders a horizontal error bar.
         * * Both - Renders both side error bar.
         * @default 'Vertical'
         */
        mode: ErrorBarMode;
        /**
         *  The color for stroke of the error bar, which accepts value in hex, rgba as a valid CSS color string.
         * @default null
         */
        color: string;
        /**
         * The vertical error of the error bar.
         * @default 1
         */
        verticalError: number;
        /**
         * The stroke width of the error bar..
         * @default 1
         */
        width: number;
        /**
         * The horizontal error of the error bar.
         * @default 1
         */
        horizontalError: number;
        /**
         * The vertical positive error of the error bar.
         * @default 3
         */
        verticalPositiveError: number;
        /**
         * The vertical negative error of the error bar.
         * @default 3
         */
        verticalNegativeError: number;
        /**
         * The horizontal positive error of the error bar.
         * @default 1
         */
        horizontalPositiveError: number;
        /**
         * The horizontal negative error of the error bar.
         * @default 1
         */
        horizontalNegativeError: number;
        /**
         * Options for customizing the cap of the error bar.
         */
        errorBarCap: ErrorBarCapSettingsModel;
    }
    /**
     * Defines the common behavior of Series and Technical Indicators
     */
    export class SeriesBase extends ej.base.ChildProperty<SeriesBase> {
        /**
         * The DataSource field that contains the x value.
         * It is applicable for series and technical indicators
         * @default ''
         */
        xName: string;
        /**
         * The DataSource field that contains the high value of y
         * It is applicable for series and technical indicators
         * @default ''
         */
        high: string;
        /**
         * The DataSource field that contains the low value of y
         * It is applicable for series and technical indicators
         * @default ''
         */
        low: string;
        /**
         * The DataSource field that contains the open value of y
         * It is applicable for series and technical indicators
         * @default ''
         */
        open: string;
        /**
         * The DataSource field that contains the close value of y
         * It is applicable for series and technical indicators
         * @default ''
         */
        close: string;
        /**
         * Defines the data source field that contains the volume value in candle charts
         * It is applicable for financial series and technical indicators
         * @default ''
         */
        volume: string;
        /**
         * The DataSource field that contains the color value of point
         * It is applicable for series
         * @default ''
         */
        pointColorMapping: string;
        /**
         * The name of the horizontal axis associated with the series. It requires `axes` of the chart.
         * It is applicable for series and technical indicators
         * ```html
         * <div id='Chart'></div>
         * ```
         * ```typescript
         * let chart: Chart = new Chart({
         * ...
         *     columns: [{ width: '50%' },
         *               { width: '50%' }],
         *     axes: [{
         *                name: 'xAxis 1',
         *                columnIndex: 1,
         *            }],
         *     series: [{
         *                dataSource: data,
         *                xName: 'x', yName: 'y',
         *                xAxisName: 'xAxis 1',
         *     }],
         * });
         * chart.appendTo('#Chart');
         * ```
         * @default null
         */
        xAxisName: string;
        /**
         * The name of the vertical axis associated with the series. It requires `axes` of the chart.
         * It is applicable for series and technical indicators
         * ```html
         * <div id='Chart'></div>
         * ```
         * ```typescript
         * let chart: Chart = new Chart({
         * ...
         *     rows: [{ height: '50%' },
         *            { height: '50%' }],
         *     axes: [{
         *                name: 'yAxis 1',
         *                rowIndex: 1,
         *            }],
         *     series: [{
         *                dataSource: data,
         *                xName: 'x', yName: 'y',
         *                yAxisName: 'yAxis 1'
         *     }],
         * });
         * chart.appendTo('#Chart');
         * ```
         * @default null
         */
        yAxisName: string;
        /**
         * Options to customizing animation for the series.
         */
        animation: AnimationModel;
        /**
         * The fill color for the series that accepts value in hex and rgba as a valid CSS color string.
         * It also represents the color of the signal lines in technical indicators.
         * For technical indicators, the default value is 'blue' and for series, it has null.
         * @default null
         */
        fill: string;
        /**
         * The stroke width for the series that is applicable only for `Line` type series.
         * It also represents the stroke width of the signal lines in technical indicators.
         * @default 1
         */
        width: number;
        /**
         * Defines the pattern of dashes and gaps to stroke the lines in `Line` type series.
         * @default '0'
         */
        dashArray: string;
        /**
         * Specifies the DataSource for the series. It can be an array of JSON objects or an instance of DataManager.
         * ```html
         * <div id='Chart'></div>
         * ```
         * ```typescript
         * let dataManager: ej.data.DataManager = new DataManager({
         *         url: 'http://mvc.syncfusion.com/Services/Northwnd.svc/Tasks/'
         * });
         * let query: ej.data.Query = new Query().take(50).where('Estimate', 'greaterThan', 0, false);
         * let chart: Chart = new Chart({
         * ...
         *     series: [{
         *        dataSource: dataManager,
         *        xName: 'Id',
         *        yName: 'Estimate',
         *        query: query
         *    }],
         * ...
         * });
         * chart.appendTo('#Chart');
         * ```
         * @default ''
         */
        dataSource: Object | ej.data.DataManager;
        /**
         * Specifies query to select data from DataSource. This property is applicable only when the DataSource is `ej.DataManager`.
         * @default null
         */
        query: ej.data.Query;
        /**
         * Defines the collection of regions that helps to differentiate a line series.
         */
        segments: ChartSegmentModel[];
        /**
         * Defines the axis, based on which the line series will be split.
         */
        segmentAxis: Segment;
        /**
         * Process data for the series.
         * @hidden
         */
        processJsonData(): void;
        private pushData(point, i);
        /** @private */
        protected dataPoint(i: number, textMappingName: string): Points;
        /**
         * To set empty point value based on empty point mode
         * @private
         */
        setEmptyPoint(point: Points, i: number): void;
        private findVisibility(point);
        /**
         * To get Y min max for the provided point seriesType XY
         */
        private setXYMinMax(yValue);
        /**
         * To get Y min max for the provided point seriesType XY
         */
        private setHiloMinMax(high, low);
        /**
         * Finds the type of the series
         * @private
         */
        private getSeriesType();
        /** @private */
        protected pushCategoryData(point: Points, index: number, pointX: string): void;
        /**
         * To find average of given property
         */
        private getAverage(member, i, data?);
        /**
         * To find the control points for spline.
         * @return {void}
         * @private
         */
        refreshDataManager(chart: Chart): void;
        private dataManagerSuccess(e, chart, isRemoteData?);
        private refreshChart(isRemoteData);
        /** @private */
        xMin: number;
        /** @private */
        xMax: number;
        /** @private */
        yMin: number;
        /** @private */
        yMax: number;
        /** @private */
        xAxis: Axis;
        /** @private */
        yAxis: Axis;
        /** @private */
        chart: Chart;
        /** @private */
        currentViewData: Object;
        /** @private */
        clipRect: Rect;
        /** @private */
        xData: number[];
        /** @private */
        yData: number[];
        /** @private */
        index: number;
        /** @private */
        dataModule: Data;
        /** @private */
        points: Points[];
        /** @private */
        seriesType: SeriesValueType;
        /** @private */
        sizeMax: number;
        /** @private */
        private recordsCount;
    }
    /**
     *  Configures the series in charts.
     */
    export class Series extends SeriesBase {
        /**
         * The name of the series visible in legend.
         * @default ''
         */
        name: string;
        /**
         * The DataSource field that contains the y value.
         * @default ''
         */
        yName: string;
        /**
         * Type of series to be drawn in radar or polar series. They are
         *  'Line'
         *  'Column'
         *  'Area'
         *  'Scatter'
         *  'Spline'
         *  'StackingColumn'
         *  'StackingArea'
         *  'RangeColumn'
         *  'SplineArea'
         * @default 'Line'
         */
        drawType: ChartDrawType;
        /**
         * Specifies whether to join start and end point of a line/area series used in polar/radar chart to form a closed path.
         * @default true
         */
        isClosed: boolean;
        /**
         * This property is used in financial charts to visualize the price movements in stock.
         * It defines the color of the candle/point, when the opening price is less than the closing price.
         * @default '#2ecd71'
         */
        bearFillColor: string;
        /**
         * This property is used in financial charts to visualize the price movements in stock.
         * It defines the color of the candle/point, when the opening price is higher than the closing price.
         * @default '#e74c3d'
         */
        bullFillColor: string;
        /**
         * This property is applicable for candle series.
         * It enables/disables to visually compare the current values with the previous values in stock.
         * @default false
         */
        enableSolidCandles: boolean;
        /**
         * The DataSource field that contains the size value of y
         * @default ''
         */
        size: string;
        /**
         * This property allows grouping series in `stacked column / bar` charts.
         * Any string value can be provided to the stackingGroup property.
         * If any two or above series have the same value, those series will be grouped together.
         * @default ''
         */
        stackingGroup: string;
        /**
         * Specifies the visibility of series.
         * @default true
         */
        visible: boolean;
        /**
         * Options to customizing the border of the series. This is applicable only for `Column` and `Bar` type series.
         */
        border: BorderModel;
        /**
         * The opacity of the series.
         * @default 1
         */
        opacity: number;
        /**
         * The type of the series are
         * * Line
         * * Column
         * * Area
         * * Bar
         * * StackingColumn
         * * StackingArea
         * * StackingBar
         * * StepLine
         * * StepArea
         * * Scatter
         * * Spline
         * * StackingColumn100
         * * StackingBar100
         * * StackingArea100
         * * RangeColumn
         * * Hilo
         * * HiloOpenClose
         * * Waterfall
         * * RangeArea
         * * Bubble
         * * Candle
         * * Polar
         * * Radar
         * * BoxAndWhisker
         * @default 'Line'
         */
        type: ChartSeriesType;
        /**
         * Options for displaying and customizing error bar for individual point in a series.
         */
        errorBar: ErrorBarSettingsModel;
        /**
         * Options for displaying and customizing markers for individual points in a series.
         */
        marker: MarkerSettingsModel;
        /**
         * Defines the collection of trendlines that are used to predict the trend
         */
        trendlines: TrendlineModel[];
        /**
         * If set true, the Tooltip for series will be visible.
         * @default true
         */
        enableTooltip: boolean;
        /**
         * The shape of the legend. Each series has its own legend shape. They are,
         * * Circle
         * * Rectangle
         * * Triangle
         * * Diamond
         * * Cross
         * * HorizontalLine
         * * VerticalLine
         * * Pentagon
         * * InvertedTriangle
         * * SeriesType
         * @default 'SeriesType'
         */
        legendShape: LegendShape;
        /**
         * Custom style for the selected series or points.
         * @default null
         */
        selectionStyle: string;
        /**
         * Minimum radius
         * @default 1
         */
        minRadius: number;
        /**
         * Maximum radius
         * @default 3
         */
        maxRadius: number;
        /**
         * Defines type of spline to be rendered.
         * @default 'Natural'
         */
        splineType: SplineType;
        /**
         * It defines tension of cardinal spline types
         * @default 0.5
         */
        cardinalSplineTension: number;
        /**
         * options to customize the empty points in series
         */
        emptyPointSettings: EmptyPointSettingsModel;
        /**
         * If set true, the mean value for box and whisker will be visible.
         * @default true
         */
        showMean: boolean;
        /**
         * The mode of the box and whisker char series. They are,
         * Exclusive
         * Inclusive
         * Normal
         * @default 'Normal'
         */
        boxPlotMode: BoxPlotMode;
        /**
         * To render the column series points with particular column width.
         * @default 0.7
         */
        columnWidth: number;
        /**
         * To render the column series points with particular column spacing. It takes value from 0 - 1.
         * @default 0
         */
        columnSpacing: number;
        /**
         * Defines the visual representation of the negative changes in waterfall charts.
         * @default '#C64E4A'
         */
        negativeFillColor: string;
        /**
         * Defines the visual representation of the summaries in waterfall charts.
         * @default '#4E81BC'
         */
        summaryFillColor: string;
        /**
         * Defines the collection of indexes of the intermediate summary columns in waterfall charts.
         * @default []
         */
        intermediateSumIndexes: number[];
        /**
         * Defines the collection of indexes of the overall summary columns in waterfall charts.
         * @default []
         */
        sumIndexes: number[];
        /**
         * Defines the appearance of line connecting adjacent points in waterfall charts.
         */
        connector: ConnectorModel;
        /**
         * To render the column series points with particular rounded corner.
         */
        cornerRadius: CornerRadiusModel;
        visibleSeriesCount: number;
        /** @private */
        position: number;
        /** @private */
        rectCount: number;
        /** @private */
        seriesElement: Element;
        /** @private */
        errorBarElement: Element;
        /** @private */
        symbolElement: Element;
        /** @private */
        shapeElement: Element;
        /** @private */
        textElement: Element;
        /** @private */
        pathElement: Element;
        /** @private */
        sourceIndex: number;
        /** @private */
        category: SeriesCategories;
        /** @private */
        isRectSeries: boolean;
        /** @private */
        clipRectElement: Element;
        /** @private */
        stackedValues: StackValues;
        /** @private */
        interior: string;
        /** @private */
        drawPoints: ControlPoints[];
        /** @private */
        delayedAnimation: boolean;
        constructor(parent: any, propName: string, defaultValue: Object, isArray?: boolean);
        /**
         * Refresh the axis label.
         * @return {boolean}
         * @private
         */
        refreshAxisLabel(): void;
        /**
         * To get the series collection.
         * @return {void}
         * @private
         */
        findSeriesCollection(column: Column, row: Row, isStack: boolean): Series[];
        /**
         * To get the column type series.
         * @return {void}
         * @private
         */
        private rectSeriesInChart(series, isStack);
        /**
         * To calculate the stacked values.
         * @return {void}
         * @private
         */
        calculateStackedValue(isStacking100: boolean, chart: Chart): void;
        private calculateStackingValues(seriesCollection, isStacking100);
        private findFrequencies(seriesCollection);
        /**
         * To find the log values.
         * @return {void}
         * @private
         */
        logWithIn(value: number, axis: Axis): number;
        /** @private */
        renderSeries(chart: Chart, index: number): void;
        /**
         * To create seris element.
         * @return {void}
         * @private
         */
        createSeriesElements(chart: Chart): void;
        /**
         * To append the series.
         * @return {void}
         * @private
         */
        appendSeriesElement(element: Element, chart: Chart): void;
        /**
         * To perform animation for chart series.
         * @return {void}
         * @private
         */
        performAnimation(chart: Chart, type: string, errorBar: ErrorBarSettingsModel, marker: MarkerSettingsModel, dataLabel: DataLabelSettingsModel): void;
        /**
         * To set border color for empty point
         * @private
         */
        setPointColor(point: Points, color: string): string;
        /**
         * To set border color for empty point
         * @private
         */
        setBorderColor(point: Points, border: BorderModel): BorderModel;
    }
    
    /**
     * Column Series Base
     */
    export class ColumnBase {
        /**
         * To get the position of the column series.
         * @return {DoubleRange}
         * @private
         */
        protected getSideBySideInfo(series: Series): DoubleRange;
        /**
         * To get the rect values.
         * @return {Rect}
         * @private
         */
        protected getRectangle(x1: number, y1: number, x2: number, y2: number, series: Series): Rect;
        /**
         * To get the position of each series.
         * @return {void}
         * @private
         */
        private getSideBySidePositions(series);
        private findRectPosition(seriesCollection);
        /**
         * Updates the symbollocation for points
         * @return void
         * @private
         */
        protected updateSymbolLocation(point: Points, rect: Rect, series: Series): void;
        /**
         * Update the region for the point.
         * @return {void}
         * @private
         */
        protected updateXRegion(point: Points, rect: Rect, series: Series): void;
        /**
         * Update the region for the point in bar series.
         * @return {void}
         * @private
         */
        protected updateYRegion(point: Points, rect: Rect, series: Series): void;
        /**
         * To trigger the point rendering event.
         * @return {void}
         * @private
         */
        protected triggerEvent(series: Series, point: Points, fill: string, border: BorderModel): IPointRenderEventArgs;
        /**
         * To draw the rectangle for points.
         * @return {void}
         * @private
         */
        protected drawRectangle(series: Series, point: Points, rect: Rect, argsData: IPointRenderEventArgs): void;
        /**
         * To animate the series.
         * @return {void}
         * @private
         */
        animate(series: Series): void;
        /**
         * To animate the series.
         * @return {void}
         * @private
         */
        private animateRect(element, series, point);
        /**
         * To get rounded rect path direction
         */
        private calculateRoundedRectPath(rect, topLeft, topRight, bottomLeft, bottomRight);
    }
    export interface RectPosition {
        position: number;
        rectCount: number;
    }
    
    /**
     * `ColumnSeries` Module used to render the column series.
     */
    export class ColumnSeries extends ColumnBase {
        /**
         * Render Column series.
         * @return {void}
         * @private
         */
        render(series: Series): void;
        /**
         * Animates the series.
         * @param  {Series} series - Defines the series to animate.
         * @return {void}
         */
        doAnimation(series: Series): void;
        /**
         * Get module name.
         */
        protected getModuleName(): string;
        /**
         * To destroy the column series.
         * @return {void}
         * @private
         */
        destroy(chart: Chart): void;
    }
    
    /**
     * `DataLabel` module is used to render data label for the data point.
     */
    export class DataLabel {
        private chart;
        private margin;
        private isShape;
        private locationX;
        private locationY;
        private fontBackground;
        private borderWidth;
        private markerHeight;
        private commonId;
        private yAxisInversed;
        private inverted;
        private errorHeight;
        private chartBackground;
        /**
         * Constructor for the data label module.
         * @private
         */
        constructor(chart: Chart);
        private initPrivateVariables(series, marker);
        private calculateErrorHeight(series, position);
        private isRectSeries(series);
        /**
         * Render the data label for series.
         * @return {void}
         */
        render(series: Series, chart: Chart, dataLabel: DataLabelSettingsModel): void;
        /**
         * Render the data label template.
         * @return {void}
         * @private
         */
        private createDataLabelTemplate(parentElement, series, dataLabel, point, data, labelIndex);
        private calculateTextPosition(point, series, textSize, dataLabel, labelIndex);
        private calculatePolarRectPosition(location, position, series, point, size, labelIndex);
        /**
         * Get the label location
         */
        private getLabelLocation(point, series, textSize, labelIndex);
        private calculateRectPosition(labelLocation, rect, isMinus, position, series, textSize, labelIndex, point);
        private calculatePathPosition(labelLocation, position, series, point, size, labelIndex);
        private isDataLabelShape(style);
        private calculateRectActualPosition(labelLocation, rect, isMinus, series, size, labelIndex, point);
        private calculateAlignment(value, labelLocation, alignment, isMinus);
        private calculateTopAndOuterPosition(location, rect, position, series, index, extraSpace, isMinus);
        /**
         * Updates the label location
         */
        private updateLabelLocation(position, location, extraSpace, margin, rect, top, inside?);
        private calculatePathActualPosition(y, markerSize, series, point, size, labelIndex);
        /**
         * Animates the data label.
         * @param  {Series} series - Data label of the series gets animated.
         * @return {void}
         */
        doDataLabelAnimation(series: Series, element?: Element): void;
        private getPosition(index);
        /**
         * Get module name.
         */
        protected getModuleName(): string;
        /**
         * To destroy the dataLabel for series.
         * @return {void}
         * @private
         */
        destroy(chart: Chart): void;
    }
    
    /**
     * `ErrorBar` module is used to render the error bar for series.
     */
    export class ErrorBar {
        private chart;
        errorHeight: number;
        error: number;
        positiveHeight: number;
        negativeHeight: number;
        /**
         * Constructor for the error bar module.
         * @private
         */
        constructor(chart: Chart);
        /**
         * Render the error bar for series.
         * @return {void}
         */
        render(series: Series): void;
        private renderErrorBar(series);
        private findLocation(point, series, isInverted, x1, y1);
        private calculateFixedValue(point, series, isInverted, errorX, errorY, xAxis, yAxis);
        private calculatePercentageValue(point, series, isInverted, errorX, errorY, xAxis, yAxis);
        private calculateStandardDeviationValue(point, series, isInverted, errorX, errorY, xAxis, yAxis);
        private calculateStandardErrorValue(point, series, isInverted, errorX, errorY, xAxis, yAxis);
        private calculateCustomValue(point, series, isInverted, errorX, errorY, xAxis, yAxis);
        private getHorizontalDirection(start, mid, end, direction, errorMode, capLength);
        private getVerticalDirection(start, mid, end, direction, errorMode, capLength);
        private getBothDirection(start, mid, end, direction, errorMode, capLength);
        private getErrorDirection(start, mid, end, series, isInverted);
        meanCalculation(series: Series, mode: ErrorBarMode): Mean;
        private createElement(series);
        /**
         * Animates the series.
         * @param  {Series} series - Defines the series to animate.
         * @return {void}
         */
        doErrorBarAnimation(series: Series): void;
        /**
         * Get module name.
         */
        protected getModuleName(): string;
        /**
         * To destroy the errorBar for series.
         * @return {void}
         * @private
         */
        destroy(chart: Chart): void;
    }
    
    /**
     * `HiloOpenCloseSeries` module is used to render the hiloOpenClose series.
     */
    export class HiloOpenCloseSeries extends ColumnBase {
        /**
         * Render HiloOpenCloseSeries series.
         * @return {void}
         * @private
         */
        render(series: Series): void;
        /**
         * Updates the tick region
         */
        private updateTickRegion(horizontal, region, borderWidth);
        /**
         * Trigger point rendering event
         */
        private triggerPointRenderEvent(series, point);
        /**
         * To draw the rectangle for points.
         * @return {void}
         * @private
         */
        protected drawHiloOpenClosePath(series: Series, point: Points, open: ChartLocation, close: ChartLocation, rect: Rect, argsData: IPointRenderEventArgs): void;
        /**
         * Get module name.
         */
        protected getModuleName(): string;
        /**
         * Animates the series.
         * @param  {Series} series - Defines the series to animate.
         * @return {void}
         */
        doAnimation(series: Series): void;
        /**
         * To destroy the column series.
         * @return {void}
         * @private
         */
        destroy(chart: Chart): void;
    }
    
    /**
     * `HiloSeries` module is used to render the hilo series.
     */
    export class HiloSeries extends ColumnBase {
        /**
         * Render Hiloseries.
         * @return {void}
         * @private
         */
        render(series: Series): void;
        /**
         * To trigger the point rendering event.
         * @return {void}
         * @private
         */
        private triggerPointRenderEvent(series, point);
        /**
         * Get module name.
         */
        protected getModuleName(): string;
        /**
         * Animates the series.
         * @param  {Series} series - Defines the series to animate.
         * @return {void}
         */
        doAnimation(series: Series): void;
        /**
         * To destroy the Hilo series.
         * @return {void}
         * @private
         */
        destroy(chart: Chart): void;
    }
    
    /**
     * Base for line type series.
     */
    export class LineBase {
        chart: Chart;
        private padding;
        /** @private */
        constructor(chartModule?: Chart);
        /**
         * To improve the chart performance.
         * @return {void}
         * @private
         */
        improveChartPerformance(series: Series): Points[];
        /**
         * To generate the line path direction
         * @param firstPoint
         * @param secondPoint
         * @param series
         * @param isInverted
         * @param getPointLocation
         * @param startPoint
         */
        getLineDirection(firstPoint: Points, secondPoint: Points, series: Series, isInverted: Boolean, getPointLocation: Function, startPoint: string): string;
        /**
         * To append the line path.
         * @return {void}
         * @private
         */
        appendLinePath(options: PathOption, series: Series, clipRect: string): void;
        /**
         * To render the marker for the series.
         * @return {void}
         * @private
         */
        renderMarker(series: Series): void;
        /**
         * To do the progressive animation.
         * @return {void}
         * @private
         */
        doProgressiveAnimation(series: Series, option: AnimationModel): void;
        /**
         * To store the symbol location and region
         * @param point
         * @param series
         * @param isInverted
         * @param getLocation
         */
        storePointLocation(point: Points, series: Series, isInverted: boolean, getLocation: Function): void;
        /**
         * To do the linear animation.
         * @return {void}
         * @private
         */
        doLinearAnimation(series: Series, animation: AnimationModel): void;
    }
    
    /**
     * `LineSeries` module used to render the line series.
     */
    export class LineSeries extends LineBase {
        /**
         * Render Line Series.
         * @return {void}.
         * @private
         */
        render(series: Series, xAxis: Axis, yAxis: Axis, isInverted: boolean): void;
        /**
         * Animates the series.
         * @param  {Series} series - Defines the series to animate.
         * @return {void}
         */
        doAnimation(series: Series): void;
        /**
         * Get module name.
         */
        protected getModuleName(): string;
        /**
         * To destroy the line series.
         * @return {void}
         * @private
         */
        destroy(chart: Chart): void;
    }
    
    /**
     * Marker Module used to render the marker for line type series.
     */
    export class MarkerExplode extends ChartData {
        private markerExplode;
        private isRemove;
        /** @private */
        elementId: string;
        /**
         * Constructor for the marker module.
         * @private
         */
        constructor(chart: Chart);
        /**
         * @hidden
         */
        addEventListener(): void;
        /**
         * @hidden
         */
        /**
         * @hidden
         */
        private mouseUpHandler();
        /**
         * @hidden
         */
        private mouseMoveHandler();
        private markerMove(remove);
        private drawTrackBall(series, point, location, index);
        /**
         * @hidden
         */
        removeHighlightedMarker(): void;
    }
    
    /**
     * Marker module used to render the marker for line type series.
     */
    export class Marker extends MarkerExplode {
        /**
         * Constructor for the marker module.
         * @private
         */
        constructor(chart: Chart);
        /**
         * Render the marker for series.
         * @return {void}
         * @private
         */
        render(series: Series): void;
        private renderMarker(series, point, location, index);
        createElement(series: Series): void;
        private getRangeLowPoint(region, series);
        /**
         * Animates the marker.
         * @return {void}.
         * @private
         */
        doMarkerAnimation(series: Series): void;
    }
    
    /**
     * `MultiColoredAreaSeries` module used to render the area series with multi color.
     */
    export class MultiColoredAreaSeries extends MultiColoredSeries {
        /**
         * Render Area series.
         * @return {void}
         * @private
         */
        render(series: Series, xAxis: Axis, yAxis: Axis, isInverted: boolean): void;
        /**
         * To Store the path directions of the area
         */
        private generatePathOption(options, series, point, direction, id);
        /**
         * To destroy the area series.
         * @return {void}
         * @private
         */
        destroy(chart: Chart): void;
        /**
         * Get module name
         */
        protected getModuleName(): string;
        /**
         * Animates the series.
         * @param  {Series} series - Defines the series to animate.
         * @return {void}
         */
        doAnimation(series: Series): void;
    }
    
    /**
     * Base class for multi colored series
     */
    export class MultiColoredSeries extends LineBase {
        /**
         * To Generate the area path direction
         * @param xValue
         * @param yValue
         * @param series
         * @param isInverted
         * @param getPointLocation
         * @param startPoint
         * @param startPath
         */
        getAreaPathDirection(xValue: number, yValue: number, series: Series, isInverted: boolean, getPointLocation: Function, startPoint: ChartLocation, startPath: string): string;
        /**
         * To Generate the empty point direction
         * @param firstPoint
         * @param secondPoint
         * @param series
         * @param isInverted
         * @param getPointLocation
         */
        getAreaEmptyDirection(firstPoint: ChartLocation, secondPoint: ChartLocation, series: Series, isInverted: boolean, getPointLocation: Function): string;
        /**
         * To set point color
         * @param points
         */
        setPointColor(currentPoint: Points, previous: Points, series: Series, isXSegment: boolean, segments: ChartSegmentModel[]): boolean;
        sortSegments(series: Series, chartSegments: ChartSegmentModel[]): ChartSegmentModel[];
        /**
         * Segment calculation performed here
         * @param series
         * @param options
         * @param chartSegments
         */
        applySegmentAxis(series: Series, options: PathOption[], segments: ChartSegmentModel[]): void;
        private includeSegment(segments, axis, series, length);
        /**
         * To create clip rect for segment axis
         * @param startValue
         * @param endValue
         * @param series
         * @param index
         * @param isX
         * @param chart
         */
        createClipRect(startValue: number, endValue: number, series: Series, index: number, isX: boolean): string;
        /**
         * To get exact value from segment value
         * @param segmentValue
         * @param axis
         * @param chart
         */
        getAxisValue(segmentValue: Object, axis: Axis, chart: Chart): number;
    }
    
    /**
     * `MultiColoredLineSeries` used to render the line series with multi color.
     */
    export class MultiColoredLineSeries extends MultiColoredSeries {
        /**
         * Render Line Series.
         * @return {void}.
         * @private
         */
        render(series: Series, xAxis: Axis, yAxis: Axis, isInverted: boolean): void;
        /**
         * Animates the series.
         * @param  {Series} series - Defines the series to animate.
         * @return {void}
         */
        doAnimation(series: Series): void;
        /**
         * Get module name.
         */
        protected getModuleName(): string;
        /**
         * To destroy the line series.
         * @return {void}
         * @private
         */
        destroy(chart: Chart): void;
    }
    
    /**
     * `PolarSeries` module is used to render the polar series.
     */
    export class PolarSeries extends PolarRadarPanel {
        /**
         * Render Polar Series.
         * @return {void}.
         * @private
         */
        render(series: Series): void;
        /**
         * Render Column DrawType.
         * @return {void}.
         * @private
         */
        columnDrawTypeRender(series: Series): void;
        /**
         * To trigger the point rendering event.
         * @return {void}
         * @private
         */
        triggerEvent(chart: Chart, series: Series, point: Points): IPointRenderEventArgs;
        /** get position for column drawtypes
         * @return {void}.
         * @private
         */
        getSeriesPosition(series: Series): void;
        /**
         * Animates the series.
         * @param  {Series} series - Defines the series to animate.
         * @return {void}
         */
        doAnimation(series: Series): void;
        /**
         * To do the Polar Radar draw type column animation.
         * @return {void}
         * @private
         */
        doPolarRadarAnimation(animateElement: Element, delay: number, duration: number, series: Series): void;
        /**
         * Get module name.
         */
        protected getModuleName(): string;
        /**
         * To destroy the polar series.
         * @return {void}
         * @private
         */
        destroy(chart: Chart): void;
    }
    
    /**
     * `RadarSeries` module is used to render the radar series.
     */
    export class RadarSeries extends PolarSeries {
        /**
         * Render radar Series.
         * @return {void}.
         * @private
         */
        render(series: Series): void;
        /**
         * Get module name.
         */
        protected getModuleName(): string;
        /**
         * To destroy the radar series.
         * @return {void}
         * @private
         */
        destroy(chart: Chart): void;
    }
    
    /**
     * `RangeAreaSeries` module is used to render the range area series.
     */
    export class RangeAreaSeries extends LineBase {
        /**
         * Render RangeArea Series.
         * @return {void}.
         * @private
         */
        render(series: Series): void;
        /**
         * path for rendering the low points
         * @return {void}.
         * @private
         */
        protected closeRangeAreaPath(visiblePoints: Points[], point: Points, series: Series, direction: string, i: number): string;
        /**
         * Animates the series.
         * @param  {Series} series - Defines the series to animate.
         * @return {void}
         */
        doAnimation(series: Series): void;
        /**
         * Get module name.
         */
        protected getModuleName(): string;
        /**
         * To destroy the line series.
         * @return {void}
         * @private
         */
        destroy(chart: Chart): void;
    }
    
    /**
     * `RangeColumnSeries` module is used to render the range column series.
     */
    export class RangeColumnSeries extends ColumnBase {
        /**
         * Render Range Column series.
         * @return {void}
         * @private
         */
        render(series: Series): void;
        /**
         * Get module name.
         */
        protected getModuleName(): string;
        /**
         * Animates the series.
         * @param  {Series} series - Defines the series to animate.
         * @return {void}
         */
        doAnimation(series: Series): void;
        /**
         * To destroy the range column series.
         * @return {void}
         * @private
         */
        destroy(chart: Chart): void;
    }
    
    /**
     * `ScatterSeries` module is used to render the scatter series.
     */
    export class ScatterSeries {
        /**
         * Render the scatter series.
         * @return {void}
         * @private
         */
        render(series: Series, xAxis: Axis, yAxis: Axis, isInverted: boolean): void;
        /**
         * Animates the series.
         * @param  {Series} series - Defines the series to animate.
         * @return {void}
         */
        doAnimation(series: Series): void;
        /**
         * Get module name.
         */
        protected getModuleName(): string;
        /**
         * To destroy the scatter.
         * @return {void}
         */
        destroy(chart: Chart): void;
    }
    
    /**
     * `SplineAreaSeries` module used to render the spline area series.
     */
    export class SplineAreaSeries extends SplineBase {
        /**
         * Render the splineArea series.
         * @return {void}
         * @private
         */
        render(series: Series, xAxis: Axis, yAxis: Axis, isInverted: boolean): void;
        /**
         * Get module name.
         */
        protected getModuleName(): string;
        /**
         * To destroy the spline.
         * @return {void}
         * @private
         */
        destroy(chart: Chart): void;
    }
    
    /**
     * render Line series
     */
    export class SplineBase extends LineBase {
        private splinePoints;
        /** @private */
        constructor(chartModule?: Chart);
        /**
         * To find the control points for spline.
         * @return {void}
         * @private
         */
        findSplinePoint(series: Series): void;
        protected getPreviousIndex(points: Points[], i: number, series: Series): number;
        getNextIndex(points: Points[], i: number, series: Series): number;
        filterEmptyPoints(series: Series): Points[];
        /**
         * To find the natural spline.
         * @return {void}
         * @private
         */
        findSplineCoefficients(points: Points[], series: Series): number[];
        /**
         * To find the control points for spline.
         * @return {void}
         * @private
         */
        getControlPoints(point1: Points, point2: Points, ySpline1: number, ySpline2: number, series: Series): ControlPoints;
        /**
         * calculate datetime interval in hours
         *
         */
        protected dateTimeInterval(series: Series): number;
        /**
         * Animates the series.
         * @param  {Series} series - Defines the series to animate.
         * @return {void}
         */
        doAnimation(series: Series): void;
    }
    
    /**
     * `SplineSeries` module is used to render the spline series.
     */
    export class SplineSeries extends SplineBase {
        /**
         * Render the spline series.
         * @return {void}
         * @private
         */
        render(series: Series, xAxis: Axis, yAxis: Axis, isInverted: boolean): void;
        /**
         * Get module name.
         */
        protected getModuleName(): string;
        /**
         * To destroy the spline.
         * @return {void}
         * @private
         */
        destroy(chart: Chart): void;
    }
    
    /**
     * `StackingAreaSeries` module used to render the Stacking Area series.
     */
    export class StackingAreaSeries extends LineBase {
        /**
         * Render the Stacking area series.
         * @return {void}
         * @private
         */
        render(series: Series, xAxis: Axis, yAxis: Axis, isInverted: boolean): void;
        /**
         * Animates the series.
         * @param  {Series} series - Defines the series to animate.
         * @return {void}
         */
        doAnimation(series: Series): void;
        /**
         * To destroy the stacking area.
         * @return {void}
         * @private
         */
        destroy(chart: Chart): void;
        /**
         * Get module name.
         */
        protected getModuleName(): string;
        /**
         * To find previous visible series
         */
        private getPreviousSeries(series);
    }
    
    /**
     * `StackingBarSeries` module is used to render the stacking bar series.
     */
    export class StackingBarSeries extends ColumnBase {
        /**
         * Render the Stacking bar series.
         * @return {void}
         * @private
         */
        render(series: Series): void;
        /**
         * To destroy the stacking bar.
         * @return {void}
         * @private
         */
        destroy(chart: Chart): void;
        /**
         * Get module name.
         */
        protected getModuleName(): string;
        /**
         * Animates the series.
         * @param  {Series} series - Defines the series to animate.
         * @return {void}
         */
        doAnimation(series: Series): void;
    }
    
    /**
     * `StackingColumnSeries` module used to render the stacking column series.
     */
    export class StackingColumnSeries extends ColumnBase {
        /**
         * Render the Stacking column series.
         * @return {void}
         * @private
         */
        render(series: Series): void;
        /**
         * Animates the series.
         * @param  {Series} series - Defines the series to animate.
         * @return {void}
         */
        doAnimation(series: Series): void;
        /**
         * To destroy the stacking column.
         * @return {void}
         * @private
         */
        destroy(chart: Chart): void;
        /**
         * Get module name.
         */
        protected getModuleName(): string;
    }
    
    /**
     * `StepAreaSeries` Module used to render the step area series.
     */
    export class StepAreaSeries extends LineBase {
        /**
         * Render StepArea series.
         * @return {void}
         * @private
         */
        render(series: Series, xAxis: Axis, yAxis: Axis, isInverted: boolean): void;
        /**
         * Animates the series.
         * @param  {Series} series - Defines the series to animate.
         * @return {void}
         */
        doAnimation(series: Series): void;
        /**
         * To destroy the step Area series.
         * @return {void}
         * @private
         */
        destroy(chart: Chart): void;
        /**
         * Get module name.
         */
        protected getModuleName(): string;
    }
    
    /**
     * `StepLineSeries` module is used to render the step line series.
     */
    export class StepLineSeries extends LineBase {
        /**
         * Render the Step line series.
         * @return {void}
         * @private
         */
        render(series: Series, xAxis: Axis, yAxis: Axis, isInverted: boolean): void;
        /**
         * Animates the series.
         * @param  {Series} series - Defines the series to animate.
         * @return {void}
         */
        doAnimation(series: Series): void;
        /**
         * To destroy the step line series.
         * @return {void}
         * @private
         */
        destroy(chart: Chart): void;
        /**
         * Get module name.
         */
        protected getModuleName(): string;
    }
    
    /**
     * `WaterfallSeries` module is used to render the waterfall series.
     */
    export class WaterfallSeries extends ColumnBase {
        /**
         * Render waterfall series.
         * @return {void}
         * @private
         */
        render(series: Series): void;
        /**
         * To check intermediateSumIndex in waterfall series.
         * @return boolean
         * @private
         */
        private isIntermediateSum(series, index);
        /**
         * To check sumIndex in waterfall series.
         * @return boolean
         * @private
         */
        private isSumIndex(series, index);
        /**
         * To trigger the point rendering event for waterfall series.
         * @return IPointRenderEventArgs
         * @private
         */
        private triggerPointRenderEvent(series, point);
        /**
         * Add sumIndex and intermediateSumIndex data.
         * @return {object[]}
         * @private
         */
        processWaterfallData(json: Object[], series: Series): Object[];
        /**
         * Animates the series.
         * @param  {Series} series - Defines the series to animate.
         * @return {void}
         */
        doAnimation(series: Series): void;
        /**
         * Get module name.
         */
        protected getModuleName(): string;
        /**
         * To destroy the waterfall series.
         * @return {void}
         * @private
         */
        destroy(chart: Chart): void;
    }
    
    /**
     * `AccumulationDistributionIndicator` module is used to render accumulation distribution indicator.
     */
    export class AccumulationDistributionIndicator extends TechnicalAnalysis {
        /**
         * Defines the predictions using accumulation distribution approach
         * @private
         */
        initDataSource(indicator: TechnicalIndicator, chart: Chart): void;
        /**
         *  Calculates the Accumulation Distribution values
         * @private
         */
        private calculateADPoints(indicator, validData);
        /**
         * To destroy the Accumulation Distribution Technical Indicator.
         * @return {void}
         * @private
         */
        destroy(chart: Chart): void;
        /**
         * Get module name.
         */
        protected getModuleName(): string;
    }
    
    /**
     * `AtrIndicator` module is used to render ATR indicator.
     */
    export class AtrIndicator extends TechnicalAnalysis {
        /**
         * Defines the predictions using Average True Range approach
         * @private
         */
        initDataSource(indicator: TechnicalIndicator, chart: Chart): void;
        /**
         *  To calculate Average True Range indicator points
         * @private
         */
        private calculateATRPoints(indicator, validData);
        /**
         * To destroy the Average true range indicator.
         * @return {void}
         * @private
         */
        destroy(chart: Chart): void;
        /**
         * Get module name.
         */
        protected getModuleName(): string;
    }
    
    /**
     * `BollingerBands` module is used to render bollinger band indicator.
     */
    export class BollingerBands extends TechnicalAnalysis {
        /**
         * Initializes the series collection to represent bollinger band
         */
        initSeriesCollection(indicator: TechnicalIndicator, chart: Chart): void;
        /**
         * Defines the predictions using Bollinger Band Approach
         * @private
         */
        initDataSource(indicator: TechnicalIndicator, chart: Chart): void;
        /**
         * To destroy the Bollinger Band.
         * @return {void}
         * @private
         */
        destroy(chart: Chart): void;
        /**
         * Get module name.
         */
        protected getModuleName(): string;
    }
    
    /**
     * `EmaIndicator` module is used to render EMA indicator.
     */
    export class EmaIndicator extends TechnicalAnalysis {
        /**
         * Defines the predictions based on EMA approach
         * @private
         */
        initDataSource(indicator: TechnicalIndicator, chart: Chart): void;
        /**
         * To destroy the EMA Indicator
         * @return {void}
         * @private
         */
        destroy(chart: Chart): void;
        /**
         * Get module name.
         */
        protected getModuleName(): string;
    }
    
    /**
     * Technical Analysis module helps to predict the market trend
     */
    export class TechnicalAnalysis extends LineBase {
        /**
         * Defines the collection of series, that are used to represent the given technical indicator
         * @private
         */
        initSeriesCollection(indicator: TechnicalIndicator, chart: Chart): void;
        /**
         * Initializes the properties of the given series
         * @private
         */
        protected setSeriesProperties(series: Series, indicator: TechnicalIndicator, name: string, fill: string, width: number, chart: Chart): void;
        /**
         * Creates the elements of a technical indicator
         * @private
         */
        createIndicatorElements(chart: Chart, indicator: TechnicalIndicator, index: number): void;
        protected getDataPoint(x: Object, y: Object, sourcePoint: Points, series: Series, index: number, indicator?: TechnicalIndicator): Points;
        protected getRangePoint(x: Object, high: Object, low: Object, sourcePoint: Points, series: Series, index: number, indicator?: TechnicalIndicator): Points;
        protected setSeriesRange(points: Points[], indicator: TechnicalIndicator, series?: Series): void;
    }
    
    /**
     * `MacdIndicator` module is used to render MACD indicator.
     */
    export class MacdIndicator extends TechnicalAnalysis {
        /**
         * Defines the collection of series to represent the MACD indicator
         * @private
         */
        initSeriesCollection(indicator: TechnicalIndicator, chart: Chart): void;
        /**
         * Defines the predictions using MACD approach
         * @private
         */
        initDataSource(indicator: TechnicalIndicator, chart: Chart): void;
        /**
         * Calculates the EMA values for the given period
         */
        private calculateEMAValues(period, validData, field);
        /**
         * Defines the MACD Points
         */
        private getMACDPoints(indicator, macdPoints, validData, series);
        /**
         * Calculates the signal points
         */
        private getSignalPoints(indicator, signalEma, validData, series);
        /**
         * Calculates the MACD values
         */
        private getMACDVales(indicator, shortEma, longEma);
        /**
         * Calculates the Histogram Points
         */
        private getHistogramPoints(indicator, macdPoints, signalEma, validData, series);
        /**
         * To destroy the MACD Indicator.
         * @return {void}
         * @private
         */
        destroy(chart: Chart): void;
        /**
         * Get module name.
         */
        protected getModuleName(): string;
    }
    
    /**
     * `MomentumIndicator` module is used to render Momentum indicator.
     */
    export class MomentumIndicator extends TechnicalAnalysis {
        /**
         * Defines the collection of series to represent a momentum indicator
         * @private
         */
        initSeriesCollection(indicator: TechnicalIndicator, chart: Chart): void;
        /**
         * Defines the predictions using momentum approach
         * @private
         */
        initDataSource(indicator: TechnicalIndicator, chart: Chart): void;
        /**
         * To destroy the momentum indicator
         * @return {void}
         * @private
         */
        destroy(chart: Chart): void;
        /**
         * Get module name.
         */
        protected getModuleName(): string;
    }
    
    /**
     * `RsiIndicator` module is used to render RSI indicator.
     */
    export class RsiIndicator extends TechnicalAnalysis {
        /**
         * Initializes the series collection to represent the RSI Indicator
         * @private
         */
        initSeriesCollection(indicator: TechnicalIndicator, chart: Chart): void;
        /**
         * Defines the predictions using RSI approach
         * @private
         */
        initDataSource(indicator: TechnicalIndicator, chart: Chart): void;
        /**
         * To destroy the RSI Indicator.
         * @return {void}
         * @private
         */
        destroy(chart: Chart): void;
        /**
         * Get module name.
         */
        protected getModuleName(): string;
    }
    
    /**
     * `SmaIndicator` module is used to render SMA indicator.
     */
    export class SmaIndicator extends TechnicalAnalysis {
        /**
         * Defines the predictions based on SMA approach
         * @private
         */
        initDataSource(indicator: TechnicalIndicator, chart: Chart): void;
        /**
         * To destroy the SMA indicator
         * @return {void}
         * @private
         */
        destroy(chart: Chart): void;
        /**
         * Get module name.
         */
        protected getModuleName(): string;
    }
    
    /**
     * `StochasticIndicator` module is used to render stochastic indicator.
     */
    export class StochasticIndicator extends TechnicalAnalysis {
        /**
         * Defines the collection of series that represents the stochastic indicator
         * @private
         */
        initSeriesCollection(indicator: TechnicalIndicator, chart: Chart): void;
        /**
         * Defines the predictions based on stochastic approach
         * @private
         */
        initDataSource(indicator: TechnicalIndicator, chart: Chart): void;
        /**
         * Calculates the SMA Values
         * @private
         */
        private smaCalculation(period, kPeriod, data, sourceSeries);
        /**
         * Calculates the period line values.
         * @private
         */
        private calculatePeriod(period, kPeriod, data, series);
        /**
         * To destroy the Stocastic Indicator.
         * @return {void}
         * @private
         */
        destroy(chart: Chart): void;
        /**
         * Get module name.
         */
        protected getModuleName(): string;
    }
    
    /**
     * Interface for a class TechnicalIndicator
     */
    export interface TechnicalIndicatorModel extends SeriesBaseModel{
    
        /**
         * Defines the type of the technical indicator
         * @default 'Sma'
         */
        type?: TechnicalIndicators;
    
        /**
         * Defines the period, the price changes over which will be considered to predict the trend
         * @default 14
         */
        period?: number;
    
        /**
         * Defines the look back period, the price changes over which will define the %K value in stochastic indicators
         * @default 14
         */
        kPeriod?: number;
    
        /**
         * Defines the period, the price changes over which will define the %D value in stochastic indicators
         * @default 3
         */
        dPeriod?: number;
    
        /**
         * Defines the over-bought(threshold) values. It is applicable for RSI and stochastic indicators
         * @default 80
         */
        overBought?: number;
    
        /**
         * Defines the over-sold(threshold) values. It is applicable for RSI and stochastic indicators
         * @default 20
         */
        overSold?: number;
    
        /**
         * Sets the standard deviation values that helps to define the upper and lower bollinger bands
         * @default 2
         */
        standardDeviation?: number;
    
        /**
         * Defines the field to compare the current value with previous values
         * @default 'Close'
         */
        field?: FinancialDataFields;
    
        /**
         * Sets the slow period to define the Macd line
         * @default 12
         */
        slowPeriod?: number;
    
        /**
         * Sets the fast period to define the Macd line
         * @default 26
         */
        fastPeriod?: number;
    
        /**
         * Enables/Disables the over-bought and over-sold regions
         * @default true
         */
        showZones?: boolean;
    
        /**
         * Defines the appearance of the the MacdLine of Macd indicator
         * @default { color: '#ff9933', width: 2 }
         */
        macdLine?: ConnectorModel;
    
        /**
         * Defines the type of the Macd indicator.
         * @default 'Both'
         */
        macdType?: MacdType;
    
        /**
         * Defines the color of the positive bars in Macd indicators
         */
        macdPositiveColor?: string;
    
        /**
         * Defines the color of the negative bars in Macd indicators
         */
        macdNegativeColor?: string;
    
        /**
         * Options for customizing the BollingerBand in the indicator.
         * @default 'rgba(211,211,211,0.25)'
         */
    
        bandColor?: string;
    
        /**
         * Defines the appearance of the upper line in technical indicators
         */
        upperLine?: ConnectorModel;
    
        /**
         * Defines the appearance of lower line in technical indicators
         */
    
        lowerLine?: ConnectorModel;
    
        /**
         * Defines the appearance of period line in technical indicators
         */
    
        periodLine?: ConnectorModel;
    
        /**
         * Defines the name of the series, the data of which has to be depicted as indicator
         * @default ''
         */
        seriesName?: string;
    
    }
    
    /**
     * Defines how to represent the market trend using technical indicators
     */
    export class TechnicalIndicator extends SeriesBase {
        /**
         * Defines the type of the technical indicator
         * @default 'Sma'
         */
        type: TechnicalIndicators;
        /**
         * Defines the period, the price changes over which will be considered to predict the trend
         * @default 14
         */
        period: number;
        /**
         * Defines the look back period, the price changes over which will define the %K value in stochastic indicators
         * @default 14
         */
        kPeriod: number;
        /**
         * Defines the period, the price changes over which will define the %D value in stochastic indicators
         * @default 3
         */
        dPeriod: number;
        /**
         * Defines the over-bought(threshold) values. It is applicable for RSI and stochastic indicators
         * @default 80
         */
        overBought: number;
        /**
         * Defines the over-sold(threshold) values. It is applicable for RSI and stochastic indicators
         * @default 20
         */
        overSold: number;
        /**
         * Sets the standard deviation values that helps to define the upper and lower bollinger bands
         * @default 2
         */
        standardDeviation: number;
        /**
         * Defines the field to compare the current value with previous values
         * @default 'Close'
         */
        field: FinancialDataFields;
        /**
         * Sets the slow period to define the Macd line
         * @default 12
         */
        slowPeriod: number;
        /**
         * Sets the fast period to define the Macd line
         * @default 26
         */
        fastPeriod: number;
        /**
         * Enables/Disables the over-bought and over-sold regions
         * @default true
         */
        showZones: boolean;
        /**
         * Defines the appearance of the the MacdLine of Macd indicator
         * @default { color: '#ff9933', width: 2 }
         */
        macdLine: ConnectorModel;
        /**
         * Defines the type of the Macd indicator.
         * @default 'Both'
         */
        macdType: MacdType;
        /**
         * Defines the color of the positive bars in Macd indicators
         */
        macdPositiveColor: string;
        /**
         * Defines the color of the negative bars in Macd indicators
         */
        macdNegativeColor: string;
        /**
         * Options for customizing the BollingerBand in the indicator.
         * @default 'rgba(211,211,211,0.25)'
         */
        bandColor: string;
        /**
         * Defines the appearance of the upper line in technical indicators
         */
        upperLine: ConnectorModel;
        /**
         * Defines the appearance of lower line in technical indicators
         */
        lowerLine: ConnectorModel;
        /**
         * Defines the appearance of period line in technical indicators
         */
        periodLine: ConnectorModel;
        /**
         * Defines the name of the series, the data of which has to be depicted as indicator
         * @default ''
         */
        seriesName: string;
        /** @private */
        targetSeries: Series[];
        /** @private */
        sourceSeries: Series;
        /** @private */
        indicatorElement: Element;
        /** @private */
        clipRectElement: Element;
        /** @private */
        clipRect: Rect;
        /** @private */
        setDataSource(series: Series, chart: Chart): void;
    }
    
    /**
     * `TmaIndicator` module is used to render TMA indicator.
     */
    export class TmaIndicator extends TechnicalAnalysis {
        /**
         * Defines the predictions based on TMA approach
         * @private
         */
        initDataSource(indicator: TechnicalIndicator, chart: Chart): void;
        /**
         * To destroy the TMA indicator.
         * @return {void}
         * @private
         */
        destroy(chart: Chart): void;
        /**
         * Get module name.
         */
        protected getModuleName(): string;
    }
    
    /**
     * `Trendline` module is used to render 6 types of trendlines in chart.
     */
    export class Trendlines {
        /**
         * Defines the collection of series, that are used to represent a trendline
         * @private
         */
        initSeriesCollection(trendline: Trendline, chart: Chart): void;
        /**
         * Initializes the properties of the trendline series
         */
        private setSeriesProperties(series, trendline, name, fill, width, chart);
        /**
         * Creates the elements of a trendline
         */
        private createTrendLineElements(chart, trendline, index, element, clipRectElement);
        /**
         * Defines the data point of trendline
         */
        private getDataPoint(x, y, sourcePoint, series, index);
        /**
         * Finds the slope and intercept of trendline
         */
        private findSlopeIntercept(xValues, yValues, trendline, points);
        /**
         * Defines the points to draw the trendlines
         */
        initDataSource(trendline: Trendline, chart: Chart): void;
        /**
         * Calculation of exponential points
         */
        private setExponentialRange(points, trendline, series);
        /**
         * Calculation of logarithmic points
         */
        private setLogarithmicRange(points, trendline, series);
        /**
         * Calculation of polynomial points
         */
        private setPolynomialRange(points, trendline, series);
        /**
         * Calculation of power points
         */
        private setPowerRange(points, trendline, series);
        /**
         * Calculation of linear points
         */
        private setLinearRange(points, trendline, series);
        /**
         * Calculation of moving average points
         */
        private setMovingAverageRange(points, trendline, series);
        /**
         * Calculation of logarithmic points
         */
        private getLogarithmicPoints(trendline, points, xValues, yValues, series, slopeInterceptLog);
        /**
         * Defines the points based on data point
         */
        private getPowerPoints(trendline, points, xValues, yValues, series, slopeInterceptPower);
        /**
         * Get the polynomial points based on polynomial slopes
         */
        private getPolynomialPoints(trendline, points, xValues, yValues, series);
        /**
         * Defines the moving average points
         */
        private getMovingAveragePoints(trendline, points, xValues, yValues, series);
        /**
         * Defines the linear points
         */
        private getLinearPoints(trendline, points, xValues, yValues, series, slopeInterceptLinear);
        /**
         * Defines the exponential points
         */
        private getExponentialPoints(trendline, points, xValues, yValues, series, slopeInterceptExp);
        /**
         * Defines the points based on data point
         */
        private getPoints(trendline, points, xValues, yValues, series);
        /**
         * Defines the polynomial value of y
         */
        private getPolynomialYValue(slopes, x);
        /**
         * Defines the gauss jordan elimination
         */
        private gaussJordanElimination(matrix, polynomialSlopes);
        /**
         * Defines the trendline elements
         */
        getTrendLineElements(series: Series, chart: Chart): void;
        /**
         * To destroy the trendline
         */
        destroy(chart: Chart): void;
        /**
         * Get module name
         */
        protected getModuleName(): string;
    }
    /** @private */
    export interface SlopeIntercept {
        slope?: number;
        intercept?: number;
    }
    
    /**
     * `Crosshair` module is used to render the crosshair for chart.
     */
    export class Crosshair {
        private elementID;
        private elementSize;
        private crosshairInterval;
        private arrowLocation;
        private isTop;
        private isBottom;
        private isLeft;
        private isRight;
        private valueX;
        private valueY;
        private rx;
        private ry;
        private chart;
        /**
         * Constructor for crosshair module.
         * @private
         */
        constructor(chart: Chart);
        /**
         * @hidden
         */
        private addEventListener();
        private mouseUpHandler();
        private mouseLeaveHandler();
        private mouseMoveHandler(event);
        /**
         * Handles the long press on chart.
         * @return {boolean}
         * @private
         */
        private longPress();
        /**
         * Renders the crosshair.
         * @return {void}
         */
        crosshair(): void;
        private renderCrosshairLine(options, crossGroup);
        private renderAxisTooltip(chart, chartRect, axisGroup);
        private getAxisText(axis);
        private tooltipLocation(text, axis, bounds, axisRect);
        private stopAnimation();
        /**
         * Removes the crosshair on mouse leave.
         * @return {void}
         * @private
         */
        removeCrosshair(duration: number): void;
        /**
         * Get module name.
         */
        protected getModuleName(): string;
        /**
         * To destroy the crosshair.
         * @return {void}
         * @private
         */
        destroy(chart: Chart): void;
    }
    
    /**
     * `Selection` module handles the selection for chart.
     * @private
     */
    export class Selection extends BaseSelection {
        private renderer;
        private isSeriesMode;
        private resizing;
        /** @private */
        rectPoints: Rect;
        private closeIconId;
        private closeIcon;
        private draggedRectGroup;
        private draggedRect;
        /** @private */
        selectedDataIndexes: Indexes[];
        private series;
        private dragging;
        private dragRect;
        private rectGrabbing;
        private resizeMode;
        private chart;
        /**
         * Constructor for selection module.
         * @private.
         */
        constructor(chart: Chart);
        /**
         * Binding events for selection module.
         */
        private addEventListener();
        /**
         * Chart mouse down
         */
        private mousedown(e);
        /**
         * UnBinding events for selection module.
         */
        private removeEventListener();
        /**
         * To find private variable values
         */
        private initPrivateVariables(chart);
        /**
         * Method to select the point and series.
         * @return {void}
         */
        invokeSelection(chart: Chart): void;
        private generateStyle(series);
        private selectDataIndex(chart, indexes);
        private getElementByIndex(chart, index, suffix?);
        private getClusterElements(chart, index);
        private findElements(chart, series, index, suffix?);
        /**
         * To find the selected element.
         * @return {void}
         * @private
         */
        calculateSelectedElements(event: Event): void;
        private performSelection(index, chart, element?);
        private selection(chart, index, selectedElements);
        private clusterSelection(chart, series, index);
        private removeMultiSelectEelments(chart, index, currentIndex, seriesCollection);
        private blurEffect(chartId, visibleSeries);
        private checkSelectionElements(element, className, visibility);
        private applyStyles(elements);
        private getSelectionClass(id);
        private removeStyles(elements);
        private addOrRemoveIndex(indexes, index, add?);
        private toEquals(first, second, checkSeriesOnly);
        /**
         * To redraw the selected points.
         * @return {void}
         * @private
         */
        redrawSelection(chart: Chart, oldMode: SelectionMode): void;
        /** @private */
        legendSelection(chart: Chart, series: number): void;
        private getSeriesElements(series);
        private indexFinder(id);
        /**
         * Drag selection that returns the selected data.
         * @return {void}
         * @private
         */
        calculateDragSelectedElements(chart: Chart, dragRect: Rect): void;
        private removeOffset(rect, clip);
        /**
         * Method to draw dragging rect.
         * @return {void}
         * @private
         */
        drawDraggingRect(chart: Chart, dragRect: Rect): void;
        private createCloseButton(x, y);
        /**
         * Method to remove dragged element.
         * @return {void}
         * @private
         */
        removeDraggedElements(chart: Chart, event: Event): void;
        /**
         * Method to resize the drag rect.
         * @return {void}
         * @private
         */
        resizingSelectionRect(chart: Chart, location: ChartLocation, tapped?: boolean): void;
        private findResizeMode(chartSvgObject, rect, location);
        private changeCursorStyle(isResize, rectelement, cursorStyle);
        private removeSelectedElements(chart, index, seriesCollection);
        private setAttributes(ele, object);
        /**
         * Method to move the dragged rect.
         * @return {void}
         * @private
         */
        draggedRectMoved(chart: Chart, grabbedPoint: Rect, doDrawing?: boolean): void;
        /**
         * To complete the selection.
         * @return {void}
         * @private
         */
        completeSelection(e: Event): void;
        private getDragRect(chart, seriesClipRect);
        /** @private */
        dragStart(chart: Chart, seriesClipRect: Rect, mouseDownX: number, mouseDownY: number, event: Event): void;
        /** @private */
        mouseMove(event: PointerEvent | TouchEvent): void;
        /**
         * Get module name.
         * @private
         */
        getModuleName(): string;
        /**
         * To destroy the selection.
         * @return {void}
         * @private
         */
        destroy(chart: Chart): void;
    }
    
    /**
     * `Tooltip` module is used to render the tooltip for chart series.
     */
    export class Tooltip extends BaseTooltip {
        /**
         * Constructor for tooltip module.
         * @private.
         */
        constructor(chart: Chart);
        /**
         * @hidden
         */
        private addEventListener();
        private mouseUpHandler();
        private mouseLeaveHandler();
        private mouseMoveHandler();
        /**
         * Handles the long press on chart.
         * @return {boolean}
         * @private
         */
        private longPress();
        /**
         * Renders the tooltip.
         * @return {void}
         */
        tooltip(): void;
        private findHeader(data);
        private renderSeriesTooltip(chart, isFirst, tooltipDiv);
        private findData(data, previous);
        private getSymbolLocation(data);
        private getTooltipText(pointData);
        private getTemplateText(data);
        private findMouseValue(data, chart);
        private renderGroupedTooltip(chart, isFirst, tooltipDiv);
        private getBoxLocation(data);
        private drawMarker(isBottom, isRight, size);
        private findColor(data, series);
        private parseTemplate(point, series, format, xAxis, yAxis);
        private formatPointValue(point, axis, dataValue, isXPoint, isYPoint);
        private getFormat(chart, series);
        private getIndicatorTooltipFormat(series, chart, format);
        removeHighlightedMarker(data: PointData[]): void;
        /**
         * Removes the tooltip on mouse leave.
         * @return {void}
         * @private
         */
        removeTooltip(duration: number): void;
        /**
         * Get module name.
         */
        protected getModuleName(): string;
        /**
         * To destroy the tooltip.
         * @return {void}
         * @private
         */
        destroy(chart: Chart): void;
    }
    
    /**
     * Zooming Toolkit created here
     * @private
     */
    export class Toolkit {
        private chart;
        private selectionColor;
        private fillColor;
        private elementOpacity;
        private elementId;
        private zoomInElements;
        private zoomOutElements;
        private zoomElements;
        private panElements;
        /** @private */
        constructor(chart: Chart);
        /**
         * To create the pan button.
         * @return {void}
         * @private
         */
        createPanButton(childElement: Element, parentElement: Element, chart: Chart): void;
        /**
         * To create the zoom button.
         * @return {void}
         * @private
         */
        createZoomButton(childElement: Element, parentElement: Element, chart: Chart): void;
        /**
         * To create the ZoomIn button.
         * @return {void}
         * @private
         */
        createZoomInButton(childElement: Element, parentElement: Element, chart: Chart): void;
        /**
         * To create the ZoomOut button.
         * @return {void}
         * @private
         */
        createZoomOutButton(childElement: Element, parentElement: Element, chart: Chart): void;
        /**
         * To create the Reset button.
         * @return {void}
         * @private
         */
        createResetButton(childElement: Element, parentElement: Element, chart: Chart, isDevice: Boolean): void;
        /**
         * To bind events.
         * @return {void}
         * @private
         */
        wireEvents(element: Element, process: Function): void;
        /**
         * To show tooltip.
         * @return {void}
         * @private
         */
        private showTooltip(event);
        /** @private */
        removeTooltip(): void;
        /** @private */
        reset(): boolean;
        private zoomIn(e);
        private zoomOut(e);
        private zoom(e);
        /** @private */
        pan(): boolean;
        private zoomInOutCalculation(scale, chart, axes, mode);
        private applySelection(elements, color);
    }
    
    /**
     * `Zooming` module handles the zooming for chart.
     */
    export class Zoom {
        private chart;
        private zooming;
        private elementId;
        /** @private */
        zoomingRect: Rect;
        /** @private */
        toolkit: Toolkit;
        /** @private */
        toolkitElements: Element;
        /** @private */
        isPanning: boolean;
        /** @private */
        isZoomed: boolean;
        /** @private */
        isPointer: Boolean;
        /** @private */
        pinchTarget: Element;
        /** @private */
        isDevice: Boolean;
        /** @private */
        browserName: string;
        /** @private */
        touchStartList: ITouches[] | TouchList;
        /** @private */
        touchMoveList: ITouches[] | TouchList;
        /** @private */
        offset: Rect;
        /** @private */
        zoomAxes: IZoomAxisRange[];
        /** @private */
        isIOS: Boolean;
        /** @private */
        performedUI: boolean;
        private zoomkitOpacity;
        private wheelEvent;
        private cancelEvent;
        /**
         * Constructor for Zooming module.
         * @private.
         */
        constructor(chart: Chart);
        /**
         * Function that handles the Rectangular zooming.
         * @return {void}
         */
        renderZooming(e: PointerEvent | TouchEvent, chart: Chart, isTouch: boolean): void;
        private drawZoomingRectangle(chart);
        private doPan(chart, axes);
        /**
         * Redraw the chart on zooming.
         * @return {void}
         * @private
         */
        performZoomRedraw(chart: Chart): void;
        private refreshAxis(layout, chart, axes);
        private doZoom(chart, axes, bounds);
        /**
         * Function that handles the Mouse wheel zooming.
         * @return {void}
         * @private
         */
        performMouseWheelZooming(e: WheelEvent, mouseX: number, mouseY: number, chart: Chart, axes: AxisModel[]): void;
        /**
         * Function that handles the Pinch zooming.
         * @return {void}
         * @private
         */
        performPinchZooming(e: TouchEvent, chart: Chart): boolean;
        private calculatePinchZoomFactor(chart, pinchRect);
        private setTransform(transX, transY, scaleX, scaleY, chart, isPinch);
        private calculateZoomAxesRange(chart, axes);
        private showZoomingToolkit(chart);
        /**
         * To the show the zooming toolkit.
         * @return {void}
         * @private
         */
        applyZoomToolkit(chart: Chart, axes: AxisModel[]): void;
        /**
         * Return boolean property to show zooming toolkit.
         * @return {void}
         * @private
         */
        isAxisZoomed(axes: AxisModel[]): boolean;
        private zoomToolkitMove(e);
        private zoomToolkitLeave(e);
        /**
         * @hidden
         */
        addEventListener(): void;
        /**
         * @hidden
         */
        removeEventListener(): void;
        /**
         * Handles the mouse wheel on chart.
         * @return {boolean}
         * @private
         */
        chartMouseWheel(e: WheelEvent): boolean;
        /**
         * @hidden
         */
        private mouseMoveHandler(e);
        /**
         * @hidden
         */
        private mouseDownHandler(e);
        /**
         * @hidden
         */
        private mouseUpHandler(e);
        /**
         * @hidden
         */
        private mouseCancelHandler(e);
        /**
         * Handles the touch pointer.
         * @return {boolean}
         * @private
         */
        addTouchPointer(touchList: ITouches[], e: PointerEvent, touches: TouchList): ITouches[];
        /**
         * Get module name.
         */
        protected getModuleName(): string;
        /**
         * To destroy the zooming.
         * @return {void}
         * @private
         */
        destroy(chart: Chart): void;
    }
    
    /**
     * Numeric Range.
     * @private
     */
    export class DoubleRange {
        private mStart;
        private mEnd;
        /** @private */
        readonly start: number;
        /** @private */
        readonly end: number;
        /** @private */
        readonly delta: number;
        /** @private */
        readonly median: number;
        constructor(start: number, end: number);
    }
    
    /**
     * Defines Orientation of axis. They are
     * * horizontal
     * * vertical
     * @private
     */
    export type Orientation = 'Horizontal' | 'Vertical';
    /**
     * Defines area type of chart. They are
     * * none
     * * cartesianAxes
     * * polarAxes
     * @private
     */
    export type ChartAreaType = 'CartesianAxes' | 'PolarAxes';
    /**
     * Defines series type of chart. They are
     * * xy
     * * highLow
     * @private
     */
    export type SeriesValueType = 'XY' | 'HighLow' | 'HighLowOpenClose' | 'BoxPlot';
    /**
     * Defines the range padding of axis. They are
     * * none - Padding cannot be applied to the axis.
     * * normal - Padding is applied to the axis based on the range calculation.
     * * additional - Interval of the axis is added as padding to the minimum and maximum values of the range.
     * * round - Axis range is rounded to the nearest possible value divided by the interval.
     */
    export type ChartRangePadding = 'Auto' | 'None' | 'Normal' | 'Additional' | 'Round';
    /**
     * Defines the segment axis. They are,
     * * X - Segment calculation rendered based on horizontal axis
     * * Y - Segment calculation rendered based on vertical axis
     */
    export type Segment = 'X' | 'Y';
    /**
     * Defines the type series in chart. They are
     * * line - Renders the line series.
     * * column - Renders the column series.
     * * area - Renders the area series.
     * * pie - Renders the pie series.
     * * polar - Renders the polar series.
     * * radar - Renders the radar series.
     * * bar - Renders the stacking column series
     * * stackingColumn - Renders the stacking column series.
     * * stackingArea - Renders the stacking area series
     * * stackingBar - Renders the stacking bar series.
     * * StackingColumn100 - Renders the stacking column series.
     * * StackingArea100 - Renders the stacking area 100 percent series
     * * StackingBar100 - Renders the stacking bar 100 percent series.
     * * stepLine -  Renders the step line series.
     * * stepArea -  Renders the step area series.
     * * scatter - Renders the scatter series.
     * * spline - Renders the spline series
     * * rangeColumn - Renders the rangeColumn series.
     * * hilo - Renders the hilo series
     * * hiloOpenClose - Renders the HiloOpenClose Series
     * * Waterfall - Renders the Waterfall Series
     * * rangeArea - Renders the rangeArea series.
     */
    export type ChartSeriesType = 'Line' | 'Column' | 'Area' | 'Bar' | 'StackingColumn' | 'StackingArea' | 'StackingBar' | 'StepLine' | 'StepArea' | 'SplineArea' | 'Scatter' | 'Spline' | 'StackingColumn100' | 'StackingBar100' | 'StackingArea100' | 'RangeColumn' | 'Hilo' | 'HiloOpenClose' | 'Waterfall' | 'RangeArea' | 'Bubble' | 'Candle' | 'Polar' | 'Radar' | 'BoxAndWhisker' | 'MultiColoredLine' | 'MultiColoredArea';
    /**
     * * Type of series to be drawn in radar or polar series. They are
     * * line - Renders the line series.
     * * column - Renders the column series.
     * * area - Renders the area series.
     * * scatter - Renders the scatter series.
     * * spline - Renders the spline series.
     * * stackingColumn - Renders the stacking column series.
     * * stackingArea - Renders the stacking area series.
     * * rangeColumn - Renders the range column series.
     * * splineArea - Renders the spline area series.
     */
    export type ChartDrawType = 'Line' | 'Column' | 'StackingColumn' | 'Area' | 'Scatter' | 'RangeColumn' | 'Spline' | 'SplineArea' | 'StackingArea';
    /**
     * Defines the Edge Label Placement for an axis. They are
     * * none - No action will be perform.
     * * hide - Edge label will be hidden.
     * * shift - Shift the edge labels.
     */
    export type EdgeLabelPlacement = 'None' | 'Hide' | 'Shift';
    /**
     * Defines the Label Placement for category axis. They are
     * * betweenTicks - Render the label between the ticks.
     * * onTicks - Render the label on the ticks.
     */
    export type LabelPlacement = 'BetweenTicks' | 'OnTicks';
    /**
     * Defines the shape of marker. They are
     * * circle - Renders a circle.
     * * rectangle - Renders a rectangle.
     * * triangle - Renders a triangle.
     * * diamond - Renders a diamond.
     * * cross - Renders a cross.
     * * horizontalLine - Renders a horizontalLine.
     * * verticalLine - Renders a verticalLine.
     * * pentagon- Renders a pentagon.
     * * invertedTriangle - Renders a invertedTriangle.
     * * image - Renders a image.
     */
    export type ChartShape = 'Circle' | 'Rectangle' | 'Triangle' | 'Diamond' | 'Cross' | 'HorizontalLine' | 'VerticalLine' | 'Pentagon' | 'InvertedTriangle' | 'Image';
    /**
     * Defines the type of axis. They are
     * * double -  Renders a numeric axis.
     * * dateTime - Renders a dateTime axis.
     * * category - Renders a category axis.
     * * logarithmic - Renders a log axis.
     * * DateTimeCategory - Renders a datetime DateTimeCategory axis
     */
    export type ValueType = 'Double' | 'DateTime' | 'Category' | 'Logarithmic' | 'DateTimeCategory';
    /**
     * Defines the type of error bar. They are
     * * fixed -  Renders a fixed type error bar.
     * * percentage - Renders a percentage type error bar.
     * * standardDeviation - Renders a standard deviation type error bar.
     * * standardError -Renders a standard error type error bar.
     * * custom -Renders a custom type error bar.
     */
    export type ErrorBarType = 'Fixed' | 'Percentage' | 'StandardDeviation' | 'StandardError' | 'Custom';
    /**
     * Defines the direction of error bar. They are
     * * both -  Renders both direction of error bar.
     * * minus - Renders minus direction of error bar.
     * * plus - Renders plus direction error bar.
     */
    export type ErrorBarDirection = 'Both' | 'Minus' | 'Plus';
    /**
     * Defines the modes of error bar. They are
     * * vertical -  Renders a vertical error bar.
     * * horizontal - Renders a horizontal error bar.
     * * both - Renders both side error bar.
     */
    export type ErrorBarMode = 'Vertical' | 'Horizontal' | 'Both';
    /**
     * Defines the interval type of datetime axis. They are
     * * auto - Define the interval of the axis based on data.
     * * years - Define the interval of the axis in years.
     * * months - Define the interval of the axis in months.
     * * days - Define the interval of the axis in days.
     * * hours - Define the interval of the axis in hours.
     * * minutes - Define the interval of the axis in minutes.
     */
    export type IntervalType = 'Auto' | 'Years' | 'Months' | 'Days' | 'Hours' | 'Minutes' | 'Seconds';
    /**
     * Defines the mode of line in crosshair. They are
     * * none - Hides both vertical and horizontal crosshair line.
     * * both - Shows both vertical and horizontal crosshair line.
     * * vertical - Shows the vertical line.
     * * horizontal - Shows the horizontal line.
     */
    export type LineType = 'None' | 'Both' | 'Vertical' | 'Horizontal';
    export type MacdType = 'Line' | 'Histogram' | 'Both';
    /**
     * Defines the position of the legend. They are
     * * auto - Places the legend based on area type.
     * * top - Displays the legend on the top of chart.
     * * left - Displays the legend on the left of chart.
     * * bottom - Displays the legend on the bottom of chart.
     * * right - Displays the legend on the right of chart.
     * * custom - Displays the legend  based on given x and y value.
     */
    export type LegendPosition = 'Auto' | 'Top' | 'Left' | 'Bottom' | 'Right' | 'Custom';
    /**
     * Defines the shape of legend. They are
     * * circle - Renders a circle.
     * * rectangle - Renders a rectangle.
     * * triangle - Renders a triangle.
     * * diamond - Renders a diamond.
     * * cross - Renders a cross.
     * * horizontalLine - Renders a horizontalLine.
     * * verticalLine - Renders a verticalLine.
     * * pentagon - Renders a pentagon.
     * * invertedTriangle - Renders a invertedTriangle.
     * * SeriesType -Render a legend shape based on series type.
     */
    export type LegendShape = 'Circle' | 'Rectangle' | 'Triangle' | 'Diamond' | 'Cross' | 'HorizontalLine' | 'VerticalLine' | 'Pentagon' | 'InvertedTriangle' | 'SeriesType';
    /**
     * Defines the zooming mode, They are.
     * * x,y - Chart will be zoomed with respect to both vertical and horizontal axis.
     * * x - Chart will be zoomed with respect to horizontal axis.
     * * y - Chart will be zoomed with respect to vertical axis.
     */
    export type ZoomMode = 'XY' | 'X' | 'Y';
    /**
     * Defines the ZoomingToolkit, They are.
     * * zoom - Renders the zoom button.
     * * zoomIn - Renders the zoomIn button.
     * * zoomOut - Renders the zoomOut button.
     * * pan - Renders the pan button.
     * * reset - Renders the reset button.
     */
    export type ToolbarItems = 'Zoom' | 'ZoomIn' | 'ZoomOut' | 'Pan' | 'Reset';
    /**
     * Defines the SelectionMode, They are.
     * * none - Disable the selection.
     * * series - To select a series.
     * * point - To select a point.
     * * cluster - To select a cluster of point
     * * dragXY - To select points, by dragging with respect to both horizontal and vertical axis
     * * dragX - To select points, by dragging with respect to horizontal axis.
     * * dragY - To select points, by dragging with respect to vertical axis.
     */
    export type SelectionMode = 'None' | 'Series' | 'Point' | 'Cluster' | 'DragXY' | 'DragY' | 'DragX';
    /**
     * Defines the LabelPosition, They are.
     * * outer - Position the label outside the point.
     * * top - Position the label on top of the point.
     * * bottom - Position the label on bottom of the point.
     * * middle - Position the label to middle of the point.
     * * auto - Position the label based on series.
     */
    export type LabelPosition = 'Outer' | 'Top' | 'Bottom' | 'Middle' | 'Auto';
    /**
     * Defines the Alignment. They are
     * * none - Shows all the labels.
     * * hide - Hide the label when it intersect.
     * * rotate45 - Rotate the label to 45 degree when it intersect.
     * * rotate90 - Rotate the label to 90 degree when it intersect.
     * *
     */
    export type LabelIntersectAction = 'None' | 'Hide' | 'Trim' | 'Wrap' | 'MultipleRows' | 'Rotate45' | 'Rotate90';
    /**
     * Defines the Position. They are
     * * inside - Place the ticks or labels inside to the axis line.
     * * outside - Place the ticks or labels outside to the axis line.
     * *
     */
    export type AxisPosition = 'Inside' | 'Outside';
    /**
     * Defines Theme of the chart. They are
     * * Material - Render a chart with Material theme.
     * * Fabric - Render a chart with Fabric theme
     */
    export type ChartTheme = 'Material' | 'Fabric' | 'Bootstrap' | 'Highcontrast';
    /**
     *  Specifies the order of the strip line. `Over` | `Behind`.
     * * Over - Places the strip line over the series elements.
     * * Behind - laces the strip line behind the series elements.
     */
    export type ZIndex = 'Over' | 'Behind';
    /**
     * Defines the strip line text position.
     * * Start - Places the strip line text at the start.
     * * Middle - Places the strip line text in the middle.
     * * End - Places the strip line text at the end.
     */
    export type Anchor = 'Start' | 'Middle' | 'End';
    /**
     * Defines the empty point mode of the chart.
     * * Gap - Used to display empty points as space.
     * * Zero - Used to display empty points as zero.
     * * Drop - Used to ignore the empty point while rendering.
     * * Average - Used to display empty points as previous and next point average.
     */
    export type EmptyPointMode = 'Gap' | 'Zero' | 'Drop' | 'Average';
    /**
     * Defines the type of technical indicators. They are
     * * Sma - Predicts the trend using Simple Moving Average approach
     * * Ema - Predicts the trend using Exponential Moving Average approach
     * * Tma - Predicts the trend using Triangle Moving Average approach
     * * Atr - Predicts the trend using Average True Range approach
     * * AccumulationDistribution - Predicts the trend using Accumulation Distribution approach
     * * Momentum - Predicts the trend using Momentum approach
     * * Rsi - Predicts the trend using RSI approach
     * * Macd - Predicts the trend using Moving Average Convergence Divergence approach
     * * Stochastic - Predicts the trend using Stochastic approach
     * * BollingerBands - Predicts the trend using Bollinger approach
     */
    export type TechnicalIndicators = 'Sma' | 'Ema' | 'Tma' | 'Momentum' | 'Atr' | 'AccumulationDistribution' | 'BollingerBands' | 'Macd' | 'Stochastic' | 'Rsi';
    /**
     * Defines the type of trendlines. They are
     * * Linear - Defines the linear trendline
     * * Exponential - Defines the exponential trendline
     * * Polynomial - Defines the polynomial trendline
     * * Power - Defines the power trendline
     * * Logarithmic - Defines the logarithmic trendline
     * * MovingAverage - Defines the moving average trendline
     */
    export type TrendlineTypes = 'Linear' | 'Exponential' | 'Polynomial' | 'Power' | 'Logarithmic' | 'MovingAverage';
    /** @private */
    export type SeriesCategories = 'TrendLine' | 'Indicator' | 'Series';
    /**
     * Defines the financial data fields
     * * High - Represents the highest price in the stocks over time
     * * Low - Represents the lowest price in the stocks over time
     * * Open - Represents the opening price in the stocks over time
     * * Close - Represents the closing price in the stocks over time
     */
    export type FinancialDataFields = 'High' | 'Low' | 'Open' | 'Close';
    /**
     * It defines type of spline.
     * Natural - Used to render Natural spline.
     * Cardinal - Used to render cardinal spline.
     * Clamped - Used to render Clamped spline
     * Monotonic - Used to render monotonic spline
     */
    export type SplineType = 'Natural' | 'Monotonic' | 'Cardinal' | 'Clamped';
    /**
     * Defines the BoxPlotMode for box and whisker chart series, They are.
     * * exclusive - Series render based on exclusive mode.
     * * inclusive - Series render based on inclusive mode.
     * * normal - Series render based on normal mode.
     */
    export type BoxPlotMode = 'Exclusive' | 'Inclusive' | 'Normal';
    /**
     * Defines the skeleton type for the axis.
     * * Date - it formats date only.
     * * DateTime - it formats date and time.
     * * Time - it formats time only.
     */
    export type SkeletonType = 'Date' | 'DateTime' | 'Time';
    /**
     * Defines border type for multi level labels.
     *  * Rectangle
     *  * Brace
     *  * WithoutBorder
     *  * Without top Border
     *  * Without top and bottom border
     *  * Curly brace
     */
    export type BorderType = 'Rectangle' | 'Brace' | 'WithoutBorder' | 'WithoutTopBorder' | 'WithoutTopandBottomBorder' | 'CurlyBrace';
    
    /**
     * To get the data on mouse move.
     * @private
     */
    export class ChartData {
        /** @private */
        chart: Chart;
        lierIndex: number;
        /** @private */
        currentPoints: PointData[] | AccPointData[];
        /** @private */
        previousPoints: PointData[] | AccPointData[];
        /**
         * Constructor for the data.
         * @private
         */
        constructor(chart: Chart);
        /**
         * Method to get the Data.
         * @private
         */
        getData(): PointData;
        isSelected(chart: Chart): boolean;
        private getRectPoint(series, rect, x, y);
        /**
         * Checks whether the region contains a point
         */
        private checkRegionContainsPoint(regionRect, rect, x, y);
        private getClosest(series, value);
        getClosestX(chart: Chart, series: Series): PointData;
    }
    
    /**
     * Annotation Module handles the Annotation for chart and accumulation series.
     */
    export class AnnotationBase {
        private control;
        private annotation;
        private isChart;
        /**
         * Constructor for chart and accumulation annotation
         * @param control
         */
        constructor(control: Chart | AccumulationChart);
        /**
         * Method to render the annotation for chart and accumulation series.
         * @private
         * @param annotation
         * @param index
         */
        render(annotation: AccumulationAnnotationSettings | ChartAnnotationSettings, index: number): HTMLElement;
        /**
         * Method to calculate the location for annotation - coordinate unit as pixel.
         * @private
         * @param location
         */
        setAnnotationPixelValue(location: ChartLocation): boolean;
        /**
         * Method to calculate the location for annotation - coordinate unit as point.
         * @private
         * @param location
         */
        setAnnotationPointValue(location: ChartLocation): boolean;
        /**
         * To process the annotation for accumulation chart
         * @param annotation
         * @param index
         * @param parentElement
         */
        processAnnotation(annotation: ChartAnnotationSettings | AccumulationAnnotationSettings, index: number, parentElement: HTMLElement): void;
        /**
         * Method to calculate the location for annotation - coordinate unit as point in accumulation chart.
         * @private
         * @param location
         */
        setAccumulationPointValue(location: ChartLocation): boolean;
        /**
         * Method to set the element style for accumulation / chart annotation.
         * @private
         * @param location
         * @param element
         * @param parentElement
         */
        setElementStyle(location: ChartLocation, element: HTMLElement, parentElement: HTMLElement): void;
        /**
         * Method to calculate the alignment value for annotation.
         * @private
         * @param alignment
         * @param size
         * @param value
         */
        setAlignmentValue(alignment: Alignment | Position, size: number, value: number): number;
    }
    
    /**
     * Interface for a class Location
     */
    export interface LocationModel {
    
        /**
         * X coordinate of the legend in pixels.
         * @default 0
         */
        x?: number;
    
        /**
         * Y coordinate of the legend in pixels.
         * @default 0
         */
        y?: number;
    
    }
    
    /**
     * Interface for a class LegendSettings
     */
    export interface LegendSettingsModel {
    
        /**
         * If set to true, legend will be visible.
         * @default true
         */
        visible?: boolean;
    
        /**
         * The height of the legend in pixels.
         * @default null
         */
        height?: string;
    
        /**
         * The width of the legend in pixels.
         * @default null
         */
        width?: string;
    
        /**
         * Specifies the location of the legend, relative to the chart.
         * If x is 20, legend moves by 20 pixels to the right of the chart. It requires the `position` to be `Custom`.
         * ```html
         * <div id='Chart'></div>
         * ```
         * ```typescript
         * let chart: Chart = new Chart({
         * ...
         *   legendSettings: {
         *     visible: true,
         *     position: 'Custom',
         *     location: { x: 100, y: 150 },
         *   },
         * ...
         * });
         * chart.appendTo('#Chart');
         * ```
         */
        location?: LocationModel;
    
        /**
         * Position of the legend in the chart are,
         * * Auto: Places the legend based on area type.
         * * Top: Displays the legend at the top of the chart.
         * * Left: Displays the legend at the left of the chart.
         * * Bottom: Displays the legend at the bottom of the chart.
         * * Right: Displays the legend at the right of the chart.
         * * Custom: Displays the legend  based on the given x and y values.
         * @default 'Auto'
         */
        position?: LegendPosition;
    
        /**
         * Option to customize the padding between legend items.
         * @default 8
         */
        padding?: number;
    
        /**
         * Legend in chart can be aligned as follows:
         * * Near: Aligns the legend to the left of the chart.
         * * Center: Aligns the legend to the center of the chart.
         * * Far: Aligns the legend to the right of the chart.
         * @default 'Center'
         */
        alignment?: Alignment;
    
        /**
         * Options to customize the legend text.
         */
        textStyle?: FontModel;
    
        /**
         * Shape height of the legend in pixels.
         * @default 10
         */
        shapeHeight?: number;
    
        /**
         * Shape width of the legend in pixels.
         * @default 10
         */
        shapeWidth?: number;
    
        /**
         * Options to customize the border of the legend.
         */
        border?: BorderModel;
    
        /**
         * Padding between the legend shape and text.
         * @default 5
         */
        shapePadding?: number;
    
        /**
         * The background color of the legend that accepts value in hex and rgba as a valid CSS color string.
         * @default 'transparent'
         */
        background?: string;
    
        /**
         * Opacity of the legend.
         * @default 1
         */
        opacity?: number;
    
        /**
         * If set to true, series' visibility collapses based on the legend visibility.
         * @default true
         */
        toggleVisibility?: boolean;
    
        /**
         * Description for legends.
         * @default null
         */
        description?: string;
    
        /**
         * TabIndex value for the legend.
         * @default 3
         */
        tabIndex?: number;
    
    }
    
    /**
     * Interface for a class BaseLegend
     * @private
     */
    export interface BaseLegendModel {
    
    }
    
    /**
     * Interface for a class LegendOptions
     * @private
     */
    export interface LegendOptionsModel {
    
    }
    
    /**
     * Configures the location for the legend.
     */
    export class Location extends ej.base.ChildProperty<Location> {
        /**
         * X coordinate of the legend in pixels.
         * @default 0
         */
        x: number;
        /**
         * Y coordinate of the legend in pixels.
         * @default 0
         */
        y: number;
    }
    /**
     * Configures the legends in charts.
     */
    export class LegendSettings extends ej.base.ChildProperty<LegendSettings> {
        /**
         * If set to true, legend will be visible.
         * @default true
         */
        visible: boolean;
        /**
         * The height of the legend in pixels.
         * @default null
         */
        height: string;
        /**
         * The width of the legend in pixels.
         * @default null
         */
        width: string;
        /**
         * Specifies the location of the legend, relative to the chart.
         * If x is 20, legend moves by 20 pixels to the right of the chart. It requires the `position` to be `Custom`.
         * ```html
         * <div id='Chart'></div>
         * ```
         * ```typescript
         * let chart: Chart = new Chart({
         * ...
         *   legendSettings: {
         *     visible: true,
         *     position: 'Custom',
         *     location: { x: 100, y: 150 },
         *   },
         * ...
         * });
         * chart.appendTo('#Chart');
         * ```
         */
        location: LocationModel;
        /**
         * Position of the legend in the chart are,
         * * Auto: Places the legend based on area type.
         * * Top: Displays the legend at the top of the chart.
         * * Left: Displays the legend at the left of the chart.
         * * Bottom: Displays the legend at the bottom of the chart.
         * * Right: Displays the legend at the right of the chart.
         * * Custom: Displays the legend  based on the given x and y values.
         * @default 'Auto'
         */
        position: LegendPosition;
        /**
         * Option to customize the padding between legend items.
         * @default 8
         */
        padding: number;
        /**
         * Legend in chart can be aligned as follows:
         * * Near: Aligns the legend to the left of the chart.
         * * Center: Aligns the legend to the center of the chart.
         * * Far: Aligns the legend to the right of the chart.
         * @default 'Center'
         */
        alignment: Alignment;
        /**
         * Options to customize the legend text.
         */
        textStyle: FontModel;
        /**
         * Shape height of the legend in pixels.
         * @default 10
         */
        shapeHeight: number;
        /**
         * Shape width of the legend in pixels.
         * @default 10
         */
        shapeWidth: number;
        /**
         * Options to customize the border of the legend.
         */
        border: BorderModel;
        /**
         * Padding between the legend shape and text.
         * @default 5
         */
        shapePadding: number;
        /**
         * The background color of the legend that accepts value in hex and rgba as a valid CSS color string.
         * @default 'transparent'
         */
        background: string;
        /**
         * Opacity of the legend.
         * @default 1
         */
        opacity: number;
        /**
         * If set to true, series' visibility collapses based on the legend visibility.
         * @default true
         */
        toggleVisibility: boolean;
        /**
         * Description for legends.
         * @default null
         */
        description: string;
        /**
         * TabIndex value for the legend.
         * @default 3
         */
        tabIndex: number;
    }
    /**
     * Legend base class for Chart and Accumulation chart.
     * @private
     */
    export class BaseLegend {
        protected chart: Chart | AccumulationChart;
        protected legend: LegendSettingsModel;
        protected maxItemHeight: number;
        protected isPaging: boolean;
        private clipPathHeight;
        protected totalPages: number;
        protected isVertical: boolean;
        private rowCount;
        private columnCount;
        private pageButtonSize;
        protected pageXCollections: number[];
        protected maxColumns: number;
        private isTrimmed;
        maxWidth: number;
        protected legendID: string;
        private clipRect;
        private legendTranslateGroup;
        private currentPage;
        private isChartControl;
        protected library: Legend | AccumulationLegend;
        /**  @private */
        position: LegendPosition;
        /**
         * Gets the legend bounds in chart.
         * @private
         */
        legendBounds: Rect;
        /** @private */
        legendCollections: LegendOptions[];
        /** @private */
        clearTooltip: number;
        /**
         * Constructor for the dateTime module.
         * @private
         */
        constructor(chart?: Chart | AccumulationChart);
        /**
         * Calculate the bounds for the legends.
         * @return {void}
         * @private
         */
        calculateLegendBounds(rect: Rect, availableSize: Size): void;
        /**
         * To find legend position based on available size for chart and accumulation chart
         */
        private getPosition(position, availableSize);
        /**
         * To set bounds for chart and accumulation chart
         */
        protected setBounds(computedWidth: number, computedHeight: number, legend: LegendSettingsModel, legendBounds: Rect): void;
        /**
         * To find legend location based on position, alignment for chart and accumulation chart
         */
        private getLocation(position, alignment, legendBounds, rect, availableSize);
        /**
         * To find legend alignment for chart and accumulation chart
         */
        private alignLegend(start, size, legendSize, alignment);
        /**
         * Renders the legend.
         * @return {void}
         * @private
         */
        renderLegend(chart: Chart | AccumulationChart, legend: LegendSettingsModel, legendBounds: Rect): void;
        /**
         * To find first valid legend text index for chart and accumulation chart
         */
        private findFirstLegendPosition(legendCollection);
        /**
         * To create legend rendering elements for chart and accumulation chart
         */
        private createLegendElements(chart, legendBounds, legendGroup, legend, id);
        /**
         * To render legend symbols for chart and accumulation chart
         */
        private renderSymbol(legendOption, group, i);
        /**
         * To render legend text for chart and accumulation chart
         */
        private renderText(chart, legendOption, group, textOptions, i);
        /**
         * To render legend paging elements for chart and accumulation chart
         */
        private renderPagingElements(chart, bounds, textOption, legendGroup);
        /**
         * To translate legend pages for chart and accumulation chart
         */
        protected translatePage(pagingText: Element, page: number, pageNumber: number): void;
        /**
         * To change legend pages for chart and accumulation chart
         */
        protected changePage(event: Event, pageUp: boolean): void;
        /**
         * To find legend elements id based on chart or accumulation chart
         * @private
         */
        generateId(option: LegendOptions, prefix: string, count: number): string;
        /**
         * To show or hide trimmed text tooltip for legend.
         * @return {void}
         * @private
         */
        move(event: Event): void;
    }
    /**
     * Class for legend options
     * @private
     */
    export class LegendOptions {
        render: boolean;
        text: string;
        fill: string;
        shape: LegendShape;
        visible: boolean;
        type: ChartSeriesType | AccumulationType;
        textSize: Size;
        location: ChartLocation;
        pointIndex?: number;
        seriesIndex?: number;
        markerShape?: ChartShape;
        markerVisibility?: boolean;
        constructor(text: string, fill: string, shape: LegendShape, visible: boolean, type: ChartSeriesType | AccumulationType, markerShape?: ChartShape, markerVisibility?: boolean, pointIndex?: number, seriesIndex?: number);
    }
    
    /**
     * Interface for a class Connector
     */
    export interface ConnectorModel {
    
        /**
         * specifies the type of the connector line. They are
         * * Smooth
         * * Line
         * @default 'Line'
         */
        type?: ConnectorType;
    
        /**
         * Color of the connector line.
         * @default null
         */
        color?: string;
    
        /**
         * Width of the connector line in pixels.
         * @default 1
         */
        width?: number;
    
        /**
         * Length of the connector line in pixels.
         * @default null
         */
        length?: string;
    
        /**
         * dashArray of the connector line.
         * @default ''
         */
        dashArray?: string;
    
    }
    
    /**
     * Interface for a class Font
     */
    export interface FontModel {
    
        /**
         * Font size for the text.
         * @default '16px'
         */
        size?: string;
    
        /**
         * Color for the text.
         * @default ''
         */
        color?: string;
    
        /**
         * FontFamily for the text.
         */
        fontFamily?: string;
    
        /**
         * FontWeight for the text.
         * @default 'Normal'
         */
        fontWeight?: string;
    
        /**
         * FontStyle for the text.
         * @default 'Normal'
         */
        fontStyle?: string;
    
        /**
         * Opacity for the text.
         * @default 1
         */
        opacity?: number;
    
        /**
         * text alignment
         * @default 'Center'
         */
        textAlignment?: Alignment;
    
        /**
         * Specifies the chart title text overflow
         * @default 'Trim'
         */
        textOverflow?: TextOverflow;
    
    }
    
    /**
     * Interface for a class Border
     */
    export interface BorderModel {
    
        /**
         * The color of the border that accepts value in hex and rgba as a valid CSS color string.
         * @default ''
         */
        color?: string;
    
        /**
         * The width of the border in pixels.
         * @default 1
         */
        width?: number;
    
    }
    
    /**
     * Interface for a class ChartArea
     */
    export interface ChartAreaModel {
    
        /**
         * Options to customize the border of the chart area.
         */
        border?: BorderModel;
    
        /**
         * The background of the chart area that accepts value in hex and rgba as a valid CSS color string..
         * @default transparent
         */
        background?: string;
    
        /**
         * The opacity for background.
         * @default 1
         */
        opacity?: number;
    
    }
    
    /**
     * Interface for a class Margin
     */
    export interface MarginModel {
    
        /**
         * Left margin in pixels.
         * @default 10
         */
        left?: number;
    
        /**
         * Right margin in pixels.
         * @default 10
         */
        right?: number;
    
        /**
         * Top margin in pixels.
         * @default 10
         */
        top?: number;
    
        /**
         * Bottom margin in pixels.
         * @default 10
         */
        bottom?: number;
    
    }
    
    /**
     * Interface for a class Animation
     */
    export interface AnimationModel {
    
        /**
         * If set to true, series gets animated on initial loading.
         * @default true
         */
    
        enable?: boolean;
    
        /**
         * The duration of animation in milliseconds.
         * @default 1000
         */
    
        duration?: number;
    
        /**
         * The option to delay animation of the series.
         * @default 0
         */
    
        delay?: number;
    
    }
    
    /**
     * Interface for a class Indexes
     * @private
     */
    export interface IndexesModel {
    
        /**
         * Specifies the series index
         * @default 0
         */
        series?: number;
    
        /**
         * Specifies the point index
         * @default 0
         */
        point?: number;
    
    }
    
    /**
     * Interface for a class CornerRadius
     */
    export interface CornerRadiusModel {
    
        /**
         * Specifies the top left corner radius value
         * @default 0
         */
        topLeft?: number;
    
        /**
         * Specifies the top right corner radius value
         * @default 0
         */
        topRight?: number;
    
        /**
         * Specifies the bottom left corner radius value
         * @default 0
         */
        bottomLeft?: number;
    
        /**
         * Specifies the bottom right corner radius value
         * @default 0
         */
        bottomRight?: number;
    
    }
    
    /**
     * Interface for a class Index
     * @private
     */
    export interface IndexModel {
    
    }
    
    /**
     * Interface for a class EmptyPointSettings
     */
    export interface EmptyPointSettingsModel {
    
        /**
         * To customize the fill color of empty points.
         * @default null
         */
        fill?: string;
    
        /**
         * Options to customize the border of empty points.
         * @default "{color: 'transparent', width: 0}"
         */
        border?: BorderModel;
    
        /**
         * To customize the mode of empty points.
         * @default Gap
         */
        mode?: EmptyPointMode | AccEmptyPointMode;
    
    }
    
    /**
     * Interface for a class TooltipSettings
     */
    export interface TooltipSettingsModel {
    
        /**
         * Enables / Disables the visibility of the tooltip.
         * @default false.
         */
    
        enable?: boolean;
    
        /**
         * If set to true, a single ToolTip will be displayed for every index.
         * @default false.
         */
    
        shared?: boolean;
    
        /**
         * The fill color of the tooltip that accepts value in hex and rgba as a valid CSS color string. 
         */
    
        fill?: string;
    
        /**
         * Header for tooltip. 
         */
    
        header?: string;
    
        /**
         * The fill color of the tooltip that accepts value in hex and rgba as a valid CSS color string. 
         */
    
        opacity?: number;
    
        /**
         * Options to customize the ToolTip text.
         */
    
        textStyle?: FontModel;
    
        /**
         * Format the ToolTip content.
         * @default null.
         */
    
        format?: string;
    
        /**
         * Custom template to format the ToolTip content. Use ${x} and ${y} as the placeholder text to display the corresponding data point.
         * @default null.
         */
    
        template?: string;
    
        /**
         * If set to true, ToolTip will animate while moving from one point to another.
         * @default true.
         */
        enableAnimation?: boolean;
    
        /**
         * Options to customize tooltip borders.
         */
        border?: BorderModel;
    
    }
    
    /**
     * Defines the appearance of the connectors
     */
    export class Connector extends ej.base.ChildProperty<Connector> {
        /**
         * specifies the type of the connector line. They are
         * * Smooth
         * * Line
         * @default 'Line'
         */
        type: ConnectorType;
        /**
         * Color of the connector line.
         * @default null
         */
        color: string;
        /**
         * Width of the connector line in pixels.
         * @default 1
         */
        width: number;
        /**
         * Length of the connector line in pixels.
         * @default null
         */
        length: string;
        /**
         * dashArray of the connector line.
         * @default ''
         */
        dashArray: string;
    }
    /**
     * Configures the fonts in charts.
     */
    export class Font extends ej.base.ChildProperty<Font> {
        /**
         * Font size for the text.
         * @default '16px'
         */
        size: string;
        /**
         * Color for the text.
         * @default ''
         */
        color: string;
        /**
         * FontFamily for the text.
         */
        fontFamily: string;
        /**
         * FontWeight for the text.
         * @default 'Normal'
         */
        fontWeight: string;
        /**
         * FontStyle for the text.
         * @default 'Normal'
         */
        fontStyle: string;
        /**
         * Opacity for the text.
         * @default 1
         */
        opacity: number;
        /**
         * text alignment
         * @default 'Center'
         */
        textAlignment: Alignment;
        /**
         * Specifies the chart title text overflow
         * @default 'Trim'
         */
        textOverflow: TextOverflow;
    }
    /**
     * Configures the borders in the chart.
     */
    export class Border extends ej.base.ChildProperty<Border> {
        /**
         * The color of the border that accepts value in hex and rgba as a valid CSS color string.
         * @default ''
         */
        color: string;
        /**
         * The width of the border in pixels.
         * @default 1
         */
        width: number;
    }
    /**
     * Configures the chart area.
     */
    export class ChartArea extends ej.base.ChildProperty<ChartArea> {
        /**
         * Options to customize the border of the chart area.
         */
        border: BorderModel;
        /**
         * The background of the chart area that accepts value in hex and rgba as a valid CSS color string..
         * @default transparent
         */
        background: string;
        /**
         * The opacity for background.
         * @default 1
         */
        opacity: number;
    }
    /**
     * Configures the chart margins.
     */
    export class Margin extends ej.base.ChildProperty<Margin> {
        /**
         * Left margin in pixels.
         * @default 10
         */
        left: number;
        /**
         * Right margin in pixels.
         * @default 10
         */
        right: number;
        /**
         * Top margin in pixels.
         * @default 10
         */
        top: number;
        /**
         * Bottom margin in pixels.
         * @default 10
         */
        bottom: number;
    }
    /**
     * Configures the animation behavior for chart series.
     */
    export class Animation extends ej.base.ChildProperty<Animation> {
        /**
         * If set to true, series gets animated on initial loading.
         * @default true
         */
        enable: boolean;
        /**
         * The duration of animation in milliseconds.
         * @default 1000
         */
        duration: number;
        /**
         * The option to delay animation of the series.
         * @default 0
         */
        delay: number;
    }
    /** @private */
    export class Indexes extends ej.base.ChildProperty<Indexes> {
        /**
         * Specifies the series index
         * @default 0
         */
        series: number;
        /**
         * Specifies the point index
         * @default 0
         */
        point: number;
    }
    /**
     * Column series rounded corner options
     */
    export class CornerRadius extends ej.base.ChildProperty<CornerRadius> {
        /**
         * Specifies the top left corner radius value
         * @default 0
         */
        topLeft: number;
        /**
         * Specifies the top right corner radius value
         * @default 0
         */
        topRight: number;
        /**
         * Specifies the bottom left corner radius value
         * @default 0
         */
        bottomLeft: number;
        /**
         * Specifies the bottom right corner radius value
         * @default 0
         */
        bottomRight: number;
    }
    /**
     * @private
     */
    export class Index {
        series: number;
        point: number;
        constructor(seriesIndex: number, pointIndex?: number);
    }
    /**
     * Configures the Empty Points of series
     */
    export class EmptyPointSettings extends ej.base.ChildProperty<EmptyPointSettings> {
        /**
         * To customize the fill color of empty points.
         * @default null
         */
        fill: string;
        /**
         * Options to customize the border of empty points.
         * @default "{color: 'transparent', width: 0}"
         */
        border: BorderModel;
        /**
         * To customize the mode of empty points.
         * @default Gap
         */
        mode: EmptyPointMode | AccEmptyPointMode;
    }
    /**
     * Configures the ToolTips in the chart.
     */
    export class TooltipSettings extends ej.base.ChildProperty<TooltipSettings> {
        /**
         * Enables / Disables the visibility of the tooltip.
         * @default false.
         */
        enable: boolean;
        /**
         * If set to true, a single ToolTip will be displayed for every index.
         * @default false.
         */
        shared: boolean;
        /**
         * The fill color of the tooltip that accepts value in hex and rgba as a valid CSS color string.
         */
        fill: string;
        /**
         * Header for tooltip.
         */
        header: string;
        /**
         * The fill color of the tooltip that accepts value in hex and rgba as a valid CSS color string.
         */
        opacity: number;
        /**
         * Options to customize the ToolTip text.
         */
        textStyle: FontModel;
        /**
         * Format the ToolTip content.
         * @default null.
         */
        format: string;
        /**
         * Custom template to format the ToolTip content. Use ${x} and ${y} as the placeholder text to display the corresponding data point.
         * @default null.
         */
        template: string;
        /**
         * If set to true, ToolTip will animate while moving from one point to another.
         * @default true.
         */
        enableAnimation: boolean;
        /**
         * Options to customize tooltip borders.
         */
        border: BorderModel;
    }
    
    /**
     * Specifies the chart constant value
     */
    /** @private */
    export const loaded: string;
    /** @private */
    export const load: string;
    /** @private */
    export const animationComplete: string;
    /** @private */
    export const legendRender: string;
    /** @private */
    export const textRender: string;
    /** @private */
    export const pointRender: string;
    /** @private */
    export const seriesRender: string;
    /** @private */
    export const axisLabelRender: string;
    /** @private */
    export const axisRangeCalculated: string;
    /** @private */
    export const axisMultiLabelRender: string;
    /** @private */
    export const tooltipRender: string;
    /** @private */
    export const chartMouseMove: string;
    /** @private */
    export const chartMouseClick: string;
    /** @private */
    export const pointClick: string;
    /** @private */
    export const pointMove: string;
    /** @private */
    export const chartMouseLeave: string;
    /** @private */
    export const chartMouseDown: string;
    /** @private */
    export const chartMouseUp: string;
    /** @private */
    export const zoomComplete: string;
    /** @private */
    export const dragComplete: string;
    /** @private */
    export const resized: string;
    /** @private */
    export const beforePrint: string;
    /** @private */
    export const annotationRender: string;
    
    /**
     * data module is used to generate query and dataSource
     */
    export class Data {
        private dataManager;
        private query;
        /**
         * Constructor for data module
         * @private
         */
        constructor(dataSource?: Object | ej.data.DataManager, query?: ej.data.Query);
        /**
         * The function used to initialize dataManager and query
         * @return {void}
         * @private
         */
        initDataManager(dataSource: Object | ej.data.DataManager, query: ej.data.Query): void;
        /**
         * The function used to generate updated Query from chart model
         * @return {void}
         * @private
         */
        generateQuery(): ej.data.Query;
        /**
         * The function used to get dataSource by executing given Query
         * @param  {Query} query - A Query that specifies to generate dataSource
         * @return {void}
         * @private
         */
        getData(query: ej.data.Query): Promise<Object>;
    }
    
    export interface IChartEventArgs {
        /** Defines the name of the event */
        name: string;
        /** Defines the event cancel status */
        cancel: boolean;
    }
    export interface ILegendRenderEventArgs extends IChartEventArgs {
        /** Defines the current legend text */
        text: string;
        /** Defines the current legend fill color */
        fill: string;
        /** Defines the current legend shape */
        shape: LegendShape;
        /** Defines the current legend marker shape */
        markerShape?: ChartShape;
    }
    export interface IAccLegendRenderEventArgs extends IChartEventArgs {
        /** Defines the current legend shape */
        shape: LegendShape;
        /** Defines the current legend fill color */
        fill: string;
        /** Defines the current legend text */
        text: string;
    }
    export interface ITextRenderEventArgs extends IChartEventArgs {
        /** Defines the current series of the label */
        series: SeriesModel;
        /** Defines the current point of the label */
        point: Points;
        /** Defines the current text */
        text: string;
        /** Defines the current label fill color */
        color: string;
        /** Defines the current label border */
        border: BorderModel;
        /** Defines the current label template */
        template: string;
    }
    export interface IAnnotationRenderEventArgs extends IChartEventArgs {
        /** Defines the current annotation content */
        content: HTMLElement;
        /** Defines the current annotation location */
        location: ChartLocation;
    }
    export interface IZoomCompleteEventArgs extends IChartEventArgs {
        /** Defines the zoomed axis */
        axis: AxisModel;
        /** Defines the previous zoom factor */
        previousZoomFactor: number;
        /** Defines the previous zoom position */
        previousZoomPosition: number;
        /** Defines the current zoom factor */
        currentZoomFactor: number;
        /** Defines the current zoom position */
        currentZoomPosition: number;
    }
    export interface IPointRenderEventArgs extends IChartEventArgs {
        /** Defines the current series of the point */
        series: Series;
        /** Defines the current point */
        point: Points;
        /** Defines the current point fill color */
        fill: string;
        /** Defines the current point border */
        border: BorderModel;
        /** Defines the current point height */
        height?: number;
        /** Defines the current point width */
        width?: number;
        /** Defines the current point marker shape */
        shape?: ChartShape;
    }
    export interface ISeriesRenderEventArgs {
        /** Defines the current series */
        series: Series;
        /** Defines the current series data object */
        data: Object;
        /** Defines name of the event */
        name: string;
        /** Defines the current series fill */
        fill: string;
    }
    export interface IAxisLabelRenderEventArgs extends IChartEventArgs {
        /** Defines the current axis */
        axis: Axis;
        /** Defines axis current label text */
        text: string;
        /** Defines axis current label value */
        value: number;
        /** Defines axis current label font style */
        labelStyle: FontModel;
    }
    export interface IAxisRangeCalculatedEventArgs extends IChartEventArgs {
        /** Defines the current axis */
        axis: Axis;
        /** Defines axis current range */
        minimum: number;
        /** Defines axis current range */
        maximum: number;
        /** Defines axis current interval */
        interval: number;
    }
    export interface IAxisMultiLabelRenderEventArgs extends IChartEventArgs {
        /** Defines the current axis */
        axis: Axis;
        /** Defines axis current label text */
        text: string;
        /** Defines font style for multi labels */
        textStyle: FontModel;
        /** Defines text alignment for multi labels */
        alignment: Alignment;
    }
    export interface ITooltipRenderEventArgs extends IChartEventArgs {
        /** Defines tooltip text collections */
        text?: string;
        /** Defines tooltip text style */
        textStyle?: FontModel;
        /** Defines current tooltip series */
        series: Series | AccumulationSeries;
        /** Defines current tooltip point */
        point: Points | AccPoints;
    }
    export interface IMouseEventArgs extends IChartEventArgs {
        /** Defines current mouse event target id */
        target: string;
        /** Defines current mouse x location */
        x: number;
        /** Defines current mouse y location */
        y: number;
    }
    export interface IPointEventArgs extends IChartEventArgs {
        /** Defines the current series */
        series: SeriesModel;
        /** Defines the current point */
        point: Points;
        /** Defines the point index */
        pointIndex: number;
        /** Defines the series index */
        seriesIndex: number;
        /** Defines the current chart instance */
        chart: Chart;
        /** Defines current mouse x location */
        x: number;
        /** Defines current mouse y location */
        y: number;
    }
    /** @private */
    export interface IFontMapping {
        size?: string;
        color?: string;
        fontWeight?: string;
        fontStyle?: string;
        fontFamily?: string;
    }
    /** @private */
    export interface ITouches {
        pageX?: number;
        pageY?: number;
        pointerId?: number;
    }
    /** @private */
    export interface IShapes {
        renderOption?: Object;
        functionName?: string;
    }
    /** @private */
    export interface IZoomAxisRange {
        actualMin?: number;
        actualDelta?: number;
        min?: number;
        delta?: number;
    }
    export interface IDragCompleteEventArgs extends IChartEventArgs {
        /** Defines current selected Data X, Y values */
        selectedDataValues: {
            x: string;
            y: number;
        }[][];
    }
    export interface ILoadedEventArgs extends IChartEventArgs {
        /** Defines the current chart instance */
        chart: Chart;
    }
    export interface IAnimationCompleteEventArgs extends IChartEventArgs {
        /** Defines the current animation series */
        series: Series;
    }
    export interface IPrintEventArgs extends IChartEventArgs {
        htmlContent: Element;
    }
    /** @private */
    export interface IBoxPlotQuartile {
        minimum: number;
        maximum: number;
        outliers: number[];
        upperQuartile: number;
        lowerQuartile: number;
        average: number;
        median: number;
    }
    /** @private */
    /**
     * Specifies the Theme style for chart and accumulation.
     */
    export interface IThemeStyle {
        axisLabel: string;
        axisTitle: string;
        axisLine: string;
        majorGridLine: string;
        minorGridLine: string;
        majorTickLine: string;
        minorTickLine: string;
        chartTitle: string;
        legendLabel: string;
        background: string;
        areaBorder: string;
        errorBar: string;
        crosshairLine: string;
        crosshairFill: string;
        crosshairLabel: string;
        tooltipFill: string;
        tooltipBoldLabel: string;
        tooltipLightLabel: string;
        tooltipHeaderLine: string;
        markerShadow: string;
        selectionRectFill: string;
        selectionRectStroke: string;
        selectionCircleStroke: string;
    }
    
    /**
     * Specifies Chart Themes
     */
    export namespace Theme {
        /** @private */
        let axisLabelFont: IFontMapping;
        /** @private */
        let axisTitleFont: IFontMapping;
        /** @private */
        let chartTitleFont: IFontMapping;
        /** @private */
        let crosshairLabelFont: IFontMapping;
        /** @private */
        let tooltipLabelFont: IFontMapping;
        /** @private */
        let legendLabelFont: IFontMapping;
        /** @private */
        let stripLineLabelFont: IFontMapping;
    }
    /** @private */
    export function getSeriesColor(theme: ChartTheme | AccumulationTheme): string[];
    /** @private */
    export function getThemeColor(theme: ChartTheme | AccumulationTheme): IThemeStyle;
    
    /**
     * Selection Module handles the selection for chart.
     * @private
     */
    export class BaseSelection {
        protected styleId: string;
        protected unselected: string;
        protected control: Chart | AccumulationChart;
        constructor(control: Chart | AccumulationChart);
        /**
         * To create selection styles for series
         */
        protected seriesStyles(): void;
        /**
         * To concat indexes
         */
        protected concatIndexes(userIndexes: IndexesModel[], localIndexes: Indexes[]): Indexes[];
        /**
         * Selected points series visibility checking on legend click
         */
        protected checkVisibility(selectedIndexes: Indexes[]): boolean;
        /**
         * To add svg element style class
         * @private
         */
        addSvgClass(element: Element, className: string): void;
        /**
         * To remove svg element style class
         * @private
         */
        removeSvgClass(element: Element, className: string): void;
        /**
         * To get children from parent element
         */
        protected getChildren(parent: Element): Element[];
    }
    
    /**
     * Tooltip Module used to render the tooltip for series.
     */
    export class BaseTooltip extends ChartData {
        element: HTMLElement;
        elementSize: Size;
        textStyle: FontModel;
        isRemove: boolean;
        toolTipInterval: number;
        padding: number;
        arrowPadding: number;
        textElements: Element[];
        templateFn: Function;
        rx: number;
        ry: number;
        isComplete: boolean;
        inverted: boolean;
        formattedText: string[];
        header: string;
        markerPoint: number[];
        /** @private */
        valueX: number;
        /** @private */
        valueY: number;
        tipRadius: number;
        control: AccumulationChart | Chart;
        /**
         * Constructor for tooltip module.
         * @private.
         */
        constructor(chart: Chart | AccumulationChart);
        getElement(id: string): HTMLElement;
        /**
         * Renders the tooltip.
         * @return {void}
         * @private
         */
        getTooltipElement(isTooltip: HTMLElement): HTMLDivElement;
        private createElement(chart);
        pushData(data: PointData | AccPointData, isFirst: boolean, tooltipDiv: HTMLDivElement, isChart: boolean): boolean;
        renderTooltip(data: PointData | AccPointData, areaRect: Rect, location: ChartLocation, textCollection: string, isFirst: boolean, cartesain: boolean): Side;
        renderTemplate(data: PointData | AccPointData, rect: Rect, location: ChartLocation, point: Points | AccPoints, isFirst: boolean): void;
        renderTooltipElement(chart: Chart | AccumulationChart, pointData: PointData | AccPointData, areaRect: Rect, location: ChartLocation, cartesain: boolean, isFirst: boolean): Side;
        private changeText(point, isBottom, isRight, rect);
        renderText(isRender: boolean, chart: Chart | AccumulationChart): void;
        private createTemplate(point, data, areaRect, location, parent, isFirst);
        private sharedTooltipLocation(bounds, x, y);
        private seriesTooltipLocation(pointData, bounds, symbolLocation, arrowLocation, tipLocation);
        progressAnimation(element: HTMLElement, tooltipGroup: HTMLElement, series: Series | AccumulationSeries, opacity: number, rectOpacity: number, timeStamp: number, isRect: boolean, shared: boolean): void;
        endAnimation(element: HTMLElement, tooltipGroup: HTMLElement, series: Series | AccumulationSeries, shared: boolean): void;
        removeHighlight(chart: Chart | AccumulationChart): void;
        highlightPoint(series: Series | AccumulationSeries, pointIndex: number, highlight: boolean): void;
        highlightPoints(item: PointData | AccPointData): void;
        private animateTooltipDiv(tooltipDiv, rect);
        private updateDiv(tooltipDiv, x, y);
        triggerEvent(point: PointData | AccPointData, isFirst: boolean, textCollection: string, firstText?: boolean): boolean;
        removeText(): void;
        private updateTemplateFn(chart);
        stopAnimation(): void;
    }
    export class Side {
        isRight: boolean;
        isBottom: boolean;
        constructor(bottom: boolean, right: boolean);
    }
    
    /**
     * Defines Coordinate units of an annotation. They are
     * * Pixel
     * * Point
     */
    export type Units = 'Pixel' | 'Point';
    /**
     * Defines the Alignment. They are
     * * near - Align the element to the left.
     * * center - Align the element to the center.
     * * far - Align the element to the right.
     * *
     */
    export type Alignment = 'Near' | 'Center' | 'Far';
    /**
     * Defines regions of an annotation. They are
     * * Chart
     * * Series
     */
    export type Regions = 'Chart' | 'Series';
    /**
     * Defines the Position. They are
     * * top - Align the element to the top.
     * * middle - Align the element to the center.
     * * bottom - Align the element to the bottom.
     * *
     */
    export type Position = 'Top' | 'Middle' | 'Bottom';
    /**
     * Defines the export file format.
     * * PNG - export the image file format as png.
     * * JPEG - export the image file format as jpeg.
     */
    export type ExportType = 'PNG' | 'JPEG' | 'SVG' | 'PDF';
    /**
     * Defines the Text overflow.
     * * None - Shown the chart title with overlap if exceed.
     * * Wrap - Shown the chart title with wrap if exceed.
     * * Trim - Shown the chart title with trim if exceed.
     */
    export type TextOverflow = 'None' | 'Wrap' | 'Trim';
    
    /**
     * Annotation Module handles the Annotation for chart and accumulation series.
     */
    export class ExportUtils {
        private control;
        private printWindow;
        /**
         * Constructor for chart and accumulation annotation
         * @param control
         */
        constructor(control: Chart | AccumulationChart);
        /**
         * To print the accumulation and chart elements
         * @param elements
         */
        print(elements?: string[] | string | Element): void;
        /**
         * To get the html string of the chart and accumulation
         * @param elements
         * @private
         */
        getHTMLContent(elements?: string[] | string | Element): Element;
        /**
         * To export the file as image/svg format
         * @param type
         * @param fileName
         */
        export(type: ExportType, fileName: string, orientation?: ej.pdfexport.PdfPageOrientation): void;
        /**
         * To trigger the download element
         * @param fileName
         * @param type
         * @param url
         */
        triggerDownload(fileName: string, type: ExportType, url: string, isDownload: boolean): void;
    }
    
    /**
     * Methods for calculating the text size.
     */
    /**
     * Function to measure the height and width of the text.
     * @param  {string} text
     * @param  {FontModel} font
     * @param  {string} id
     * @returns no
     * @private
     */
    export function measureText(text: string, font: FontModel): Size;
    /**
     * Function to sort the dataSource, by default it sort the data in ascending order.
     * @param  {Object} data
     * @param  {string} fields
     * @param  {boolean} isDescending
     * @returns Object
     */
    export function sort(data: Object[], fields: string[], isDescending?: boolean): Object[];
    /** @private */
    export function rotateTextSize(font: FontModel, text: string, angle: number, chart: Chart): Size;
    /** @private */
    export function removeElement(id: string): void;
    /** @private */
    export function logBase(value: number, base: number): number;
    /** @private */
    export function showTooltip(text: string, x: number, y: number, areaWidth: number, id: string, element: Element, isTouch?: boolean): void;
    /** @private */
    export function inside(value: number, range: VisibleRangeModel): boolean;
    /** @private */
    export function withIn(value: number, range: VisibleRangeModel): boolean;
    /** @private */
    export function withInRange(previousPoint: Points, currentPoint: Points, nextPoint: Points, series: Series): boolean;
    /** @private */
    export function sum(values: number[]): number;
    /** @private */
    export function subArraySum(values: Object[], first: number, last: number, index: number[], series: Series): number;
    /** @private */
    export function subtractThickness(rect: Rect, thickness: Thickness): Rect;
    /** @private */
    export function subtractRect(rect: Rect, thickness: Rect): Rect;
    /** @private */
    export function degreeToLocation(degree: number, radius: number, center: ChartLocation): ChartLocation;
    /** @private */
    export function getAngle(center: ChartLocation, point: ChartLocation): number;
    /** @private */
    export function subArray(values: number[], index: number): number[];
    /** @private */
    export function valueToCoefficient(value: number, axis: Axis): number;
    /** @private */
    export function TransformToVisible(x: number, y: number, xAxis: Axis, yAxis: Axis, isInverted?: boolean, series?: Series): ChartLocation;
    /**
     * method to find series, point index by element id
     * @private
     */
    export function indexFinder(id: string): Index;
    /** @private */
    export function CoefficientToVector(coefficient: number, startAngle: number): ChartLocation;
    /** @private */
    export function valueToPolarCoefficient(value: number, axis: Axis): number;
    /** @private */
    export class Mean {
        verticalStandardMean: number;
        horizontalStandardMean: number;
        verticalSquareRoot: number;
        horizontalSquareRoot: number;
        verticalMean: number;
        horizontalMean: number;
        constructor(verticalStandardMean: number, verticalSquareRoot: number, horizontalStandardMean: number, horizontalSquareRoot: number, verticalMean: number, horizontalMean: number);
    }
    /** @private */
    export class PolarArc {
        startAngle: number;
        endAngle: number;
        innerRadius: number;
        radius: number;
        currentXPosition: number;
        constructor(startAngle?: number, endAngle?: number, innerRadius?: number, radius?: number, currentXPosition?: number);
    }
    /** @private */
    export function createTooltip(id: string, text: string, top: number, left: number, fontSize: string): void;
    /** @private */
    export function createZoomingLabels(chart: Chart, axis: Axis, parent: Element, index: number, isVertical: boolean, rect: Rect): Element;
    /** @private */
    export function withInBounds(x: number, y: number, bounds: Rect, width?: number, height?: number): boolean;
    /** @private */
    export function getValueXByPoint(value: number, size: number, axis: Axis): number;
    /** @private */
    export function getValueYByPoint(value: number, size: number, axis: Axis): number;
    /** @private */
    export function findClipRect(series: Series): void;
    /** @private */
    export function firstToLowerCase(str: string): string;
    /** @private */
    export function getMinPointsDelta(axis: Axis, seriesCollection: Series[]): number;
    /** @private */
    export function getAnimationFunction(effect: string): Function;
    /**
     * Animation Effect Calculation Started Here
     * @param currentTime
     * @param startValue
     * @param endValue
     * @param duration
     * @private
     */
    export function linear(currentTime: number, startValue: number, endValue: number, duration: number): number;
    /**
     * Animation Effect Calculation End
     * @private
     */
    export function markerAnimate(element: Element, delay: number, duration: number, series: Series | AccumulationSeries, pointIndex: number, point: ChartLocation, isLabel: boolean): void;
    /**
     * Animation for template
     * @private
     */
    export function templateAnimate(element: Element, delay: number, duration: number, name: ej.base.Effect, isRemove?: boolean): void;
    /** @private */
    export function drawSymbol(location: ChartLocation, shape: string, size: Size, url: string, options: PathOption, label: string): Element;
    /** @private */
    export function calculateShapes(location: ChartLocation, size: Size, shape: string, options: PathOption, url: string): IShapes;
    /** @private */
    export function getRectLocation(startLocation: ChartLocation, endLocation: ChartLocation, outerRect: Rect): Rect;
    /** @private */
    export function minMax(value: number, min: number, max: number): number;
    /** @private */
    export function getElement(id: string): Element;
    /** @private */
    export function getTemplateFunction(template: string): Function;
    /** @private */
    export function createTemplate(childElement: HTMLElement, pointIndex: number, content: string, chart: Chart | AccumulationChart, point?: Points | AccPoints, series?: Series | AccumulationSeries): HTMLElement;
    /** @private */
    export function getFontStyle(font: FontModel): string;
    /** @private */
    export function measureElementRect(element: HTMLElement): ClientRect;
    /** @private */
    export function findlElement(elements: NodeList, id: string): Element;
    /** @private */
    export function getPoint(x: number, y: number, xAxis: Axis, yAxis: Axis, isInverted?: boolean, series?: Series): ChartLocation;
    /** @private */
    export function appendElement(child: Element, parent: Element): void;
    /** @private */
    export function getDraggedRectLocation(x1: number, y1: number, x2: number, y2: number, outerRect: Rect): Rect;
    /** @private */
    export function checkBounds(start: number, size: number, min: number, max: number): number;
    /** @private */
    export function getLabelText(currentPoint: Points, series: Series, chart: Chart): string[];
    /** @private */
    export function stopTimer(timer: number): void;
    /** @private */
    export function isCollide(rect: Rect, collections: Rect[], clipRect: Rect): boolean;
    /** @private */
    export function isOverlap(currentRect: Rect, rect: Rect): boolean;
    /** @private */
    export function containsRect(currentRect: Rect, rect: Rect): boolean;
    /** @private */
    export function calculateRect(location: ChartLocation, textSize: Size, margin: MarginModel): Rect;
    /** @private */
    export function convertToHexCode(value: ColorValue): string;
    /** @private */
    export function componentToHex(value: number): string;
    /** @private */
    export function convertHexToColor(hex: string): ColorValue;
    /** @private */
    export function colorNameToHex(color: string): string;
    /** @private */
    export function getSaturationColor(color: string, factor: number): string;
    /** @private */
    export function getMedian(values: number[]): number;
    /** @private */
    export function calculateLegendShapes(location: ChartLocation, size: Size, shape: string, options: PathOption): IShapes;
    /** @private */
    export function textTrim(maxWidth: number, text: string, font: FontModel): string;
    /** @private */
    export function stringToNumber(value: string, containerSize: number): number;
    /** @private */
    export function findDirection(rX: number, rY: number, rect: Rect, arrowLocation: ChartLocation, arrowPadding: number, top: boolean, bottom: boolean, left: boolean, tipX: number, tipY: number, tipRadius?: number): string;
    /** @private */
    export function textElement(options: TextOption, font: FontModel, color: string, parent: HTMLElement | Element, isMinus?: boolean): Element;
    /**
     * Method to calculate the width and height of the chart
     */
    export function calculateSize(chart: Chart | AccumulationChart): void;
    export function createSvg(chart: Chart | AccumulationChart): void;
    /**
     * To calculate chart title and height
     * @param title
     * @param style
     * @param width
     */
    export function getTitle(title: string, style: FontModel, width: number): string[];
    /**
     * Method to calculate x position of title
     */
    export function titlePositionX(chartSize: Size, leftPadding: number, rightPadding: number, titleStyle: FontModel): number;
    /**
     * Method to find new text and element size based on textOverflow
     */
    export function textWrap(currentLabel: string, maximumWidth: number, font: FontModel): string[];
    /** @private */
    export class CustomizeOption {
        id: string;
        constructor(id?: string);
    }
    /** @private */
    export class StackValues {
        startValues?: number[];
        endValues?: number[];
        constructor(startValue?: number[], endValue?: number[]);
    }
    /** @private */
    export class TextOption extends CustomizeOption {
        anchor: string;
        text: string | string[];
        transform: string;
        x: number;
        y: number;
        baseLine: string;
        constructor(id?: string, x?: number, y?: number, anchor?: string, text?: string | string[], transform?: string, baseLine?: string);
    }
    /** @private */
    export class PathOption extends CustomizeOption {
        opacity: number;
        fill: string;
        stroke: string;
        ['stroke-width']: number;
        ['stroke-dasharray']: string;
        d: string;
        constructor(id: string, fill: string, width: number, color: string, opacity?: number, dashArray?: string, d?: string);
    }
    /** @private */
    export class RectOption extends PathOption {
        x: number;
        y: number;
        height: number;
        width: number;
        rx: number;
        ry: number;
        transform: string;
        constructor(id: string, fill: string, border: BorderModel, opacity: number, rect: Rect, rx?: number, ry?: number, transform?: string, dashArray?: string);
    }
    /** @private */
    export class CircleOption extends PathOption {
        cy: number;
        cx: number;
        r: number;
        constructor(id: string, fill: string, border: BorderModel, opacity: number, cx: number, cy: number, r: number);
    }
    /** @private */
    export class PolygonOption {
        id: string;
        points: string;
        fill: string;
        constructor(id: string, points: string, fill: string);
    }
    /** @private */
    export class Size {
        height: number;
        width: number;
        constructor(width: number, height: number);
    }
    /** @private */
    export class Rect {
        x: number;
        y: number;
        height: number;
        width: number;
        constructor(x: number, y: number, width: number, height: number);
    }
    /** @private */
    export class ChartLocation {
        x: number;
        y: number;
        constructor(x: number, y: number);
    }
    /** @private */
    export class Thickness {
        left: number;
        right: number;
        top: number;
        bottom: number;
        constructor(left: number, right: number, top: number, bottom: number);
    }
    /** @private */
    export class ColorValue {
        r: number;
        g: number;
        b: number;
        constructor(r?: number, g?: number, b?: number);
    }
    /** @private */
    export class PointData {
        point: Points;
        series: Series;
        lierIndex: number;
        constructor(point: Points, series: Series, index?: number);
    }
    /** @private */
    export class AccPointData {
        point: AccPoints;
        series: AccumulationSeries;
        constructor(point: AccPoints, series: AccumulationSeries, index?: number);
    }
    /** @private */
    export class ControlPoints {
        controlPoint1: ChartLocation;
        controlPoint2: ChartLocation;
        constructor(controlPoint1: ChartLocation, controlPoint2: ChartLocation);
    }
    
  }
  export namespace circulargauge {
    
    /**
     * Interface for a class CircularGauge
     */
    export interface CircularGaugeModel extends ej.base.ComponentModel{
    
        /**
         * The width of the circular gauge as a string in order to provide input as both like '100px' or '100%'.
         * If specified as '100%, gauge will render to the full width of its parent element.
         * @default null
         */
    
        width?: string;
    
        /**
         * The height of the circular gauge as a string in order to provide input as both like '100px' or '100%'.
         * If specified as '100%, gauge will render to the full height of its parent element.
         * @default null
         */
    
        height?: string;
    
        /**
         * Options for customizing the color and width of the gauge border.
         */
    
        border?: BorderModel;
    
        /**
         * The background color of the gauge, which accepts value in hex, rgba as a valid CSS color string.
         * @default 'transparent'
         */
        background?: string;
    
        /**
         * Title for gauge
         * @default ''
         */
    
        title?: string;
    
        /**
         * Options for customizing the title of Gauge.
         */
    
        titleStyle?: FontModel;
    
        /**
         *  Options to customize the left, right, top and bottom margins of the gauge.
         */
    
        margin?: MarginModel;
    
        /**
         * Options for customizing the axes of gauge
         */
    
        axes?: AxisModel[];
    
        /**
         * Options for customizing the tooltip of gauge.
         */
    
        tooltip?: TooltipSettingsModel;
    
        /**
         * If set true, pointers can able to drag on interaction.
         * @default true
         */
        enablePointerDrag?: boolean;
    
        /**
         * X coordinate of the circular gauge center point, which takes values either in pixels or in percentage.
         * @default null
         */
    
        centerX?: string;
    
        /**
         * Y coordinate of the circular gauge center point, which takes values either in pixels or in percentage.
         * @default null
         */
    
        centerY?: string;
    
        /**
         * Specifies the theme for circular gauge.
         * * Material - Gauge render with material theme.
         * * Fabric - Gauge render with fabric theme.
         * @default Material
         */
        theme?: GaugeTheme;
    
        /**
         * Specifies whether a grouping separator should be used for a number.
         * @default false
         */
        useGroupingSeparator?: boolean;
    
        /**
         * Information about gauge for assistive technology.
         * @default null
         */
        description?: string;
    
        /**
         * TabIndex value for the gauge.
         * @default 1
         */
        tabIndex?: number;
    
        /**
         * Triggers after gauge loaded.
         * @event
         */
        loaded?: ej.base.EmitType<ILoadedEventArgs>;
    
        /**
         * Triggers before gauge load.
         * @event
         */
        load?: ej.base.EmitType<ILoadedEventArgs>;
    
        /**
         * Triggers after animation gets completed for pointers.
         * @event
         */
        animationComplete?: ej.base.EmitType<IAnimationCompleteEventArgs>;
    
        /**
         * Triggers before each axis label gets rendered.
         * @event
         */
        axisLabelRender?: ej.base.EmitType<IAxisLabelRenderEventArgs>;
    
        /**
         * Triggers before each annotation gets rendered.
         * @event
         */
        annotationRender?: ej.base.EmitType<IAnnotationRenderEventArgs>;
    
        /**
         * Triggers before the tooltip for pointer gets rendered.
         * @event
         */
    
        tooltipRender?: ej.base.EmitType<ITooltipRenderEventArgs>;
    
        /**
         * Triggers before the pointer is dragged.
         * @event
         */
    
        dragStart?: ej.base.EmitType<IPointerDragEventArgs>;
    
        /**
         * Triggers while dragging the pointers.
         * @event
         */
    
        dragMove?: ej.base.EmitType<IPointerDragEventArgs>;
    
        /**
         * Triggers after the pointer is dragged.
         * @event
         */
    
        dragEnd?: ej.base.EmitType<IPointerDragEventArgs>;
    
        /**
         * Triggers on hovering the circular gauge.
         * @event
         */
    
        gaugeMouseMove?: ej.base.EmitType<IMouseEventArgs>;
    
        /**
         * Triggers while cursor leaves the circular gauge.
         * @event
         */
    
        gaugeMouseLeave?: ej.base.EmitType<IMouseEventArgs>;
    
        /**
         * Triggers on mouse down.
         * @event
         */
    
        gaugeMouseDown?: ej.base.EmitType<IMouseEventArgs>;
    
        /**
         * Triggers on mouse up.
         * @event
         */
    
        gaugeMouseUp?: ej.base.EmitType<IMouseEventArgs>;
    
        /**
         * Triggers after window resize.
         * @event
         */
    
        resized?: ej.base.EmitType<IResizeEventArgs>;
    
    }
    /**
     * Circular Gauge
     */
    
    /**
     * Represents the Circular gauge control.
     * ```html
     * <div id="gauge"/>
     * <script>
     *   var gaugeObj = new CircularGauge();
     *   gaugeObj.appendTo("#gauge");
     * </script>
     * ```
     */
    export class CircularGauge extends ej.base.Component<HTMLElement> implements ej.base.INotifyPropertyChanged {
        /**
         * annotationModule is used to add annotation in gauge.
         */
        annotationsModule: Annotations;
        /**
         * `tooltipModule` is used to show the tooltip to the circular gauge..
         */
        tooltipModule: GaugeTooltip;
        /**
         * The width of the circular gauge as a string in order to provide input as both like '100px' or '100%'.
         * If specified as '100%, gauge will render to the full width of its parent element.
         * @default null
         */
        width: string;
        /**
         * The height of the circular gauge as a string in order to provide input as both like '100px' or '100%'.
         * If specified as '100%, gauge will render to the full height of its parent element.
         * @default null
         */
        height: string;
        /**
         * Options for customizing the color and width of the gauge border.
         */
        border: BorderModel;
        /**
         * The background color of the gauge, which accepts value in hex, rgba as a valid CSS color string.
         * @default 'transparent'
         */
        background: string;
        /**
         * Title for gauge
         * @default ''
         */
        title: string;
        /**
         * Options for customizing the title of Gauge.
         */
        titleStyle: FontModel;
        /**
         *  Options to customize the left, right, top and bottom margins of the gauge.
         */
        margin: MarginModel;
        /**
         * Options for customizing the axes of gauge
         */
        axes: AxisModel[];
        /**
         * Options for customizing the tooltip of gauge.
         */
        tooltip: TooltipSettingsModel;
        /**
         * If set true, pointers can able to drag on interaction.
         * @default true
         */
        enablePointerDrag: boolean;
        /**
         * X coordinate of the circular gauge center point, which takes values either in pixels or in percentage.
         * @default null
         */
        centerX: string;
        /**
         * Y coordinate of the circular gauge center point, which takes values either in pixels or in percentage.
         * @default null
         */
        centerY: string;
        /**
         * Specifies the theme for circular gauge.
         * * Material - Gauge render with material theme.
         * * Fabric - Gauge render with fabric theme.
         * @default Material
         */
        theme: GaugeTheme;
        /**
         * Specifies whether a grouping separator should be used for a number.
         * @default false
         */
        useGroupingSeparator: boolean;
        /**
         * Information about gauge for assistive technology.
         * @default null
         */
        description: string;
        /**
         * TabIndex value for the gauge.
         * @default 1
         */
        tabIndex: number;
        /**
         * Triggers after gauge loaded.
         * @event
         */
        loaded: ej.base.EmitType<ILoadedEventArgs>;
        /**
         * Triggers before gauge load.
         * @event
         */
        load: ej.base.EmitType<ILoadedEventArgs>;
        /**
         * Triggers after animation gets completed for pointers.
         * @event
         */
        animationComplete: ej.base.EmitType<IAnimationCompleteEventArgs>;
        /**
         * Triggers before each axis label gets rendered.
         * @event
         */
        axisLabelRender: ej.base.EmitType<IAxisLabelRenderEventArgs>;
        /**
         * Triggers before each annotation gets rendered.
         * @event
         */
        annotationRender: ej.base.EmitType<IAnnotationRenderEventArgs>;
        /**
         * Triggers before the tooltip for pointer gets rendered.
         * @event
         */
        tooltipRender: ej.base.EmitType<ITooltipRenderEventArgs>;
        /**
         * Triggers before the pointer is dragged.
         * @event
         */
        dragStart: ej.base.EmitType<IPointerDragEventArgs>;
        /**
         * Triggers while dragging the pointers.
         * @event
         */
        dragMove: ej.base.EmitType<IPointerDragEventArgs>;
        /**
         * Triggers after the pointer is dragged.
         * @event
         */
        dragEnd: ej.base.EmitType<IPointerDragEventArgs>;
        /**
         * Triggers on hovering the circular gauge.
         * @event
         */
        gaugeMouseMove: ej.base.EmitType<IMouseEventArgs>;
        /**
         * Triggers while cursor leaves the circular gauge.
         * @event
         */
        gaugeMouseLeave: ej.base.EmitType<IMouseEventArgs>;
        /**
         * Triggers on mouse down.
         * @event
         */
        gaugeMouseDown: ej.base.EmitType<IMouseEventArgs>;
        /**
         * Triggers on mouse up.
         * @event
         */
        gaugeMouseUp: ej.base.EmitType<IMouseEventArgs>;
        /**
         * Triggers after window resize.
         * @event
         */
        resized: ej.base.EmitType<IResizeEventArgs>;
        /** @private */
        renderer: ej.base.SvgRenderer;
        /** @private */
        svgObject: Element;
        /** @private */
        availableSize: Size;
        /** @private */
        intl: ej.base.Internationalization;
        /** @private */
        private resizeTo;
        /** @private */
        midPoint: GaugeLocation;
        /** @private */
        activePointer: Pointer;
        /** @private */
        activeAxis: Axis;
        /** @private */
        animatePointer: boolean;
        /** @private */
        /**
         * Render axis panel for gauge.
         * @hidden
         */
        gaugeAxisLayoutPanel: AxisLayoutPanel;
        /**
         * Constructor for creating the widget
         * @hidden
         */
        constructor(options?: CircularGaugeModel, element?: string | HTMLElement);
        /**
         *  To create svg object, renderer and binding events for the container.
         */
        protected preRender(): void;
        private themeEffect();
        private setThemeColors(labelcolor, others);
        /**
         * To render the circular gauge elements
         */
        protected render(): void;
        /**
         * Method to unbind events for circular gauge
         */
        private unWireEvents();
        /**
         * Method to bind events for circular gauge
         */
        private wireEvents();
        /**
         * Handles the mouse move.
         * @return {boolean}
         * @private
         */
        mouseMove(e: PointerEvent): boolean;
        /**
         * Handles the mouse leave.
         * @return {boolean}
         * @private
         */
        mouseLeave(e: PointerEvent): boolean;
        /**
         * Handles the mouse right click.
         * @return {boolean}
         * @private
         */
        gaugeRightClick(event: MouseEvent | PointerEvent): boolean;
        /**
         * Handles the pointer draf while mouse move on gauge.
         * @private
         */
        pointerDrag(location: GaugeLocation): void;
        /**
         * Handles the mouse down on gauge.
         * @return {boolean}
         * @private
         */
        gaugeOnMouseDown(e: PointerEvent): boolean;
        /**
         * Handles the mouse end.
         * @return {boolean}
         * @private
         */
        mouseEnd(e: PointerEvent): boolean;
        /**
         * Handles the mouse event arguments.
         * @return {IMouseEventArgs}
         * @private
         */
        private getMouseArgs(e, type, name);
        /**
         * Handles the gauge resize.
         * @return {boolean}
         * @private
         */
        gaugeResize(e: Event): boolean;
        /**
         * Applying styles for circular gauge elements
         */
        private setGaugeStyle(element);
        /**
         * Method to set culture for gauge
         */
        private setCulture();
        /**
         * Methods to create svg element for circular gauge.
         */
        private createSvg();
        /**
         * To Remove the SVG from circular gauge.
         * @return {boolean}
         * @private
         */
        removeSvg(): void;
        /**
         * To initialize the circular gauge private variable.
         * @private
         */
        private initPrivateVariable();
        /**
         * To calculate the size of the circular gauge element.
         */
        private calculateSvgSize();
        /**
         * Method to calculate the availble size for circular gauge.
         */
        private calculateBounds();
        /**
         * To render elements for circular gauge
         */
        private renderElements();
        /**
         * Method to render the title for circular gauge.
         */
        private renderTitle();
        /**
         * Method to render the border for circular gauge.
         */
        private renderBorder();
        /**
         * Method to set the pointer value dynamically for circular gauge.
         */
        setPointerValue(axisIndex: number, pointerIndex: number, value: number): void;
        /**
         * Method to set the annotation content dynamically for circular gauge.
         */
        setAnnotationValue(axisIndex: number, annotationIndex: number, content: string): void;
        /**
         * Method to set the range values dynamically for circular gauge.
         */
        setRangeValue(axisIndex: number, rangeIndex: number, start: number, end: number): void;
        /**
         * To destroy the widget
         * @method destroy
         * @return {void}
         * @member of Circular-Gauge
         */
        destroy(): void;
        /**
         * To provide the array of modules needed for control rendering
         * @return {ej.base.ModuleDeclaration[]}
         * @private
         */
        requiredModules(): ej.base.ModuleDeclaration[];
        /**
         * Get the properties to be maintained in the persisted state.
         * @private
         */
        getPersistData(): string;
        /**
         * Called internally if any of the property value changed.
         * @private
         */
        onPropertyChanged(newProp: CircularGaugeModel, oldProp: CircularGaugeModel): void;
        /**
         * Get component name for circular gauge
         * @private
         */
        getModuleName(): string;
    }
    
    /**
     * Annotation Module handles the annotation of the axis.
     */
    export class Annotations {
        private gauge;
        private elementId;
        /**
         * Constructor for Annotation module.
         * @private.
         */
        constructor(gauge: CircularGauge);
        /**
         * Method to render the annotation for circular gauge.
         */
        renderAnnotation(axis: Axis, index: number): void;
        /**
         * Method to create annotation template for circular gauge.
         */
        createTemplate(element: HTMLElement, annotationIndex: number, axisIndex: number): void;
        /**
         * Method to update the annotation location for circular gauge.
         */
        private updateLocation(element, axis, annotation);
        /**
         * Get module name.
         */
        protected getModuleName(): string;
        /**
         * To destroy the annotation.
         * @return {void}
         * @private
         */
        destroy(gauge: CircularGauge): void;
    }
    
    /**
     * Interface for a class Line
     */
    export interface LineModel {
    
        /**
         * The width of the line in pixels.
         * @default 1
         */
    
        width?: number;
    
        /**
         * The dash array of the axis line.
         * @default ''
         */
    
        dashArray?: string;
    
        /**
         * The color of the axis line, which accepts value in hex, rgba as a valid CSS color string.
         */
    
        color?: string;
    
    }
    
    /**
     * Interface for a class Label
     */
    export interface LabelModel {
    
        /**
         * The font of the axis labels
         */
    
        font?: FontModel;
    
        /**
         * To format the axis label, which accepts any global string format like 'C', 'n1', 'P' etc.
         * Also accepts placeholder like '{value}°C' in which value represent the axis label e.g. 20°C.
         * @default ''
         */
    
        format?: string;
    
        /**
         * Specifies the position of the labels. They are,
         * * inside -  Places the labels inside the axis.
         * * outside - Places the labels outside of the axis.
         * @default 'Inside'
         */
    
        position?: Position;
    
        /**
         * Specifies the label of an axis, which must get hide when an axis makes a complete circle. They are
         * * first -  Hides the 1st label on intersect.
         * * last - Hides the last label on intersect.
         * * none - Places both the labels.
         * @default 'None'
         */
    
        hiddenLabel?: HiddenLabel;
    
        /**
         * if set true, the labels will get rotated along the axis.
         * @default false
         */
        autoAngle?: boolean;
    
        /**
         * If set true, labels takes the range color.
         */
    
        useRangeColor?: boolean;
    
        /**
         * Distance of the labels from axis in pixel.
         * @default 0
         */
    
        offset?: number;
    
    }
    
    /**
     * Interface for a class Range
     */
    export interface RangeModel {
    
        /**
         * Specifies the minimum value of the range.
         * @default null
         */
    
        start?: number;
    
        /**
         * Specifies the maximum value of the range.
         * @default null
         */
    
        end?: number;
    
        /**
         * The radius of the range in pixels or in percentage.
         * @default null
         */
    
        radius?: string;
    
        /**
         * Specifies the start width of the ranges
         */
    
        startWidth?: number | string;
    
        /**
         * Specifies the end width of the ranges
         */
    
        endWidth?: number | string;
    
        /**
         * Specifies the color of the ranges
         */
    
        color?: string;
    
    }
    
    /**
     * Interface for a class Tick
     */
    export interface TickModel {
    
        /**
         * The width of the ticks in pixels.
         * @default null
         */
    
        width?: number;
    
        /**
         * The height of the line in pixels.
         * @default null
         */
    
        height?: number;
    
        /**
         * Specifies the interval of the tick line.
         * @default null
         */
    
        interval?: number;
    
        /**
         * Distance of the ticks from axis in pixel.
         * @default 0
         */
    
        offset?: number;
    
        /**
         * The color of the tick line, which accepts value in hex, rgba as a valid CSS color string.
         */
    
        color?: string;
    
        /**
         * Specifies the position of the ticks. They are
         * * inside -  Places the ticks inside the axis.
         * * outside - Places the ticks outside of the axis.
         * @default 'Inside'
         */
    
        position?: Position;
    
        /**
         * If set true, major ticks takes the range color.
         */
    
        useRangeColor?: boolean;
    
    }
    
    /**
     * Interface for a class Cap
     */
    export interface CapModel {
    
        /**
         * The color of the cap.
         * @default 'transparent'
         */
    
        color?: string;
    
        /**
         * Options for customizing the border of the cap.
         */
    
        border?: BorderModel;
    
        /**
         * Radius of the cap in pixels.
         * @default 8
         */
    
        radius?: number;
    
    }
    
    /**
     * Interface for a class NeedleTail
     */
    export interface NeedleTailModel {
    
        /**
         * The color of the back needle.
         */
    
        color?: string;
    
        /**
         * Options for customizing the border of the back needle.
         */
    
        border?: BorderModel;
    
        /**
         * The radius of the back needle in pixels or in percentage.
         * @default 0%
         */
    
        length?: string;
    
    }
    
    /**
     * Interface for a class Animation
     */
    export interface AnimationModel {
    
        /**
         * If set true, pointers get animate on initial loading.
         * @default true
         */
    
        enable?: boolean;
    
        /**
         * Duration of animation in milliseconds.
         * @default 1000
         */
    
        duration?: number;
    
    }
    
    /**
     * Interface for a class Annotation
     */
    export interface AnnotationModel {
    
        /**
         * Content of the annotation, which accepts the id of the custom element.
         * @default null
         */
        content?: string;
    
        /**
         * Angle for annotation with respect to axis.
         * @default 90
         */
        angle?: number;
    
        /**
         * Radius for annotation with respect to axis.
         * @default '50%'
         */
        radius?: string;
    
        /**
         * Order of an annotation in an axis.
         * @default '-1'
         */
        zIndex?: string;
    
        /**
         * Rotates the annotation along the axis.
         * @default false
         */
        autoAngle?: boolean;
    
        /**
         * Options for customizing the annotation text.
         */
    
        textStyle?: FontModel;
    
        /**
         * Information about annotation for assistive technology.
         * @default null
         */
        description?: string;
    
    }
    
    /**
     * Interface for a class Pointer
     */
    export interface PointerModel {
    
        /**
         * Specifies the value of the pointer.
         * @default null
         */
    
        value?: number;
    
        /**
         * Specifies the type of pointer for an axis.
         * * needle -  Renders a needle.
         * * marker - Renders a marker.
         * * rangeBar - Renders a rangeBar.
         * @default 'Needle'
         */
    
        type?: PointerType;
    
        /**
         * The URL for the Image that is to be displayed as pointer.
         * It requires marker shape value to be Image.
         * @default null
         */
        imageUrl?: string;
    
        /**
         * Length of the pointer in pixels or in percentage.
         * @default null
         */
        radius?: string;
    
        /**
         * Width of the pointer in pixels.
         * @default 20
         */
        pointerWidth?: number;
    
        /**
         * Options for customizing the cap
         */
    
        cap?: CapModel;
    
        /**
         * Options for customizing the back needle.
         */
    
        needleTail?: NeedleTailModel;
    
        /**
         * The color of the pointer.
         */
    
        color?: string;
    
        /**
         * Options for customizing the border of the needle.
         */
    
        border?: BorderModel;
    
        /**
         * Configures the animation of pointers.
         */
    
        animation?: AnimationModel;
    
        /**
         * Specifies the shape of the marker. They are
         * * circle - Renders a circle.
         * * rectangle - Renders a rectangle.
         * * triangle - Renders a triangle.
         * * diamond - Renders a diamond.
         * * invertedTriangle - Renders a invertedTriangle.
         * * image - Renders a image.
         * @default 'Circle'
         */
    
        markerShape?: GaugeShape;
    
        /**
         * The height of the marker in pixels.
         * @default 5
         */
    
        markerHeight?: number;
    
        /**
         * Information about pointer for assistive technology.
         * @default null
         */
        description?: string;
    
        /**
         * The width of the marker in pixels.
         * @default 5
         */
    
        markerWidth?: number;
    
    }
    
    /**
     * Interface for a class Axis
     */
    export interface AxisModel {
    
        /**
         * Specifies the minimum value of an axis.
         * @default null
         */
    
        minimum?: number;
    
        /**
         * Specifies the maximum value of an axis.
         * @default null
         */
    
        maximum?: number;
    
        /**
         * Radius of an axis in pixels or in percentage.
         * @default null
         */
    
        radius?: string;
    
        /**
         * Options for customizing the axis lines.
         */
    
        lineStyle?: LineModel;
    
        /**
         * Options for customizing the ranges of an axis
         */
    
        ranges?: RangeModel[];
    
        /**
         * Options for customizing the pointers of an axis
         */
    
        pointers?: PointerModel[];
    
        /**
         * ‘Annotation’ module is used to handle annotation action for an axis.
         */
    
        annotations?: AnnotationModel[];
    
        /**
         * Options for customizing the major tick lines.
         */
    
        majorTicks?: TickModel;
    
        /**
         * Options for customizing the minor tick lines.
         */
    
        minorTicks?: TickModel;
    
        /**
         * The start angle of an axis
         * @default 200
         */
    
        startAngle?: number;
    
        /**
         * The end angle of an axis
         * @default 160
         */
    
        endAngle?: number;
    
        /**
         * Specifies the direction of an axis. They are
         * * clockWise -  Renders the axis in clock wise direction.
         * * antiClockWise - Renders the axis in anti-clock wise direction.
         * @default 'clockWise'
         */
    
        direction?: GaugeDirection;
    
        /**
         * The background color of the axis, which accepts value in hex, rgba as a valid CSS color string.
         * @default null
         */
        background?: string;
    
        /**
         * Options to customize the axis label.
         */
    
        labelStyle?: LabelModel;
    
    }
    
    export class AxisLayoutPanel {
        private gauge;
        private farSizes;
        private axisRenderer;
        pointerRenderer: PointerRenderer;
        constructor(gauge: CircularGauge);
        /**
         * Measure the calculate the axis size and radius.
         * @return {void}
         * @private
         */
        measureAxis(rect: Rect): void;
        /**
         * Measure to calculate the axis radius of the circular gauge.
         * @return {void}
         * @private
         */
        private calculateAxesRadius();
        /**
         * Measure to calculate the axis size.
         * @return {void}
         * @private
         */
        private measureAxisSize(gauge, rect);
        /**
         * Calculate the axis values of the circular gauge.
         * @return {void}
         * @private
         */
        private calculateAxisValues(rect?);
        /**
         * Calculate the visible range of an axis.
         * @return {void}
         * @private
         */
        private calculateVisibleRange(axis, rect);
        /**
         * Calculate the numeric intervals of an axis range.
         * @return {void}
         * @private
         */
        private calculateNumericInterval(axis, rect);
        /**
         * Calculate the nice interval of an axis range.
         * @return {void}
         * @private
         */
        private calculateNiceInterval(maxValue, minValue, radius, degree);
        /**
         * Calculate the visible labels of an axis.
         * @return {void}
         * @private
         */
        private calculateVisibleLabels(axis);
        /**
         * Measure the axes available size.
         * @return {void}
         * @private
         */
        private computeSize(axes, rect);
        /**
         * To render the axis element of the circular gauge.
         * @return {void}
         * @private
         */
        renderAxes(): void;
        /**
         * Calculate maximum label width for the axis.
         * @return {void}
         */
        private getMaxLabelWidth(gauge, axis);
    }
    
    /**
     * Specifies the Axis rendering for circular gauge
     */
    export class AxisRenderer {
        private majorValues;
        private gauge;
        /**
         * Constructor for axis renderer.
         * @private.
         */
        constructor(gauge: CircularGauge);
        /**
         * Method to render the axis element of the circular gauge.
         * @return {void}
         * @private
         */
        drawAxisOuterLine(axis: Axis, index: number, element: Element, gauge: CircularGauge): void;
        /**
         * Method to render the axis line of the circular gauge.
         * @return {void}
         * @private
         */
        drawAxisLine(axis: Axis, index: number, element: Element, gauge: CircularGauge): void;
        /**
         * Method to render the axis labels of the circular gauge.
         * @return {void}
         * @private
         */
        drawAxisLabels(axis: Axis, index: number, element: Element, gauge: CircularGauge): void;
        /**
         * Method to find the anchor of the axis label.
         * @private
         */
        private findAnchor(location, style, angle, label);
        /**
         * Method to render the axis minor tick lines of the circular gauge.
         * @return {void}
         * @private
         */
        drawMinorTickLines(axis: Axis, index: number, element: Element, gauge: CircularGauge): void;
        /**
         * Method to render the axis major tick lines of the circular gauge.
         * @return {void}
         * @private
         */
        drawMajorTickLines(axis: Axis, index: number, element: Element, gauge: CircularGauge): void;
        /**
         * Method to calcualte the tick elements for the circular gauge.
         * @return {void}
         * @private
         */
        calculateTicks(value: number, options: Tick, axis: Axis): string;
        /**
         * Method to render the axis range of the circular gauge.
         * @return {void}
         * @private
         */
        drawAxisRange(axis: Axis, index: number, element: Element, gauge: CircularGauge): void;
        /**
         * Method to calculate the radius of the axis range.
         * @return {void}
         */
        private calculateRangeRadius(axis, range);
        /**
         * Method to get the range color of the circular gauge.
         * @return {void}
         * @private
         */
        setRangeColor(axis: Axis): void;
    }
    
    /**
     * Configures the axis line.
     */
    export class Line extends ej.base.ChildProperty<Line> {
        /**
         * The width of the line in pixels.
         * @default 1
         */
        width: number;
        /**
         * The dash array of the axis line.
         * @default ''
         */
        dashArray: string;
        /**
         * The color of the axis line, which accepts value in hex, rgba as a valid CSS color string.
         */
        color: string;
    }
    /**
     * Configures the axis label.
     */
    export class Label extends ej.base.ChildProperty<Label> {
        /**
         * The font of the axis labels
         */
        font: FontModel;
        /**
         * To format the axis label, which accepts any global string format like 'C', 'n1', 'P' etc.
         * Also accepts placeholder like '{value}°C' in which value represent the axis label e.g. 20°C.
         * @default ''
         */
        format: string;
        /**
         * Specifies the position of the labels. They are,
         * * inside -  Places the labels inside the axis.
         * * outside - Places the labels outside of the axis.
         * @default 'Inside'
         */
        position: Position;
        /**
         * Specifies the label of an axis, which must get hide when an axis makes a complete circle. They are
         * * first -  Hides the 1st label on intersect.
         * * last - Hides the last label on intersect.
         * * none - Places both the labels.
         * @default 'None'
         */
        hiddenLabel: HiddenLabel;
        /**
         * if set true, the labels will get rotated along the axis.
         * @default false
         */
        autoAngle: boolean;
        /**
         * If set true, labels takes the range color.
         */
        useRangeColor: boolean;
        /**
         * Distance of the labels from axis in pixel.
         * @default 0
         */
        offset: number;
    }
    /**
     * Configures the ranges of an axis.
     */
    export class Range extends ej.base.ChildProperty<Range> {
        /**
         * Specifies the minimum value of the range.
         * @default null
         */
        start: number;
        /**
         * Specifies the maximum value of the range.
         * @default null
         */
        end: number;
        /**
         * The radius of the range in pixels or in percentage.
         * @default null
         */
        radius: string;
        /**
         * Specifies the start width of the ranges
         */
        startWidth: number | string;
        /**
         * Specifies the end width of the ranges
         */
        endWidth: number | string;
        /**
         * Specifies the color of the ranges
         */
        color: string;
        /** @private */
        currentRadius: number;
        /** @private */
        rangeColor: string;
    }
    /**
     * Configures the major and minor tick lines of an axis.
     */
    export class Tick extends ej.base.ChildProperty<Tick> {
        /**
         * The width of the ticks in pixels.
         * @default null
         */
        width: number;
        /**
         * The height of the line in pixels.
         * @default null
         */
        height: number;
        /**
         * Specifies the interval of the tick line.
         * @default null
         */
        interval: number;
        /**
         * Distance of the ticks from axis in pixel.
         * @default 0
         */
        offset: number;
        /**
         * The color of the tick line, which accepts value in hex, rgba as a valid CSS color string.
         */
        color: string;
        /**
         * Specifies the position of the ticks. They are
         * * inside -  Places the ticks inside the axis.
         * * outside - Places the ticks outside of the axis.
         * @default 'Inside'
         */
        position: Position;
        /**
         * If set true, major ticks takes the range color.
         */
        useRangeColor: boolean;
    }
    /**
     * Configures the needle cap in pointer.
     */
    export class Cap extends ej.base.ChildProperty<Cap> {
        /**
         * The color of the cap.
         * @default 'transparent'
         */
        color: string;
        /**
         * Options for customizing the border of the cap.
         */
        border: BorderModel;
        /**
         * Radius of the cap in pixels.
         * @default 8
         */
        radius: number;
    }
    /**
     * Configures the back needle in pointers.
     */
    export class NeedleTail extends ej.base.ChildProperty<NeedleTail> {
        /**
         * The color of the back needle.
         */
        color: string;
        /**
         * Options for customizing the border of the back needle.
         */
        border: BorderModel;
        /**
         * The radius of the back needle in pixels or in percentage.
         * @default 0%
         */
        length: string;
    }
    /**
     * Configures the animation of pointers.
     */
    export class Animation extends ej.base.ChildProperty<Animation> {
        /**
         * If set true, pointers get animate on initial loading.
         * @default true
         */
        enable: boolean;
        /**
         * Duration of animation in milliseconds.
         * @default 1000
         */
        duration: number;
    }
    /**
     * ‘Annotation’ module is used to handle annotation action for an axis.
     */
    export class Annotation extends ej.base.ChildProperty<Annotation> {
        /**
         * Content of the annotation, which accepts the id of the custom element.
         * @default null
         */
        content: string;
        /**
         * Angle for annotation with respect to axis.
         * @default 90
         */
        angle: number;
        /**
         * Radius for annotation with respect to axis.
         * @default '50%'
         */
        radius: string;
        /**
         * Order of an annotation in an axis.
         * @default '-1'
         */
        zIndex: string;
        /**
         * Rotates the annotation along the axis.
         * @default false
         */
        autoAngle: boolean;
        /**
         * Options for customizing the annotation text.
         */
        textStyle: FontModel;
        /**
         * Information about annotation for assistive technology.
         * @default null
         */
        description: string;
    }
    /**
     * Configures the pointers of an axis.
     */
    export class Pointer extends ej.base.ChildProperty<Pointer> {
        /**
         * Specifies the value of the pointer.
         * @default null
         */
        value: number;
        /**
         * Specifies the type of pointer for an axis.
         * * needle -  Renders a needle.
         * * marker - Renders a marker.
         * * rangeBar - Renders a rangeBar.
         * @default 'Needle'
         */
        type: PointerType;
        /**
         * The URL for the Image that is to be displayed as pointer.
         * It requires marker shape value to be Image.
         * @default null
         */
        imageUrl: string;
        /**
         * Length of the pointer in pixels or in percentage.
         * @default null
         */
        radius: string;
        /**
         * Width of the pointer in pixels.
         * @default 20
         */
        pointerWidth: number;
        /**
         * Options for customizing the cap
         */
        cap: CapModel;
        /**
         * Options for customizing the back needle.
         */
        needleTail: NeedleTailModel;
        /**
         * The color of the pointer.
         */
        color: string;
        /**
         * Options for customizing the border of the needle.
         */
        border: BorderModel;
        /**
         * Configures the animation of pointers.
         */
        animation: AnimationModel;
        /**
         * Specifies the shape of the marker. They are
         * * circle - Renders a circle.
         * * rectangle - Renders a rectangle.
         * * triangle - Renders a triangle.
         * * diamond - Renders a diamond.
         * * invertedTriangle - Renders a invertedTriangle.
         * * image - Renders a image.
         * @default 'Circle'
         */
        markerShape: GaugeShape;
        /**
         * The height of the marker in pixels.
         * @default 5
         */
        markerHeight: number;
        /**
         * Information about pointer for assistive technology.
         * @default null
         */
        description: string;
        /**
         * The width of the marker in pixels.
         * @default 5
         */
        markerWidth: number;
        /** @private */
        currentValue: number;
        /** @private */
        pathElement: Element[];
        /** @private */
        currentRadius: number;
    }
    /**
     * Configures an axis in a gauge.
     */
    export class Axis extends ej.base.ChildProperty<Axis> {
        /**
         * Specifies the minimum value of an axis.
         * @default null
         */
        minimum: number;
        /**
         * Specifies the maximum value of an axis.
         * @default null
         */
        maximum: number;
        /**
         * Radius of an axis in pixels or in percentage.
         * @default null
         */
        radius: string;
        /**
         * Options for customizing the axis lines.
         */
        lineStyle: LineModel;
        /**
         * Options for customizing the ranges of an axis
         */
        ranges: RangeModel[];
        /**
         * Options for customizing the pointers of an axis
         */
        pointers: PointerModel[];
        /**
         * ‘Annotation’ module is used to handle annotation action for an axis.
         */
        annotations: AnnotationModel[];
        /**
         * Options for customizing the major tick lines.
         */
        majorTicks: TickModel;
        /**
         * Options for customizing the minor tick lines.
         */
        minorTicks: TickModel;
        /**
         * The start angle of an axis
         * @default 200
         */
        startAngle: number;
        /**
         * The end angle of an axis
         * @default 160
         */
        endAngle: number;
        /**
         * Specifies the direction of an axis. They are
         * * clockWise -  Renders the axis in clock wise direction.
         * * antiClockWise - Renders the axis in anti-clock wise direction.
         * @default 'clockWise'
         */
        direction: GaugeDirection;
        /**
         * The background color of the axis, which accepts value in hex, rgba as a valid CSS color string.
         * @default null
         */
        background: string;
        /**
         * Options to customize the axis label.
         */
        labelStyle: LabelModel;
        /** @private */
        currentRadius: number;
        /** @private */
        visibleRange: VisibleRangeModel;
        /** @private */
        visibleLabels: VisibleLabels[];
        /** @private */
        maxLabelSize: Size;
        /** @private */
        rect: Rect;
        /** @private */
        nearSize: number;
        /** @private */
        farSize: number;
    }
    /** @private */
    export interface VisibleRangeModel {
        min?: number;
        max?: number;
        interval?: number;
    }
    
    /**
     * Specifies the Axis rendering for circular gauge
     */
    export class PointerRenderer {
        private gauge;
        /**
         * Constructor for pointer renderer.
         * @private.
         */
        constructor(gauge: CircularGauge);
        /**
         * Method to render the axis pointers of the circular gauge.
         * @return {void}
         * @private
         */
        drawPointers(axis: Axis, axisIndex: number, element: Element, gauge: CircularGauge): void;
        /**
         * Measure the pointer length of the circular gauge.
         * @return {void}
         */
        private calculatePointerRadius(axis, pointer);
        /**
         * Method to render the needle pointer of the ciruclar gauge.
         * @return {void}
         */
        private drawNeedlePointer(axis, axisIndex, index, parentElement, gauge);
        /**
         * Method to set the pointer value of the circular gauge.
         * @return {void}
         * @private
         */
        setPointerValue(axis: Axis, pointer: Pointer, value: number): void;
        /**
         * Method to render the marker pointer of the ciruclar gauge.
         * @return {void}
         */
        private drawMarkerPointer(axis, axisIndex, index, parentElement, gauge);
        /**
         * Method to render the range bar pointer of the ciruclar gauge.
         * @return {void}
         */
        private drawRangeBarPointer(axis, axisIndex, index, parentElement, gauge);
        /**
         * Method to perform the animation of the pointer in circular gauge.
         * @return {void}
         */
        private doPointerAnimation(pointer, axis);
        /**
         * Perform the needle and marker pointer animation for circular gauge.
         * @return {void}
         * @private
         */
        performNeedleAnimation(element: HTMLElement, start: number, end: number, axis: Axis, pointer: Pointer, radius?: number, innerRadius?: number): void;
        /**
         * Perform the range bar pointer animation for circular gauge.
         * @return {void}
         * @private
         */
        performRangeBarAnimation(element: HTMLElement, start: number, end: number, axis: Axis, pointer: Pointer, radius: number, innerRadius?: number): void;
    }
    
    /**
     * Interface for a class Border
     */
    export interface BorderModel {
    
        /**
         * The color of the border, which accepts value in hex, rgba as a valid CSS color string.
         */
        color?: string;
    
        /**
         * The width of the border in pixels.
         */
        width?: number;
    
    }
    
    /**
     * Interface for a class Font
     */
    export interface FontModel {
    
        /**
         * Font size for text.
         */
        size?: string;
    
        /**
         * Color for text.
         */
        color?: string;
    
        /**
         * FontFamily for text.
         */
        fontFamily?: string;
    
        /**
         * FontWeight for text.
         */
        fontWeight?: string;
    
        /**
         * FontStyle for text.
         */
        fontStyle?: string;
    
        /**
         * Opacity for text.
         */
        opacity?: number;
    
    }
    
    /**
     * Interface for a class Margin
     */
    export interface MarginModel {
    
        /**
         * Left margin in pixels.
         * @default 10
         */
        left?: number;
    
        /**
         * Right margin in pixels.
         * @default 10
         */
        right?: number;
    
        /**
         * Top margin in pixels.
         * @default 10
         */
        top?: number;
    
        /**
         * Bottom margin in pixels.
         * @default 10
         */
        bottom?: number;
    
    }
    
    /**
     * Interface for a class TooltipSettings
     */
    export interface TooltipSettingsModel {
    
        /**
         * Enable / Disable the visibility of tooltip.
         * @default false
         */
    
        enable?: boolean;
    
        /**
         * The fill color of the tooltip, which accepts value in hex, rgba as a valid CSS color string. 
         */
    
        fill?: string;
    
        /**
         * Options to customize the tooltip text.
         */
    
        textStyle?: FontModel;
    
        /**
         * Format of the tooltip content.
         * @default null
         */
    
        format?: string;
    
        /**
         * Custom template to format the tooltip content. Use ${x} and ${y} as a placeholder text to display the corresponding data point.
         * @default null
         */
    
        template?: string;
    
        /**
         * If set true, tooltip will animate, while moving from one point to another.
         * @default true
         */
        enableAnimation?: boolean;
    
        /**
         * Options to customize the border for tooltip.
         */
        border?: BorderModel;
    
    }
    
    /**
     * Configures the borders in circular gauge.
     */
    export class Border extends ej.base.ChildProperty<Border> {
        /**
         * The color of the border, which accepts value in hex, rgba as a valid CSS color string.
         */
        color: string;
        /**
         * The width of the border in pixels.
         */
        width: number;
    }
    /**
     * Configures the fonts in circular gauge.
     */
    export class Font extends ej.base.ChildProperty<Font> {
        /**
         * Font size for text.
         */
        size: string;
        /**
         * Color for text.
         */
        color: string;
        /**
         * FontFamily for text.
         */
        fontFamily: string;
        /**
         * FontWeight for text.
         */
        fontWeight: string;
        /**
         * FontStyle for text.
         */
        fontStyle: string;
        /**
         * Opacity for text.
         */
        opacity: number;
    }
    /**
     * Configures the margin of circular gauge.
     */
    export class Margin extends ej.base.ChildProperty<Margin> {
        /**
         * Left margin in pixels.
         * @default 10
         */
        left: number;
        /**
         * Right margin in pixels.
         * @default 10
         */
        right: number;
        /**
         * Top margin in pixels.
         * @default 10
         */
        top: number;
        /**
         * Bottom margin in pixels.
         * @default 10
         */
        bottom: number;
    }
    /**
     * Configures the tooltip in circular gauge.
     */
    export class TooltipSettings extends ej.base.ChildProperty<TooltipSettings> {
        /**
         * Enable / Disable the visibility of tooltip.
         * @default false
         */
        enable: boolean;
        /**
         * The fill color of the tooltip, which accepts value in hex, rgba as a valid CSS color string.
         */
        fill: string;
        /**
         * Options to customize the tooltip text.
         */
        textStyle: FontModel;
        /**
         * Format of the tooltip content.
         * @default null
         */
        format: string;
        /**
         * Custom template to format the tooltip content. Use ${x} and ${y} as a placeholder text to display the corresponding data point.
         * @default null
         */
        template: string;
        /**
         * If set true, tooltip will animate, while moving from one point to another.
         * @default true
         */
        enableAnimation: boolean;
        /**
         * Options to customize the border for tooltip.
         */
        border: BorderModel;
    }
    
    /**
     * Specifies the gauge constant value
     */
    /** @private */
    export const loaded: string;
    /** @private */
    export const load: string;
    /** @private */
    export const animationComplete: string;
    /** @private */
    export const axisLabelRender: string;
    /** @private */
    export const tooltipRender: string;
    /** @private */
    export const annotationRender: string;
    /** @private */
    export const gaugeMouseMove: string;
    /** @private */
    export const gaugeMouseLeave: string;
    /** @private */
    export const gaugeMouseDown: string;
    /** @private */
    export const gaugeMouseUp: string;
    /** @private */
    export const dragStart: string;
    /** @private */
    export const dragMove: string;
    /** @private */
    export const dragEnd: string;
    /** @private */
    export const resized: string;
    
    /**
     * interface doc
     */
    
    /**
     * Specifies Circular-Gauge Events
     */
    export interface ICircularGaugeEventArgs {
        /**
         * name of the event
         */
        name: string;
        /**
         * to cancel the event
         */
        cancel: boolean;
    }
    /**
     * Specifies Loaded event arguments for circular gauge.
     */
    export interface ILoadedEventArgs extends ICircularGaugeEventArgs {
        /**
         * gauge event argument
         */
        gauge: CircularGauge;
    }
    /**
     * Specifies AnimationComplete event arguments for circular gauge.
     */
    export interface IAnimationCompleteEventArgs extends ICircularGaugeEventArgs {
        /**
         * axis event argument
         */
        axis: Axis;
        /**
         * pointer event argument
         */
        pointer: Pointer;
    }
    /**
     * Specifies AxisLabelRender event arguments for circular gauge.
     */
    export interface IAxisLabelRenderEventArgs extends ICircularGaugeEventArgs {
        /**
         * axis event argument
         */
        axis: Axis;
        /**
         * text event argument
         */
        text: string;
        /**
         * value event argument
         */
        value: number;
    }
    /**
     * Specifies TooltipRender event arguments for circular gauge.
     */
    export interface ITooltipRenderEventArgs extends ICircularGaugeEventArgs {
        /**
         * content event argument
         */
        content?: string | HTMLElement;
        /**
         * textStyle event argument
         */
        textStyle?: FontModel;
        /**
         * border event argument
         */
        border?: BorderModel;
        /**
         * axis event argument
         */
        axis: Axis;
        /**
         * pointer event argument
         */
        pointer: Pointer;
    }
    /**
     * Specifies AnnotationRender event arguments for circular gauge.
     */
    export interface IAnnotationRenderEventArgs extends ICircularGaugeEventArgs {
        /**
         * content event argument
         */
        content?: string;
        /**
         * textStyle event argument
         */
        textStyle?: FontModel;
        /**
         * axis event argument
         */
        axis: Axis;
        /**
         * annotation event argument
         */
        annotation: Annotation;
    }
    /**
     * Specifies DragStart, DragMove and DragEnd events arguments for circular gauge.
     */
    export interface IPointerDragEventArgs {
        /**
         * name event argument
         */
        name: string;
        /**
         * axis event argument
         */
        axis: Axis;
        /**
         * pointer event argument
         */
        pointer: Pointer;
        /**
         * currentValue event argument
         */
        currentValue: number;
        /**
         * previousValue event argument
         */
        previousValue?: number;
    }
    /**
     * Specifies Resize event arguments for circular gauge.
     */
    export interface IResizeEventArgs {
        /**
         * name event argument
         */
        name: string;
        /**
         * previousSize event argument
         */
        previousSize: Size;
        /**
         * currentSize event argument
         */
        currentSize: Size;
        /**
         * gauge event argument
         */
        gauge: CircularGauge;
    }
    /**
     * Specifies Mouse events arguments for circular gauge.
     */
    export interface IMouseEventArgs extends ICircularGaugeEventArgs {
        /**
         * target event argument
         */
        target: Element;
        /**
         * x event argument
         */
        x: number;
        /**
         * y event argument
         */
        y: number;
    }
    /**
     * Specifies visible point
     */
    export interface IVisiblePointer {
        /**
         * axisIndex event argument
         */
        axisIndex?: number;
        /**
         * pointerIndex event argument
         */
        pointerIndex?: number;
    }
    /**
     * Specifies font mapping
     */
    export interface IFontMapping {
        /**
         * size event argument
         */
        size?: string;
        /**
         * color event argument
         */
        color?: string;
        /**
         * fontWeight event argument
         */
        fontWeight?: string;
        /**
         * fontStyle event argument
         */
        fontStyle?: string;
        /**
         * fontFamily event argument
         */
        fontFamily?: string;
    }
    
    /**
     * Specifies gauge Themes
     */
    export namespace Theme {
        /** @private */
        let axisLabelFont: IFontMapping;
        /** @private */
        let axisLineColor: string;
        /** @private */
        let tickLineColor: string;
        /** @private */
        let pointerColor: string;
    }
    /** @private */
    export function getRangePalette(theme: string): string[];
    
    /**
     * Tooltip Module handles the tooltip of the circular gauge
     */
    export class GaugeTooltip {
        private gauge;
        private element;
        private currentAxis;
        private tooltip;
        private currentPointer;
        private borderStyle;
        private textStyle;
        ejTooltip: ej.popups.Tooltip;
        /**
         * Constructor for Tooltip module.
         * @private.
         */
        constructor(gauge: CircularGauge);
        /**
         * Method to render the tooltip for circular gauge.
         */
        renderTooltip(target: Element): void;
        /**
         * Method to append the target element for tooltip
         */
        private appendTargetElement(angle);
        /**
         * Method to find the position of the tooltip anchor for circular gauge.
         */
        private findPosition(angle);
        /**
         * Method to perform the tooltip for circular gauge.
         */
        private onBeforeRender(args);
        /**
         * Method to customize the tooltip elements for circular gauge.
         */
        private tooltipCustomization(args);
        /**
         * Get module name.
         */
        protected getModuleName(): string;
        /**
         * To destroy the tooltip.
         * @return {void}
         * @private
         */
        destroy(gauge: CircularGauge): void;
    }
    
    /**
     * Defines position of the axis ticks / labels. They are
     * * inside
     * * outside
     * @private
     */
    export type Position = 'Inside' | 'Outside';
    /**
     * Defines Pointer type of the axis. They are
     * * needle
     * * marker
     * * rangeBar
     * @private
     */
    export type PointerType = 'Needle' | 'Marker' | 'RangeBar';
    /**
     * Defines Direction of the gauge. They are
     * * ClockWise
     * * AntiClockWise
     * @private
     */
    export type GaugeDirection = 'ClockWise' | 'AntiClockWise';
    /**
     * Defines Theme of the gauge. They are
     * * Material
     * * Fabric
     * @private
     */
    export type GaugeTheme = 'Material' | 'Bootstrap' | 'Highcontrast' | 'Fabric';
    /**
     * Defines Hidden label of the axis. They are
     * * First
     * * Last
     * @private
     */
    export type HiddenLabel = 'First' | 'Last' | 'None';
    /**
     * Defines the shape of marker. They are
     * * circle - Renders a circle.
     * * rectangle - Renders a rectangle.
     * * triangle - Renders a triangle.
     * * diamond - Renders a diamond.
     * * cross - Renders a cross.
     * * horizontalLine - Renders a horizontalLine.
     * * verticalLine - Renders a verticalLine.
     * * pentagon- Renders a pentagon.
     * * invertedTriangle - Renders a invertedTriangle.
     * * image - Renders a image.
     */
    export type GaugeShape = 'Circle' | 'Rectangle' | 'Triangle' | 'Diamond' | 'InvertedTriangle' | 'Image';
    
    /**
     * Function to measure the height and width of the text.
     * @param  {string} text
     * @param  {FontModel} font
     * @param  {string} id
     * @returns Size
     * @private
     */
    export function measureText(text: string, font: FontModel): Size;
    /**
     * Function to find number from string
     * * @returns number
     * @private
     */
    export function toPixel(value: string, maxDimension: number): number;
    /**
     * Function to get the style from FontModel.
     * @returns string
     * @private
     */
    export function getFontStyle(font: FontModel): string;
    /**
     * Function to set style to the element.
     * @private
     */
    export function setStyles(element: HTMLElement, fill: string, border: BorderModel): void;
    /**
     * Function to measure the element rect.
     * @returns ClientRect
     * @private
     */
    export function measureElementRect(element: HTMLElement): ClientRect;
    /**
     * Function to convert the number from string.
     * @returns number
     * @private
     */
    export function stringToNumber(value: string, containerSize: number): number;
    /**
     * Function to create the text element.
     * @returns Element
     * @private
     */
    export function textElement(options: TextOption, font: FontModel, color: string, parent: HTMLElement | Element, styles?: string): Element;
    /**
     * Function to append the path to the element.
     * @returns Element
     * @private
     */
    export function appendPath(options: PathOption, element: Element, gauge: CircularGauge, functionName?: string): Element;
    /**
     * Function to calculate the sum of array values.
     * @returns number
     * @private
     */
    export function calculateSum(from: number, to: number, values: number[]): number;
    /**
     * Function to calculate the value for linear animation effect
     * @param currentTime
     * @param startValue
     * @param endValue
     * @param duration
     * @private
     */
    export function linear(currentTime: number, startValue: number, endValue: number, duration: number): number;
    /**
     * Function to get the angle from value for circular gauge.
     * @returns number
     * @private
     */
    export function getAngleFromValue(value: number, maximumValue: number, minimumValue: number, startAngle: number, endAngle: number, isClockWise: boolean): number;
    /**
     * Function to get the degree for circular gauge.
     * @returns number
     * @private
     */
    export function getDegree(startAngle: number, endAngle: number): number;
    /**
     * Function to get the value from angle for circular gauge.
     * @returns number
     * @private
     */
    export function getValueFromAngle(angle: number, maximumValue: number, minimumValue: number, startAngle: number, endAngle: number, isClockWise: boolean): number;
    /**
     * Function to check whether it's a complete circle for circular gauge.
     * @returns boolean
     * @private
     */
    export function isCompleteAngle(startAngle: number, endAngle: number): boolean;
    /**
     * Function to get angle from location for circular gauge.
     * @returns number
     * @private
     */
    export function getAngleFromLocation(center: GaugeLocation, point: GaugeLocation): number;
    /**
     * Function to get the location from angle for circular gauge.
     * @returns GaugeLocation
     * @private
     */
    export function getLocationFromAngle(degree: number, radius: number, center: GaugeLocation): GaugeLocation;
    /**
     * Function to get the path direction of the circular gauge.
     * @returns string
     * @private
     */
    export function getPathArc(center: GaugeLocation, start: number, end: number, radius: number, startWidth?: number, endWidth?: number): string;
    /**
     * Function to get the range path direction of the circular gauge.
     * @returns string
     * @private
     */
    export function getRangePath(start: GaugeLocation, end: GaugeLocation, innerStart: GaugeLocation, innerEnd: GaugeLocation, radius: number, startRadius: number, endRadius: number, clockWise: number): string;
    /**
     * Function to calculate the complete path arc of the circular gauge.
     * @returns string
     * @private
     */
    export function getCompleteArc(center: GaugeLocation, start: number, end: number, radius: number, innerRadius: number): string;
    /**
     * Function to get the circular path direction of the circular gauge.
     * @returns string
     * @private
     */
    export function getCirclePath(start: GaugeLocation, end: GaugeLocation, radius: number, clockWise: number): string;
    /**
     * Function to get the complete path direction of the circular gauge.
     * @returns string
     * @private
     */
    export function getCompletePath(center: GaugeLocation, start: GaugeLocation, end: GaugeLocation, radius: number, innerStart: GaugeLocation, innerEnd: GaugeLocation, innerRadius: number, clockWise: number): string;
    /**
     * Function to get element from id.
     * @returns Element
     * @private
     */
    export function getElement(id: string): Element;
    /**
     * Function to compile the template function for circular gauge.
     * @returns Function
     * @private
     */
    export function getTemplateFunction(template: string): Function;
    /**
     * Function to remove the element from id.
     * @private
     */
    export function removeElement(id: string): void;
    /**
     * Function to get current point for circular gauge using element id.
     * @returns IVisiblePointer
     * @private
     */
    export function getPointer(targetId: string, gauge: CircularGauge): IVisiblePointer;
    /**
     * Function to convert the label using formar for cirular gauge.
     * @returns string
     * @private
     */
    export function getLabelFormat(format: string): string;
    /**
     * Function to calculate the marker shape for circular gauge.
     * @returns PathOption
     * @private
     */
    export function calculateShapes(location: GaugeLocation, shape: string, size: Size, url: string, options: PathOption): PathOption;
    /**
     * Function to get range color from value for circular gauge.
     * @returns string
     * @private
     */
    export function getRangeColor(value: number, ranges: Range[], color: string): string;
    /** @private */
    export class CustomizeOption {
        id: string;
        constructor(id?: string);
    }
    /** @private */
    export class PathOption extends CustomizeOption {
        opacity: number;
        fill: string;
        stroke: string;
        ['stroke-width']: number;
        ['stroke-dasharray']: string;
        d: string;
        transform: string;
        style: string;
        constructor(id: string, fill: string, width: number, color: string, opacity?: number, dashArray?: string, d?: string, transform?: string, style?: string);
    }
    /** @private */
    export class RectOption extends CustomizeOption {
        x: number;
        y: number;
        height: number;
        width: number;
        opacity: number;
        fill: string;
        stroke: string;
        ['stroke-width']: number;
        constructor(id: string, fill: string, border: BorderModel, opacity: number, rect: Rect);
    }
    /**
     * Internal class size
     */
    export class Size {
        /**
         * Specifies the height.
         */
        height: number;
        /**
         * Specifies the width.
         */
        width: number;
        constructor(width: number, height: number);
    }
    /** @private */
    export class GaugeLocation {
        x: number;
        y: number;
        constructor(x: number, y: number);
    }
    /** @private */
    export class Rect {
        x: number;
        y: number;
        height: number;
        width: number;
        constructor(x: number, y: number, width: number, height: number);
    }
    /** @private */
    export class TextOption extends CustomizeOption {
        anchor: string;
        text: string;
        transform: string;
        x: number;
        y: number;
        baseLine: string;
        constructor(id?: string, x?: number, y?: number, anchor?: string, text?: string, transform?: string, baseLine?: string);
    }
    /** @private */
    export class VisibleLabels {
        text: string;
        value: number;
        size: Size;
        constructor(text: string, value: number, size?: Size);
    }
    
  }
  export namespace compression {
    
    /**
     * represent compression stream writer
     * ```typescript
     * let compressedWriter = new CompressedStreamWriter();
     * let text: string = 'Hello world!!!';
     * compressedWriter.write(text, 0, text.length);
     * compressedWriter.close();
     * ```
     */
    export class CompressedStreamWriter {
        private stream;
        private pendingBuffer;
        private pendingBufLength;
        private pendingBufCache;
        private pendingBufBitsInCache;
        private treeLiteral;
        private treeDistances;
        private treeCodeLengths;
        private bufferPosition;
        private arrLiterals;
        private arrDistances;
        private extraBits;
        private currentHash;
        private hashHead;
        private hashPrevious;
        private matchStart;
        private matchLength;
        private matchPrevAvail;
        private blockStart;
        private stringStart;
        private lookAhead;
        private dataWindow;
        private inputBuffer;
        private totalBytesIn;
        private inputOffset;
        private inputEnd;
        private windowSize;
        private windowMask;
        private hashSize;
        private hashMask;
        private hashShift;
        private maxDist;
        private checkSum;
        private noWrap;
        /**
         * get compressed data
         */
        readonly compressedData: Uint8Array[];
        readonly getCompressedString: string;
        /**
         * Initializes compressor and writes ZLib header if needed.
         * @param {boolean} noWrap - optional if true, ZLib header and checksum will not be written.
         */
        constructor(noWrap?: boolean);
        /**
         * Compresses data and writes it to the stream.
         * @param {Uint8Array} data - data to compress
         * @param {number} offset - offset in data
         * @param {number} length - length of the data
         * @returns {void}
         */
        write(data: Uint8Array | string, offset: number, length: number): void;
        /**
         * write ZLib header to the compressed data
         * @return {void}
         */
        writeZLibHeader(): void;
        /**
         *  Write Most Significant Bytes in to stream
         * @param {number} s - check sum value
         */
        pendingBufferWriteShortBytes(s: number): void;
        private compressData(finish);
        private compressSlow(flush, finish);
        private discardMatch();
        private matchPreviousAvailable();
        private matchPreviousBest(prevMatch, prevLen);
        private lookAheadCompleted(finish);
        private huffmanIsFull(finish);
        private fillWindow();
        private slideWindow();
        private insertString();
        private findLongestMatch(curMatch);
        private updateHash();
        private huffmanTallyLit(literal);
        private huffmanTallyDist(dist, len);
        private huffmanFlushBlock(stored, storedOffset, storedLength, lastBlock);
        private huffmanFlushStoredBlock(stored, storedOffset, storedLength, lastBlock);
        private huffmanLengthCode(len);
        private huffmanDistanceCode(distance);
        private huffmanSendAllTrees(blTreeCodes);
        private huffmanReset();
        private huffmanCompressBlock();
        /**
         * write bits in to internal buffer
         * @param {number} b - source of bits
         * @param {number} count - count of bits to write
         */
        pendingBufferWriteBits(b: number, count: number): void;
        private pendingBufferFlush(isClose?);
        private pendingBufferFlushBits();
        private pendingBufferWriteByteBlock(data, offset, length);
        private pendingBufferWriteShort(s);
        private pendingBufferAlignToByte();
        /**
         * close the stream and write all pending buffer in to stream
         * @returns {void}
         */
        close(): void;
        /**
         * release allocated un-managed resource
         * @returns {void}
         */
        destroy(): void;
    }
    /**
     * represent the Huffman Tree
     */
    export class CompressorHuffmanTree {
        private codeFrequency;
        private codes;
        private codeLength;
        private lengthCount;
        private codeMinCount;
        private codeCount;
        private maxLength;
        private writer;
        private static reverseBits;
        static huffCodeLengthOrders: number[];
        readonly treeLength: number;
        readonly codeLengths: Uint8Array;
        readonly codeFrequencies: Uint16Array;
        /**
         * Create new Huffman Tree
         * @param {CompressedStreamWriter} writer instance
         * @param {number} elementCount - element count
         * @param {number} minCodes - minimum count
         * @param {number} maxLength - maximum count
         */
        constructor(writer: CompressedStreamWriter, elementCount: number, minCodes: number, maxLength: number);
        setStaticCodes(codes: Int16Array, lengths: Uint8Array): void;
        /**
         * reset all code data in tree
         * @returns {void}
         */
        reset(): void;
        /**
         * write code to the compressor output stream
         * @param {number} code - code to be written
         * @returns {void}
         */
        writeCodeToStream(code: number): void;
        /**
         * calculate code from their frequencies
         * @returns {void}
         */
        buildCodes(): void;
        static bitReverse(value: number): number;
        /**
         * calculate length of compressed data
         * @returns {number}
         */
        getEncodedLength(): number;
        /**
         * calculate code frequencies
         * @param {CompressorHuffmanTree} blTree
         * @returns {void}
         */
        calculateBLFreq(blTree: CompressorHuffmanTree): void;
        /**
         * @param {CompressorHuffmanTree} blTree - write tree to output stream
         * @returns {void}
         */
        writeTree(blTree: CompressorHuffmanTree): void;
        /**
         * Build huffman tree
         * @returns {void}
         */
        buildTree(): void;
        private constructHuffmanTree(arrTree, treeLength, values, nodesCount, child);
        private buildLength(child);
        private recreateTree(child, overflow, numLeafs);
        private calculateOptimalCodeLength(child, overflow, numNodes);
    }
    /**
     * Checksum calculator, based on Adler32 algorithm.
     */
    export class ChecksumCalculator {
        private static checkSumBitOffset;
        private static checksumBase;
        private static checksumIterationCount;
        /**
         * Updates checksum by calculating checksum of the
         * given buffer and adding it to current value.
         * @param {number} checksum - current checksum.
         * @param {Uint8Array} buffer - data byte array.
         * @param {number} offset - offset in the buffer.
         * @param {number} length - length of data to be used from the stream.
         * @returns {number}
         */
        static checksumUpdate(checksum: number, buffer: Uint8Array, offset: number, length: number): number;
    }
    
    /**
     * class provide compression library
     * ```typescript
     * let archive = new ZipArchive();
     * archive.compressionLevel = 'Normal';
     * let archiveItem = new ZipArchiveItem(archive, 'directoryName\fileName.txt');
     * archive.addItem(archiveItem);
     * archive.save(fileName.zip);
     * ```
     */
    export class ZipArchive {
        private files;
        private level;
        /**
         * gets compression level
         */
        /**
         * sets compression level
         */
        compressionLevel: CompressionLevel;
        /**
         * gets items count
         */
        readonly length: number;
        /**
         * constructor for creating ZipArchive instance
         */
        constructor();
        /**
         * add new item to archive
         * @param {ZipArchiveItem} item - item to be added
         * @returns {void}
         */
        addItem(item: ZipArchiveItem): void;
        /**
         * add new directory to archive
         * @param directoryName directoryName to be created
         * @returns {void}
         */
        addDirectory(directoryName: string): void;
        /**
         * gets item at specified index
         * @param {number} index - item index
         * @returns {ZipArchiveItem}
         */
        getItem(index: number): ZipArchiveItem;
        /**
         * determines whether an element is in the collection
         * @param {string | ZipArchiveItem} item - item to search
         * @returns {boolean}
         */
        contains(item: string | ZipArchiveItem): boolean;
        /**
         * save archive with specified file name
         * @param {string} fileName save archive with specified file name
         * @returns {Promise<ZipArchive>}
         */
        save(fileName: string): Promise<ZipArchive>;
        /**
         * Save archive as blob
         * @return {Promise<Blob>}
         */
        saveAsBlob(): Promise<Blob>;
        private saveInternal(fileName, skipFileSave);
        /**
         * release allocated un-managed resource
         * @returns {void}
         */
        destroy(): void;
        private getCompressedData(item);
        private compressData(input, data, crc32Table);
        private constructZippedObject(zipParts, data, dirLength, isDirectory);
        private writeHeader(data, date);
        private writeZippedContent(fileName, zipData, localDirLen, skipFileSave);
        private writeCentralDirectory(data, localHeader, offset, externalFileAttribute);
        private writeFooter(zipData, centralLength, localLength);
        private getArrayBuffer(input);
        private getBytes(value, offset);
        private getModifiedTime(date);
        private getModifiedDate(date);
        private calculateCrc32Value(crc32Value, input, crc32Table);
    }
    /**
     * Class represent unique ZipArchive item
     * ```typescript
     * let archiveItem = new ZipArchiveItem(archive, 'directoryName\fileName.txt');
     * ```
     */
    export class ZipArchiveItem {
        data: Blob | ArrayBuffer;
        private fileName;
        /**
         * Get the name of archive item
         * @returns string
         */
        /**
         * Set the name of archive item
         * @param  {string} value
         */
        name: string;
        /**
         * constructor for creating {ZipArchiveItem} instance
         * @param {Blob|ArrayBuffer} data file data
         * @param {itemName} itemName absolute file path
         */
        constructor(data: Blob | ArrayBuffer, itemName: string);
        /**
         * release allocated un-managed resource
         * @returns {void}
         */
        destroy(): void;
    }
    export interface CompressedData {
        fileName: string;
        compressedData: Uint8Array[] | string;
        uncompressedDataSize: number;
        compressedSize: number;
        crc32Value: number;
        compressionType: string;
        isDirectory: boolean;
    }
    export interface ZippedObject {
        localHeader: string;
        centralDir: string;
        compressedData: CompressedData;
    }
    /**
     * Compression level.
     */
    export type CompressionLevel = 'NoCompression' | 'Normal';
    
  }
  export namespace data {
    
    /**
     * Adaptors are specific data source type aware interfaces that are used by DataManager to communicate with DataSource.
     * This is the base adaptor class that other adaptors can extend.
     * @hidden
     */
    export class Adaptor {
        /**
         * Specifies the datasource option.
         * @default null
         */
        dataSource: DataOptions;
        /**
         * It contains the datamanager operations list like group, searches, etc.,
         * @default null
         * @hidden
         */
        pvt: PvtOptions;
        /**
         * Constructor for Adaptor class
         * @param  {DataOptions} ds?
         * @hidden
         * @returns aggregates
         */
        constructor(ds?: DataOptions);
        protected options: RemoteOptions;
        /**
         * Returns the data from the query processing.
         * @param  {Object} data
         * @param  {DataOptions} ds?
         * @param  {Query} query?
         * @param  {XMLHttpRequest} xhr?
         * @returns Object
         */
        processResponse(data: Object, ds?: DataOptions, query?: ej.data.Query, xhr?: XMLHttpRequest): Object;
        /**
         * Specifies the type of adaptor.
         * @default Adaptor
         */
        type: Object;
    }
    /**
     * JsonAdaptor is used to process JSON data. It contains methods to process the given JSON data based on the queries.
     * @hidden
     */
    export class JsonAdaptor extends Adaptor {
        /**
         * Process the JSON data based on the provided queries.
         * @param  {DataManager} dataManager
         * @param  {Query} query
         * @returns Object
         */
        processQuery(dataManager: ej.data.DataManager, query: ej.data.Query): Object;
        /**
         * Performs batch update in the JSON array which add, remove and update records.
         * @param  {DataManager} dm
         * @param  {CrudOptions} changes
         * @param  {RemoteArgs} e
         */
        batchRequest(dm: ej.data.DataManager, changes: CrudOptions, e: RemoteArgs): CrudOptions;
        /**
         * Performs filter operation with the given data and where query.
         * @param  {Object[]} ds
         * @param  {{validate:Function}} e
         */
        onWhere(ds: Object[], e: {
            validate: Function;
        }): Object[];
        /**
         * Returns aggregate function based on the aggregate type.
         * @param  {Object[]} ds
         * @param  {{field:string} e
         * @param  {string}} type
         */
        onAggregates(ds: Object[], e: {
            field: string;
            type: string;
        }): Function;
        /**
         * Performs search operation based on the given query.
         * @param  {Object[]} ds
         * @param  {QueryOptions} e
         */
        onSearch(ds: Object[], e: QueryOptions): Object[];
        /**
         * Sort the data with given direction and field.
         * @param  {Object[]} ds
         * @param  {{comparer:(a:Object} e
         * @param  {Object} b
         */
        onSortBy(ds: Object[], e: {
            comparer: (a: Object, b: Object) => number;
            fieldName: string;
        }, query: ej.data.Query): Object[];
        /**
         * Group the data based on the given query.
         * @param  {Object[]} ds
         * @param  {QueryOptions} e
         * @param  {Query} query
         */
        onGroup(ds: Object[], e: QueryOptions, query: ej.data.Query): Object[];
        /**
         * Retrieves records based on the given page index and size.
         * @param  {Object[]} ds
         * @param  {{pageSize:number} e
         * @param  {number}} pageIndex
         * @param  {Query} query
         */
        onPage(ds: Object[], e: {
            pageSize: number;
            pageIndex: number;
        }, query: ej.data.Query): Object[];
        /**
         * Retrieves records based on the given start and end index from query.
         * @param  {Object[]} ds
         * @param  {{start:number} e
         * @param  {number}} end
         */
        onRange(ds: Object[], e: {
            start: number;
            end: number;
        }): Object[];
        /**
         * Picks the given count of records from the top of the datasource.
         * @param  {Object[]} ds
         * @param  {{nos:number}} e
         */
        onTake(ds: Object[], e: {
            nos: number;
        }): Object[];
        /**
         * Skips the given count of records from the data source.
         * @param  {Object[]} ds
         * @param  {{nos:number}} e
         */
        onSkip(ds: Object[], e: {
            nos: number;
        }): Object[];
        /**
         * Selects specified columns from the data source.
         * @param  {Object[]} ds
         * @param  {{fieldNames:string}} e
         */
        onSelect(ds: Object[], e: {
            fieldNames: string[] | Function;
        }): Object[];
        /**
         * Inserts new record in the table.
         * @param  {DataManager} dm
         * @param  {Object} data
         * @param  {number} position
         */
        insert(dm: ej.data.DataManager, data: Object, tableName?: string, query?: ej.data.Query, position?: number): Object;
        /**
         * Remove the data from the dataSource based on the key field value.
         * @param  {DataManager} dm
         * @param  {string} keyField
         * @param  {Object} value
         * @param  {string} tableName?
         * @returns null
         */
        remove(dm: ej.data.DataManager, keyField: string, value: Object, tableName?: string): Object[];
        /**
         * Updates existing record and saves the changes to the table.
         * @param  {DataManager} dm
         * @param  {string} keyField
         * @param  {Object} value
         * @param  {string} tableName?
         * @returns null
         */
        update(dm: ej.data.DataManager, keyField: string, value: Object, tableName?: string): void;
    }
    /**
     * URL Adaptor of DataManager can be used when you are required to use remote service to retrieve data.
     * It interacts with server-side for all DataManager Queries and CRUD operations.
     * @hidden
     */
    export class UrlAdaptor extends Adaptor {
        /**
         * Process the query to generate request body.
         * @param  {DataManager} dm
         * @param  {Query} query
         * @param  {Object[]} hierarchyFilters?
         * @returns p
         */
        processQuery(dm: ej.data.DataManager, query: ej.data.Query, hierarchyFilters?: Object[]): Object;
        private getRequestQuery(options, query, singles, request, request1);
        /**
         * Convert the object from processQuery to string which can be added query string.
         * @param  {Object} req
         * @param  {Query} query
         * @param  {DataManager} dm
         */
        convertToQueryString(request: Object, query: ej.data.Query, dm: ej.data.DataManager): string;
        /**
         * Return the data from the data manager processing.
         * @param  {DataResult} data
         * @param  {DataOptions} ds?
         * @param  {Query} query?
         * @param  {XMLHttpRequest} xhr?
         * @param  {Object} request?
         * @param  {CrudOptions} changes?
         */
        processResponse(data: DataResult, ds?: DataOptions, query?: ej.data.Query, xhr?: XMLHttpRequest, request?: Object, changes?: CrudOptions): DataResult;
        /**
         * Add the group query to the adaptor`s option.
         * @param  {Object[]} e
         * @returns void
         */
        onGroup(e: QueryOptions[]): QueryOptions[];
        /**
         * Add the aggregate query to the adaptor`s option.
         * @param  {Aggregates[]} e
         * @returns void
         */
        onAggregates(e: Aggregates[]): void;
        /**
         * Prepare the request body based on the newly added, removed and updated records.
         * The result is used by the batch request.
         * @param  {DataManager} dm
         * @param  {CrudOptions} changes
         * @param  {Object} e
         */
        batchRequest(dm: ej.data.DataManager, changes: CrudOptions, e: Object): Object;
        /**
         * Method will trigger before send the request to server side.
         * Used to set the custom header or modify the request options.
         * @param  {DataManager} dm
         * @param  {XMLHttpRequest} request
         * @returns void
         */
        beforeSend(dm: ej.data.DataManager, request: XMLHttpRequest): void;
        /**
         * Prepare and returns request body which is used to insert a new record in the table.
         * @param  {DataManager} dm
         * @param  {Object} data
         * @param  {string} tableName
         */
        insert(dm: ej.data.DataManager, data: Object, tableName: string): Object;
        /**
         * Prepare and return request body which is used to remove record from the table.
         * @param  {DataManager} dm
         * @param  {string} keyField
         * @param  {number|string} value
         * @param  {string} tableName
         */
        remove(dm: ej.data.DataManager, keyField: string, value: number | string, tableName: string): Object;
        /**
         * Prepare and return request body which is used to update record.
         * @param  {DataManager} dm
         * @param  {string} keyField
         * @param  {Object} value
         * @param  {string} tableName
         */
        update(dm: ej.data.DataManager, keyField: string, value: Object, tableName: string): Object;
        /**
         * To generate the predicate based on the filtered query.
         * @param  {Object[]|string[]|number[]} data
         * @param  {Query} query
         * @hidden
         */
        getFiltersFrom(data: Object[] | string[] | number[], query: ej.data.Query): Predicate;
        protected getAggregateResult(pvt: PvtOptions, data: DataResult, args: DataResult, groupDs?: Object[]): DataResult;
        protected getQueryRequest(query: ej.data.Query): Requests;
        private addParams(options);
    }
    /**
     * OData Adaptor that is extended from URL Adaptor, is used for consuming data through OData Service.
     * @hidden
     */
    export class ODataAdaptor extends UrlAdaptor {
        private getModuleName;
        protected options: RemoteOptions;
        constructor();
        /**
         * Generate request string based on the filter criteria from query.
         * @param  {Predicate} pred
         * @param  {boolean} requiresCast?
         */
        onPredicate(predicate: Predicate, query: ej.data.Query | boolean, requiresCast?: boolean): string;
        /**
         * Generate request string based on the multiple filter criteria from query.
         * @param  {Predicate} pred
         * @param  {boolean} requiresCast?
         */
        onComplexPredicate(predicate: Predicate, query: ej.data.Query, requiresCast?: boolean): string;
        /**
         * Generate query string based on the multiple filter criteria from query.
         * @param  {Predicate} filter
         * @param  {boolean} requiresCast?
         */
        onEachWhere(filter: Predicate, query: ej.data.Query, requiresCast?: boolean): string;
        /**
         * Generate query string based on the multiple filter criteria from query.
         * @param  {string[]} filters
         */
        onWhere(filters: string[]): string;
        /**
         * Generate query string based on the multiple search criteria from query.
         * @param  {{fields:string[]} e
         * @param  {string} operator
         * @param  {string} key
         * @param  {boolean}} ignoreCase
         */
        onEachSearch(e: {
            fields: string[];
            operator: string;
            key: string;
            ignoreCase: boolean;
        }): void;
        /**
         * Generate query string based on the search criteria from query.
         * @param  {Object} e
         */
        onSearch(e: Object): string;
        /**
         * Generate query string based on multiple sort criteria from query.
         * @param  {QueryOptions} e
         */
        onEachSort(e: QueryOptions): string;
        /**
         * Returns sort query string.
         * @param  {string[]} e
         */
        onSortBy(e: string[]): string;
        /**
         * Adds the group query to the adaptor option.
         * @param  {Object[]} e
         * @returns string
         */
        onGroup(e: QueryOptions[]): QueryOptions[];
        /**
         * Returns the select query string.
         * @param  {string[]} e
         */
        onSelect(e: string[]): string;
        /**
         * Add the aggregate query to the adaptor option.
         * @param  {Object[]} e
         * @returns string
         */
        onAggregates(e: Object[]): string;
        /**
         * Returns the query string which requests total count from the data source.
         * @param  {boolean} e
         * @returns string
         */
        onCount(e: boolean): string;
        /**
         * Method will trigger before send the request to server side.
         * Used to set the custom header or modify the request options.
         * @param  {DataManager} dm
         * @param  {XMLHttpRequest} request
         * @param  {Ajax} settings?
         */
        beforeSend(dm: ej.data.DataManager, request: XMLHttpRequest, settings?: ej.base.Ajax): void;
        /**
         * Returns the data from the query processing.
         * @param  {DataResult} data
         * @param  {DataOptions} ds?
         * @param  {Query} query?
         * @param  {XMLHttpRequest} xhr?
         * @param  {Ajax} request?
         * @param  {CrudOptions} changes?
         * @returns aggregateResult
         */
        processResponse(data: DataResult, ds?: DataOptions, query?: ej.data.Query, xhr?: XMLHttpRequest, request?: ej.base.Ajax, changes?: CrudOptions): Object;
        /**
         * Converts the request object to query string.
         * @param  {Object} req
         * @param  {Query} query
         * @param  {DataManager} dm
         * @returns tableName
         */
        convertToQueryString(request: Object, query: ej.data.Query, dm: ej.data.DataManager): string;
        /**
         * Prepare and returns request body which is used to insert a new record in the table.
         * @param  {DataManager} dm
         * @param  {Object} data
         * @param  {string} tableName?
         */
        insert(dm: ej.data.DataManager, data: Object, tableName?: string): Object;
        /**
         * Prepare and return request body which is used to remove record from the table.
         * @param  {DataManager} dm
         * @param  {string} keyField
         * @param  {number} value
         * @param  {string} tableName?
         */
        remove(dm: ej.data.DataManager, keyField: string, value: number, tableName?: string): Object;
        /**
         * Updates existing record and saves the changes to the table.
         * @param  {DataManager} dm
         * @param  {string} keyField
         * @param  {Object} value
         * @param  {string} tableName?
         * @returns this
         */
        update(dm: ej.data.DataManager, keyField: string, value: Object, tableName?: string): Object;
        /**
         * Prepare the request body based on the newly added, removed and updated records.
         * The result is used by the batch request.
         * @param  {DataManager} dm
         * @param  {CrudOptions} changes
         * @param  {RemoteArgs} e
         * @returns {Object}
         */
        batchRequest(dm: ej.data.DataManager, changes: CrudOptions, e: RemoteArgs): Object;
        /**
         * Generate the string content from the removed records.
         * The result will be send during batch update.
         * @param  {Object[]} arr
         * @param  {RemoteArgs} e
         * @returns this
         */
        generateDeleteRequest(arr: Object[], e: RemoteArgs): string;
        /**
         * Generate the string content from the inserted records.
         * The result will be send during batch update.
         * @param  {Object[]} arr
         * @param  {RemoteArgs} e
         */
        generateInsertRequest(arr: Object[], e: RemoteArgs): string;
        /**
         * Generate the string content from the updated records.
         * The result will be send during batch update.
         * @param  {Object[]} arr
         * @param  {RemoteArgs} e
         */
        generateUpdateRequest(arr: Object[], e: RemoteArgs): string;
        private static getField(prop);
        private generateBodyContent(arr, e, stat);
        protected processBatchResponse(data: DataResult, query?: ej.data.Query, xhr?: XMLHttpRequest, request?: ej.base.Ajax, changes?: CrudOptions): CrudOptions | DataResult;
    }
    /**
     * The OData v4 is an improved version of OData protocols.
     * The DataManager uses the ODataV4Adaptor to consume OData v4 services.
     * @hidden
     */
    export class ODataV4Adaptor extends ODataAdaptor {
        /**
         * @hidden
         */
        protected getModulename(): string;
        protected options: RemoteOptions;
        /**
         * Returns the query string which requests total count from the data source.
         * @param  {boolean} e
         * @returns string
         */
        onCount(e: boolean): string;
        /**
         * Generate request string based on the filter criteria from query.
         * @param  {Predicate} pred
         * @param  {boolean} requiresCast?
         */
        onPredicate(predicate: Predicate, query: ej.data.Query | boolean, requiresCast?: boolean): string;
        /**
         *  Generate query string based on the multiple search criteria from query.
         * @param  {{fields:string[]} e
         * @param  {string} operator
         * @param  {string} key
         * @param  {boolean}} ignoreCase
         */
        onEachSearch(e: {
            fields: string[];
            operator: string;
            key: string;
            ignoreCase: boolean;
        }): void;
        /**
         *  Generate query string based on the search criteria from query.
         * @param  {Object} e
         */
        onSearch(e: Object): string;
        /**
         * Method will trigger before send the request to server side.
         * Used to set the custom header or modify the request options.
         * @param  {DataManager} dm
         * @param  {XMLHttpRequest} request
         * @param  {Ajax} settings
         * @returns void
         */
        beforeSend(dm: ej.data.DataManager, request: XMLHttpRequest, settings: ej.base.Ajax): void;
        /**
         * Returns the data from the query processing.
         * @param  {DataResult} data
         * @param  {DataOptions} ds?
         * @param  {Query} query?
         * @param  {XMLHttpRequest} xhr?
         * @param  {Ajax} request?
         * @param  {CrudOptions} changes?
         * @returns aggregateResult
         */
        processResponse(data: DataResult, ds?: DataOptions, query?: ej.data.Query, xhr?: XMLHttpRequest, request?: ej.base.Ajax, changes?: CrudOptions): Object;
    }
    /**
     * The Web API is a programmatic interface to define the request and response messages system that is mostly exposed in JSON or XML.
     * The DataManager uses the WebApiAdaptor to consume Web API.
     * Since this adaptor is targeted to interact with Web API created using OData endpoint, it is extended from ODataAdaptor
     * @hidden
     */
    export class WebApiAdaptor extends ODataAdaptor {
        /**
         * Prepare and returns request body which is used to insert a new record in the table.
         * @param  {DataManager} dm
         * @param  {Object} data
         * @param  {string} tableName?
         */
        insert(dm: ej.data.DataManager, data: Object, tableName?: string): Object;
        /**
         * Prepare and return request body which is used to remove record from the table.
         * @param  {DataManager} dm
         * @param  {string} keyField
         * @param  {number} value
         * @param  {string} tableName?
         */
        remove(dm: ej.data.DataManager, keyField: string, value: number, tableName?: string): Object;
        /**
         * Prepare and return request body which is used to update record.
         * @param  {DataManager} dm
         * @param  {string} keyField
         * @param  {Object} value
         * @param  {string} tableName?
         */
        update(dm: ej.data.DataManager, keyField: string, value: Object, tableName?: string): Object;
        /**
         * Method will trigger before send the request to server side.
         * Used to set the custom header or modify the request options.
         * @param  {DataManager} dm
         * @param  {XMLHttpRequest} request
         * @param  {Ajax} settings
         * @returns void
         */
        beforeSend(dm: ej.data.DataManager, request: XMLHttpRequest, settings: ej.base.Ajax): void;
        /**
         * Returns the data from the query processing.
         * @param  {DataResult} data
         * @param  {DataOptions} ds?
         * @param  {Query} query?
         * @param  {XMLHttpRequest} xhr?
         * @param  {Ajax} request?
         * @param  {CrudOptions} changes?
         * @returns aggregateResult
         */
        processResponse(data: DataResult, ds?: DataOptions, query?: ej.data.Query, xhr?: XMLHttpRequest, request?: ej.base.Ajax, changes?: CrudOptions): Object;
    }
    /**
     * WebMethodAdaptor can be used by DataManager to interact with web method.
     * @hidden
     */
    export class WebMethodAdaptor extends UrlAdaptor {
        /**
         * Prepare the request body based on the query.
         * The query information can be accessed at the WebMethod using variable named `value`.
         * @param  {DataManager} dm
         * @param  {Query} query
         * @param  {Object[]} hierarchyFilters?
         * @returns application
         */
        processQuery(dm: ej.data.DataManager, query: ej.data.Query, hierarchyFilters?: Object[]): Object;
    }
    /**
     * RemoteSaveAdaptor, extended from JsonAdaptor and it is used for binding local data and performs all DataManager queries in client-side.
     * It interacts with server-side only for CRUD operations.
     * @hidden
     */
    export class RemoteSaveAdaptor extends JsonAdaptor {
        /**
         * @hidden
         */
        constructor();
        /**
         * Prepare the request body based on the newly added, removed and updated records.
         * Also perform the changes in the locally cached data to sync with the remote data.
         * The result is used by the batch request.
         * @param  {DataManager} dm
         * @param  {CrudOptions} changes
         * @param  {RemoteArgs} e
         */
        batchRequest(dm: ej.data.DataManager, changes: CrudOptions, e: RemoteArgs): Object;
    }
    /**
     * Cache Adaptor is used to cache the data of the visited pages. It prevents new requests for the previously visited pages.
     * You can configure cache page size and duration of caching by using cachingPageSize and timeTillExpiration properties of the DataManager
     * @hidden
     */
    export class CacheAdaptor extends UrlAdaptor {
        private cacheAdaptor;
        private pageSize;
        private guidId;
        private isCrudAction;
        private isInsertAction;
        /**
         * Constructor for CacheAdaptor class.
         * @param  {CacheAdaptor} adaptor?
         * @param  {number} timeStamp?
         * @param  {number} pageSize?
         * @hidden
         */
        constructor(adaptor?: CacheAdaptor, timeStamp?: number, pageSize?: number);
        /**
         * It will generate the key based on the URL when we send a request to server.
         * @param  {string} url
         * @param  {Query} query?
         * @hidden
         */
        generateKey(url: string, query: ej.data.Query): string;
        /**
         * Process the query to generate request body.
         * If the data is already cached, it will return the cached data.
         * @param  {DataManager} dm
         * @param  {Query} query?
         * @param  {Object[]} hierarchyFilters?
         */
        processQuery(dm: ej.data.DataManager, query?: ej.data.Query, hierarchyFilters?: Object[]): Object;
        /**
         * Returns the data from the query processing.
         * It will also cache the data for later usage.
         * @param  {DataResult} data
         * @param  {DataManager} ds?
         * @param  {Query} query?
         * @param  {XMLHttpRequest} xhr?
         * @param  {Ajax} request?
         * @param  {CrudOptions} changes?
         */
        processResponse(data: DataResult, ds?: ej.data.DataManager, query?: ej.data.Query, xhr?: XMLHttpRequest, request?: ej.base.Ajax, changes?: CrudOptions): DataResult;
        /**
         * Method will trigger before send the request to server side. Used to set the custom header or modify the request options.
         * @param  {DataManager} dm
         * @param  {XMLHttpRequest} request
         * @param  {Ajax} settings?
         */
        beforeSend(dm: ej.data.DataManager, request: XMLHttpRequest, settings?: ej.base.Ajax): void;
        /**
         * Updates existing record and saves the changes to the table.
         * @param  {DataManager} dm
         * @param  {string} keyField
         * @param  {Object} value
         * @param  {string} tableName
         */
        update(dm: ej.data.DataManager, keyField: string, value: Object, tableName: string): Object;
        /**
         * Prepare and returns request body which is used to insert a new record in the table.
         * @param  {DataManager} dm
         * @param  {Object} data
         * @param  {string} tableName?
         */
        insert(dm: ej.data.DataManager, data: Object, tableName?: string): Object;
        /**
         * Prepare and return request body which is used to remove record from the table.
         * @param  {DataManager} dm
         * @param  {string} keyField
         * @param  {Object} value
         * @param  {string} tableName?
         */
        remove(dm: ej.data.DataManager, keyField: string, value: Object, tableName?: string): Object[];
        /**
         * Prepare the request body based on the newly added, removed and updated records.
         * The result is used by the batch request.
         * @param  {DataManager} dm
         * @param  {CrudOptions} changes
         * @param  {RemoteArgs} e
         */
        batchRequest(dm: ej.data.DataManager, changes: CrudOptions, e: RemoteArgs): CrudOptions;
    }
    /**
     * @hidden
     */
    export interface CrudOptions {
        changedRecords?: Object[];
        addedRecords?: Object[];
        deletedRecords?: Object[];
        action?: string;
        table?: string;
        key?: string;
    }
    /**
     * @hidden
     */
    export interface PvtOptions {
        groups?: QueryOptions[];
        aggregates?: Aggregates[];
        search?: Object | Predicate;
        changeSet?: number;
        searches?: Object[];
    }
    /**
     * @hidden
     */
    export interface DataResult {
        nodeType?: number;
        addedRecords?: Object[];
        d?: DataResult | Object[];
        Count?: number;
        count?: number;
        result?: Object;
        results?: Object[] | DataResult;
        aggregate?: DataResult;
        aggregates?: Aggregates;
        value?: Object;
        Items?: Object[] | DataResult;
        keys?: string[];
        groupDs?: Object[];
    }
    /**
     * @hidden
     */
    export interface Requests {
        sorts: QueryOptions[];
        groups: QueryOptions[];
        filters: QueryOptions[];
        searches: QueryOptions[];
        aggregates: QueryOptions[];
    }
    /**
     * @hidden
     */
    export interface RemoteArgs {
        guid?: string;
        url?: string;
        key?: string;
        cid?: number;
        cSet?: string;
    }
    /**
     * @hidden
     */
    export interface RemoteOptions {
        from?: string;
        requestType?: string;
        sortBy?: string;
        select?: string;
        skip?: string;
        group?: string;
        take?: string;
        search?: string;
        count?: string;
        where?: string;
        aggregates?: string;
        expand?: string;
        accept?: string;
        multipartAccept?: string;
        batch?: string;
        changeSet?: string;
        batchPre?: string;
        contentId?: string;
        batchContent?: string;
        changeSetContent?: string;
        batchChangeSetContentType?: string;
    }
    
    /**
     * DataManager is used to manage and manipulate relational data.
     */
    export class DataManager {
        /** @hidden */
        adaptor: AdaptorOptions;
        /** @hidden */
        defaultQuery: ej.data.Query;
        /** @hidden */
        dataSource: DataOptions;
        /** @hidden */
        dateParse: boolean;
        /** @hidden */
        ready: Promise<ej.base.Ajax>;
        private isDataAvailable;
        private requests;
        /**
         * Constructor for DataManager class
         * @param  {DataOptions|JSON[]} dataSource?
         * @param  {Query} query?
         * @param  {AdaptorOptions|string} adaptor?
         * @hidden
         */
        constructor(dataSource?: DataOptions | JSON[] | Object[], query?: ej.data.Query, adaptor?: AdaptorOptions | string);
        /**
         * Overrides DataManager's default query with given query.
         * @param  {Query} query - Defines the new default query.
         */
        setDefaultQuery(query: ej.data.Query): ej.data.DataManager;
        /**
         * Executes the given query with local data source.
         * @param  {Query} query - Defines the query to retrieve data.
         */
        executeLocal(query?: ej.data.Query): Object[];
        /**
         * Executes the given query with either local or remote data source.
         * It will be executed as asynchronously and returns Promise object which will be resolved or rejected after action completed.
         * @param  {Query|Function} query - Defines the query to retrieve data.
         * @param  {Function} done - Defines the callback function and triggers when the Promise is resolved.
         * @param  {Function} fail - Defines the callback function and triggers when the Promise is rejected.
         * @param  {Function} always - Defines the callback function and triggers when the Promise is resolved or rejected.
         */
        executeQuery(query: ej.data.Query | Function, done?: Function, fail?: Function, always?: Function): Promise<ej.base.Ajax>;
        private static getDeferedArgs(query, result, args?);
        private static nextTick(fn);
        private extendRequest(url, fnSuccess, fnFail);
        private makeRequest(url, deffered, args?, query?);
        private beforeSend(request, settings?);
        /**
         * Save bulk changes to the given table name.
         * User can add a new record, edit an existing record, and delete a record at the same time.
         * If the datasource from remote, then updated in a single post.
         * @param  {Object} changes - Defines the CrudOptions.
         * @param  {string} key - Defines the column field.
         * @param  {string|Query} tableName - Defines the table name.
         * @param  {Query} query - Sets default query for the DataManager.
         */
        saveChanges(changes: Object, key?: string, tableName?: string | Query, query?: ej.data.Query): Promise<Object> | Object;
        /**
         * Inserts new record in the given table.
         * @param  {Object} data - Defines the data to insert.
         * @param  {string|Query} tableName - Defines the table name.
         * @param  {Query} query - Sets default query for the DataManager.
         */
        insert(data: Object, tableName?: string | Query, query?: ej.data.Query, position?: number): Object | Promise<Object>;
        /**
         * Removes data from the table with the given key.
         * @param  {string} keyField - Defines the column field.
         * @param  {Object} value - Defines the value to find the data in the specified column.
         * @param  {string|Query} tableName - Defines the table name
         * @param  {Query} query - Sets default query for the DataManager.
         */
        remove(keyField: string, value: Object, tableName?: string | Query, query?: ej.data.Query): Object | Promise<Object>;
        /**
         * Updates existing record in the given table.
         * @param  {string} keyField - Defines the column field.
         * @param  {Object} value - Defines the value to find the data in the specified column.
         * @param  {string|Query} tableName - Defines the table name
         * @param  {Query} query - Sets default query for the DataManager.
         */
        update(keyField: string, value: Object, tableName?: string | Query, query?: ej.data.Query): Object | Promise<Object>;
        private doAjaxRequest(res);
    }
    /**
     * Deferred is used to handle asynchronous operation.
     */
    export class Deferred {
        /**
         * Resolve a Deferred object and call doneCallbacks with the given args.
         */
        resolve: Function;
        /**
         * Reject a Deferred object and call failCallbacks with the given args.
         */
        reject: Function;
        /**
         * Promise is an object that represents a value that may not be available yet, but will be resolved at some point in the future.
         */
        promise: Promise<Object>;
        /**
         * Defines the callback function triggers when the Deferred object is resolved.
         */
        then: Function;
        /**
         * Defines the callback function triggers when the Deferred object is rejected.
         */
        catch: Function;
    }
    /**
     * @hidden
     */
    export interface DataOptions {
        url?: string;
        adaptor?: AdaptorOptions;
        insertUrl?: string;
        removeUrl?: string;
        updateUrl?: string;
        crudUrl?: string;
        batchUrl?: string;
        json?: Object[];
        headers?: Object[];
        accept?: boolean;
        data?: JSON;
        timeTillExpiration?: number;
        cachingPageSize?: number;
        enableCaching?: boolean;
        requestType?: string;
        key?: string;
        crossDomain?: boolean;
        jsonp?: string;
        dataType?: string;
        offline?: boolean;
        requiresFormat?: boolean;
    }
    /**
     * @hidden
     */
    export interface ReturnOption {
        result?: ReturnOption;
        count?: number;
        url?: string;
        aggregates?: Aggregates;
    }
    /**
     * @hidden
     */
    export interface RequestOptions {
        xhr?: XMLHttpRequest;
        count?: number;
        result?: ReturnOption;
        request?: ej.base.Ajax;
        aggregates?: Aggregates;
        actual?: Object;
        virtualSelectRecords?: Object;
        error?: string;
    }
    /**
     * @hidden
     */
    export interface AdaptorOptions {
        processQuery?: Function;
        processResponse?: Function;
        beforeSend?: Function;
        batchRequest?: Function;
        insert?: Function;
        remove?: Function;
        update?: Function;
    }
    
    /**
     * Query class is used to build query which is used by the DataManager to communicate with datasource.
     */
    export class Query {
        /** @hidden */
        queries: QueryOptions[];
        /** @hidden */
        key: string;
        /** @hidden */
        fKey: string;
        /** @hidden */
        fromTable: string;
        /** @hidden */
        lookups: string[];
        /** @hidden */
        expands: Object[];
        /** @hidden */
        sortedColumns: Object[];
        /** @hidden */
        groupedColumns: Object[];
        /** @hidden */
        subQuerySelector: Function;
        /** @hidden */
        subQuery: ej.data.Query;
        /** @hidden */
        isChild: boolean;
        /** @hidden */
        params: ParamOption[];
        /** @hidden */
        isCountRequired: boolean;
        /** @hidden */
        dataManager: ej.data.DataManager;
        /**
         * Constructor for Query class.
         * @param  {string|string[]} from?
         * @hidden
         */
        constructor(from?: string | string[]);
        /**
         * Sets the primary key.
         * @param  {string} field - Defines the column field.
         */
        setKey(field: string): ej.data.Query;
        /**
         * Sets default DataManager to execute query.
         * @param  {DataManager} dataManager - Defines the DataManager.
         */
        using(dataManager: ej.data.DataManager): ej.data.Query;
        /**
         * Executes query with the given DataManager.
         * @param  {DataManager} dataManager - Defines the DataManager.
         * @param  {Function} done - Defines the success callback.
         * @param  {Function} fail - Defines the failure callback.
         * @param  {Function} always - Defines the callback which will be invoked on either success or failure.
         *
         * <pre>
         * let dataManager: ej.data.DataManager = new DataManager([{ ID: '10' }, { ID: '2' }, { ID: '1' }, { ID: '20' }]);
         * let query: ej.data.Query = new Query();
         * query.sortBy('ID', (x: string, y: string): number => { return parseInt(x, 10) - parseInt(y, 10) });
         * let promise: Promise< Object > = query.execute(dataManager);
         * promise.then((e: { result: Object }) => { });
         * </pre>
         */
        execute(dataManager?: ej.data.DataManager, done?: Function, fail?: Function, always?: Function): Promise<Object>;
        /**
         * Executes query with the local datasource.
         * @param  {DataManager} dataManager - Defines the DataManager.
         */
        executeLocal(dataManager?: ej.data.DataManager): Object[];
        /**
         * Creates deep copy of the Query object.
         */
        clone(): ej.data.Query;
        /**
         * Specifies the name of table to retrieve data in query execution.
         * @param  {string} tableName - Defines the table name.
         */
        from(tableName: string): ej.data.Query;
        /**
         * Adds additional parameter which will be sent along with the request which will be generated while DataManager execute.
         * @param  {string} key - Defines the key of additional parameter.
         * @param  {Function|string} value - Defines the value for the key.
         */
        addParams(key: string, value: Function | string): ej.data.Query;
        /**
         * Expands the related table.
         * @param  {string|Object[]} tables
         */
        expand(tables: string | Object[]): ej.data.Query;
        /**
         * Filter data with given filter criteria.
         * @param  {string|Predicate} fieldName - Defines the column field or Predicate.
         * @param  {string} operator - Defines the operator how to filter data.
         * @param  {string|number|boolean} value - Defines the values to match with data.
         * @param  {boolean} ignoreCase - If ignore case set to false, then filter data with exact match or else
         * filter data with case insensitive.
         */
        where(fieldName: string | Predicate | Predicate[], operator?: string, value?: string | Date | number | boolean, ignoreCase?: boolean, ignoreAccent?: boolean): ej.data.Query;
        /**
         * Search data with given search criteria.
         * @param  {string|number|boolean} searchKey - Defines the search key.
         * @param  {string|string[]} fieldNames - Defines the collection of column fields.
         * @param  {string} operator - Defines the operator how to search data.
         * @param  {boolean} ignoreCase - If ignore case set to false, then filter data with exact match or else
         * filter data with case insensitive.
         */
        search(searchKey: string | number | boolean, fieldNames?: string | string[], operator?: string, ignoreCase?: boolean, ignoreAccent?: boolean): ej.data.Query;
        /**
         * Sort the data with given sort criteria.
         * By default, sort direction is ascending.
         * @param  {string|string[]} fieldName - Defines the single or collection of column fields.
         * @param  {string|Function} comparer - Defines the sort direction or custom sort comparer function.
         */
        sortBy(fieldName: string | string[], comparer?: string | Function, isFromGroup?: boolean): ej.data.Query;
        /**
         * Sorts data in descending order.
         * @param  {string} fieldName - Defines the column field.
         */
        sortByDesc(fieldName: string): ej.data.Query;
        /**
         * Groups data with the given field name.
         * @param  {string} fieldName - Defines the column field.
         */
        group(fieldName: string, fn?: Function, format?: string | ej.base.NumberFormatOptions | ej.base.DateFormatOptions): ej.data.Query;
        /**
         * Gets data based on the given page index and size.
         * @param  {number} pageIndex - Defines the current page index.
         * @param  {number} pageSize - Defines the no of records per page.
         */
        page(pageIndex: number, pageSize: number): ej.data.Query;
        /**
         * Gets data based on the given start and end index.
         * @param  {number} start - Defines the start index of the datasource.
         * @param  {number} end - Defines the end index of the datasource.
         */
        range(start: number, end: number): ej.data.Query;
        /**
         * Gets data from the top of the data source based on given number of records count.
         * @param  {number} nos - Defines the no of records to retrieve from datasource.
         */
        take(nos: number): ej.data.Query;
        /**
         * Skips data with given number of records count from the top of the data source.
         * @param  {number} nos - Defines the no of records skip in the datasource.
         */
        skip(nos: number): ej.data.Query;
        /**
         * Selects specified columns from the data source.
         * @param  {string|string[]} fieldNames - Defines the collection of column fields.
         */
        select(fieldNames: string | string[]): ej.data.Query;
        /**
         * Gets the records in hierarchical relationship from two tables. It requires the foreign key to relate two tables.
         * @param  {Query} query - Defines the query to relate two tables.
         * @param  {Function} selectorFn - Defines the custom function to select records.
         */
        hierarchy(query: ej.data.Query, selectorFn: Function): ej.data.Query;
        /**
         * Sets the foreign key which is used to get data from the related table.
         * @param  {string} key - Defines the foreign key.
         */
        foreignKey(key: string): ej.data.Query;
        /**
         * It is used to get total number of records in the DataManager execution result.
         */
        requiresCount(): ej.data.Query;
        /**
         * Aggregate the data with given type and field name.
         * @param  {string} type - Defines the aggregate type.
         * @param  {string} field - Defines the column field to aggregate.
         */
        aggregate(type: string, field: string): ej.data.Query;
        /**
         * Pass array of filterColumn query for performing filter operation.
         * @param  {QueryOptions[]} queries
         * @param  {string} name
         * @hidden
         */
        static filterQueries(queries: QueryOptions[], name: string): QueryOptions[];
        /**
         * To get the list of queries which is already filtered in current data source.
         * @param  {Object[]} queries
         * @param  {string[]} singles
         * @hidden
         */
        static filterQueryLists(queries: Object[], singles: string[]): Object;
    }
    /**
     * Predicate class is used to generate complex filter criteria.
     * This will be used by DataManager to perform multiple filtering operation.
     */
    export class Predicate {
        /** @hidden */
        field: string;
        /** @hidden */
        operator: string;
        /** @hidden */
        value: string | number | Date | boolean | Predicate | Predicate[];
        /** @hidden */
        condition: string;
        /** @hidden */
        ignoreCase: boolean;
        /** @hidden */
        ignoreAccent: boolean;
        /** @hidden */
        isComplex: boolean;
        /** @hidden */
        predicates: Predicate[];
        /** @hidden */
        comparer: Function;
        [x: string]: string | number | Date | boolean | Predicate | Predicate[] | Function;
        /**
         * Constructor for Predicate class.
         * @param  {string|Predicate} field
         * @param  {string} operator
         * @param  {string|number|boolean|Predicate|Predicate[]} value
         * @param  {boolean=false} ignoreCase
         * @hidden
         */
        constructor(field: string | Predicate, operator: string, value: string | number | Date | boolean | Predicate | Predicate[], ignoreCase?: boolean, ignoreAccent?: boolean);
        /**
         * Adds n-number of new predicates on existing predicate with “and” condition.
         * @param  {Object[]} args - Defines the collection of predicates.
         */
        static and(...args: Object[]): Predicate;
        /**
         * Adds new predicate on existing predicate with “and” condition.
         * @param  {string} field - Defines the column field.
         * @param  {string} operator - Defines the operator how to filter data.
         * @param  {string} value - Defines the values to match with data.
         * @param  {boolean} ignoreCase? - If ignore case set to false, then filter data with exact match or else
         * filter data with case insensitive.
         */
        and(field: string | Predicate, operator?: string, value?: string | number, ignoreCase?: boolean, ignoreAccent?: boolean): Predicate;
        /**
         * Adds n-number of new predicates on existing predicate with “or” condition.
         * @param  {Object[]} args - Defines the collection of predicates.
         */
        static or(...args: Object[]): Predicate;
        /**
         * Adds new predicate on existing predicate with “or” condition.
         * @param  {string} field - Defines the column field.
         * @param  {string} operator - Defines the operator how to filter data.
         * @param  {string} value - Defines the values to match with data.
         * @param  {boolean} ignoreCase? - If ignore case set to false, then filter data with exact match or else
         * filter data with case insensitive.
         */
        or(field: string | Predicate, operator?: string, value?: string | number, ignoreCase?: boolean, ignoreAccent?: boolean): Predicate;
        /**
         * Converts plain JavaScript object to Predicate object.
         * @param  {Predicate[]|Predicate} json - Defines single or collection of Predicate.
         */
        static fromJson(json: Predicate[] | Predicate): Predicate[];
        /**
         * Validate the record based on the predicates.
         * @param  {Object} record - Defines the datasource record.
         */
        validate(record: Object): boolean;
        /**
         * Converts predicates to plain JavaScript.
         * This method is uses Json stringify when serializing Predicate object.
         */
        toJson(): Object;
        private static combinePredicates(predicates, operator);
        private static combine(pred, field, operator, value, condition, ignoreCase?, ignoreAccent?);
        private static fromJSONData(json);
    }
    /**
     * @hidden
     */
    export interface QueryOptions {
        fn?: string;
        e?: QueryOptions;
        fieldNames?: string | string[];
        operator?: string;
        searchKey?: string | number | boolean;
        ignoreCase?: boolean;
        ignoreAccent?: boolean;
        comparer?: string | Function;
        format?: string | ej.base.NumberFormatOptions | ej.base.DateFormatOptions;
        direction?: string;
        pageIndex?: number;
        pageSize?: number;
        start?: number;
        end?: number;
        nos?: number;
        field?: string;
        fieldName?: string;
        type?: Object;
        name?: string | string[];
        filter?: Object;
        key?: string;
        value?: string | number | Date | boolean | Predicate | Predicate[];
        isComplex?: boolean;
        predicates?: Predicate[];
        condition?: string;
    }
    /**
     * @hidden
     */
    export interface QueryList {
        onSelect?: QueryOptions;
        onPage?: QueryOptions;
        onSkip?: QueryOptions;
        onTake?: QueryOptions;
        onRange?: QueryOptions;
    }
    /**
     * @hidden
     */
    export interface ParamOption {
        key: string;
        value?: string;
        fn?: Function;
    }
    
    /**
     * Data manager common utility methods.
     * @hidden
     */
    export class DataUtil {
        /**
         * Specifies the value which will be used to adjust the date value to server timezone.
         * @default null
         */
        static serverTimezoneOffset: number;
        /**
         * Returns the value by invoking the provided parameter function.
         * If the paramater is not of type function then it will be returned as it is.
         * @param  {Function|string|string[]|number} value
         * @param  {Object} inst?
         * @hidden
         */
        static getValue<T>(value: T | Function, inst?: Object): T;
        /**
         * Returns true if the input string ends with given string.
         * @param  {string} input
         * @param  {string} substr
         */
        static endsWith(input: string, substr: string): boolean;
        /**
         * Returns true if the input string starts with given string.
         * @param  {string} str
         * @param  {string} startstr
         */
        static startsWith(input: string, start: string): boolean;
        /**
         * To return the sorting function based on the string.
         * @param  {string} order
         * @hidden
         */
        static fnSort(order: string): Function;
        /**
         * Comparer function which is used to sort the data in ascending order.
         * @param  {string|number} x
         * @param  {string|number} y
         * @returns number
         */
        static fnAscending(x: string | number, y: string | number): number;
        /**
         * Comparer function which is used to sort the data in descending order.
         * @param  {string|number} x
         * @param  {string|number} y
         * @returns number
         */
        static fnDescending(x: string | number, y: string | number): number;
        private static extractFields(obj, fields);
        /**
         * Select objects by given fields from jsonArray.
         * @param  {Object[]} jsonArray
         * @param  {string[]} fields
         */
        static select(jsonArray: Object[], fields: string[]): Object[];
        /**
         * Group the input data based on the field name.
         * It also performs aggregation of the grouped records based on the aggregates paramater.
         * @param  {Object[]} jsonArray
         * @param  {string} field?
         * @param  {Object[]} agg?
         * @param  {number} level?
         * @param  {Object[]} groupDs?
         */
        static group(jsonArray: Object[], field?: string, aggregates?: Object[], level?: number, groupDs?: Object[], format?: Function): Object[];
        /**
         * It is used to categorize the multiple items based on a specific field in jsonArray.
         * The hierarchical queries are commonly required when you use foreign key binding.
         * @param  {string} fKey
         * @param  {string} from
         * @param  {Object[]} source
         * @param  {Group} lookup?
         * @param  {string} pKey?
         * @hidden
         */
        static buildHierarchy(fKey: string, from: string, source: Group, lookup?: Group, pKey?: string): void;
        /**
         * Throw error with the given string as message.
         * @param  {string} er
         */
        static throwError: Function;
        static aggregates: Aggregates;
        /**
         * The method used to get the field names which started with specified characters.
         * @param  {Object} obj
         * @param  {string[]} fields?
         * @param  {string} prefix?
         * @hidden
         */
        static getFieldList(obj: Object, fields?: string[], prefix?: string): string[];
        /**
         * Gets the value of the property in the given object.
         * The complex object can be accessed by providing the field names concatenated with dot(.).
         * @param  {string} nameSpace - The name of the property to be accessed.
         * @param  {Object} from - Defines the source object.
         */
        static getObject(nameSpace: string, from: Object): Object;
        /**
         * To set value for the nameSpace in desired object.
         * @param {string} nameSpace - String value to the get the inner object.
         * @param {Object} value - Value that you need to set.
         * @param {Object} obj - Object to get the inner object value.
         * @return { [key: string]: Object; } | Object
         * @hidden
         */
        static setValue(nameSpace: string, value: Object, obj: Object): {
            [key: string]: Object;
        } | Object;
        /**
         * Sort the given data based on the field and comparer.
         * @param  {Object[]} ds - Defines the input data.
         * @param  {string} field - Defines the field to be sorted.
         * @param  {Function} comparer - Defines the comparer function used to sort the records.
         */
        static sort(ds: Object[], field: string, comparer: Function): Object[];
        static ignoreDiacritics(value: string | number | boolean): string | Object;
        private static merge(left, right, fieldName, comparer);
        private static getVal(array, index, field?);
        private static toLowerCase(val);
        /**
         * Specifies the Object with filter operators.
         */
        static operatorSymbols: {
            [key: string]: string;
        };
        /**
         * Specifies the Object with filter operators which will be used for OData filter query generation.
         * * It will be used for date/number type filter query.
         */
        static odBiOperator: {
            [key: string]: string;
        };
        /**
         * Specifies the Object with filter operators which will be used for OData filter query generation.
         * It will be used for string type filter query.
         */
        static odUniOperator: {
            [key: string]: string;
        };
        /**
         * Specifies the Object with filter operators which will be used for ODataV4 filter query generation.
         * It will be used for string type filter query.
         */
        static odv4UniOperator: {
            [key: string]: string;
        };
        static diacritics: {
            [key: string]: string;
        };
        static fnOperators: Operators;
        /**
         * To perform the filter operation with specified adaptor and returns the result.
         * @param  {Object} adaptor
         * @param  {string} fnName
         * @param  {Object} param1?
         * @param  {Object} param2?
         * @hidden
         */
        static callAdaptorFunction(adaptor: Object, fnName: string, param1?: Object, param2?: Object): Object;
        /**
         * To perform the parse operation on JSON data, like convert to string from JSON or convert to JSON from string.
         */
        static parse: ParseOption;
        /**
         * Checks wheather the given input is a plain object or not.
         * @param  {Object|Object[]} obj
         */
        static isPlainObject(obj: Object | Object[]): boolean;
        /**
         * Returns true when the browser cross origin request.
         */
        static isCors(): boolean;
        /**
         * Generate random GUID value which will be prefixed with the given value.
         * @param  {string} prefix
         */
        static getGuid(prefix: string): string;
        /**
         * Checks wheather the given value is null or not.
         * @param  {string|Object} val
         * @returns boolean
         */
        static isNull(val: string | Object): boolean;
        /**
         * To get the required items from collection of objects.
         * @param  {Object[]} array
         * @param  {string} field
         * @param  {Function} comparer
         * @returns Object
         * @hidden
         */
        static getItemFromComparer(array: Object[], field: string, comparer: Function): Object;
        /**
         * To get distinct values of Array or Array of Objects.
         * @param  {Object[]} json
         * @param  {string} field
         * @param  {boolean} requiresCompleteRecord
         * @returns Object[]
         * * distinct array of objects is return when requiresCompleteRecord set as true.
         * @hidden
         */
        static distinct(json: Object[], fieldName: string, requiresCompleteRecord?: boolean): Object[];
        /**
         * @hidden
         */
        static dateParse: DateParseOption;
    }
    /**
     * @hidden
     */
    export interface Aggregates {
        sum?: Function;
        average?: Function;
        min?: Function;
        max?: Function;
        truecount?: Function;
        falsecount?: Function;
        count?: Function;
        type?: string;
        field?: string;
    }
    /**
     * @hidden
     */
    export interface Operators {
        equal?: Function;
        notequal?: Function;
        lessthan?: Function;
        greaterthan?: Function;
        lessthanorequal?: Function;
        greaterthanorequal?: Function;
        contains?: Function;
        notnull?: Function;
        isnull?: Function;
        startswith?: Function;
        endswith?: Function;
        processSymbols?: Function;
        processOperator?: Function;
    }
    /**
     * @hidden
     */
    export interface Group {
        GroupGuid?: string;
        level?: number;
        childLevels?: number;
        records?: Object[];
        key?: string;
        count?: number;
        items?: Object[];
        aggregates?: Object;
        field?: string;
        result?: Object;
    }
    /**
     * @hidden
     */
    export interface ParseOption {
        parseJson?: Function;
        iterateAndReviveArray?: Function;
        iterateAndReviveJson?: Function;
        jsonReviver?: (key: string, value: Object) => Object;
        isJson?: Function;
        isGuid?: Function;
        replacer?: Function;
        jsonReplacer?: Function;
        arrayReplacer?: Function;
    }
    /**
     * @hidden
     */
    export interface DateParseOption {
        addSelfOffset?: (input: Date) => Date;
        toUTC?: (input: Date) => Date;
        toTimeZone?: (input: Date, offset?: number, utc?: boolean) => Date;
    }
    
  }
  export namespace dropdowns {
    
    /**
     * Interface for a class AutoComplete
     */
    export interface AutoCompleteModel extends ComboBoxModel{
    
        /**
         * The `fields` property maps the columns of the data table and binds the data to the component.
         * * text - Maps the text column from data table for each list item
         * * value - Maps the value column from data table for each list item
         * * iconCss - Maps the icon class column from data table for each list item
         * * groupBy - Group the list items with it's related items by mapping groupBy field
         * 
         * > For more details about the field mapping refer to [`Data binding`](./data-binding.html) documentation.
         * @default { value: null, iconCss: null, groupBy: null}
         */
        fields?: FieldSettingsModel;
    
        /**
         * When set to ‘false’, consider the [`case-sensitive`](./filtering.html#case-sensitive-filtering) 
         * on performing the search to find suggestions.
         * By default consider the casing.
         * @default true.
         */
        ignoreCase?: boolean;
    
        /**
         * Allows you to either show or hide the popup button on the component.
         * @default false.
         */
        showPopupButton?: boolean;
    
        /**
         * When set to ‘true’, highlight the searched characters on suggested list items.
         * > For more details about the highlight refer to [`Custom highlight search`](./how-to.html#custom-highlight-search) documentation. 
         * @default false.
         */
        highlight?: boolean;
    
        /**
         * Supports the [`specified number`](./filtering.html#filter-item-count) 
         * of list items on the suggestion popup.
         * @default 20.
         */
        suggestionCount?: number;
    
        /**
         * Allows additional HTML attributes such as title, name, etc., and
         * accepts n number of attributes in a key-value pair format.
         * 
         * {% codeBlock src="autocomplete/html-attributes-api/index.ts" %}{% endcodeBlock %}
         * 
         * {% codeBlock src="autocomplete/html-attributes-api/index.html" %}{% endcodeBlock %}
         * @default {}.
         */
        htmlAttributes?: { [key: string]: string; };
    
        /**
         * Accepts the external [`query`](./api-query.html)
         * that execute along with data processing.
         * 
         * {% codeBlock src="autocomplete/query-api/index.ts" %}{% endcodeBlock %}
         * 
         * {% codeBlock src="autocomplete/query-api/index.html" %}{% endcodeBlock %}
         * @default null.
         */
        query?: ej.data.Query;
    
        /**
         * Allows you to set [`the minimum search character length']
         * (./filtering.html#limit-the-minimum-filter-character),
         * the search action will perform after typed minimum characters.
         * @default 1.
         */
        minLength?: number;
    
        /**
         * Determines on which filter type, the component needs to be considered on search action. 
         * The available [`FilterType`](./filtering.html#change-the-filter-type) 
         * and its supported data types are 
         * 
         * <table> 
         * <tr> 
         * <td colSpan=1 rowSpan=1> 
         * FilterType<br/></td><td colSpan=1 rowSpan=1> 
         * Description<br/></td><td colSpan=1 rowSpan=1> 
         * Supported Types<br/></td></tr> 
         * <tr> 
         * <td colSpan=1 rowSpan=1> 
         * StartsWith<br/></td><td colSpan=1 rowSpan=1> 
         * Checks whether a value begins with the specified value.<br/></td><td colSpan=1 rowSpan=1> 
         * String<br/></td></tr> 
         * <tr> 
         * <td colSpan=1 rowSpan=1> 
         * EndsWith<br/></td><td colSpan=1 rowSpan=1> 
         * Checks whether a value ends with specified value.<br/><br/></td><td colSpan=1 rowSpan=1> 
         * <br/>String<br/></td></tr> 
         * <tr> 
         * <td colSpan=1 rowSpan=1> 
         * Contains<br/></td><td colSpan=1 rowSpan=1> 
         * Checks whether a value contains with specified value.<br/><br/></td><td colSpan=1 rowSpan=1> 
         * <br/>String<br/></td></tr> 
         * </table> 
         * 
         * {% codeBlock src="autocomplete/filter-type-api/index.ts" %}{% endcodeBlock %}
         * 
         * {% codeBlock src="autocomplete/filter-type-api/index.html" %}{% endcodeBlock %}
         * 
         * The default value set to `Contains`, all the suggestion items which contain typed characters to listed in the suggestion popup.
         * @default 'Contains'.
         */
        filterType?: FilterType;
    
        /**
         * Triggers on typing a character in the component.
         * @event
         */
        filtering?: ej.base.EmitType<FilteringArgs>;
    
        /**
         * Not applicable to this component.
         * @default null.
         * @private
         */
        index?: number;
    
        /**
         * Specifies whether to display the floating label above the input element.
         * Possible values are:
         * * Never: The label will never float in the input when the placeholder is available.
         * * Always: The floating label will always float above the input.
         * * Auto: The floating label will float above the input after focusing or entering a value in the input.
         * 
         * {% codeBlock src="autocomplete/float-label-type-api/index.ts" %}{% endcodeBlock %}
         * 
         * {% codeBlock src="autocomplete/float-label-type-api/index.html" %}{% endcodeBlock %}
         * 
         *  @default 'Never'.
         */
        floatLabelType?: ej.inputs.FloatLabelType;
    
        /**
         * Not applicable to this component.
         * @default null.
         * @private
         */
        valueTemplate?: string;
    
        /**
         * Not applicable to this component.
         * @default null.
         * @private
         */
        filterBarPlaceholder?: string;
    
        /**
         * Not applicable to this component. 
         * @default false.
         * @private
         */
        allowFiltering?: boolean;
    
        /**
         * Not applicable to this component. 
         * @default null.
         * @private
         */
        text?: string;
    
    }
    
    export type FilterType = 'Contains' | 'StartsWith' | 'EndsWith';
    /**
     * The AutoComplete component provides the matched suggestion list when type into the input,
     * from which the user can select one.
     * ```html
     * <input id="list" type="text"/>
     * ```
     * ```typescript
     *   let atcObj:AutoComplete = new AutoComplete();
     *   atcObj.appendTo("#list");
     * ```
     */
    export class AutoComplete extends ComboBox {
        private isFiltered;
        /**
         * The `fields` property maps the columns of the data table and binds the data to the component.
         * * text - Maps the text column from data table for each list item
         * * value - Maps the value column from data table for each list item
         * * iconCss - Maps the icon class column from data table for each list item
         * * groupBy - Group the list items with it's related items by mapping groupBy field
         *
         * > For more details about the field mapping refer to [`Data binding`](./data-binding.html) documentation.
         * @default { value: null, iconCss: null, groupBy: null}
         */
        fields: FieldSettingsModel;
        /**
         * When set to ‘false’, consider the [`case-sensitive`](./filtering.html#case-sensitive-filtering)
         * on performing the search to find suggestions.
         * By default consider the casing.
         * @default true.
         */
        ignoreCase: boolean;
        /**
         * Allows you to either show or hide the popup button on the component.
         * @default false.
         */
        showPopupButton: boolean;
        /**
         * When set to ‘true’, highlight the searched characters on suggested list items.
         * > For more details about the highlight refer to [`Custom highlight search`](./how-to.html#custom-highlight-search) documentation.
         * @default false.
         */
        highlight: boolean;
        /**
         * Supports the [`specified number`](./filtering.html#filter-item-count)
         * of list items on the suggestion popup.
         * @default 20.
         */
        suggestionCount: number;
        /**
         * Allows additional HTML attributes such as title, name, etc., and
         * accepts n number of attributes in a key-value pair format.
         *
         * {% codeBlock src="autocomplete/html-attributes-api/index.ts" %}{% endcodeBlock %}
         *
         * {% codeBlock src="autocomplete/html-attributes-api/index.html" %}{% endcodeBlock %}
         * @default {}.
         */
        htmlAttributes: {
            [key: string]: string;
        };
        /**
         * Accepts the external [`query`](./api-query.html)
         * that execute along with data processing.
         *
         * {% codeBlock src="autocomplete/query-api/index.ts" %}{% endcodeBlock %}
         *
         * {% codeBlock src="autocomplete/query-api/index.html" %}{% endcodeBlock %}
         * @default null.
         */
        query: ej.data.Query;
        /**
         * Allows you to set [`the minimum search character length']
         * (./filtering.html#limit-the-minimum-filter-character),
         * the search action will perform after typed minimum characters.
         * @default 1.
         */
        minLength: number;
        /**
         * Determines on which filter type, the component needs to be considered on search action.
         * The available [`FilterType`](./filtering.html#change-the-filter-type)
         * and its supported data types are
         *
         * <table>
         * <tr>
         * <td colSpan=1 rowSpan=1>
         * FilterType<br/></td><td colSpan=1 rowSpan=1>
         * Description<br/></td><td colSpan=1 rowSpan=1>
         * Supported Types<br/></td></tr>
         * <tr>
         * <td colSpan=1 rowSpan=1>
         * StartsWith<br/></td><td colSpan=1 rowSpan=1>
         * Checks whether a value begins with the specified value.<br/></td><td colSpan=1 rowSpan=1>
         * String<br/></td></tr>
         * <tr>
         * <td colSpan=1 rowSpan=1>
         * EndsWith<br/></td><td colSpan=1 rowSpan=1>
         * Checks whether a value ends with specified value.<br/><br/></td><td colSpan=1 rowSpan=1>
         * <br/>String<br/></td></tr>
         * <tr>
         * <td colSpan=1 rowSpan=1>
         * Contains<br/></td><td colSpan=1 rowSpan=1>
         * Checks whether a value contains with specified value.<br/><br/></td><td colSpan=1 rowSpan=1>
         * <br/>String<br/></td></tr>
         * </table>
         *
         * {% codeBlock src="autocomplete/filter-type-api/index.ts" %}{% endcodeBlock %}
         *
         * {% codeBlock src="autocomplete/filter-type-api/index.html" %}{% endcodeBlock %}
         *
         * The default value set to `Contains`, all the suggestion items which contain typed characters to listed in the suggestion popup.
         * @default 'Contains'.
         */
        filterType: FilterType;
        /**
         * Triggers on typing a character in the component.
         * @event
         */
        filtering: ej.base.EmitType<FilteringArgs>;
        /**
         * Not applicable to this component.
         * @default null.
         * @private
         */
        index: number;
        /**
         * Specifies whether to display the floating label above the input element.
         * Possible values are:
         * * Never: The label will never float in the input when the placeholder is available.
         * * Always: The floating label will always float above the input.
         * * Auto: The floating label will float above the input after focusing or entering a value in the input.
         *
         * {% codeBlock src="autocomplete/float-label-type-api/index.ts" %}{% endcodeBlock %}
         *
         * {% codeBlock src="autocomplete/float-label-type-api/index.html" %}{% endcodeBlock %}
         *
         *  @default 'Never'.
         */
        floatLabelType: ej.inputs.FloatLabelType;
        /**
         * Not applicable to this component.
         * @default null.
         * @private
         */
        valueTemplate: string;
        /**
         * Not applicable to this component.
         * @default null.
         * @private
         */
        filterBarPlaceholder: string;
        /**
         * Not applicable to this component.
         * @default false.
         * @private
         */
        allowFiltering: boolean;
        /**
         * Not applicable to this component.
         * @default null.
         * @private
         */
        text: string;
        /**
         * * Constructor for creating the widget
         */
        constructor(options?: AutoCompleteModel, element?: string | HTMLElement);
        /**
         * Initialize the event handler
         * @private
         */
        protected preRender(): void;
        protected getNgDirective(): string;
        protected getQuery(query: ej.data.Query): ej.data.Query;
        protected searchLists(e: ej.base.KeyboardEventArgs): void;
        private filterAction(dataSource, query?, fields?);
        protected clear(e?: MouseEvent, property?: string): void;
        protected onActionComplete(ulElement: HTMLElement, list: {
            [key: string]: Object;
        }[], e?: Object, isUpdated?: boolean): void;
        private postBackAction();
        protected setSelection(li: Element, e: MouseEvent | ej.base.KeyboardEventArgs | TouchEvent): void;
        protected showSpinner(): void;
        protected hideSpinner(): void;
        protected isFiltering(): boolean;
        protected renderPopup(): void;
        protected isEditTextBox(): boolean;
        protected isPopupButton(): boolean;
        protected isSelectFocusItem(element: Element): boolean;
        /**
         * Search the entered text and show it in the suggestion list if available.
         * @returns void.
         */
        showPopup(): void;
        /**
         * Hides the popup if it is in open state.
         * @returns void.
         */
        hidePopup(): void;
        /**
         * Dynamically change the value of properties.
         * @private
         */
        onPropertyChanged(newProp: AutoCompleteModel, oldProp: AutoCompleteModel): void;
        /**
         * Return the module name of this component.
         * @private
         */
        getModuleName(): string;
        /**
         * To initialize the control rendering
         * @private
         */
        render(): void;
    }
    export interface FilteringArgs extends FilteringEventArgs {
        /**
         * To prevent the internal filtering action.
         */
        preventDefaultAction: boolean;
    }
    
    /**
     * Interface for a class ComboBox
     */
    export interface ComboBoxModel extends ej.dropdowns.DropDownListModel{
    
        /**
         * Specifies whether suggest a first matched item in input when searching. No action happens when no matches found.
         * @default false.
         */
        autofill?: boolean;
    
        /**
         * Specifies whether the component allows user defined value which does not exist in data source.    
         * @default true.
         */
        allowCustom?: boolean;
    
        /**
         * Allows additional HTML attributes such as title, name, etc., and
         * accepts n number of attributes in a key-value pair format.
         * 
         * {% codeBlock src="combobox/html-attributes-api/index.ts" %}{% endcodeBlock %}
         * 
         * {% codeBlock src="combobox/html-attributes-api/index.html" %}{% endcodeBlock %}
         * @default {}.
         */
        htmlAttributes?: { [key: string]: string; };
    
        /**
         * When allowFiltering is set to true, show the filter bar (search box) of the component.
         * The filter action retrieves matched items through the `filtering` event based on
         * the characters typed in the search TextBox.
         * If no match is found, the value of the `noRecordsTemplate` property will be displayed.
         * 
         * {% codeBlock src="combobox/allow-filtering-api/index.ts" %}{% endcodeBlock %}
         * 
         * {% codeBlock src="combobox/allow-filtering-api/index.html" %}{% endcodeBlock %}
         * @default false.
         */
        allowFiltering?: boolean;
    
        /**
         * Accepts the external [`Query`](./api-query.html)
         * that execute along with [`data processing`](./data-binding.html).
         * 
         * {% codeBlock src="combobox/query-api/index.ts" %}{% endcodeBlock %}
         * 
         * {% codeBlock src="combobox/query-api/index.html" %}{% endcodeBlock %}
         * @default null.
         */
        query?: ej.data.Query;
    
        /**
         * Gets or sets the index of the selected item in the component.
         * 
         * {% codeBlock src="combobox/index-api/index.ts" %}{% endcodeBlock %}
         * 
         * {% codeBlock src="combobox/index-api/index.html" %}{% endcodeBlock %}
         * 
         * @default null.
         */
        index?: number;
    
        /**
         * Specifies whether to show or hide the clear button. 
         * When the clear button is clicked, `value`, `text`, and `index` properties are reset to null.
         * @default true.
         */
        showClearButton?: boolean;
    
        /**
         * Triggers on set a 
         * [`custom value`](./getting-started.html#custom-values) to this component.
         * @event
         */
        customValueSpecifier?: ej.base.EmitType<CustomValueSpecifierEventArgs>;
    
        /**
         * Triggers on typing a character in the component.
         * > For more details about the filtering refer to [`Filtering`](./filtering.html) documentation.
         * @event
         */
        filtering?: ej.base.EmitType<FilteringEventArgs>;
    
        /**
         * Not applicable to this component.
         * @default null.
         * @private
         */
        valueTemplate?: string;
    
        /**
         * Specifies whether to display the floating label above the input element.
         * Possible values are:
         * * Never: The label will never float in the input when the placeholder is available.
         * * Always: The floating label will always float above the input.
         * * Auto: The floating label will float above the input after focusing or entering a value in the input.
         * 
         * {% codeBlock src="combobox/float-label-type-api/index.ts" %}{% endcodeBlock %}
         * 
         * {% codeBlock src="combobox/float-label-type-api/index.html" %}{% endcodeBlock %}
         * 
         *  @default 'Never'.
         */
        floatLabelType?: ej.inputs.FloatLabelType;
    
        /**
         * Not applicable to this component.
         * @default null.
         * @private
         */
        filterBarPlaceholder?: string;
    
    }
    
    /**
     * The ComboBox component allows the user to type a value or choose an option from the list of predefined options.
     * ```html
     * <select id="list">
     *      <option value='1'>Badminton</option>
     *      <option value='2'>Basketball</option>
     *      <option value='3'>Cricket</option>
     *      <option value='4'>Football</option>
     *      <option value='5'>Tennis</option>
     * </select>
     * ```
     * ```typescript
     *   let games:ComboBox = new ComboBox();
     *   games.appendTo("#list");
     * ```
     */
    export class ComboBox extends DropDownList {
        /**
         * Specifies whether suggest a first matched item in input when searching. No action happens when no matches found.
         * @default false.
         */
        autofill: boolean;
        /**
         * Specifies whether the component allows user defined value which does not exist in data source.
         * @default true.
         */
        allowCustom: boolean;
        /**
         * Allows additional HTML attributes such as title, name, etc., and
         * accepts n number of attributes in a key-value pair format.
         *
         * {% codeBlock src="combobox/html-attributes-api/index.ts" %}{% endcodeBlock %}
         *
         * {% codeBlock src="combobox/html-attributes-api/index.html" %}{% endcodeBlock %}
         * @default {}.
         */
        htmlAttributes: {
            [key: string]: string;
        };
        /**
         * When allowFiltering is set to true, show the filter bar (search box) of the component.
         * The filter action retrieves matched items through the `filtering` event based on
         * the characters typed in the search TextBox.
         * If no match is found, the value of the `noRecordsTemplate` property will be displayed.
         *
         * {% codeBlock src="combobox/allow-filtering-api/index.ts" %}{% endcodeBlock %}
         *
         * {% codeBlock src="combobox/allow-filtering-api/index.html" %}{% endcodeBlock %}
         * @default false.
         */
        allowFiltering: boolean;
        /**
         * Accepts the external [`Query`](./api-query.html)
         * that execute along with [`data processing`](./data-binding.html).
         *
         * {% codeBlock src="combobox/query-api/index.ts" %}{% endcodeBlock %}
         *
         * {% codeBlock src="combobox/query-api/index.html" %}{% endcodeBlock %}
         * @default null.
         */
        query: ej.data.Query;
        /**
         * Gets or sets the index of the selected item in the component.
         *
         * {% codeBlock src="combobox/index-api/index.ts" %}{% endcodeBlock %}
         *
         * {% codeBlock src="combobox/index-api/index.html" %}{% endcodeBlock %}
         *
         * @default null.
         */
        index: number;
        /**
         * Specifies whether to show or hide the clear button.
         * When the clear button is clicked, `value`, `text`, and `index` properties are reset to null.
         * @default true.
         */
        showClearButton: boolean;
        /**
         * Triggers on set a
         * [`custom value`](./getting-started.html#custom-values) to this component.
         * @event
         */
        customValueSpecifier: ej.base.EmitType<CustomValueSpecifierEventArgs>;
        /**
         * Triggers on typing a character in the component.
         * > For more details about the filtering refer to [`Filtering`](./filtering.html) documentation.
         * @event
         */
        filtering: ej.base.EmitType<FilteringEventArgs>;
        /**
         * Not applicable to this component.
         * @default null.
         * @private
         */
        valueTemplate: string;
        /**
         * Specifies whether to display the floating label above the input element.
         * Possible values are:
         * * Never: The label will never float in the input when the placeholder is available.
         * * Always: The floating label will always float above the input.
         * * Auto: The floating label will float above the input after focusing or entering a value in the input.
         *
         * {% codeBlock src="combobox/float-label-type-api/index.ts" %}{% endcodeBlock %}
         *
         * {% codeBlock src="combobox/float-label-type-api/index.html" %}{% endcodeBlock %}
         *
         *  @default 'Never'.
         */
        floatLabelType: ej.inputs.FloatLabelType;
        /**
         * Not applicable to this component.
         * @default null.
         * @private
         */
        filterBarPlaceholder: string;
        /**
         * *Constructor for creating the component
         */
        constructor(options?: ComboBoxModel, element?: string | HTMLElement);
        /**
         * Initialize the event handler
         * @private
         */
        protected preRender(): void;
        protected wireEvent(): void;
        private preventBlur(e);
        protected targetElement(): HTMLElement | HTMLInputElement;
        protected setOldText(text: string): void;
        protected setOldValue(value: string | number): void;
        private valueMuteChange(value);
        protected updateValues(): void;
        protected getAriaAttributes(): {
            [key: string]: string;
        };
        protected searchLists(e: ej.base.KeyboardEventArgs): void;
        protected getNgDirective(): string;
        protected setSearchBox(): ej.inputs.InputObject;
        protected onActionComplete(ulElement: HTMLElement, list: {
            [key: string]: Object;
        }[], e?: Object, isUpdated?: boolean): void;
        protected getFocusElement(): Element;
        protected setValue(e?: ej.base.KeyboardEventArgs): boolean;
        protected showSpinner(): void;
        protected hideSpinner(): void;
        protected setAutoFill(activeElement: Element, isHover?: boolean): void;
        private isAndroidAutoFill(value);
        protected isSelectFocusItem(element: Element): boolean;
        private inlineSearch(e?);
        protected incrementalSearch(e: ej.base.KeyboardEventArgs): void;
        private setAutoFillSelection(currentValue);
        protected getValueByText(text: string): string | number;
        protected unWireEvent(): void;
        protected setSelection(li: Element, e: MouseEvent | ej.base.KeyboardEventArgs | TouchEvent): void;
        protected selectCurrentItem(e: ej.base.KeyboardEventArgs): void;
        protected setHoverList(li: Element): void;
        private targetFocus(e);
        protected dropDownClick(e: MouseEvent): void;
        private customValue();
        /**
         * Dynamically change the value of properties.
         * @private
         */
        onPropertyChanged(newProp: ComboBoxModel, oldProp: ComboBoxModel): void;
        /**
         * To initialize the control rendering.
         * @private
         */
        render(): void;
        /**
         * Return the module name of this component.
         * @private
         */
        getModuleName(): string;
        /**
         * Hides the popup if it is in open state.
         * @returns void.
         */
        hidePopup(): void;
        /**
         * Sets the focus to the component for interaction.
         * @returns void.
         */
        focusIn(): void;
    }
    export interface CustomValueSpecifierEventArgs {
        /**
         * Gets the typed custom text to make a own text format and assign it to `item` argument.
         */
        text: string;
        /**
         * Sets the text custom format data for set a `value` and `text`.
         */
        item: {
            [key: string]: string | Object;
        };
    }
    
    export type HightLightType = 'Contains' | 'StartsWith' | 'EndsWith';
    /**
     * Function helps to find which highlightSearch is to call based on your data.
     * @param  {HTMLElement} content - Specifies an content element.
     * @param  {string} query - Specifies the string to be highlighted.
     * @param  {boolean} ignoreCase - Specifies the ignoreCase option.
     * @param  {HightLightType} type - Specifies the type of highlight.
     */
    export function highlightSearch(content: HTMLElement, query: string, ignoreCase: boolean, type?: HightLightType): void;
    
    export type SearchType = 'StartsWith' | 'Equal';
    /**
     * Search and focus the list item based on key code matches with list text content
     * @param  { number } keyCode - Specifies the key code which pressed on keyboard events.
     * @param  { HTMLElement[]] } items - Specifies an array of HTMLElement, from which matches find has done.
     * @param { number } selectedIndex - Specifies the selected item in list item, so that search will happen
     * after selected item otherwise it will do from initial.
     * @param  { boolean } ignoreCase - Specifies the case consideration when search has done.
     */
    export function incrementalSearch(keyCode: number, items: HTMLElement[], selectedIndex: number, ignoreCase: boolean): Element;
    export function Search(inputVal: string, items: HTMLElement[], searchType: SearchType, ignoreCase?: boolean): {
        [key: string]: Element | number;
    };
    
    /**
     * Interface for a class FieldSettings
     */
    export interface FieldSettingsModel {
    
        /**
         * Maps the text column from data table for each list item
         * @default null.
         */
        text?: string;
    
        /**
         * Maps the value column from data table for each list item
         * @default null.
         */
        value?: string;
    
        /**
         * Maps the icon class column from data table for each list item.
         * @default null.
         */
        iconCss?: string;
    
        /**
         * Group the list items with it's related items by mapping groupBy field.
         * @default null.
         */
        groupBy?: string;
    
    }
    
    /**
     * Interface for a class DropDownBase
     */
    export interface DropDownBaseModel extends ej.base.ComponentModel{
    
        /**
         * The `fields` property maps the columns of the data table and binds the data to the component.
         * * text - Maps the text column from data table for each list item.
         * * value - Maps the value column from data table for each list item.
         * * iconCss - Maps the icon class column from data table for each list item.
         * * groupBy - Group the list items with it's related items by mapping groupBy field.
         * ```html
         * <input type="text" tabindex="1" id="list"> </input>
         * ```
         * ```typescript  
         *   let customers: DropDownList = new DropDownList({
         *      dataSource:new DataManager({ url:'http://js.syncfusion.com/demos/ejServices/Wcf/Northwind.svc/' }),
         *      query: new Query().from('Customers').select(['ContactName', 'CustomerID']).take(5),
         *      fields: { text: 'ContactName', value: 'CustomerID' },
         *      placeholder: 'Select a customer'
         *   });
         *   customers.appendTo("#list");
         * ```
         * @default {text: null, value: null, iconCss: null, groupBy: null}
         */
        fields?: FieldSettingsModel;
    
        /**
         * When set to true, enables RTL mode of the component that 
         * displays the content in the right-to-left direction.
         * @default false.
         */
        enableRtl?: boolean;
    
        /**
         * Enable or disable persisting component's state between page reloads. 
         * If enabled, following list of states will be persisted.
         * 1. value
         * @default false.
         */
        enablePersistence?: boolean;
    
        /**
         * Accepts the template design and assigns it to each list item present in the popup.
         * We have built-in [`template engine`](./template-engine.html)
         * 
         * which provides options to compile template string into a executable function. 
         * For EX: We have expression evolution as like ES6 expression string literals. 
         * @default null.
         */
        itemTemplate?: string;
    
        /**
         * Accepts the template design and assigns it to the group headers present in the popup list.
         * @default null.
         */
        groupTemplate?: string;
    
        /**
         * Accepts the template design and assigns it to popup list of component
         * when no data is available on the component.
         * @default 'No Records Found'.
         */
        noRecordsTemplate?: string;
    
        /**
         * Accepts the template and assigns it to the popup list content of the component
         * when the data fetch request from the remote server fails.
         * @default 'The Request Failed'.
         */
        actionFailureTemplate?: string;
    
        /**
         * Specifies the `sortOrder` to sort the data source. The available type of sort orders are
         * * `None` - The data source is not sorting.
         * * `Ascending` - The data source is sorting with ascending order.
         * * `Descending` - The data source is sorting with descending order.
         * @default None.
         */
        sortOrder?: ej.lists.SortOrder;
    
        /**
         * Specifies a value that indicates whether the component is enabled or not.
         * @default true.
         */
        enabled?: boolean;
    
        /**
         * Accepts the list items either through local or remote service and binds it to the component.
         * It can be an array of JSON Objects or an instance of
         * [`DataManager`](./api-dataManager.html).
         * @default [].
         */
        dataSource?: { [key: string]: Object }[] | ej.data.DataManager | string[] | number[];
    
        /**
         * Accepts the external [`Query`](./api-query.html)
         * which will execute along with the data processing.
         * @default null.
         */
        query?: ej.data.Query;
    
        /**
         * specifies the z-index value of the component popup element.
         * @default 1000
         */
        zIndex?: number;
    
        /**
         * ignoreAccent set to true, then ignores the diacritic characters or accents when filtering.
         */
        ignoreAccent?: boolean;
    
        /**
         * Triggers before fetching data from the remote server.
         * @event
         */
        actionBegin?: ej.base.EmitType<Object>;
    
        /**
         * Triggers after data is fetched successfully from the remote server.
         * @event
         */
        actionComplete?: ej.base.EmitType<Object>;
    
        /**
         * Triggers when the data fetch request from the remote server fails.
         * @event
         */
        actionFailure?: ej.base.EmitType<Object>;
    
        /**
         * Triggers when an item in the popup is selected by the user either with mouse/tap or with keyboard navigation.
         * @event
         */
        select?: ej.base.EmitType<SelectEventArgs>;
    
    }
    
    export class FieldSettings extends ej.base.ChildProperty<FieldSettings> {
        /**
         * Maps the text column from data table for each list item
         * @default null.
         */
        text: string;
        /**
         * Maps the value column from data table for each list item
         * @default null.
         */
        value: string;
        /**
         * Maps the icon class column from data table for each list item.
         * @default null.
         */
        iconCss: string;
        /**
         * Group the list items with it's related items by mapping groupBy field.
         * @default null.
         */
        groupBy: string;
    }
    export const dropDownBaseClasses: DropDownBaseClassList;
    export interface DropDownBaseClassList {
        root: string;
        rtl: string;
        content: string;
        selected: string;
        hover: string;
        noData: string;
        fixedHead: string;
        focus: string;
        li: string;
        disabled: string;
        group: string;
        grouping: string;
    }
    export interface SelectEventArgs {
        /**
         * If the event is triggered by interaction, it returns true. Otherwise, it returns false.
         */
        isInteracted: boolean;
        /**
         * Returns the selected list item
         */
        item: HTMLLIElement;
        /**
         * Returns the selected item as JSON Object from the data source.
         */
        itemData: FieldSettingsModel;
        /**
         * Specifies the original event arguments.
         */
        e: MouseEvent | KeyboardEvent | TouchEvent;
        /**
         * Illustrates whether the current action needs to be prevented or not.
         */
        cancel?: boolean;
    }
    /**
     * DropDownBase component will generate the list items based on given data and act as base class to drop-down related components
     */
    export class DropDownBase extends ej.base.Component<HTMLElement> implements ej.base.INotifyPropertyChanged {
        protected listData: {
            [key: string]: Object;
        }[];
        protected ulElement: HTMLElement;
        protected liCollections: HTMLElement[];
        private bindEvent;
        private scrollTimer;
        protected list: HTMLElement;
        protected fixedHeaderElement: HTMLElement;
        protected keyboardModule: ej.base.KeyboardEvents;
        protected enableRtlElements: HTMLElement[];
        protected rippleFun: Function;
        protected l10n: ej.base.L10n;
        protected item: HTMLLIElement;
        protected itemData: {
            [key: string]: Object;
        };
        protected isActive: boolean;
        protected isRequested: boolean;
        protected queryString: string;
        /**
         * The `fields` property maps the columns of the data table and binds the data to the component.
         * * text - Maps the text column from data table for each list item.
         * * value - Maps the value column from data table for each list item.
         * * iconCss - Maps the icon class column from data table for each list item.
         * * groupBy - Group the list items with it's related items by mapping groupBy field.
         * ```html
         * <input type="text" tabindex="1" id="list"> </input>
         * ```
         * ```typescript
         *   let customers: DropDownList = new DropDownList({
         *      dataSource:new DataManager({ url:'http://js.syncfusion.com/demos/ejServices/Wcf/Northwind.svc/' }),
         *      query: new Query().from('Customers').select(['ContactName', 'CustomerID']).take(5),
         *      fields: { text: 'ContactName', value: 'CustomerID' },
         *      placeholder: 'Select a customer'
         *   });
         *   customers.appendTo("#list");
         * ```
         * @default {text: null, value: null, iconCss: null, groupBy: null}
         */
        fields: FieldSettingsModel;
        /**
         * When set to true, enables RTL mode of the component that
         * displays the content in the right-to-left direction.
         * @default false.
         */
        enableRtl: boolean;
        /**
         * Enable or disable persisting component's state between page reloads.
         * If enabled, following list of states will be persisted.
         * 1. value
         * @default false.
         */
        enablePersistence: boolean;
        /**
         * Accepts the template design and assigns it to each list item present in the popup.
         * We have built-in [`template engine`](./template-engine.html)
         *
         * which provides options to compile template string into a executable function.
         * For EX: We have expression evolution as like ES6 expression string literals.
         * @default null.
         */
        itemTemplate: string;
        /**
         * Accepts the template design and assigns it to the group headers present in the popup list.
         * @default null.
         */
        groupTemplate: string;
        /**
         * Accepts the template design and assigns it to popup list of component
         * when no data is available on the component.
         * @default 'No Records Found'.
         */
        noRecordsTemplate: string;
        /**
         * Accepts the template and assigns it to the popup list content of the component
         * when the data fetch request from the remote server fails.
         * @default 'The Request Failed'.
         */
        actionFailureTemplate: string;
        /**
         * Specifies the `sortOrder` to sort the data source. The available type of sort orders are
         * * `None` - The data source is not sorting.
         * * `Ascending` - The data source is sorting with ascending order.
         * * `Descending` - The data source is sorting with descending order.
         * @default None.
         */
        sortOrder: ej.lists.SortOrder;
        /**
         * Specifies a value that indicates whether the component is enabled or not.
         * @default true.
         */
        enabled: boolean;
        /**
         * Accepts the list items either through local or remote service and binds it to the component.
         * It can be an array of JSON Objects or an instance of
         * [`DataManager`](./api-dataManager.html).
         * @default [].
         */
        dataSource: {
            [key: string]: Object;
        }[] | ej.data.DataManager | string[] | number[];
        /**
         * Accepts the external [`Query`](./api-query.html)
         * which will execute along with the data processing.
         * @default null.
         */
        query: ej.data.Query;
        /**
         * specifies the z-index value of the component popup element.
         * @default 1000
         */
        zIndex: number;
        /**
         * ignoreAccent set to true, then ignores the diacritic characters or accents when filtering.
         */
        ignoreAccent: boolean;
        /**
         * Triggers before fetching data from the remote server.
         * @event
         */
        actionBegin: ej.base.EmitType<Object>;
        /**
         * Triggers after data is fetched successfully from the remote server.
         * @event
         */
        actionComplete: ej.base.EmitType<Object>;
        /**
         * Triggers when the data fetch request from the remote server fails.
         * @event
         */
        actionFailure: ej.base.EmitType<Object>;
        /**
         * Triggers when an item in the popup is selected by the user either with mouse/tap or with keyboard navigation.
         * @event
         */
        select: ej.base.EmitType<SelectEventArgs>;
        /**
         * * Constructor for DropDownBase class
         */
        constructor(options?: DropDownBaseModel, element?: string | HTMLElement);
        protected getPropObject(prop: string, newProp: {
            [key: string]: string;
        }, oldProp: {
            [key: string]: string;
        }): {
            [key: string]: Object;
        };
        protected getValueByText(text: string, ignoreCase?: boolean): string | number;
        protected l10nUpdate(actionFailure?: boolean): void;
        protected getTextByValue(value: string | number): string;
        protected getFormattedValue(value: string): string | number;
        /**
         * Sets RTL to dropdownbase wrapper
         */
        protected setEnableRtl(): void;
        /**
         * Initialize the Component.
         */
        private initialize();
        /**
         * Get the properties to be maintained in persisted state.
         */
        protected getPersistData(): string;
        /**
         * Sets the enabled state to DropDownBase.
         */
        protected setEnabled(): void;
        private renderItemsBySelect();
        private getJSONfromOption(items, options, fields);
        /**
         * Execute before render the list items
         * @private
         */
        protected preRender(): void;
        /**
         * Creates the list items of DropDownBase component.
         */
        private setListData(dataSource, fields, query);
        protected showSpinner(): void;
        protected hideSpinner(): void;
        protected onActionFailure(e: Object): void;
        protected onActionComplete(ulElement: HTMLElement, list: {
            [key: string]: Object;
        }[], e?: Object): void;
        protected postRender(listElement: HTMLElement, list: {
            [key: string]: Object;
        }[], bindEvent: boolean): void;
        /**
         * Get the query to do the data operation before list item generation.
         */
        protected getQuery(query: ej.data.Query): ej.data.Query;
        /**
         * To render the template content for group header element.
         */
        private renderGroupTemplate(listEle);
        /**
         * To create the ul li list items
         */
        private createListItems(dataSource, fields);
        protected listOption(dataSource: {
            [key: string]: Object;
        }[], fields: FieldSettingsModel): {
            [key: string]: Object;
        };
        protected setFloatingHeader(e: Event): void;
        private scrollStop(e);
        /**
         * To render the list items
         */
        private renderItems(listData, fields);
        protected templateListItem(dataSource: {
            [key: string]: Object;
        }[], fields: FieldSettingsModel): HTMLElement;
        protected typeOfData(items: {
            [key: string]: Object;
        }[] | string[]): {
            [key: string]: Object;
        };
        protected setFixedHeader(): void;
        private getSortedDataSource(dataSource);
        /**
         * Return the index of item which matched with given value in data source
         */
        protected getIndexByValue(value: string | number): number;
        /**
         * To dispatch the event manually
         */
        protected dispatchEvent(element: HTMLElement, type: string): void;
        /**
         * To set the current fields
         */
        protected setFields(): void;
        /**
         * reset the items list.
         */
        protected resetList(dataSource?: {
            [key: string]: Object;
        }[] | ej.data.DataManager | string[] | number[], fields?: FieldSettingsModel, query?: ej.data.Query): void;
        protected updateSelection(): void;
        protected renderList(): void;
        protected updateDataSource(prop?: string): void;
        protected setUpdateInitial(props: string[], newProp: {
            [key: string]: string;
        }): void;
        /**
         * When property value changes happened, then onPropertyChanged method will execute the respective changes in this component.
         * @private
         */
        onPropertyChanged(newProp: DropDownBaseModel, oldProp: DropDownBaseModel): void;
        /**
         * Build and render the component
         * @private
         */
        render(isEmptyData?: boolean): void;
        /**
         * Return the module name of this component.
         * @private
         */
        getModuleName(): string;
        /**
         * Gets all the list items bound on this component.
         * @returns Element[].
         */
        getItems(): Element[];
        /**
         * Adds a new item to the popup list. By default, new item appends to the list as the last item,
         * but you can insert based on the index parameter.
         * @param  { Object[] } items - Specifies an array of JSON data or a JSON data.
         * @param { number } itemIndex - Specifies the index to place the newly added item in the popup list.
         * @return {void}.
         */
        addItem(items: {
            [key: string]: Object;
        }[] | {
            [key: string]: Object;
        }, itemIndex?: number): void;
        protected setZIndex(): void;
        protected updateActionCompleteData(li: HTMLElement, item: {
            [key: string]: Object;
        }): void;
        /**
         * Gets the data Object that matches the given value.
         * @param { string | number } value - Specifies the value of the list item.
         * @returns Object.
         */
        getDataByValue(value: string | number): {
            [key: string]: Object;
        };
        /**
         * Removes the component from the DOM and detaches all its related event handlers. It also removes the attributes and classes.
         * @method destroy
         * @return {void}.
         */
        destroy(): void;
    }
    
    /**
     * Interface for a class DropDownList
     */
    export interface DropDownListModel extends DropDownBaseModel{
    
        /**
         * Sets CSS classes to the root element of the component that allows customization of appearance.
         * @default null.
         */
        cssClass?: string;
    
        /**
         * Specifies the width of the component. By default, the component width sets based on the width of 
         * its parent container. You can also set the width in pixel values.
         * @default '100%'.
         */
        width?: string | number;
    
        /**
         * Specifies the height of the popup list.  
         * > For more details about the popup configuration refer to 
         * [`Popup Configuration`](./getting-started.html#configure-the-popup-list) documentation.
         * @default '300px'.
         */
        popupHeight?: string | number;
    
        /**
         * Specifies the width of the popup list. By default, the popup width sets based on the width of 
         * the component.
         * > For more details about the popup configuration refer to 
         * [`Popup Configuration`](./getting-started.html#configure-the-popup-list) documentation.
         * @default '100%'.
         */
        popupWidth?: string | number;
    
        /**
         * Specifies a short hint that describes the expected value of the DropDownList component.
         * @default null.
         */
        placeholder?: string;
    
        /**
         * Accepts the value to be displayed as a watermark text on the filter bar. 
         * @default null.
         */
        filterBarPlaceholder?: string;
    
        /**
         * Allows additional HTML attributes such as title, name, etc., and
         * accepts n number of attributes in a key-value pair format.
         * 
         * {% codeBlock src="dropdownlist/html-attributes-api/index.ts" %}{% endcodeBlock %}
         * 
         * {% codeBlock src="dropdownlist/html-attributes-api/index.html" %}{% endcodeBlock %}
         *
         * @default {}.
         */
        htmlAttributes?: { [key: string]: string; };
    
        /**
         * Accepts the external [`Query`](./api-query.html)
         * that execute along with data processing.
         * 
         * {% codeBlock src="dropdownlist/query-api/index.ts" %}{% endcodeBlock %}
         * 
         * {% codeBlock src="dropdownlist/query-api/index.html" %}{% endcodeBlock %}
         * 
         * @default null.
         */
        query?: ej.data.Query;
    
        /**
         * Accepts the template design and assigns it to the selected list item in the input element of the component.
         * For more details about the available template options refer to 
         * [`Template`](./templates.html) documentation.
         * 
         * We have built-in [`template engine`](./template-engine.html) 
         * which provides options to compile template string into a executable function. 
         * For EX: We have expression evolution as like ES6 expression string literals.
         * @default null.
         */
        valueTemplate?: string;
    
        /**
         * Accepts the template design and assigns it to the header container of the popup list.
         * > For more details about the available template options refer to [`Template`](./templates.html) documentation.
         * @default null.
         */
        headerTemplate?: string;
    
        /**
         * Accepts the template design and assigns it to the footer container of the popup list.
         * > For more details about the available template options refer to [`Template`](./templates.html) documentation.
         * @default null.
         */
        footerTemplate?: string;
    
        /**
         * When allowFiltering is set to true, show the filter bar (search box) of the component.
         * The filter action retrieves matched items through the `filtering` event based on
         * the characters typed in the search TextBox.
         * 
         * If no match is found, the value of the `noRecordsTemplate` property will be displayed.
         * > For more details about the filtering refer to [`Filtering`](./filtering.html) documentation.
         * 
         * {% codeBlock src="dropdownlist/allow-filtering-api/index.ts" %}{% endcodeBlock %}
         * 
         * {% codeBlock src="dropdownlist/allow-filtering-api/index.html" %}{% endcodeBlock %}
         * @default false.
         */
        allowFiltering?: boolean;
    
        /**
         * When set to true, the user interactions on the component are disabled.
         * @default false.
         */
        readonly?: boolean;
    
        /**
         * Gets or sets the display text of the selected item in the component.
         * @default null.
         */
        text?: string;
    
        /**
         * Gets or sets the value of the selected item in the component.
         * @default null.
         */
        value?: number | string;
    
        /**
         * Gets or sets the index of the selected item in the component.
         * 
         * {% codeBlock src="dropdownlist/index-api/index.ts" %}{% endcodeBlock %}
         * 
         * {% codeBlock src="dropdownlist/index-api/index.html" %}{% endcodeBlock %}
         * 
         * @default null.
         */
        index?: number;
    
        /**
         * Specifies whether to display the floating label above the input element.
         * Possible values are:
         * * Never: The label will never float in the input when the placeholder is available.
         * * Always: The floating label will always float above the input.
         * * Auto: The floating label will float above the input after focusing or entering a value in the input.
         * 
         * {% codeBlock src="dropdownlist/float-label-type-api/index.ts" %}{% endcodeBlock %}
         * 
         * {% codeBlock src="dropdownlist/float-label-type-api/index.html" %}{% endcodeBlock %}
         * 
         *  @default 'Never'.
         */
        floatLabelType?: ej.inputs.FloatLabelType;
    
        /**
         * Specifies whether to show or hide the clear button. 
         * When the clear button is clicked, `value`, `text`, and `index` properties are reset to null.
         * @default false.
         */
        showClearButton?: boolean;
    
        /**
         * Triggers on typing a character in the filter bar when the 
         * [`allowFiltering`](./api-dropDownList.html#allowfiltering) 
         * is enabled.
         * > For more details about the filtering refer to [`Filtering`](./filtering.html) documentation.
         * 
         * @event
         */
        filtering?: ej.base.EmitType<FilteringEventArgs>;
    
        /**
         * Triggers when an item in a popup is selected or when the model value is changed by user.
         * Use change event to 
         * [`Configure the Cascading DropDownList`](./how-to.html#configure-the-cascading-dropdownlist)
         * @event
         */
        change?: ej.base.EmitType<ChangeEventArgs>;
    
        /**
         * Triggers when the popup opens.
         * @event
         */
        open?: ej.base.EmitType<PopupEventArgs>;
    
        /**
         * Triggers when the popup is closed.
         * @event
         */
        close?: ej.base.EmitType<PopupEventArgs>;
    
        /**
         * Triggers when focus moves out from the component.
         * @event
         */
        blur?: ej.base.EmitType<Object>;
    
        /**
         * Triggers when the component is focused.
         * @event
         */
        focus?: ej.base.EmitType<Object>;
    
    }
    
    export interface ChangeEventArgs extends SelectEventArgs {
        /**
         * Returns the selected value
         */
        value: number | string;
    }
    export const dropDownListClasses: DropDownListClassList;
    /**
     * The DropDownList component contains a list of predefined values from which you can
     * choose a single value.
     * ```html
     * <input type="text" tabindex="1" id="list"> </input>
     * ```
     * ```typescript
     *   let dropDownListObj:DropDownList = new DropDownList();
     *   dropDownListObj.appendTo("#list");
     * ```
     */
    export class DropDownList extends DropDownBase implements ej.inputs.IInput {
        protected inputWrapper: ej.inputs.InputObject;
        protected inputElement: HTMLInputElement;
        private valueTempElement;
        private listObject;
        private header;
        private footer;
        protected selectedLI: HTMLElement;
        private listHeight;
        protected hiddenElement: HTMLSelectElement;
        protected isPopupOpen: boolean;
        private isDocumentClick;
        protected isInteracted: boolean;
        private isFilterFocus;
        protected beforePopupOpen: boolean;
        protected initial: boolean;
        private initRemoteRender;
        private searchBoxHeight;
        private popupObj;
        private backIconElement;
        private clearIconElement;
        private containerStyle;
        protected previousValue: string | number;
        protected activeIndex: number;
        protected filterInput: HTMLInputElement;
        private searchKeyModule;
        private tabIndex;
        private isNotSearchList;
        protected isTyped: boolean;
        protected isSelected: boolean;
        protected preventFocus: boolean;
        protected preventAutoFill: boolean;
        protected queryString: string;
        protected isValidKey: boolean;
        protected typedString: string;
        protected isEscapeKey: boolean;
        private isPreventBlur;
        protected isTabKey: boolean;
        private actionCompleteData;
        protected prevSelectPoints: {
            [key: string]: number;
        };
        protected isSelectCustom: boolean;
        protected isDropDownClick: boolean;
        protected preventAltUp: boolean;
        private searchKeyEvent;
        private filterInputObj;
        protected spinnerElement: HTMLElement;
        protected keyConfigure: {
            [key: string]: string;
        };
        protected isCustomFilter: boolean;
        /**
         * Sets CSS classes to the root element of the component that allows customization of appearance.
         * @default null.
         */
        cssClass: string;
        /**
         * Specifies the width of the component. By default, the component width sets based on the width of
         * its parent container. You can also set the width in pixel values.
         * @default '100%'.
         */
        width: string | number;
        /**
         * Specifies the height of the popup list.
         * > For more details about the popup configuration refer to
         * [`Popup Configuration`](./getting-started.html#configure-the-popup-list) documentation.
         * @default '300px'.
         */
        popupHeight: string | number;
        /**
         * Specifies the width of the popup list. By default, the popup width sets based on the width of
         * the component.
         * > For more details about the popup configuration refer to
         * [`Popup Configuration`](./getting-started.html#configure-the-popup-list) documentation.
         * @default '100%'.
         */
        popupWidth: string | number;
        /**
         * Specifies a short hint that describes the expected value of the DropDownList component.
         * @default null.
         */
        placeholder: string;
        /**
         * Accepts the value to be displayed as a watermark text on the filter bar.
         * @default null.
         */
        filterBarPlaceholder: string;
        /**
         * Allows additional HTML attributes such as title, name, etc., and
         * accepts n number of attributes in a key-value pair format.
         *
         * {% codeBlock src="dropdownlist/html-attributes-api/index.ts" %}{% endcodeBlock %}
         *
         * {% codeBlock src="dropdownlist/html-attributes-api/index.html" %}{% endcodeBlock %}
         *
         * @default {}.
         */
        htmlAttributes: {
            [key: string]: string;
        };
        /**
         * Accepts the external [`Query`](./api-query.html)
         * that execute along with data processing.
         *
         * {% codeBlock src="dropdownlist/query-api/index.ts" %}{% endcodeBlock %}
         *
         * {% codeBlock src="dropdownlist/query-api/index.html" %}{% endcodeBlock %}
         *
         * @default null.
         */
        query: ej.data.Query;
        /**
         * Accepts the template design and assigns it to the selected list item in the input element of the component.
         * For more details about the available template options refer to
         * [`Template`](./templates.html) documentation.
         *
         * We have built-in [`template engine`](./template-engine.html)
         * which provides options to compile template string into a executable function.
         * For EX: We have expression evolution as like ES6 expression string literals.
         * @default null.
         */
        valueTemplate: string;
        /**
         * Accepts the template design and assigns it to the header container of the popup list.
         * > For more details about the available template options refer to [`Template`](./templates.html) documentation.
         * @default null.
         */
        headerTemplate: string;
        /**
         * Accepts the template design and assigns it to the footer container of the popup list.
         * > For more details about the available template options refer to [`Template`](./templates.html) documentation.
         * @default null.
         */
        footerTemplate: string;
        /**
         * When allowFiltering is set to true, show the filter bar (search box) of the component.
         * The filter action retrieves matched items through the `filtering` event based on
         * the characters typed in the search TextBox.
         *
         * If no match is found, the value of the `noRecordsTemplate` property will be displayed.
         * > For more details about the filtering refer to [`Filtering`](./filtering.html) documentation.
         *
         * {% codeBlock src="dropdownlist/allow-filtering-api/index.ts" %}{% endcodeBlock %}
         *
         * {% codeBlock src="dropdownlist/allow-filtering-api/index.html" %}{% endcodeBlock %}
         * @default false.
         */
        allowFiltering: boolean;
        /**
         * When set to true, the user interactions on the component are disabled.
         * @default false.
         */
        readonly: boolean;
        /**
         * Gets or sets the display text of the selected item in the component.
         * @default null.
         */
        text: string;
        /**
         * Gets or sets the value of the selected item in the component.
         * @default null.
         */
        value: number | string;
        /**
         * Gets or sets the index of the selected item in the component.
         *
         * {% codeBlock src="dropdownlist/index-api/index.ts" %}{% endcodeBlock %}
         *
         * {% codeBlock src="dropdownlist/index-api/index.html" %}{% endcodeBlock %}
         *
         * @default null.
         */
        index: number;
        /**
         * Specifies whether to display the floating label above the input element.
         * Possible values are:
         * * Never: The label will never float in the input when the placeholder is available.
         * * Always: The floating label will always float above the input.
         * * Auto: The floating label will float above the input after focusing or entering a value in the input.
         *
         * {% codeBlock src="dropdownlist/float-label-type-api/index.ts" %}{% endcodeBlock %}
         *
         * {% codeBlock src="dropdownlist/float-label-type-api/index.html" %}{% endcodeBlock %}
         *
         *  @default 'Never'.
         */
        floatLabelType: ej.inputs.FloatLabelType;
        /**
         * Specifies whether to show or hide the clear button.
         * When the clear button is clicked, `value`, `text`, and `index` properties are reset to null.
         * @default false.
         */
        showClearButton: boolean;
        /**
         * Triggers on typing a character in the filter bar when the
         * [`allowFiltering`](./api-dropDownList.html#allowfiltering)
         * is enabled.
         * > For more details about the filtering refer to [`Filtering`](./filtering.html) documentation.
         *
         * @event
         */
        filtering: ej.base.EmitType<FilteringEventArgs>;
        /**
         * Triggers when an item in a popup is selected or when the model value is changed by user.
         * Use change event to
         * [`Configure the Cascading DropDownList`](./how-to.html#configure-the-cascading-dropdownlist)
         * @event
         */
        change: ej.base.EmitType<ChangeEventArgs>;
        /**
         * Triggers when the popup opens.
         * @event
         */
        open: ej.base.EmitType<PopupEventArgs>;
        /**
         * Triggers when the popup is closed.
         * @event
         */
        close: ej.base.EmitType<PopupEventArgs>;
        /**
         * Triggers when focus moves out from the component.
         * @event
         */
        blur: ej.base.EmitType<Object>;
        /**
         * Triggers when the component is focused.
         * @event
         */
        focus: ej.base.EmitType<Object>;
        /**
         * * Constructor for creating the DropDownList component.
         */
        constructor(options?: ej.dropdowns.DropDownListModel, element?: string | HTMLElement);
        /**
         * Initialize the event handler.
         * @private
         */
        protected preRender(): void;
        private initializeData();
        protected setZIndex(): void;
        protected renderList(isEmptyData?: boolean): void;
        private floatLabelChange();
        protected resetHandler(e: MouseEvent): void;
        protected resetFocusElement(): void;
        protected clear(e?: MouseEvent | ej.base.KeyboardEventArgs, property?: string): void;
        private resetSelection();
        private setHTMLAttributes();
        protected getAriaAttributes(): {
            [key: string]: string;
        };
        protected setEnableRtl(): void;
        private setEnable();
        /**
         * Get the properties to be maintained in the persisted state.
         */
        protected getPersistData(): string;
        private preventTabIndex(element);
        protected targetElement(): HTMLElement | HTMLInputElement;
        protected getNgDirective(): string;
        protected getElementByText(text: string): Element;
        protected getElementByValue(value: string | number): Element;
        private initValue();
        protected updateValues(): void;
        protected onBlur(e: MouseEvent): void;
        protected focusOutAction(): void;
        protected onFocusOut(): void;
        protected onFocus(): void;
        protected wireEvent(): void;
        protected bindCommonEvent(): void;
        private bindClearEvent();
        protected unBindCommonEvent(): void;
        protected updateIconState(): void;
        /**
         * Event binding for list
         */
        private wireListEvents();
        private onSearch(e);
        protected onMouseClick(e: MouseEvent): void;
        private onMouseOver(e);
        private setHover(li);
        private onMouseLeave(e);
        private removeHover();
        protected isValidLI(li: Element | HTMLElement): boolean;
        protected incrementalSearch(e: ej.base.KeyboardEventArgs): void;
        protected hideSpinner(): void;
        protected showSpinner(): void;
        protected keyActionHandler(e: ej.base.KeyboardEventArgs): void;
        protected selectCurrentItem(e: ej.base.KeyboardEventArgs): void;
        protected isSelectFocusItem(element: Element): boolean;
        private getPageCount();
        private pageUpSelection(steps, event);
        private pageDownSelection(steps, event);
        protected unWireEvent(): void;
        /**
         * Event un binding for list items.
         */
        private unWireListEvents();
        protected onDocumentClick(e: MouseEvent): void;
        private activeStateChange();
        private focusDropDown(e?);
        protected dropDownClick(e: MouseEvent): void;
        protected updateSelectedItem(li: Element, e: MouseEvent | KeyboardEvent | TouchEvent, preventSelect?: boolean): void;
        protected activeItem(li: Element): void;
        protected setValue(e?: ej.base.KeyboardEventArgs): boolean;
        protected setSelection(li: Element, e: MouseEvent | ej.base.KeyboardEventArgs | TouchEvent): void;
        private setValueTemplate();
        protected removeSelection(): void;
        protected getItemData(): {
            [key: string]: string;
        };
        /**
         * To trigger the change event for list.
         */
        protected onChangeEvent(eve: MouseEvent | KeyboardEvent | TouchEvent): void;
        protected detachChangeEvent(eve: MouseEvent | KeyboardEvent | TouchEvent): void;
        protected setHiddenValue(): void;
        /**
         * Filter bar implementation
         */
        protected onFilterUp(e: ej.base.KeyboardEventArgs): void;
        protected onFilterDown(e: ej.base.KeyboardEventArgs): void;
        protected removeFillSelection(): void;
        protected getSelectionPoints(): {
            [key: string]: number;
        };
        protected searchLists(e: ej.base.KeyboardEventArgs): void;
        private filteringAction(dataSource, query?, fields?);
        protected setSearchBox(popupElement: HTMLElement): ej.inputs.InputObject;
        protected onInput(): void;
        protected onActionFailure(e: Object): void;
        protected onActionComplete(ulElement: HTMLElement, list: {
            [key: string]: Object;
        }[], e?: Object, isUpdated?: boolean): void;
        private addNewItem(listData, newElement);
        protected updateActionCompleteData(li: HTMLElement, item: {
            [key: string]: Object;
        }): void;
        private focusIndexItem();
        protected updateSelection(): void;
        protected removeFocus(): void;
        protected renderPopup(): void;
        private checkCollision(popupEle);
        private getOffsetValue(popupEle);
        private createPopup(element, offsetValue, left);
        private isEmptyList();
        protected getFocusElement(): void;
        private isFilterLayout();
        private scrollHandler();
        private setSearchBoxPosition();
        private setPopupPosition(border?);
        private setWidth();
        private scrollBottom(isInitial?);
        private scrollTop();
        protected isEditTextBox(): boolean;
        protected isFiltering(): boolean;
        protected isPopupButton(): boolean;
        protected setScrollPosition(e?: ej.base.KeyboardEventArgs): void;
        private clearText();
        private listScroll();
        private closePopup(delay?);
        private destroyPopup();
        private clickOnBackIcon();
        /**
         * To Initialize the control rendering
         * @private
         */
        render(): void;
        private setFooterTemplate(popupEle);
        protected setOldText(text: string): void;
        protected setOldValue(value: string | number): void;
        protected refreshPopup(): void;
        protected updateDataSource(prop?: string): void;
        /**
         * Dynamically change the value of properties.
         * @private
         */
        onPropertyChanged(newProp: ej.dropdowns.DropDownListModel, oldProp: ej.dropdowns.DropDownListModel): void;
        /**
         * Return the module name.
         * @private
         */
        getModuleName(): string;
        /**
         * Opens the popup that displays the list of items.
         * @returns void.
         */
        showPopup(): void;
        /**
         * Hides the popup if it is in an open state.
         * @returns void.
         */
        hidePopup(): void;
        /**
         * Sets the focus on the component for interaction.
         * @returns void.
         */
        focusIn(): void;
        /**
         * Moves the focus from the component if the component is already focused.
         * @returns void.
         */
        focusOut(): void;
        /**
         * Removes the component from the DOM and detaches all its related event handlers. Also it removes the attributes and classes.
         * @method destroy
         * @return {void}.
         */
        destroy(): void;
    }
    export interface DropDownListClassList {
        root: string;
        hover: string;
        selected: string;
        rtl: string;
        base: string;
        disable: string;
        input: string;
        inputFocus: string;
        li: string;
        icon: string;
        iconAnimation: string;
        value: string;
        focus: string;
        device: string;
        backIcon: string;
        filterBarClearIcon: string;
        filterInput: string;
        filterParent: string;
        mobileFilter: string;
        footer: string;
        header: string;
        clearIcon: string;
        clearIconHide: string;
        popupFullScreen: string;
        disableIcon: string;
    }
    export interface FilteringEventArgs {
        /**
         * Gets the `keyup` event arguments.
         */
        baseEventArgs: Object;
        /**
         * Illustrates whether the current action needs to be prevented or not.
         */
        cancel: boolean;
        /**
         * Search text value.
         */
        text: string;
        /**
         * To filter the data from given data source by using query
         * @param  {Object[] | ej.data.DataManager } dataSource - Set the data source to filter.
         * @param  {Query} query - Specify the query to filter the data.
         * @param  {FieldSettingsModel} fields - Specify the fields to map the column in the data table.
         * @return {void}.
         */
        updateData(dataSource: {
            [key: string]: Object;
        }[] | ej.data.DataManager | string[] | number[], query?: ej.data.Query, fields?: FieldSettingsModel): void;
    }
    export interface PopupEventArgs {
        /**
         * Specifies the popup Object.
         */
        popup: ej.popups.Popup;
        /**
         * Illustrates whether the current action needs to be prevented or not.
         */
        cancel?: boolean;
    }
    
    /**
     * The Multiselect enable CheckBoxSelection call this inject module.
     */
    export class CheckBoxSelection {
        private parent;
        private checkAllParent;
        private selectAllSpan;
        filterInput: HTMLInputElement;
        private filterParent;
        private filterInputObj;
        private backIconElement;
        private clearIconElement;
        private checkWrapper;
        list: HTMLElement;
        private activeLi;
        private activeEle;
        constructor(parent?: IMulitSelect);
        getModuleName(): string;
        addEventListener(): void;
        removeEventListener(): void;
        listOption(args: {
            [key: string]: Object;
        }): void;
        private checboxCreate(e);
        private setSelectAll();
        destroy(): void;
        listSelection(args: IUpdateListArgs): void;
        private validateCheckNode(checkWrap, isCheck, li?, e?, selectAll?);
        private clickHandler(e);
        private changeState(wrapper, state, e?, isPrevent?, selectAll?);
        protected setSearchBox(args: IUpdateListArgs): ej.inputs.InputObject | void;
        private clickOnBackIcon(e);
        private clearText(e);
        private setDeviceSearchBox();
        private setSearchBoxPosition();
        protected targetElement(): string;
        private onBlur(e);
        protected onDocumentClick(e: MouseEvent): void;
        private getFocus(e);
        private checkSelectAll(e);
        private setLocale(unSelect?);
        private getActiveList(args);
        private setReorder(args);
    }
    export interface ItemCreatedArgs {
        curData: {
            [key: string]: Object;
        };
        item: HTMLElement;
        text: string;
    }
    export interface IUpdateListArgs {
        module: string;
        enable: boolean;
        li: HTMLElement;
        e: MouseEvent | ej.base.KeyboardEventArgs;
        popupElement: HTMLElement;
        value: string;
        index: number;
    }
    
    /**
     * Specifies mulitselct interfaces.
     * @hidden
     */
    export interface IMulitSelect extends ej.base.Component<HTMLElement> {
        listCurrentOptions?: {
            [key: string]: Object;
        };
        inputElement?: HTMLInputElement;
        popupWrapper?: HTMLDivElement;
        selectAll?(state?: boolean): void;
        selectAllHeight?: number;
        searchBoxHeight?: number;
        onInput?(): void;
        filterInput?: HTMLInputElement;
        KeyUp?(e?: ej.base.KeyboardEventArgs): void;
        onKeyDown?(e?: ej.base.KeyboardEventArgs): void;
        mainList?: HTMLElement;
        list?: HTMLElement;
        targetElement?(): string;
        targetInputElement?: HTMLInputElement | string;
        selectAllText?: string;
        unSelectAllText?: string;
        popupObj?: ej.popups.Popup;
        onDocumentFocus?: boolean;
        hidePopup?(): void;
        refreshPopup?(): void;
        refreshListItems?(data?: string): void;
        filterBarPlaceholder?: string;
        overAllWrapper?: HTMLDivElement;
        templateList?: {
            [key: string]: Object;
        };
        itemTemplate?: string;
        headerTemplate?: string;
        mobFilter?: boolean;
        header?: HTMLElement;
        updateDelimView?(): void;
        updateValueState?(event?: ej.base.KeyboardEventArgs | MouseEvent, newVal?: [string | number], oldVal?: [string | number]): void;
        tempValues?: [number | string];
        value?: [number | string];
        refreshInputHight?(): void;
        refreshPlaceHolder?(): void;
        ulElement?: HTMLElement;
        hiddenElement?: HTMLSelectElement;
        dispatchEvent?(element?: HTMLElement, type?: string): void;
        inputFocus?: boolean;
        enableSelectionOrder?: boolean;
        focusAtFirstListItem(): void;
        isPopupOpen(): boolean;
        showSelectAll: boolean;
    }
    
    /**
     * Interface for a class MultiSelect
     */
    export interface MultiSelectModel extends DropDownBaseModel{
    
        /**
         * Sets the CSS classes to root element of this component which helps to customize the
         * complete styles.
         * @default null
         */
        cssClass?: string;
    
        /**
         * Gets or sets the width of the component. By default, it sizes based on its parent.
         * container dimension.
         * @default '100%'
         */
        width?: string | number;
    
        /**
         * Gets or sets the height of the popup list. By default it renders based on its list item.
         * > For more details about the popup configuration refer to 
         * [`Popup Configuration`](./getting-started.html#configure-the-popup-list) documentation.
         * 
         * @default '300px'
         */
        popupHeight?: string | number;
    
        /**
         * Gets or sets the width of the popup list and percentage values has calculated based on input width.
         * > For more details about the popup configuration refer to 
         * [`Popup Configuration`](./getting-started.html#configure-the-popup-list) documentation.
         * 
         * @default '100%'
         */
        popupWidth?: string | number;
    
        /**
         * Gets or sets the placeholder in the component to display the given information
         * in input when no item selected. 
         * @default null
         */
        placeholder?: string;
    
        /**
         * Accepts the value to be displayed as a watermark text on the filter bar. 
         * @default null.
         */
        filterBarPlaceholder?: string;
    
        /**
         * Gets or sets the additional attribute to `HtmlAttributes` property in MultiSelect,
         * which helps to add attribute like title, name etc, input should be key value pair.
         * 
         * {% codeBlock src="multiselect/html-attributes-api/index.ts" %}{% endcodeBlock %}
         * 
         * {% codeBlock src="multiselect/html-attributes-api/index.html" %}{% endcodeBlock %}
         * @default {}
         */
        htmlAttributes?: { [key: string]: string; };
    
        /**
         * Accepts the template design and assigns it to the selected list item in the input element of the component.
         * For more details about the available template options refer to 
         * [`Template`](./templates.html) documentation.
         * 
         * We have built-in [`template engine`](./template-engine.html) 
         * which provides options to compile template string into a executable function. 
         * For EX: We have expression evolution as like ES6 expression string literals.
         * @default null
         */
        valueTemplate?: string;
    
        /**
         * Accepts the template design and assigns it to the header container of the popup list.
         * > For more details about the available template options refer to [`Template`](./templates.html) documentation.
         * 
         * @default null
         */
        headerTemplate?: string;
    
        /**
         * Accepts the template design and assigns it to the footer container of the popup list.
         * > For more details about the available template options refer to [`Template`](./templates.html) documentation.
         * 
         * @default null
         */
        footerTemplate?: string;
    
        /**
         * Accepts the template design and assigns it to each list item present in the popup.
         * > For more details about the available template options refer to [`Template`](./templates.html) documentation.
         * 
         * We have built-in [`template engine`](./template-engine.html) 
         * which provides options to compile template string into a executable function. 
         * For EX: We have expression evolution as like ES6 expression string literals.
         * @default null
         */
        itemTemplate?: string;
    
        /**
         * To enable the filtering option in this component. 
         * Filter action performs when type in search box and collect the matched item through `filtering` event.
         * If searching character does not match, `noRecordsTemplate` property value will be shown.
         * 
         * {% codeBlock src="multiselect/allow-filtering-api/index.ts" %}{% endcodeBlock %}
         * 
         * {% codeBlock src="multiselect/allow-filtering-api/index.html" %}{% endcodeBlock %}
         * 
         * @default false
         */
        allowFiltering?: boolean;
    
        /**
         * Allows user to add a 
         * [`custom value`](./custom-value.html), the value which is not present in the suggestion list. 
         * @default false
         */
        allowCustomValue?: boolean;
    
        /**
         * Enables close icon with the each selected item.
         * @default true
         */
        showClearButton?: boolean;
    
        /**
         * Sets limitation to the value selection.
         * based on the limitation, list selection will be prevented.
         * @default 1000
         */
        maximumSelectionLength?: number;
    
        /**
         * Gets or sets the `readonly` to input or not. Once enabled, just you can copy or highlight 
         * the text however tab key action will perform.
         * 
         * @default false
         */
        readonly?: boolean;
    
        /**
         * Selects the list item which maps the data `text` field in the component.
         * @default null
         */
        text?: string;
    
        /**
         * Selects the list item which maps the data `value` field in the component.
         * @default null
         */
        value?: [number | string];
    
        /**
         * Hides the selected item from the list item.
         * @default false
         */
        hideSelectedItem?: boolean;
    
        /**
         * Based on the property, when item get select popup visibility state will changed.
         * @default true
         */
        closePopupOnSelect?: boolean;
    
        /**
         * configures visibility mode for component interaction.
         * 
         *   - `Box` - selected items will be visualized in chip.
         * 
         *   - `Delimiter` - selected items will be visualized in text content.
         * 
         *   - `Default` - on `focus in` component will act in `box` mode.
         *    on `blur` component will act in `delimiter` mode.
         * 
         * {% codeBlock src="multiselect/visual-mode-api/index.ts" %}{% endcodeBlock %}
         * 
         * {% codeBlock src="multiselect/visual-mode-api/index.html" %}{% endcodeBlock %}
         * 
         * @default Default
         */
        mode?: visualMode;
    
        /**
         * Sets the delimiter character for 'default' and 'delimiter' visibility modes.
         * @default ,
         */
        delimiterChar?: string;
    
        /**
         * Sets [`case sensitive`](./filtering.html#case-sensitive-filtering) 
         * option for filter operation.
         * @default false
         */
        ignoreCase?: boolean;
    
        /**
         * Allows you to either show or hide the DropDown button on the component
         * 
         * @default false
         */
        showDropDownIcon?: boolean;
    
        /**
         * Allows you to either show or hide the selectAll option on the component.
         * 
         * @default false
         */
        showSelectAll?: boolean;
    
        /**
         * Specifies the selectAllText to be displayed on the component.
         * 
         * @default 'select All'
         */
        selectAllText?: string;
    
        /**
         * Specifies the UnSelectAllText to be displayed on the component.
         * 
         * @default 'select All'
         */
        unSelectAllText?: string;
    
        /**
         * Reorder the selected items in popup visibility state.
         * 
         * @default true
         */
        enableSelectionOrder?: boolean;
    
        /**
         * Whether to automatically open the popup when the control is clicked.
         * @default true
         */
        openOnClick?: boolean;
    
        /**
         * Fires each time when selection changes happened in list items after model and input value get affected.
         * @event
         */
        change?: ej.base.EmitType<MultiSelectChangeEventArgs>;
    
        /**
         * Fires before the selected item removed from the widget.
         * @event
         */
        removing?: ej.base.EmitType<RemoveEventArgs>;
    
        /**
         * Fires after the selected item removed from the widget.
         * @event
         */
        removed?: ej.base.EmitType<RemoveEventArgs>;
    
        /**
         * Fires when popup opens after animation completion.
         * @event
         */
        open?: ej.base.EmitType<PopupEventArgs>;
    
        /**
         * Fires when popup close after animation completion.
         * @event
         */
        close?: ej.base.EmitType<PopupEventArgs>;
    
        /**
         * Event triggers when the input get focus-out.
         * @event
         */
        blur?: ej.base.EmitType<Object>;
    
        /**
         * Event triggers when the input get focused.
         * @event
         */
        focus?: ej.base.EmitType<Object>;
    
        /**
         * Event triggers when the chip selection.
         * @event
         */
        chipSelection?: ej.base.EmitType<Object>;
    
        /**
         * Triggers event,when user types a text in search box.
         * > For more details about filtering, refer to [`Filtering`](./filtering.html) documentation.
         * 
         * @event
         */
        filtering?: ej.base.EmitType<FilteringEventArgs>;
    
        /**
         * Fires before set the selected item as chip in the component.
         * > For more details about chip customization refer [`Chip Customization`](./chip-customization.html)
         * 
         * @event
         */
        tagging?: ej.base.EmitType<TaggingEventArgs>;
    
        /**
         * Triggers when the [`customValue`](./custom-value.html) is selected.
         * @event
         */
        customValueSelection?: ej.base.EmitType<CustomValueEventArgs>;
    
    }
    
    export interface RemoveEventArgs extends SelectEventArgs {
    }
    /**
     * The Multiselect allows the user to pick a more than one value from list of predefined values.
     * ```html
     * <select id="list">
     *      <option value='1'>Badminton</option>
     *      <option value='2'>Basketball</option>
     *      <option value='3'>Cricket</option>
     *      <option value='4'>Football</option>
     *      <option value='5'>Tennis</option>
     * </select>
     * ```
     * ```typescript
     * <script>
     *   var multiselectObj = new Multiselect();
     *   multiselectObj.appendTo("#list");
     * </script>
     * ```
     */
    export class MultiSelect extends DropDownBase implements ej.inputs.IInput {
        private spinnerElement;
        private selectAllAction;
        private setInitialValue;
        private setDynValue;
        private listCurrentOptions;
        private targetInputElement;
        private selectAllHeight?;
        private searchBoxHeight?;
        private mobFilter?;
        private isFiltered;
        private isFirstClick;
        /**
         * Sets the CSS classes to root element of this component which helps to customize the
         * complete styles.
         * @default null
         */
        cssClass: string;
        /**
         * Gets or sets the width of the component. By default, it sizes based on its parent.
         * container dimension.
         * @default '100%'
         */
        width: string | number;
        /**
         * Gets or sets the height of the popup list. By default it renders based on its list item.
         * > For more details about the popup configuration refer to
         * [`Popup Configuration`](./getting-started.html#configure-the-popup-list) documentation.
         *
         * @default '300px'
         */
        popupHeight: string | number;
        /**
         * Gets or sets the width of the popup list and percentage values has calculated based on input width.
         * > For more details about the popup configuration refer to
         * [`Popup Configuration`](./getting-started.html#configure-the-popup-list) documentation.
         *
         * @default '100%'
         */
        popupWidth: string | number;
        /**
         * Gets or sets the placeholder in the component to display the given information
         * in input when no item selected.
         * @default null
         */
        placeholder: string;
        /**
         * Accepts the value to be displayed as a watermark text on the filter bar.
         * @default null.
         */
        filterBarPlaceholder: string;
        /**
         * Gets or sets the additional attribute to `HtmlAttributes` property in MultiSelect,
         * which helps to add attribute like title, name etc, input should be key value pair.
         *
         * {% codeBlock src="multiselect/html-attributes-api/index.ts" %}{% endcodeBlock %}
         *
         * {% codeBlock src="multiselect/html-attributes-api/index.html" %}{% endcodeBlock %}
         * @default {}
         */
        htmlAttributes: {
            [key: string]: string;
        };
        /**
         * Accepts the template design and assigns it to the selected list item in the input element of the component.
         * For more details about the available template options refer to
         * [`Template`](./templates.html) documentation.
         *
         * We have built-in [`template engine`](./template-engine.html)
         * which provides options to compile template string into a executable function.
         * For EX: We have expression evolution as like ES6 expression string literals.
         * @default null
         */
        valueTemplate: string;
        /**
         * Accepts the template design and assigns it to the header container of the popup list.
         * > For more details about the available template options refer to [`Template`](./templates.html) documentation.
         *
         * @default null
         */
        headerTemplate: string;
        /**
         * Accepts the template design and assigns it to the footer container of the popup list.
         * > For more details about the available template options refer to [`Template`](./templates.html) documentation.
         *
         * @default null
         */
        footerTemplate: string;
        /**
         * Accepts the template design and assigns it to each list item present in the popup.
         * > For more details about the available template options refer to [`Template`](./templates.html) documentation.
         *
         * We have built-in [`template engine`](./template-engine.html)
         * which provides options to compile template string into a executable function.
         * For EX: We have expression evolution as like ES6 expression string literals.
         * @default null
         */
        itemTemplate: string;
        /**
         * To enable the filtering option in this component.
         * Filter action performs when type in search box and collect the matched item through `filtering` event.
         * If searching character does not match, `noRecordsTemplate` property value will be shown.
         *
         * {% codeBlock src="multiselect/allow-filtering-api/index.ts" %}{% endcodeBlock %}
         *
         * {% codeBlock src="multiselect/allow-filtering-api/index.html" %}{% endcodeBlock %}
         *
         * @default false
         */
        allowFiltering: boolean;
        /**
         * Allows user to add a
         * [`custom value`](./custom-value.html), the value which is not present in the suggestion list.
         * @default false
         */
        allowCustomValue: boolean;
        /**
         * Enables close icon with the each selected item.
         * @default true
         */
        showClearButton: boolean;
        /**
         * Sets limitation to the value selection.
         * based on the limitation, list selection will be prevented.
         * @default 1000
         */
        maximumSelectionLength: number;
        /**
         * Gets or sets the `readonly` to input or not. Once enabled, just you can copy or highlight
         * the text however tab key action will perform.
         *
         * @default false
         */
        readonly: boolean;
        /**
         * Selects the list item which maps the data `text` field in the component.
         * @default null
         */
        text: string;
        /**
         * Selects the list item which maps the data `value` field in the component.
         * @default null
         */
        value: [number | string];
        /**
         * Hides the selected item from the list item.
         * @default false
         */
        hideSelectedItem: boolean;
        /**
         * Based on the property, when item get select popup visibility state will changed.
         * @default true
         */
        closePopupOnSelect: boolean;
        /**
         * configures visibility mode for component interaction.
         *
         *   - `Box` - selected items will be visualized in chip.
         *
         *   - `Delimiter` - selected items will be visualized in text content.
         *
         *   - `Default` - on `focus in` component will act in `box` mode.
         *    on `blur` component will act in `delimiter` mode.
         *
         * {% codeBlock src="multiselect/visual-mode-api/index.ts" %}{% endcodeBlock %}
         *
         * {% codeBlock src="multiselect/visual-mode-api/index.html" %}{% endcodeBlock %}
         *
         * @default Default
         */
        mode: visualMode;
        /**
         * Sets the delimiter character for 'default' and 'delimiter' visibility modes.
         * @default ,
         */
        delimiterChar: string;
        /**
         * Sets [`case sensitive`](./filtering.html#case-sensitive-filtering)
         * option for filter operation.
         * @default false
         */
        ignoreCase: boolean;
        /**
         * Allows you to either show or hide the DropDown button on the component
         *
         * @default false
         */
        showDropDownIcon: boolean;
        /**
         * Allows you to either show or hide the selectAll option on the component.
         *
         * @default false
         */
        showSelectAll: boolean;
        /**
         * Specifies the selectAllText to be displayed on the component.
         *
         * @default 'select All'
         */
        selectAllText: string;
        /**
         * Specifies the UnSelectAllText to be displayed on the component.
         *
         * @default 'select All'
         */
        unSelectAllText: string;
        /**
         * Reorder the selected items in popup visibility state.
         *
         * @default true
         */
        enableSelectionOrder: boolean;
        /**
         * Whether to automatically open the popup when the control is clicked.
         * @default true
         */
        openOnClick: boolean;
        /**
         * Fires each time when selection changes happened in list items after model and input value get affected.
         * @event
         */
        change: ej.base.EmitType<MultiSelectChangeEventArgs>;
        /**
         * Fires before the selected item removed from the widget.
         * @event
         */
        removing: ej.base.EmitType<RemoveEventArgs>;
        /**
         * Fires after the selected item removed from the widget.
         * @event
         */
        removed: ej.base.EmitType<RemoveEventArgs>;
        /**
         * Fires when popup opens after animation completion.
         * @event
         */
        open: ej.base.EmitType<PopupEventArgs>;
        /**
         * Fires when popup close after animation completion.
         * @event
         */
        close: ej.base.EmitType<PopupEventArgs>;
        /**
         * Event triggers when the input get focus-out.
         * @event
         */
        blur: ej.base.EmitType<Object>;
        /**
         * Event triggers when the input get focused.
         * @event
         */
        focus: ej.base.EmitType<Object>;
        /**
         * Event triggers when the chip selection.
         * @event
         */
        chipSelection: ej.base.EmitType<Object>;
        /**
         * Triggers event,when user types a text in search box.
         * > For more details about filtering, refer to [`Filtering`](./filtering.html) documentation.
         *
         * @event
         */
        filtering: ej.base.EmitType<FilteringEventArgs>;
        /**
         * Fires before set the selected item as chip in the component.
         * > For more details about chip customization refer [`Chip Customization`](./chip-customization.html)
         *
         * @event
         */
        tagging: ej.base.EmitType<TaggingEventArgs>;
        /**
         * Triggers when the [`customValue`](./custom-value.html) is selected.
         * @event
         */
        customValueSelection: ej.base.EmitType<CustomValueEventArgs>;
        /**
         * Constructor for creating the DropDownList widget.
         */
        constructor(option?: MultiSelectModel, element?: string | HTMLElement);
        private isValidKey;
        private mainList;
        ulElement: HTMLElement;
        private mainData;
        private mainListCollection;
        private customValueFlag;
        private inputElement;
        private componentWrapper;
        private overAllWrapper;
        private searchWrapper;
        private viewWrapper;
        private chipCollectionWrapper;
        private overAllClear;
        private dropIcon;
        private hiddenElement;
        private delimiterWrapper;
        private popupObj;
        private inputFocus;
        private header;
        private footer;
        private initStatus;
        private popupWrapper;
        private keyCode;
        private beforePopupOpen;
        private remoteCustomValue;
        private filterAction;
        private enableRTL(state);
        requiredModules(): ej.base.ModuleDeclaration[];
        private updateHTMLAttribute();
        private updateReadonly(state);
        private updateClearButton(state);
        private updateCssClass();
        private onPopupShown();
        private focusAtFirstListItem();
        private focusAtLastListItem(data);
        protected getAriaAttributes(): {
            [key: string]: string;
        };
        private updateListARIA();
        private removelastSelection(e);
        protected onActionFailure(e: Object): void;
        protected targetElement(): string;
        protected onActionComplete(ulElement: HTMLElement, list: {
            [key: string]: Object;
        }[], e?: Object, isUpdated?: boolean): void;
        private refreshSelection();
        private checkSelectAll();
        private openClick(e);
        private KeyUp(e);
        protected getQuery(query: ej.data.Query): ej.data.Query;
        private dataUpdater(dataSource, query?, fields?);
        private tempQuery;
        private tempValues;
        private checkForCustomValue(query?, fields?);
        protected getNgDirective(): string;
        private wrapperClick(e);
        private enable(state);
        private scrollFocusStatus;
        private keyDownStatus;
        private onBlur(eve);
        private refreshInputHight();
        private validateValues(newValue, oldValue);
        private updateValueState(event, newVal, oldVal);
        private getPagingCount();
        private pageUpSelection(steps);
        private pageDownSelection(steps);
        private focusIn();
        private showDelimWrapper();
        private hideDelimWrapper();
        private expandTextbox();
        private isPopupOpen();
        private refreshPopup();
        private checkTextLength();
        private popupKeyActions(keyCode);
        private updateAriaAttribute();
        private onKeyDown(e);
        private selectByKey(e);
        private escapeAction();
        private scrollBottom(selectedLI, activeIndex);
        private scrollTop(selectedLI, activeIndex);
        private selectListByKey(e);
        private refreshListItems(data);
        private removeSelectedChip(e);
        private moveByTop(state);
        private moveByList(position);
        private moveBy(position);
        private chipClick(e);
        private removeChipSelection();
        private addChipSelection(element);
        private onChipRemove(e);
        private makeTextBoxEmpty();
        private refreshPlaceHolder();
        private removeValue(value, eve);
        private updateMainList(state, value);
        private removeChip(value);
        private updateChipStatus();
        private addValue(value, text, eve);
        private checkMaxSelection();
        private dispatchSelect(value, eve, element, isNotTrigger);
        private addChip(text, value, e?);
        private removeChipFocus();
        private onMobileChipInteraction(e);
        private getChip(data, value, e?);
        private calcPopupWidth();
        private mouseIn();
        private mouseOut();
        protected listOption(dataSource: {
            [key: string]: Object;
        }[], fields: FieldSettingsModel): {
            [key: string]: Object;
        };
        private renderPopup();
        private ClearAll(e);
        private windowResize();
        protected wireEvent(): void;
        private onInput();
        protected preRender(): void;
        private initializeData();
        private updateData(delimiterChar);
        private initialValueUpdate();
        protected isValidLI(li: Element | HTMLElement): boolean;
        protected updateListSelection(li: Element, e: MouseEvent | ej.base.KeyboardEventArgs): void;
        protected removeListSelection(): void;
        private removeHover();
        private removeFocus();
        private addListHover(li);
        private addListFocus(element);
        private addListSelection(element);
        private updateDelimeter(delimChar);
        private onMouseClick(e);
        private onMouseOver(e);
        private onMouseLeave(e);
        private onListMouseDown(e);
        private wireListEvents();
        private unwireListEvents();
        private hideOverAllClear();
        private showOverAllClear();
        protected showSpinner(): void;
        protected hideSpinner(): void;
        private updateDelimView();
        private unWireEvent();
        private selectAllItem(state);
        protected setZIndex(): void;
        protected updateDataSource(prop?: string): void;
        private onLoadSelect();
        /**
         * Get the properties to be maintained in the persisted state.
         */
        protected getPersistData(): string;
        /**
         * Dynamically change the value of properties.
         * @private
         */
        onPropertyChanged(newProp: MultiSelectModel, oldProp: MultiSelectModel): void;
        /**
         * Hides the popup, if the popup in a open state.
         * @returns void
         */
        hidePopup(): void;
        /**
         * Shows the popup, if the popup in a closed state.
         * @returns void
         */
        showPopup(): void;
        /**
         * Based on the state parameter, entire list item will be selected/deselected.
         * parameter
         * `true`   - Selects entire list items.
         * `false`  - Un Selects entire list items.
         * @returns void
         */
        selectAll(state: boolean): void;
        getModuleName(): string;
        /**
         * To Initialize the control rendering
         * @private
         */
        render(): void;
        private dropDownIcon();
        private initialUpdate();
        /**
         * Removes the component from the DOM and detaches all its related event handlers. Also it removes the attributes and classes.
         * @method destroy
         * @return {void}
         */
        destroy(): void;
    }
    export interface CustomValueEventArgs {
        /**
         * Gets the newly added data.
         */
        newData: Object;
        /**
         * Illustrates whether the current action needs to be prevented or not.
         */
        cancel: boolean;
    }
    export interface TaggingEventArgs {
        /**
         * If the event is triggered by interaction, it returns true. Otherwise, it returns false.
         */
        isInteracted: boolean;
        /**
         * Returns the selected item as JSON Object from the data source.
         */
        itemData: FieldSettingsModel;
        /**
         * Specifies the original event arguments.
         */
        e: MouseEvent | KeyboardEvent | TouchEvent;
        /**
         * To set the classes to chip element
         * @param  { string } classes - Specify the classes to chip element.
         * @return {void}.
         */
        setClass: Function;
    }
    export interface MultiSelectChangeEventArgs {
        /**
         * If the event is triggered by interaction, it returns true. Otherwise, it returns false.
         */
        isInteracted: boolean;
        /**
         * Returns the component initial Value.
         */
        oldValue: number[] | string[];
        /**
         * Returns the updated component Values.
         */
        value: number[] | string[];
        /**
         * Specifies the original event arguments.
         */
        e: MouseEvent | KeyboardEvent | TouchEvent;
    }
    export type visualMode = 'Default' | 'Delimiter' | 'Box' | 'CheckBox';
    
  }
  export namespace excelexport {
    
    /**
     * BlobHelper class
     */
    export class BlobHelper {
        private parts;
        private blob;
        append(part: any): void;
        getBlob(): Blob;
    }
    
    /**
     * CellStyle class
     */
    export class CellStyle {
        name: string;
        index: number;
        backColor: string;
        numFmtId: number;
        borders: Borders;
        fontName: string;
        fontSize: number;
        fontColor: string;
        italic: boolean;
        bold: boolean;
        hAlign: HAlignType;
        vAlign: VAlignType;
        underline: boolean;
        wrapText: boolean;
        numberFormat: string;
        type: string;
        isGlobalStyle: boolean;
        constructor();
    }
    export class Font {
        b: boolean;
        i: boolean;
        u: boolean;
        sz: number;
        name: string;
        color: string;
        constructor();
    }
    export class CellXfs {
        numFmtId: number;
        fontId: number;
        fillId: number;
        borderId: number;
        xfId: number;
        applyAlignment: number;
        alignment: Alignment;
    }
    export class Alignment {
        horizontal: string;
        vertical: string;
        wrapText: number;
    }
    export class CellStyleXfs {
        numFmtId: number;
        fontId: number;
        fillId: number;
        borderId: number;
        applyAlignment: number;
        alignment: Alignment;
    }
    export class CellStyles {
        name: string;
        xfId: number;
        constructor();
    }
    export class NumFmt {
        numFmtId: number;
        formatCode: string;
        constructor();
        constructor(id: number, code: string);
    }
    /**
     * Border class
     */
    export class Border {
        lineStyle: LineStyle;
        color: string;
        constructor();
        constructor(mLine: LineStyle, mColor: string);
    }
    /**
     * Border class
     */
    export class Borders {
        left: Border;
        right: Border;
        bottom: Border;
        top: Border;
        all: Border;
        constructor();
    }
    
    /**
     * Worksheet class
     */
    export class Cell {
        index: number;
        rowSpan: number;
        colSpan: number;
        value: string | Date | number | boolean;
        cellStyle: CellStyle;
        styleIndex: number;
        sharedStringIndex: number;
        saveType: string;
        type: string;
        refName: string;
    }
    /**
     * Rows class
     */
    export class Cells extends Array {
        add: (cell: Cell) => void;
    }
    
    /**
     * Column class
     */
    export class Column {
        index: number;
        width: number;
    }
    
    /**
     * CsvHelper class
     */
    export class CsvHelper {
        private isMicrosoftBrowser;
        private buffer;
        private csvStr;
        private formatter;
        private globalStyles;
        constructor(json: any);
        private parseWorksheet(json);
        private parseRows(rows);
        private parseRow(row);
        private parseCell(cell);
        private parseCellValue(value);
        /**
         * Saves the file with specified name and sends the file to client browser
         * @param  {string} fileName- file name to save.
         * @param  {Blob} buffer- the content to write in file
         */
        save(fileName: string): void;
        saveAsBlob(): Blob;
    }
    
    /**
     * LineStyle
     */
    export type LineStyle = 'thin' | 'thick' | 'medium' | 'none';
    export type HAlignType = 'center ' | 'justify' | 'left' | 'right' | 'general';
    export type VAlignType = 'bottom' | 'center' | 'top';
    export type HyperLinkType = 'none' | 'url' | 'file' | 'unc' | 'workbook';
    export type SaveType = 'xlsx' | 'csv';
    export type CellType = 'b' | 'e' | 'inlineStr' | 'n' | 's' | 'str';
    export type BlobSaveType = 'text/csv' | 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet';
    
    /**
     * Worksheet class
     */
    export class Row {
        height: number;
        index: number;
        cells: Cells;
        spans: string;
        grouping: Grouping;
    }
    /**
     * Rows class
     */
    export class Rows extends Array {
        add: (row: Row) => void;
    }
    
    /**
     * ValueFormatter class to globalize the value.
     * @hidden
     */
    export class ValueFormatter {
        private intl;
        constructor(cultureName?: string);
        getFormatFunction(format: ej.base.NumberFormatOptions | ej.base.DateFormatOptions): Function;
        toView(value: number | Date, format: Function): string | Object;
        displayText(value: any, format: ej.base.NumberFormatOptions | ej.base.DateFormatOptions): string;
    }
    
    /**
     * Workbook class
     */
    export class Workbook {
        private mArchive;
        private sharedString;
        private sharedStringCount;
        cellStyles: any;
        private worksheets;
        private builtInProperties;
        private mFonts;
        private mBorders;
        private mFills;
        private mNumFmt;
        private mStyles;
        private mCellXfs;
        private mCellStyleXfs;
        private mergeCells;
        private csvHelper;
        private mSaveType;
        private mHyperLinks;
        private unitsProportions;
        private hyperlinkStyle;
        private printTitles;
        private culture;
        private intl;
        private globalStyles;
        constructor(json: any, saveType: SaveType, culture?: string);
        private parserBuiltInProperties(jsonBuiltInProperties, builtInProperties);
        private parserWorksheets(json);
        private mergeOptions(fromJson, toJson);
        private applyProperties(sourceJson, destJson);
        private getCellName(row, column);
        private getColumnName(col);
        private parserPrintTitle(json, sheet);
        private parserFreezePanes(json, sheet);
        private parserColumns(json, sheet);
        private parserRows(json, sheet);
        private parserRow(json, rowIndex);
        private parseGrouping(json, row);
        private parseCells(json, row);
        private applyGlobalStyle(json, cellStyle);
        private compareStyleXfs(toCompareStyle);
        private parserCellStyle(json, cellStyle, cellType);
        private parserCellStyle(json, cellStyle, cellType, defStyleIndex);
        private switchNumberFormat(numberFormat, type);
        private getNumberFormat(numberFormat, type);
        private parserBorder(json, border);
        private processCellStyle(style);
        private isNewFont(toCompareStyle);
        private isNewBorder(toCompareStyle);
        private isAllBorder(toCompareBorder);
        private compareStyle(toCompareStyle);
        private contains(array, item);
        private getCellValueType(value);
        private parseCellType(cell);
        saveAsBlob(blobSaveType: BlobSaveType): Promise<{
            blobData: Blob;
        }>;
        save(fileName: string, proxyUrl?: string): void;
        private saveInternal();
        private saveWorkbook();
        private saveWorksheets();
        private saveWorksheet(sheet, index);
        private pixelsToColumnWidth(pixels);
        private trunc(x);
        private pixelsToRowHeight(pixels);
        private saveSheetRelations(sheet);
        private saveFreezePanes(sheet);
        private saveSharedString();
        private processString(value);
        private saveStyles();
        private saveNumberFormats();
        private saveFonts();
        private saveFills();
        private saveBorders();
        private saveCellStyles();
        private saveCellStyleXfs();
        private saveCellXfs();
        private saveApp(builtInProperties);
        private saveCore(builtInProperties);
        private saveTopLevelRelation();
        private saveWorkbookRelation();
        private saveContentType();
        private addToArchive(xmlString, itemName);
        private processMergeCells(cell, rowIndex, mergeCells);
        /**
         * Returns the tick count corresponding to the given year, month, and day.
         * @param year number value of year
         * @param month number value of month
         * @param day number value of day
         */
        private dateToTicks(year, month, day);
        /**
         * Return the tick count corresponding to the given hour, minute, second.
         * @param hour number value of hour
         * @param minute number value if minute
         * @param second number value of second
         */
        private timeToTicks(hour, minute, second);
        /**
         * Checks if given year is a leap year.
         * @param year Year value.
         */
        isLeapYear(year: number): boolean;
        /**
         * Converts `DateTime` to the equivalent OLE Automation date.
         */
        private toOADate(date);
    }
    export class BuiltInProperties {
        author: string;
        comments: string;
        category: string;
        company: string;
        manager: string;
        subject: string;
        title: string;
        createdDate: Date;
        modifiedDate: Date;
        tags: string;
        status: string;
    }
    
    /**
     * Worksheet class
     */
    export class Worksheet {
        isSummaryRowBelow: boolean;
        index: number;
        columns: Column[];
        rows: Rows;
        freezePanes: FreezePane;
        name: string;
        mergeCells: MergeCells;
        hyperLinks: HyperLink[];
    }
    export class HyperLink {
        ref: string;
        rId: number;
        toolTip: string;
        location: string;
        display: string;
        target: string;
        type: HyperLinkType;
    }
    export class Grouping {
        outlineLevel: number;
        isCollapsed: boolean;
        isHidden: boolean;
    }
    export class FreezePane {
        row: number;
        column: number;
        leftCell: string;
    }
    export class MergeCell {
        ref: string;
        x: number;
        width: number;
        y: number;
        height: number;
    }
    /**
     * MergeCells class
     */
    export class MergeCells extends Array {
        add: (mergeCell: MergeCell) => void;
        static isIntersecting(base: MergeCell, compare: MergeCell): boolean;
    }
    
    /**
     * Worksheets class
     */
    export class Worksheets extends Array<Worksheet> {
    }
    
  }
  export namespace fileutils {
    
    /**
     * Encoding class: Contains the details about encoding type, whether to write a Unicode byte order mark (BOM).
     * ```typescript
     * let encoding : Encoding = new Encoding();
     * encoding.type = 'Utf8';
     * encoding.getBytes('Encoding', 0, 5);
     * ```
     */
    export class Encoding {
        private emitBOM;
        private encodingType;
        /**
         * Gets a value indicating whether to write a Unicode byte order mark
         * @returns boolean- true to specify that a Unicode byte order mark is written; otherwise, false
         */
        readonly includeBom: boolean;
        /**
         * Gets the encoding type.
         * @returns EncodingType
         */
        /**
         * Sets the encoding type.
         * @param  {EncodingType} value
         */
        type: EncodingType;
        /**
         * Initializes a new instance of the Encoding class. A parameter specifies whether to write a Unicode byte order mark
         * @param  {boolean} includeBom?-true to specify that a Unicode byte order mark is written; otherwise, false.
         */
        constructor(includeBom?: boolean);
        /**
         * Initialize the includeBom to emit BOM or Not
         * @param  {boolean} includeBom
         */
        private initBOM(includeBom);
        /**
         * Calculates the number of bytes produced by encoding the characters in the specified string
         * @param  {string} chars - The string containing the set of characters to encode
         * @returns {number} - The number of bytes produced by encoding the specified characters
         */
        getByteCount(chars: string): number;
        /**
         * Return the Byte of character
         * @param  {number} codePoint
         * @returns {number}
         */
        private utf8Len(codePoint);
        /**
         * for 4 byte character return surrogate pair true, otherwise false
         * @param  {number} codeUnit
         * @returns {boolean}
         */
        private isHighSurrogate(codeUnit);
        /**
         * for 4byte character generate the surrogate pair
         * @param  {number} highCodeUnit
         * @param  {number} lowCodeUnit
         */
        private toCodepoint(highCodeUnit, lowCodeUnit);
        /**
         * private method to get the byte count for specific charindex and count
         * @param  {string} chars
         * @param  {number} charIndex
         * @param  {number} charCount
         */
        private getByteCountInternal(chars, charIndex, charCount);
        /**
         * Encodes a set of characters from the specified string into the ArrayBuffer.
         * @param  {string} s- The string containing the set of characters to encode
         * @param  {number} charIndex-The index of the first character to encode.
         * @param  {number} charCount- The number of characters to encode.
         * @returns {ArrayBuffer} - The ArrayBuffer that contains the resulting sequence of bytes.
         */
        getBytes(s: string, charIndex: number, charCount: number): ArrayBuffer;
        /**
         * Decodes a sequence of bytes from the specified ArrayBuffer into the string.
         * @param  {ArrayBuffer} bytes- The ArrayBuffer containing the sequence of bytes to decode.
         * @param  {number} index- The index of the first byte to decode.
         * @param  {number} count- The number of bytes to decode.
         * @returns {string} - The string that contains the resulting set of characters.
         */
        getString(bytes: ArrayBuffer, index: number, count: number): string;
        private getBytesOfAnsiEncoding(byteCount, s, charIndex, charCount);
        private getBytesOfUtf8Encoding(byteCount, s, charIndex, charCount);
        private getBytesOfUnicodeEncoding(byteCount, s, charIndex, charCount);
        private getStringOfUtf8Encoding(byteCal, index, count);
        private getStringofUnicodeEncoding(byteUni, index, count);
        /**
         * To clear the encoding instance
         * @return {void}
         */
        destroy(): void;
    }
    /**
     * EncodingType : Specifies the encoding type
     */
    export type EncodingType = 'Ansi' | 'Utf8' | 'Unicode';
    /**
     * To check the object is null or undefined and throw error if it is null or undefined
     * @param {Object} value - object to check is null or undefined
     * @return {boolean}
     * @throws {ArgumentException} - if the value is null or undefined
     * @private
     */
    export function validateNullOrUndefined(value: Object, message: string): void;
    
    /**
     * Save class provide method to save file
     * ```typescript
     * let blob : Blob = new Blob([''], { type: 'text/plain' });
     * Save.save('fileName.txt',blob);
     */
    export class Save {
        static isMicrosoftBrowser: boolean;
        /**
         * Initialize new instance of {save}
         */
        constructor();
        /**
         * Saves the file with specified name and sends the file to client browser
         * @param  {string} fileName- file name to save.
         * @param  {Blob} buffer- the content to write in file
         * @param  {boolean} isMicrosoftBrowser- specify whether microsoft browser or not
         * @returns {void}
         */
        static save(fileName: string, buffer: Blob): void;
        private static saveInternal(fileName, extension, buffer, downloadLink, hasDownloadAttribute);
        /**
         *
         * @param {string} extension - get mime type of the specified extension
         * @private
         */
        static getMimeType(extension: string): string;
    }
    
    /**
     * StreamWriter class contains the implementation for writing characters to a file in a particular encoding
     * ```typescript
     * let writer = new StreamWriter();
     * writer.write('Hello World');
     * writer.save('Sample.txt');
     * writer.dispose();
     * ```
     */
    export class StreamWriter {
        private bufferBlob;
        private bufferText;
        private enc;
        /**
         * Gets the content written to the StreamWriter as Blob.
         * @returns Blob
         */
        readonly buffer: Blob;
        /**
         * Gets the encoding.
         * @returns Encoding
         */
        readonly encoding: Encoding;
        /**
         * Initializes a new instance of the StreamWriter class by using the specified encoding.
         * @param  {Encoding} encoding?- The character encoding to use.
         */
        constructor(encoding?: Encoding);
        private init(encoding);
        /**
         * Private method to set Byte Order Mark(BOM) value based on EncodingType
         */
        private setBomByte();
        /**
         * Saves the file with specified name and sends the file to client browser
         * @param  {string} fileName - The file name to save
         * @returns {void}
         */
        save(fileName: string): void;
        /**
         * Writes the specified string.
         * @param  {string} value - The string to write. If value is null or undefined, nothing is written.
         * @returns {void}
         */
        write(value: string): void;
        private flush();
        /**
         * Writes the specified string followed by a line terminator
         * @param  {string} value - The string to write. If value is null or undefined, nothing is written
         * @returns {void}
         */
        writeLine(value: string): void;
        /**
         * Releases the resources used by the StreamWriter
         * @returns {void}
         */
        destroy(): void;
    }
    
  }
  export namespace grids {
    
    /**
     * Summary Action controller.
     */
    export class Aggregate implements IAction {
        private parent;
        private locator;
        private footerRenderer;
        constructor(parent: IGrid, locator?: ServiceLocator);
        getModuleName(): string;
        private initiateRender();
        private prepareSummaryInfo();
        private getFormatFromType(format, type);
        onPropertyChanged(e: NotifyArgs): void;
        addEventListener(): void;
        removeEventListener(): void;
        destroy(): void;
    }
    /**
     * @private
     */
    export function summaryIterator(aggregates: AggregateRowModel[], callback: Function): void;
    
    /**
     * `BatchEdit` module is used to handle batch editing actions.
     * @hidden
     */
    export class BatchEdit {
        private parent;
        private serviceLocator;
        private form;
        formObj: ej.inputs.FormValidator;
        private renderer;
        private focus;
        private dataBoundFunction;
        private cellDetails;
        private isColored;
        constructor(parent?: IGrid, serviceLocator?: ServiceLocator, renderer?: EditRender);
        /**
         * @hidden
         */
        addEventListener(): void;
        /**
         * @hidden
         */
        removeEventListener(): void;
        private dataBound();
        /**
         * @hidden
         */
        destroy(): void;
        protected clickHandler(e: MouseEvent): void;
        protected dblClickHandler(e: MouseEvent): void;
        private onBeforeCellFocused(e);
        private onCellFocused(e);
        private isAddRow(index);
        private editCellFromIndex(rowIdx, cellIdx);
        closeEdit(): void;
        deleteRecord(fieldname?: string, data?: Object): void;
        addRecord(data?: Object): void;
        endEdit(data?: Object): void;
        private validateFormObj();
        batchSave(): void;
        getBatchChanges(): Object;
        private mergeBatchChanges(row, mRow, frzCols);
        /**
         * @hidden
         */
        removeRowObjectFromUID(uid: string): void;
        /**
         * @hidden
         */
        addRowObject(row: Row<Column>): void;
        private bulkDelete(fieldname?, data?);
        private refreshRowIdx();
        private getIndexFromData(data);
        private bulkAddRow(data?);
        private renderMovable(ele);
        private findNextEditableCell(columnIndex, isAdd);
        private checkNPCell(col);
        private getDefaultData();
        private setCellIdx(target);
        editCell(index: number, field: string, isAdd?: boolean): void;
        updateCell(rowIndex: number, field: string, value: string | number | boolean | Date): void;
        private setChanges(rowObj, field, value);
        updateRow(index: number, data: Object): void;
        private getCellIdx(uid);
        private refreshTD(td, column, rowObj, value);
        private getColIndex(cells, index);
        saveCell(isForceSave?: boolean): void;
        protected getDataByIndex(index: number): Object;
    }
    
    /**
     * @hidden
     * `CheckBoxFilter` module is used to handle filtering action.
     */
    export class CheckBoxFilter {
        protected sBox: HTMLElement;
        protected isExcel: boolean;
        protected id: string;
        protected colType: string;
        protected fullData: Object[];
        protected filteredData: Object[];
        protected isFiltered: boolean | number;
        protected dlg: Element;
        protected dialogObj: ej.popups.Dialog;
        protected cBox: HTMLElement;
        protected spinner: HTMLElement;
        protected searchBox: Element;
        protected sInput: HTMLInputElement;
        protected sIcon: Element;
        protected options: IFilterArgs;
        protected filterSettings: FilterSettings;
        protected existingPredicate: {
            [key: string]: PredicateModel[];
        };
        protected foreignKeyData: Object[];
        protected filterState: boolean;
        protected defaultConstants: Object;
        protected values: Object;
        private cBoxTrue;
        private cBoxFalse;
        private itemsCnt;
        private result;
        protected parent: IGrid;
        protected serviceLocator: ServiceLocator;
        protected localeObj: ej.base.L10n;
        protected valueFormatter: ValueFormatter;
        /**
         * Constructor for checkbox filtering module
         * @hidden
         */
        constructor(parent?: IGrid, filterSettings?: FilterSettings, serviceLocator?: ServiceLocator);
        protected initLocale(constants: Object): void;
        /**
         * To destroy the filter bar.
         * @return {void}
         * @hidden
         */
        destroy(): void;
        private wireEvents();
        private unWireEvents();
        private searchBoxClick(e);
        private searchBoxKeyUp(e?);
        private updateSearchIcon();
        /**
         * Gets the localized label by locale keyword.
         * @param  {string} key
         * @return {string}
         */
        getLocalizedLabel(key: string): string;
        private updateDataSource();
        protected updateModel(options: IFilterArgs): void;
        protected getAndSetChkElem(options: IFilterArgs): HTMLElement;
        protected showDialog(options: IFilterArgs): void;
        private dialogCreated(e);
        openDialog(options: IFilterArgs): void;
        closeDialog(): void;
        protected clearFilter(): void;
        private btnClick(e);
        private fltrBtnHandler();
        private initiateFilter(fColl);
        private refreshCheckboxes();
        private getPredicateFromCols(columns);
        private getAllData();
        private dataSuccess(e);
        private processDataSource(query?, isInitial?);
        private updateResult();
        private clickHandler(e);
        private updateAllCBoxes(checked);
        private dialogOpen();
        private createCheckbox(value, checked);
        private updateIndeterminatenBtn();
        private createFilterItems(data, isInitial?);
        private getCheckedState(isColFiltered, value);
        static getDistinct(json: Object[], field: string, column?: Column, foreignKeyData?: Object[]): Object;
        static getPredicate(columns: PredicateModel[]): Predicate;
        private static generatePredicate(cols);
        private static getCaseValue(filter);
        private static updateDateFilter(filter);
        /**
         * For internal use only - Get the module name.
         * @private
         */
        protected getModuleName(): string;
    }
    
    /**
     * The `Clipboard` module is used to handle clipboard copy action.
     */
    export class Clipboard implements IAction {
        private clipBoardTextArea;
        private copyContent;
        private isSelect;
        private parent;
        /**
         * Constructor for the Grid clipboard module
         * @hidden
         */
        constructor(parent?: IGrid);
        /**
         * @hidden
         */
        addEventListener(): void;
        /**
         * @hidden
         */
        removeEventListener(): void;
        private initialEnd();
        private keyDownHandler(e);
        private setCopyData(withHeader?);
        private getCopyData(cells, isCell, splitKey, withHeader?);
        /**
         * Copy selected rows or cells data into clipboard.
         * @param {boolean} withHeader - Specifies whether the column header data need to be copied or not.
         */
        copy(withHeader?: boolean): void;
        /**
         * For internal use only - Get the module name.
         * @private
         */
        protected getModuleName(): string;
        /**
         * To destroy the clipboard
         * @return {void}
         * @hidden
         */
        destroy(): void;
        private checkBoxSelection();
    }
    
    /**
     * The `ColumnChooser` module is used to show or hide columns dynamically.
     */
    export class ColumnChooser implements IAction {
        private dataManager;
        private column;
        private parent;
        private serviceLocator;
        private l10n;
        private dlgObj;
        private searchValue;
        private flag;
        private timer;
        getShowHideService: ShowHide;
        private showColumn;
        private hideColumn;
        private mainDiv;
        private innerDiv;
        private ulElement;
        private isDlgOpen;
        private dlghide;
        private initialOpenDlg;
        private stateChangeColumns;
        private dlgDiv;
        private isInitialOpen;
        private isCustomizeOpenCC;
        private cBoxTrue;
        private cBoxFalse;
        private searchBoxObj;
        /**
         * Constructor for the Grid ColumnChooser module
         * @hidden
         */
        constructor(parent?: IGrid, serviceLocator?: ServiceLocator);
        private destroy();
        private rtlUpdate();
        /**
         * @hidden
         */
        addEventListener(): void;
        /**
         * @hidden
         */
        removeEventListener(): void;
        private render();
        private clickHandler(e);
        private hideDialog();
        /**
         * To render columnChooser when showColumnChooser enabled.
         * @return {void}
         * @hidden
         */
        renderColumnChooser(x?: number, y?: number, target?: Element): void;
        /**
         * Column chooser can be displayed on screen by given position(X and Y axis).
         * @param  {number} X - Defines the X axis.
         * @param  {number} Y - Defines the Y axis.
         * @return {void}
         */
        openColumnChooser(X?: number, Y?: number): void;
        private enableAfterRenderEle(e);
        private customDialogOpen();
        private customDialogClose();
        private getColumns();
        private renderDlgContent();
        private renderChooserList();
        private confirmDlgBtnClick(args);
        private columnStateChange(stateColumns, state);
        private clearActions();
        private checkstatecolumn(isChecked, coluid);
        private columnChooserSearch(searchVal);
        private wireEvents();
        private unWireEvents();
        private checkBoxClickHandler(e);
        private refreshCheckboxList(gdCol, searchVal?);
        private refreshCheckboxState();
        private checkState(element, state);
        private createCheckBox(label, checked, uid);
        private renderCheckbox(column);
        private columnChooserManualSearch(e);
        private startTimer(e);
        private stopTimer();
        private addcancelIcon();
        private removeCancelIcon();
        private mOpenDlg();
        private getModuleName();
    }
    
    /**
     * 'column menu module used to handle column menu actions'
     */
    export class ColumnMenu implements IAction {
        private element;
        private gridID;
        private parent;
        private serviceLocator;
        private columnMenu;
        private l10n;
        private defaultItems;
        private localeText;
        private targetColumn;
        private disableItems;
        private hiddenItems;
        private headerCell;
        private isOpen;
        private eventArgs;
        private GROUP;
        private UNGROUP;
        private ASCENDING;
        private DESCENDING;
        private ROOT;
        private FILTER;
        private POP;
        private WRAP;
        private CHOOSER;
        constructor(parent?: IGrid, serviceLocator?: ServiceLocator);
        wireEvents(): void;
        unwireEvents(): void;
        /**
         * To destroy the resize
         * @return {void}
         * @hidden
         */
        destroy(): void;
        columnMenuHandlerClick(e: Event): void;
        private openColumnMenu(e);
        columnMenuHandlerDown(e: Event): void;
        private getColumnMenuHandlers();
        /**
         * @hidden
         */
        addEventListener(): void;
        /**
         * @hidden
         */
        removeEventListener(): void;
        private enableAfterRenderMenu(e);
        private render();
        private wireFilterEvents();
        private unwireFilterEvents();
        private beforeMenuItemRender(args);
        private columnMenuBeforeClose(args);
        private isChooserItem(item);
        private columnMenuBeforeOpen(args);
        private ensureDisabledStatus(item);
        private columnMenuItemClick(args);
        private columnMenuOnClose(args);
        private getDefaultItems();
        private getItems();
        private getDefaultItem(item);
        private getLocaleText(item);
        private generateID(item, append?);
        private getKeyFromId(id, append?);
        getColumnMenu(): HTMLElement;
        private getModuleName();
        private setLocaleKey();
        private getHeaderCell(e);
        private getColumn();
        private createChooserItems();
        private appendFilter(e);
        private getFilter(target, id, isClose?);
        private setPosition(li, ul);
        private filterPosition(e);
        private getDefault();
        private isFilterPopupOpen();
        private getFilterPop();
        private isFilterItemAdded();
    }
    
    /**
     * `CommandColumn` used to handle the command column actions.
     * @hidden
     */
    export class CommandColumn {
        private parent;
        private previousClickedTD;
        private locator;
        private clickedButton;
        constructor(parent: IGrid, locator?: ServiceLocator);
        private initiateRender();
        private commandClickHandler(e);
        /**
         * For internal use only - Get the module name.
         */
        private getModuleName();
        /**
         * To destroy CommandColumn.
         * @method destroy
         * @return {void}
         */
        private destroy();
        private removeEventListener();
        private addEventListener();
        private keyPressHandler(e);
    }
    
    export const menuClass: CMenuClassList;
    export interface CMenuClassList {
        header: string;
        content: string;
        edit: string;
        batchEdit: string;
        editIcon: string;
        pager: string;
        cancel: string;
        save: string;
        delete: string;
        copy: string;
        pdf: string;
        group: string;
        ungroup: string;
        csv: string;
        excel: string;
        fPage: string;
        lPage: string;
        nPage: string;
        pPage: string;
        ascending: string;
        descending: string;
        groupHeader: string;
        touchPop: string;
    }
    /**
     * The `ContextMenu` module is used to handle context menu actions.
     */
    export class ContextMenu implements IAction {
        private element;
        contextMenu: any;
        private defaultItems;
        private disableItems;
        private hiddenItems;
        private gridID;
        private parent;
        private serviceLocator;
        private l10n;
        private localeText;
        private targetColumn;
        private eventArgs;
        isOpen: boolean;
        row: HTMLTableRowElement;
        cell: HTMLTableCellElement;
        private keyPressHandlerFunction;
        constructor(parent?: IGrid, serviceLocator?: ServiceLocator);
        /**
         * @hidden
         */
        addEventListener(): void;
        /**
         * @hidden
         */
        removeEventListener(): void;
        private keyDownHandler(e);
        private render();
        private enableAfterRenderMenu(e);
        private getMenuItems();
        private getLastPage();
        private contextMenuOpen();
        private contextMenuItemClick(args);
        private contextMenuOnClose(args);
        private getLocaleText(item);
        private updateItemStatus();
        private contextMenuBeforeOpen(args);
        private ensureTarget(targetElement, selector);
        private ensureFrozenHeader(targetElement);
        private ensureDisabledStatus(item);
        /**
         * Gets the context menu element from the Grid.
         * @return {Element}
         */
        getContextMenu(): Element;
        /**
         * Destroys the context menu component in the Grid.
         * @method destroy
         * @return {void}
         * @hidden
         */
        destroy(): void;
        private getModuleName();
        private generateID(item);
        private getKeyFromId(id);
        private buildDefaultItems(item);
        private getDefaultItems();
        private setLocaleKey();
        private getColumn(e);
        private selectRow(e, isSelectable);
    }
    
    /**
     * Grid data module is used to generate query and data source.
     * @hidden
     */
    export class Data implements IDataProcessor {
        dataManager: ej.data.DataManager;
        protected parent: IGrid;
        protected serviceLocator: ServiceLocator;
        protected dataState: PendingState;
        /**
         * Constructor for data module.
         * @hidden
         */
        constructor(parent?: IGrid, serviceLocator?: ServiceLocator);
        /**
         * The function used to initialize dataManager and external query
         * @return {void}
         */
        private initDataManager();
        /**
         * The function is used to generate updated Query from Grid model.
         * @return {Query}
         * @hidden
         */
        generateQuery(skipPage?: boolean): ej.data.Query;
        protected aggregateQuery(query: ej.data.Query, isForeign?: boolean): ej.data.Query;
        protected pageQuery(query: ej.data.Query, skipPage?: boolean): ej.data.Query;
        protected groupQuery(query: ej.data.Query): ej.data.Query;
        protected sortQuery(query: ej.data.Query): ej.data.Query;
        protected searchQuery(query: ej.data.Query): ej.data.Query;
        protected filterQuery(query: ej.data.Query, column?: PredicateModel[], skipFoerign?: boolean): ej.data.Query;
        private fGeneratePredicate(col, predicateList);
        /**
         * The function is used to get dataManager promise by executing given Query.
         * @param  {Query} query - Defines the query which will execute along with data processing.
         * @return {Promise<Object>}
         * @hidden
         */
        getData(args?: {
            requestType?: string;
            foreignKeyData?: string[];
            data?: Object;
            index?: number;
        }, query?: ej.data.Query): Promise<Object>;
        private formatGroupColumn(value, field);
        private crudActions(args);
        /** @hidden */
        saveChanges(changes: Object, key: string): Promise<Object>;
        private getKey(keys);
        /** @hidden */
        isRemote(): boolean;
        private addRows(e);
        private removeRows(e);
        private getColumnByField(field);
        protected destroy(): void;
        getState(): PendingState;
        setState(state: PendingState): Object;
        getStateEventArgument(query: ej.data.Query): PendingState;
        private eventPromise(args, query?, key?);
    }
    
    /**
     * The `DetailRow` module is used to handle detail template and hierarchy Grid operations.
     */
    export class DetailRow {
        private aria;
        private parent;
        private focus;
        /**
         * Constructor for the Grid detail template module
         * @hidden
         */
        constructor(parent?: IGrid, locator?: ServiceLocator);
        private clickHandler(e);
        private toogleExpandcollapse(target);
        private isDetailRow(row);
        private destroy();
        private getTDfromIndex(index, className);
        /**
         * Expands a detail row with the given target.
         * @param  {Element} target - Defines the collapsed element to expand.
         * @return {void}
         */
        expand(target: number | Element): void;
        /**
         * Collapses a detail row with the given target.
         * @param  {Element} target - Defines the expanded element to collapse.
         * @return {void}
         */
        collapse(target: number | Element): void;
        /**
         * Expands all the detail rows of the Grid.
         * @return {void}
         */
        expandAll(): void;
        /**
         * Collapses all the detail rows of the Grid.
         * @return {void}
         */
        collapseAll(): void;
        private expandCollapse(isExpand);
        private keyPressHandler(e);
        /**
         * For internal use only - Get the module name.
         * @private
         */
        protected getModuleName(): string;
    }
    
    /**
     * `DialogEdit` module is used to handle dialog editing actions.
     * @hidden
     */
    export class DialogEdit extends NormalEdit {
        protected parent: IGrid;
        protected serviceLocator: ServiceLocator;
        protected renderer: EditRender;
        constructor(parent?: IGrid, serviceLocator?: ServiceLocator, renderer?: EditRender);
        closeEdit(): void;
        addRecord(data?: Object, index?: number): void;
        endEdit(): void;
        deleteRecord(fieldname?: string, data?: Object): void;
        protected startEdit(tr?: Element): void;
    }
    
    /**
     * The `Edit` module is used to handle editing actions.
     */
    export class Edit implements IAction {
        private edit;
        protected renderer: EditRender;
        private editModule;
        /** @hidden */
        formObj: ej.inputs.FormValidator;
        mFormObj: ej.inputs.FormValidator;
        private editCellType;
        private editType;
        protected parent: IGrid;
        protected serviceLocator: ServiceLocator;
        protected l10n: ej.base.L10n;
        private dialogObj;
        private alertDObj;
        private actionBeginFunction;
        private actionCompleteFunction;
        private preventObj;
        /**
         * Constructor for the Grid editing module
         * @hidden
         */
        constructor(parent?: IGrid, serviceLocator?: ServiceLocator);
        private updateColTypeObj();
        /**
         * For internal use only - Get the module name.
         * @private
         */
        protected getModuleName(): string;
        /**
         * @hidden
         */
        onPropertyChanged(e: NotifyArgs): void;
        private updateEditObj();
        private initialEnd();
        private wireEvents();
        private unwireEvents();
        private tapEvent(e);
        private getUserAgent();
        /**
         * Edits any bound record in the Grid by TR element.
         * @param {HTMLTableRowElement} tr - Defines the table row to be edited.
         */
        startEdit(tr?: HTMLTableRowElement): void;
        /**
         * Cancels edited state.
         */
        closeEdit(): void;
        protected refreshToolbar(): void;
        /**
         * To adds a new row at the top with the given data. When data is not passed, it will add empty rows.
         * > `editSettings.allowEditing` should be true.
         * @param {Object} data - Defines the new add record data.
         * @param {number} index - Defines the row index to be added
         */
        addRecord(data?: Object, index?: number): void;
        /**
         * Deletes a record with the given options. If fieldname and data are not given, the Grid will delete the selected record.
         * > `editSettings.allowDeleting` should be true.
         * @param {string} fieldname - Defines the primary key field name of the column.
         * @param {Object} data - Defines the JSON data record to be deleted.
         */
        deleteRecord(fieldname?: string, data?: Object): void;
        /**
         * Deletes a visible row by TR element.
         * @param {HTMLTableRowElement} tr - Defines the table row element.
         */
        deleteRow(tr: HTMLTableRowElement): void;
        /**
         * If Grid is in editable state, you can save a record by invoking endEdit.
         */
        endEdit(): void;
        /**
         * To update the specified cell by given value without changing into edited state.
         * @param {number} rowIndex Defines the row index.
         * @param {string} field Defines the column field.
         * @param {string | number | boolean | Date} value - Defines the value to be changed.
         */
        updateCell(rowIndex: number, field: string, value: string | number | boolean | Date): void;
        /**
         * To update the specified row by given values without changing into edited state.
         * @param {number} index Defines the row index.
         * @param {Object} data Defines the data object to be updated.
         */
        updateRow(index: number, data: Object): void;
        /**
         * Resets added, edited, and deleted records in the batch mode.
         */
        batchCancel(): void;
        /**
         * Bulk saves added, edited, and deleted records in the batch mode.
         */
        batchSave(): void;
        /**
         * Changes a particular cell into edited state based on the row index and field name provided in the `batch` mode.
         * @param {number} index - Defines row index to edit a particular cell.
         * @param {string} field - Defines the field name of the column to perform batch edit.
         */
        editCell(index: number, field: string): void;
        /**
         * Checks the status of validation at the time of editing. If validation is passed, it returns true.
         * @return {boolean}
         */
        editFormValidate(): boolean;
        /**
         * Gets the added, edited,and deleted data before bulk save to the DataSource in batch mode.
         * @return {Object}
         */
        getBatchChanges(): Object;
        /**
         * Gets the current value of the edited component.
         */
        getCurrentEditCellData(): string;
        /**
         * Saves the cell that is currently edited. It does not save the value to the DataSource.
         */
        saveCell(): void;
        private endEditing();
        private showDialog(content, obj);
        getValueFromType(col: Column, value: string | Date | boolean): number | string | Date | boolean;
        private destroyToolTip();
        private createConfirmDlg();
        private createAlertDlg();
        private alertClick();
        private dlgWidget(btnOptions, name);
        private dlgCancel();
        private dlgOk(e);
        /**
         * @hidden
         */
        addEventListener(): void;
        /**
         * @hidden
         */
        removeEventListener(): void;
        private actionComplete(e);
        /**
         * @hidden
         */
        getCurrentEditedData(form: Element, editedData: Object): Object;
        /**
         * @hidden
         */
        onActionBegin(e: NotifyArgs): void;
        /**
         * @hidden
         */
        destroyWidgets(cols?: Column[]): void;
        /**
         * @hidden
         */
        destroyForm(): void;
        /**
         * To destroy the editing.
         * @return {void}
         * @hidden
         */
        destroy(): void;
        private keyPressHandler(e);
        private preventBatch(args);
        private executeAction();
        /**
         * @hidden
         */
        applyFormValidation(cols?: Column[]): void;
        private createFormObj(form, rules);
        private valErrorPlacement(inputElement, error);
        private getElemTable(inputElement);
        private validationComplete(args);
        private createTooltip(element, error, name, display);
    }
    /** @hidden */
    export namespace Global {
        let timer: Object;
    }
    
    /**
     * @hidden
     * `ExcelExport` module is used to handle the Excel export action.
     */
    export class ExcelExport {
        private parent;
        private isExporting;
        private theme;
        private book;
        private workSheet;
        private rows;
        private columns;
        private styles;
        private data;
        private rowLength;
        private footer;
        private expType;
        private includeHiddenColumn;
        private isCsvExport;
        private isBlob;
        private blobPromise;
        private exportValueFormatter;
        private isElementIdChanged;
        private helper;
        private foreignKeyData;
        /**
         * Constructor for the Grid Excel Export module.
         * @hidden
         */
        constructor(parent?: IGrid);
        /**
         * For internal use only - Get the module name.
         */
        private getModuleName();
        private init(gObj);
        /**
         * Export Grid to Excel file.
         * @param  {exportProperties} exportProperties - Defines the export properties of the Grid.
         * @param  {isMultipleExport} isMultipleExport - Defines is multiple Grid's are exported.
         * @param  {workbook} workbook - Defined the Workbook if multiple Grid is exported.
         * @param  {isCsv} isCsv - true if export to CSV.
         * @return {Promise<any>}
         */
        Map(grid: IGrid, exportProperties: ExcelExportProperties, isMultipleExport: boolean, workbook: any, isCsv: boolean, isBlob: boolean): Promise<any>;
        private processRecords(gObj, exportProperties, isMultipleExport, workbook);
        private processInnerRecords(gObj, exportProperties, isMultipleExport, workbook, r);
        private processRecordContent(gObj, returnType, headerRow, isMultipleExport, currentViewRecords?);
        private processGroupedRows(gObj, dataSource, headerRow, level);
        private processRecordRows(gObj, record, headerRow, level);
        private processAggregates(gObj, rec, currentViewRecords?, indent?, byGroup?);
        private fillAggregates(gObj, cells, indent, customIndex?);
        private getAggreateValue(cellType, template, cell, row);
        private mergeOptions(JSON1, JSON2);
        private getColumnStyle(gObj, columnIndex);
        private processHeaderContent(gObj, headerRow, exportProperties, indent);
        private getHeaderThemeStyle(theme);
        private updateThemeStyle(themestyle, style);
        private getCaptionThemeStyle(theme);
        private getRecordThemeStyle(theme);
        private processExcelHeader(header);
        private updatedCellIndex(json);
        private processExcelFooter(footer);
        private getIndex(spannedCells, rowIndex, columnIndex);
        private parseStyles(gObj, col, style, index);
        /**
         * To destroy the excel export
         * @return {void}
         * @hidden
         */
        destroy(): void;
    }
    
    /**
     * @hidden
     * `ExcelFilter` module is used to handle filtering action.
     */
    export class ExcelFilter extends CheckBoxFilter {
        private datePicker;
        private actObj;
        private numericTxtObj;
        private dlgDiv;
        private l10n;
        private dlgObj;
        private menuEle;
        private customFilterOperators;
        private dropOptr;
        private optrData;
        private menuItem;
        private menu;
        private cmenu;
        protected menuObj: ContextMenu;
        private isCMenuOpen;
        private localeConstants;
        /**
         * Constructor for excel filtering module
         * @hidden
         */
        constructor(parent?: IGrid, filterSettings?: FilterSettings, serviceLocator?: ServiceLocator, customFltrOperators?: Object);
        private getCMenuDS(type, operator?);
        /**
         * To destroy the filter bar.
         * @return {void}
         * @hidden
         */
        destroy(): void;
        private createMenu(type, isFiltered, isCheckIcon);
        private createMenuElem(val, className?, iconName?, isSubMenu?);
        private wireExEvents();
        private unwireExEvents();
        private clickExHandler(e);
        private destroyCMenu();
        private hoverHandler(e);
        private ensureTextFilter();
        private preventClose(args);
        private getContextBounds(context);
        private getCMenuYPosition(target, context);
        openDialog(options: IFilterArgs): void;
        closeDialog(): void;
        private selectHandler(e);
        private renderDialogue(e);
        private removeDialog();
        private clearBtnClick(field);
        private createdDialog(target, column);
        private renderCustomFilter(target, column);
        private filterBtnClick(col);
        /**
         * Filters grid row by column name with given options.
         * @param {string} fieldName - Defines the field name of the filter column.
         * @param {string} firstOperator - Defines the first operator by how to filter records.
         * @param {string | number | Date | boolean} firstValue - Defines the first value which is used to filter records.
         * @param  {string} predicate - Defines the relationship between one filter query with another by using AND or OR predicate.
         * @param {boolean} matchCase - If ignore case set to true, then filter records with exact match or else
         * filter records with case insensitive(uppercase and lowercase letters treated as same).
         * @param {boolean} ignoreAccent - If ignoreAccent set to true, then ignores the diacritic characters or accents when filtering.
         * @param {string} secondOperator - Defines the second operator by how to filter records.
         * @param {string | number | Date | boolean} secondValue - Defines the first value which is used to filter records.
         */
        private filterByColumn(fieldName, firstOperator, firstValue, predicate?, matchCase?, ignoreAccent?, secondOperator?, secondValue?);
        private renderOperatorUI(column, table, elementID, predicates, isFirst?);
        private dropDownOpen(args);
        private getSelectedValue(text);
        private dropSelectedVal(col, predicates, isFirst?);
        private getSelectedText(operator);
        private renderFilterUI(column, dlgConetntEle);
        private renderRadioButton(column, tr, predicates);
        private removeObjects(elements);
        private renderFlValueUI(column, optr, elementId, predicates, isFirst?);
        private renderMatchCase(column, tr, matchCase, elementId, predicates);
        private renderDate(options, column, inputValue, fValue, isRtl);
        private completeAction(e);
        private renderNumericTextBox(options, column, inputValue, fValue, isRtl);
        private renderAutoComplete(options, column, inputValue, fValue, isRtl);
        /**
         * For internal use only - Get the module name.
         * @private
         */
        protected getModuleName(): string;
    }
    
    /**
     * @hidden
     * `ExportHelper` for `PdfExport` & `ExcelExport`
     */
    export class ExportHelper {
        parent: IGrid;
        private colDepth;
        private hideColumnInclude;
        private foreignKeyData;
        constructor(parent: IGrid);
        static getQuery(parent: IGrid, data: Data): ej.data.Query;
        getFData(value: string, column: Column): Object;
        getColumnData(gridObj: Grid): Promise<Object>;
        getHeaders(column: any[], isHideColumnInclude?: boolean): {
            rows: any[];
            columns: Column[];
        };
        getConvertedWidth(input: string): number;
        private generateActualColumns(column, actualColumns);
        private removeCellFromRow(cells, cellIndex);
        private processHeaderCells(rows);
        private appendGridCells(cols, gridRows, index, isFirstObj, isFirstColumn, isLastColumn);
        private generateCell(gridColumn, cellType?, rowSpan?, className?, rowIndex?, columnIndex?);
        private processColumns(rows);
        private getCellCount(column, count);
        private measureColumnDepth(column);
        private checkDepth(col, index);
    }
    /**
     * @hidden
     * `ExportValueFormatter` for `PdfExport` & `ExcelExport`
     */
    export class ExportValueFormatter {
        private internationalization;
        private valueFormatter;
        constructor();
        private returnFormattedValue(args, customFormat);
        formatCellValue(args: any): string;
    }
    
    /**
     *
     * The `Filter` module is used to handle filtering action.
     */
    export class Filter implements IAction {
        private filterSettings;
        private element;
        private value;
        private predicate;
        private operator;
        private column;
        private fieldName;
        private matchCase;
        private ignoreAccent;
        private timer;
        private filterStatusMsg;
        private currentFilterObject;
        private isRemove;
        private contentRefresh;
        private values;
        private nextFlMenuOpen;
        private type;
        private filterModule;
        private filterOperators;
        private fltrDlgDetails;
        private customOperators;
        private parent;
        private serviceLocator;
        private l10n;
        private valueFormatter;
        private actualPredicate;
        /**
         * Constructor for Grid filtering module
         * @hidden
         */
        constructor(parent?: IGrid, filterSettings?: FilterSettings, serviceLocator?: ServiceLocator);
        /**
         * To render filter bar when filtering enabled.
         * @return {void}
         * @hidden
         */
        render(e?: NotifyArgs): void;
        /**
         * To destroy the filter bar.
         * @return {void}
         * @hidden
         */
        destroy(): void;
        private generateRow(index?);
        private generateCells();
        private generateCell(column, cellType?);
        /**
         * To update filterSettings when applying filter.
         * @return {void}
         * @hidden
         */
        updateModel(): void;
        private getFilteredColsIndexByField(col);
        /**
         * To trigger action complete event.
         * @return {void}
         * @hidden
         */
        onActionComplete(e: NotifyArgs): void;
        private wireEvents();
        private unWireEvents();
        private enableAfterRender(e);
        private initialEnd();
        /**
         * @hidden
         */
        addEventListener(): void;
        /**
         * @hidden
         */
        removeEventListener(): void;
        private filterMenuClose(args);
        /**
         * Filters the Grid row by fieldName, filterOperator, and filterValue.
         * @param  {string} fieldName - Defines the field name of the filter column.
         * @param  {string} filterOperator - Defines the operator to filter records.
         * @param  {string | number | Date | boolean} filterValue - Defines the value which is used to filter records.
         * @param  {string} predicate - Defines the relationship of one filter query with another by using AND or OR predicate.
         * @param  {boolean} matchCase - If match case is set to true, then the filter records
         * the exact match or <br> filters records that are case insensitive (uppercase and lowercase letters treated the same).
         * @param {boolean} ignoreAccent - If ignoreAccent set to true, then filter ignores the diacritic characters or accents while filtering.
         * @param  {string} actualFilterValue - Defines the actual filter value for the filter column.
         * @param  {string} actualOperator - Defines the actual filter operator for the filter column.
         * @return {void}
         */
        filterByColumn(fieldName: string, filterOperator: string, filterValue: string | number | Date | boolean, predicate?: string, matchCase?: boolean, ignoreAccent?: boolean, actualFilterValue?: Object, actualOperator?: Object): void;
        private onPropertyChanged(e);
        /**
         * Clears all the filtered rows of the Grid.
         * @return {void}
         */
        clearFiltering(): void;
        private checkAlreadyColFiltered(field);
        private columnMenuFilter(args);
        private filterDialogOpen(col, target, left?, top?);
        /**
         * Removes filtered column by field name.
         * @param  {string} field - Defines column field name to remove filter.
         * @param  {boolean} isClearFilterBar -  Specifies whether the filter bar value needs to be cleared.
         * @return {void}
         * @hidden
         */
        removeFilteredColsByField(field: string, isClearFilterBar?: boolean): void;
        /**
         * For internal use only - Get the module name.
         * @private
         */
        protected getModuleName(): string;
        private keyUpHandler(e);
        private updateCrossIcon(element);
        private updateFilterMsg();
        private setFormatForFlColumn(value, column);
        private checkForSkipInput(column, value);
        private processFilter(e);
        private startTimer(e);
        private stopTimer();
        private onTimerTick();
        private validateFilterValue(value);
        private getOperator(value);
        private columnPositionChanged(e);
        private getLocalizedCustomOperators();
        private filterIconClickHandler(e);
        private clickHandler(e);
        private filterHandler(args);
    }
    
    /**
     * `ForeignKey` module is used to handle foreign key column's actions.
     */
    export class ForeignKey extends Data {
        constructor(parent: IGrid, serviceLocator: ServiceLocator);
        private initEvent();
        private initForeignKeyColumns(columns);
        private getForeignKeyData(args);
        private generateQueryFormData(args);
        private genarateQuery(column, e?, fromData?, needQuery?);
        private genarateColumnQuery(column);
        private isFiltered(column);
        protected getModuleName(): string;
        protected destroy(): void;
        private destroyEvent();
    }
    
    /**
     * `Freeze` module is used to handle Frozen rows and columns.
     * @hidden
     */
    export class Freeze implements IAction {
        private locator;
        private parent;
        constructor(parent: IGrid, locator?: ServiceLocator);
        getModuleName(): string;
        addEventListener(): void;
        private wireEvents();
        private dblClickHandler(e);
        private instantiateRenderer();
        removeEventListener(): void;
        destroy(): void;
    }
    
    /**
     *
     * The `Group` module is used to handle group action.
     */
    export class Group implements IAction {
        private groupSettings;
        private element;
        private colName;
        private column;
        private isAppliedGroup;
        private isAppliedUnGroup;
        private visualElement;
        private helper;
        private dragStart;
        private drag;
        private dragStop;
        private drop;
        private parent;
        private serviceLocator;
        private contentRefresh;
        private sortedColumns;
        private l10n;
        private aria;
        private focus;
        /**
         * Constructor for Grid group module
         * @hidden
         */
        constructor(parent?: IGrid, groupSettings?: GroupSettingsModel, sortedColumns?: string[], serviceLocator?: ServiceLocator);
        private columnDrag(e);
        private columnDragStart(e);
        private columnDrop(e);
        /**
         * @hidden
         */
        addEventListener(): void;
        /**
         * @hidden
         */
        removeEventListener(): void;
        private initialEnd();
        private keyPressHandler(e);
        private clickHandler(e);
        private unGroupFromTarget(target);
        private toogleGroupFromHeader(target);
        private applySortFromTarget(target);
        /**
         * Expands or collapses grouped rows by target element.
         * @param  {Element} target - Defines the target element of the grouped row.
         * @return {void}
         */
        expandCollapseRows(target: Element): void;
        private expandCollapse(isExpand);
        /**
         * Expands all the grouped rows of the Grid.
         * @return {void}
         */
        expandAll(): void;
        /**
         * Collapses all the grouped rows of the Grid.
         * @return {void}
         */
        collapseAll(): void;
        /**
         * The function is used to render grouping
         * @return {Element}
         * @hidden
         */
        render(): void;
        private renderGroupDropArea();
        private updateGroupDropArea();
        private initDragAndDrop();
        private initializeGHeaderDrag();
        private initializeGHeaderDrop();
        /**
         * Groups a column by column name.
         * @param  {string} columnName - Defines the column name to group.
         * @return {void}
         */
        groupColumn(columnName: string): void;
        /**
         * Ungroups a column by column name.
         * @param  {string} columnName - Defines the column name to ungroup.
         * @return {void}
         */
        ungroupColumn(columnName: string): void;
        /**
         * The function used to update groupSettings
         * @return {void}
         * @hidden
         */
        updateModel(): void;
        /**
         * The function used to trigger onActionComplete
         * @return {void}
         * @hidden
         */
        onActionComplete(e: NotifyArgs): void;
        private groupAddSortingQuery(colName);
        private addColToGroupDrop(field);
        private refreshToggleBtn(isRemove?);
        private removeColFromGroupDrop(field);
        private onPropertyChanged(e);
        private updateGroupedColumn(isVisible);
        private updateButtonVisibility(isVisible, className);
        private enableAfterRender(e);
        /**
         * To destroy the reorder
         * @return {void}
         * @hidden
         */
        destroy(): void;
        /**
         * Clears all the grouped columns of the Grid.
         * @return {void}
         */
        clearGrouping(): void;
        /**
         * For internal use only - Get the module name.
         * @private
         */
        protected getModuleName(): string;
        private refreshSortIcons(e?);
        private getGHeaderCell(field);
    }
    
    /**
     * `InlineEdit` module is used to handle inline editing actions.
     * @hidden
     */
    export class InlineEdit extends NormalEdit {
        protected parent: IGrid;
        protected serviceLocator: ServiceLocator;
        protected renderer: EditRender;
        constructor(parent?: IGrid, serviceLocator?: ServiceLocator, renderer?: EditRender);
        closeEdit(): void;
        addRecord(data?: Object, index?: number): void;
        endEdit(): void;
        deleteRecord(fieldname?: string, data?: Object): void;
        protected startEdit(tr?: Element): void;
    }
    
    /**
     * `NormalEdit` module is used to handle normal('inline, dialog, external') editing actions.
     * @hidden
     */
    export class NormalEdit {
        protected parent: IGrid;
        protected serviceLocator: ServiceLocator;
        protected renderer: EditRender;
        formObj: ej.inputs.FormValidator;
        protected previousData: Object;
        private editRowIndex;
        private rowIndex;
        private addedRowIndex;
        private uid;
        private args;
        constructor(parent?: IGrid, serviceLocator?: ServiceLocator, renderer?: EditRender);
        protected clickHandler(e: MouseEvent): void;
        protected dblClickHandler(e: MouseEvent): void;
        /**
         * The function used to trigger editComplete
         * @return {void}
         * @hidden
         */
        editComplete(e: NotifyArgs): void;
        protected startEdit(tr: Element): void;
        protected endEdit(): void;
        private destroyElements();
        private editHandler(args);
        private edSucc(e, args);
        private edFail(e);
        private editSuccess(e, args);
        private editFailure(e);
        private refreshRow(data);
        protected closeEdit(): void;
        protected addRecord(data?: Object, index?: number): void;
        protected deleteRecord(fieldname?: string, data?: Object): void;
        private stopEditStatus();
        /**
         * @hidden
         */
        addEventListener(): void;
        /**
         * @hidden
         */
        removeEventListener(): void;
        /**
         * @hidden
         */
        destroy(): void;
    }
    
    /**
     * The `Page` module is used to render pager and handle paging action.
     */
    export class Page implements IAction {
        private element;
        private pageSettings;
        private isForceCancel;
        private parent;
        private pagerObj;
        private handlers;
        /**
         * Constructor for the Grid paging module
         * @hidden
         */
        constructor(parent?: IGrid, pageSettings?: PageSettingsModel);
        /**
         * For internal use only - Get the module name.
         * @private
         */
        protected getModuleName(): string;
        /**
         * The function used to render pager from grid pageSettings
         * @return {void}
         * @hidden
         */
        render(): void;
        private onSelect(e);
        private addAriaAttr();
        private dataReady(e?);
        /**
         * Refreshes the page count, pager information, and external message.
         * @return {void}
         */
        refresh(): void;
        /**
         * Navigates to the target page according to the given number.
         * @param  {number} pageNo - Defines the page number to navigate.
         * @return {void}
         */
        goToPage(pageNo: number): void;
        /**
         * The function used to update pageSettings model
         * @return {void}
         * @hidden
         */
        updateModel(e?: NotifyArgs): void;
        /**
         * The function used to trigger onActionComplete
         * @return {void}
         * @hidden
         */
        onActionComplete(e: NotifyArgs): void;
        /**
         * @hidden
         */
        onPropertyChanged(e: NotifyArgs): void;
        private clickHandler(e);
        private keyPressHandler(e);
        /**
         * Defines the text of the external message.
         * @param  {string} message - Defines the message to update.
         * @return {void}
         */
        updateExternalMessage(message: string): void;
        private appendToElement(e?);
        private enableAfterRender(e?);
        /**
         * @hidden
         */
        addEventListener(): void;
        /**
         * @hidden
         */
        removeEventListener(): void;
        /**
         * To destroy the pager
         * @return {void}
         * @hidden
         */
        destroy(): void;
        private pagerDestroy();
    }
    
    /**
     * `PDF Export` module is used to handle the exportToPDF action.
     * @hidden
     */
    export class PdfExport {
        private parent;
        private isExporting;
        private data;
        private pdfDocument;
        private hideColumnInclude;
        private currentViewData;
        private customDataSource;
        private exportValueFormatter;
        private gridTheme;
        private isGrouping;
        private helper;
        private isBlob;
        private blobPromise;
        /**
         * Constructor for the Grid PDF Export module
         * @hidden
         */
        constructor(parent?: IGrid);
        /**
         * For internal use only - Get the module name.
         */
        private getModuleName();
        private init(parent);
        /**
         * Used to map the input data
         * @return {void}
         */
        Map(parent?: IGrid, pdfExportProperties?: PdfExportProperties, isMultipleExport?: boolean, pdfDoc?: Object, isBlob?: boolean): Promise<Object>;
        private processExport(gObj, returnType, pdfExportProperties, isMultipleExport);
        private getSummaryCaptionThemeStyle();
        private getHeaderThemeStyle();
        private processGroupedRecords(pdfGrid, dataSource, gridColumns, gObj, border, level, font, brush, backgroundBrush, returnType);
        private processGridHeaders(childLevels, pdfGrid, rows, gridColumns, border, headerFont, headerBrush);
        private processExportProperties(pdfExportProperties, dataSource, section);
        private drawPageTemplate(template, element);
        private processContentValidation(content);
        private drawText(pageTemplate, content);
        private drawPageNumber(documentHeader, content);
        private drawImage(documentHeader, content);
        private drawLine(documentHeader, content);
        private processAggregates(sRows, pdfGrid, border, font, brush, backgroundBrush, isCaption, captionRow?, groupIndex?);
        private getTemplateFunction(templateFn, index, leastCaptionSummaryIndex, column);
        private getSummaryWithoutTemplate(data);
        private setColumnProperties(gridColumns, pdfGrid);
        /**
         * set default style properties of each rows in exporting grid
         * @private
         */
        private setRecordThemeStyle(row, border);
        /**
         * generate the formatted cell values
         * @private
         */
        private processRecord(border, columns, gObj, dataSource, pdfGrid, groupIndex?);
        private processCellStyle(cell, args);
        /**
         * set text alignment of each columns in exporting grid
         * @private
         */
        private getHorizontalAlignment(textAlign, format?);
        /**
         * set vertical alignment of each columns in exporting grid
         * @private
         */
        private getVerticalAlignment(verticalAlign, format?, textAlign?);
        private getFontFamily(fontFamily);
        private getFont(content);
        private getPageNumberStyle(pageNumberType);
        private setContentFormat(content, format);
        private getPageSize(pageSize);
        private getDashStyle(dashStyle);
        private getPenFromContent(content);
        private getBrushFromContent(content);
        private hexToRgb(hex);
        /**
         * To destroy the pdf export
         * @return {void}
         * @hidden
         */
        destroy(): void;
    }
    
    /**
     *
     * The `Print` module is used to handle print action.
     */
    export class Print {
        private parent;
        private printWind;
        private scrollModule;
        private isAsyncPrint;
        private printing;
        private static printGridProp;
        /**
         * Constructor for the Grid print module
         * @hidden
         */
        constructor(parent?: IGrid, scrollModule?: Scroll);
        /**
         * By default, prints all the Grid pages and hides the pager.
         * > You can customize print options using the
         * [`printMode`](./api-grid.html#printmode-string).
         * @return {void}
         */
        print(): void;
        private onEmpty();
        private actionBegin();
        private renderPrintGrid();
        private contentReady();
        private printGrid();
        private removeColGroup(depth, element);
        private isPrintGrid();
        /**
         * To destroy the print
         * @return {void}
         * @hidden
         */
        destroy(): void;
        /**
         * For internal use only - Get the module name.
         * @private
         */
        protected getModuleName(): string;
    }
    
    /**
     *
     * The `Reorder` module is used for reordering columns.
     */
    export class Reorder implements IAction {
        private element;
        private upArrow;
        private downArrow;
        private x;
        private timer;
        private parent;
        /**
         * Constructor for the Grid reorder module
         * @hidden
         */
        constructor(parent?: IGrid);
        private chkDropPosition(srcElem, destElem);
        private chkDropAllCols(srcElem, destElem);
        private findColParent(col, cols, parent);
        private getColumnsModel(cols);
        private headerDrop(e);
        private isActionPrevent(gObj);
        private moveColumns(destIndex, column);
        private targetParentContainerIndex(srcElem, destElem);
        private getHeaderCells();
        private getColParent(column, columns);
        /**
         * Changes the position of the Grid columns by field names.
         * @param  {string} fromFName - Defines the origin field name.
         * @param  {string} toFName - Defines the destination field name.
         * @return {void}
         */
        reorderColumns(fromFName: string, toFName: string): void;
        private enableAfterRender(e);
        private createReorderElement();
        /**
         * The function used to trigger onActionComplete
         * @return {void}
         * @hidden
         */
        onActionComplete(e: NotifyArgs): void;
        /**
         * To destroy the reorder
         * @return {void}
         * @hidden
         */
        destroy(): void;
        private drag(e);
        private updateScrollPostion(e);
        private setScrollLeft(scrollElem, isLeft);
        private stopTimer();
        private updateArrowPosition(target, isLeft);
        private dragStart(e);
        private dragStop(e);
        private setDisplay(display);
        /**
         * For internal use only - Get the module name.
         * @private
         */
        protected getModuleName(): string;
    }
    
    export const resizeClassList: ResizeClasses;
    export interface ResizeClasses {
        root: string;
        suppress: string;
        icon: string;
        helper: string;
        header: string;
        cursor: string;
    }
    /**
     * `Resize` module is used to handle Resize to fit for columns.
     * @hidden
     * @private
     */
    export class Resize implements IAction {
        private content;
        private header;
        private pageX;
        private column;
        private element;
        private helper;
        private tapped;
        private isDblClk;
        private minMove;
        private parentElementWidth;
        private parent;
        private widthService;
        /**
         * Constructor for the Grid resize module
         * @hidden
         */
        constructor(parent?: IGrid);
        /**
         * Resize by field names.
         * @param  {string|string[]} fName - Defines the field name.
         * @return {void}
         */
        autoFitColumns(fName: string | string[]): void;
        private resizeColumn(fName, index, id?);
        /**
         * To destroy the resize
         * @return {void}
         * @hidden
         */
        destroy(): void;
        /**
         * For internal use only - Get the module name.
         * @private
         */
        protected getModuleName(): string;
        private findColumn(fName);
        /**
         * To create table for autofit
         * @hidden
         */
        protected createTable(table: Element, text: Element[], tag: string): number;
        /**
         * @hidden
         */
        addEventListener(): void;
        /**
         * @hidden
         */
        removeEventListener(): void;
        /**
         * @hidden
         */
        render(): void;
        private wireEvents();
        private unwireEvents();
        private getResizeHandlers();
        private setHandlerHeight();
        private callAutoFit(e);
        private resizeStart(e);
        private cancelResizeAction(removeEvents?);
        private getWidth(width, minWidth, maxWidth);
        private resizing(e);
        private resizeEnd(e);
        private getPointX(e);
        private refreshColumnWidth();
        private getTargetColumn(e);
        private updateCursor(action);
        private refresh();
        private appendHelper();
        private setHelperHeight();
        private getScrollBarWidth(height?);
        private removeHelper(e);
        private updateHelper();
        private calcPos(elem);
        private doubleTapEvent(e);
        private getUserAgent();
        private timeoutHandler();
    }
    
    /**
     *
     * Reorder module is used to handle row reordering.
     * @hidden
     */
    export class RowDD implements IAction {
        private selectedRows;
        private isDragStop;
        private helper;
        private dragStart;
        private drag;
        private dragStop;
        private parent;
        /**
         * Constructor for the Grid print module
         * @hidden
         */
        constructor(parent?: IGrid);
        private initializeDrag();
        private getElementFromPosition(element, event);
        /**
         * The function used to trigger onActionComplete
         * @return {void}
         * @hidden
         */
        onActionComplete(e: NotifyArgs): void;
        private getTargetIdx(targetRow);
        private columnDrop(e);
        private enableAfterRender(e);
        /**
         * To destroy the print
         * @return {void}
         * @hidden
         */
        destroy(): void;
        /**
         * For internal use only - Get the module name.
         * @private
         */
        protected getModuleName(): string;
    }
    
    /**
     * The `Scroll` module is used to handle scrolling behaviour.
     */
    export class Scroll implements IAction {
        private parent;
        private lastScrollTop;
        private previousValues;
        private oneTimeReady;
        private content;
        private header;
        private widthService;
        private pageXY;
        /**
         * Constructor for the Grid scrolling.
         * @hidden
         */
        constructor(parent?: IGrid);
        /**
         * For internal use only - Get the module name.
         * @private
         */
        protected getModuleName(): string;
        /**
         * @hidden
         */
        setWidth(): void;
        /**
         * @hidden
         */
        setHeight(): void;
        /**
         * @hidden
         */
        setPadding(): void;
        /**
         * @hidden
         */
        removePadding(rtl?: boolean): void;
        /**
         * Refresh makes the Grid adoptable with the height of parent container.
         *
         * > The [`height`](./api-grid.html#height) must be set to 100%.
         * @return
         */
        refresh(): void;
        private getThreshold();
        /**
         * @hidden
         */
        addEventListener(): void;
        /**
         * @hidden
         */
        removeEventListener(): void;
        private onContentScroll(scrollTarget);
        private onFreezeContentScroll(scrollTarget);
        private onWheelScroll(scrollTarget);
        private onTouchScroll(scrollTarget);
        private setPageXY();
        private getPointXY(e);
        private wireEvents();
        /**
         * @hidden
         */
        getCssProperties(rtl?: boolean): ScrollCss;
        private ensureOverflow(content);
        private onPropertyChanged(e);
        /**
         * @hidden
         */
        destroy(): void;
        /**
         * Function to get the scrollbar width of the browser.
         * @return {number}
         * @hidden
         */
        static getScrollBarWidth(): number;
    }
    /**
     * @hidden
     */
    export interface ScrollCss {
        padding?: string;
        border?: string;
    }
    
    /**
     * The `Search` module is used to handle search action.
     */
    export class Search implements IAction {
        private parent;
        private refreshSearch;
        private actionCompleteFunc;
        /**
         * Constructor for Grid search module.
         * @hidden
         */
        constructor(parent?: IGrid);
        /**
         * Searches Grid records by given key.
         *
         * > You can customize the default search action by using [`searchSettings`](./api-grid.html#searchsettings-searchsettingsmodel).
         * @param  {string} searchString - Defines the key.
         * @return {void}
         */
        search(searchString: string): void;
        /**
         * @hidden
         */
        addEventListener(): void;
        /**
         * @hidden
         */
        removeEventListener(): void;
        /**
         * To destroy the print
         * @return {void}
         * @hidden
         */
        destroy(): void;
        /**
         * @hidden
         */
        onPropertyChanged(e: NotifyArgs): void;
        /**
         * The function used to trigger onActionComplete
         * @return {void}
         * @hidden
         */
        onSearchComplete(e: NotifyArgs): void;
        onActionComplete(e: NotifyArgs): void;
        /**
         * For internal use only - Get the module name.
         * @private
         */
        protected getModuleName(): string;
    }
    
    /**
     * The `Selection` module is used to handle cell and row selection.
     */
    export class Selection implements IAction {
        /**
         * @hidden
         */
        selectedRowIndexes: number[];
        /**
         * @hidden
         */
        selectedRowCellIndexes: ISelectedCell[];
        /**
         * @hidden
         */
        selectedRecords: Element[];
        /**
         * @hidden
         */
        isRowSelected: boolean;
        /**
         * @hidden
         */
        isCellSelected: boolean;
        private selectionSettings;
        private prevRowIndex;
        private prevCIdxs;
        private prevECIdxs;
        private preventFocus;
        private selectedRowIndex;
        private isMultiShiftRequest;
        private isMultiCtrlRequest;
        private enableSelectMultiTouch;
        private element;
        private startIndex;
        private startCellIndex;
        private currentIndex;
        private isDragged;
        private isCellDrag;
        private x;
        private y;
        private target;
        private preSelectedCellIndex;
        private factory;
        private contentRenderer;
        private checkedTarget;
        private primaryKey;
        private chkField;
        private selectedRowState;
        private totalRecordsCount;
        private chkAllCollec;
        private isCheckedOnAdd;
        private persistSelectedData;
        private selectionRequest;
        private onDataBoundFunction;
        private actionBeginFunction;
        private actionCompleteFunction;
        private actionCompleteFunc;
        private parent;
        private focus;
        private checkAllRecords;
        private unSelectRowKey;
        /**
         * Constructor for the Grid selection module
         * @hidden
         */
        constructor(parent?: IGrid, selectionSettings?: SelectionSettings, locator?: ServiceLocator);
        private initializeSelection();
        /**
         * The function used to trigger onActionBegin
         * @return {void}
         * @hidden
         */
        onActionBegin(args: Object, type: string): void;
        private fDataUpdate(args);
        /**
         * The function used to trigger onActionComplete
         * @return {void}
         * @hidden
         */
        onActionComplete(args: Object, type: string): void;
        /**
         * For internal use only - Get the module name.
         * @private
         */
        protected getModuleName(): string;
        /**
         * To destroy the selection
         * @return {void}
         * @hidden
         */
        destroy(): void;
        private isEditing();
        private getSelectedMovableRow(index);
        /**
         * Selects a row by the given index.
         * @param  {number} index - Defines the row index.
         * @param  {boolean} isToggle - If set to true, then it toggles the selection.
         * @return {void}
         */
        selectRow(index: number, isToggle?: boolean): void;
        private addMovableArgs(targetObj, mRow);
        /**
         * Selects a range of rows from start and end row indexes.
         * @param  {number} startIndex - Specifies the start row index.
         * @param  {number} endIndex - Specifies the end row index.
         * @return {void}
         */
        selectRowsByRange(startIndex: number, endIndex?: number): void;
        /**
         * Selects a collection of rows by index.
         * @param  {number[]} rowIndexes - Specifies an array of row indexes.
         * @return {void}
         */
        selectRows(rowIndexes: number[]): void;
        /**
         * Select rows with existing row selection by passing row indexes.
         * @param  {number} startIndex - Specifies the row indexes.
         * @return {void}
         * @hidden
         */
        addRowsToSelection(rowIndexes: number[]): void;
        private getCollectionFromIndexes(startIndex, endIndex);
        private clearRow();
        private updateRowProps(startIndex);
        private updatePersistCollection(selectedRow, chkState);
        private updateCheckBoxes(row, chkState?);
        private updateRowSelection(selectedRow, startIndex);
        /**
         * Deselects the currently selected rows and cells.
         * @return {void}
         */
        clearSelection(): void;
        /**
         * Deselects the currently selected rows.
         * @return {void}
         */
        clearRowSelection(): void;
        private rowDeselect(type, rowIndex, data, row, foreignKeyData, mRow?);
        private getRowObj(row?);
        private getSelectedMovableCell(cellIndex);
        /**
         * Selects a cell by the given index.
         * @param  {IIndex} cellIndex - Defines the row and column indexes.
         * @param  {boolean} isToggle - If set to true, then it toggles the selection.
         * @return {void}
         */
        selectCell(cellIndex: IIndex, isToggle?: boolean): void;
        private getCellIndex(rIdx, cIdx);
        /**
         * Selects a range of cells from start and end indexes.
         * @param  {IIndex} startIndex - Specifies the row and column's start index.
         * @param  {IIndex} endIndex - Specifies the row and column's end index.
         * @return {void}
         */
        selectCellsByRange(startIndex: IIndex, endIndex?: IIndex): void;
        /**
         * Selects a collection of cells by row and column indexes.
         * @param  {ISelectedCell[]} rowCellIndexes - Specifies the row and column indexes.
         * @return {void}
         */
        selectCells(rowCellIndexes: ISelectedCell[]): void;
        /**
         * Select cells with existing cell selection by passing row and column index.
         * @param  {IIndex} startIndex - Defines the collection of row and column index.
         * @return {void}
         * @hidden
         */
        addCellsToSelection(cellIndexes: IIndex[]): void;
        private getColIndex(rowIndex, index);
        private getLastColIndex(rowIndex);
        private clearCell();
        private cellDeselect(type, cellIndexes, data, cells, foreignKeyData);
        private updateCellSelection(selectedCell, rowIndex?, cellIndex?);
        private addAttribute(cell);
        private updateCellProps(startIndex, endIndex);
        private addRowCellIndex(rowCellIndex);
        /**
         * Deselects the currently selected cells.
         * @return {void}
         */
        clearCellSelection(): void;
        private getSelectedCellsElement();
        private mouseMoveHandler(e);
        private selectLikeExcel(rowIndex, cellIndex);
        private mouseUpHandler(e);
        private mouseDownHandler(e);
        private clearSelAfterRefresh(e);
        /**
         * @hidden
         */
        addEventListener(): void;
        /**
         * @hidden
         */
        removeEventListener(): void;
        private columnPositionChanged();
        private refreshHeader();
        private rowsRemoved(e);
        dataReady(e: {
            requestType: string;
        }): void;
        private getCheckAllBox();
        private onPropertyChanged(e);
        private hidePopUp();
        private initialEnd();
        private checkBoxSelectionChanged();
        private initPerisistSelection();
        private ensureCheckboxFieldSelection();
        private dataSuccess(res);
        private refreshPersistSelection();
        private actionBegin(e);
        private actionComplete(e);
        private onDataBound();
        private checkSelectAllAction(checkState);
        private checkSelectAll(checkBox);
        private getCheckAllStatus(ele?);
        private checkSelect(checkBox);
        private moveIntoUncheckCollection(row);
        private triggerChkChangeEvent(checkBox, checkState);
        private setCheckAllState(isInteraction?);
        private clickHandler(e);
        private popUpClickHandler(e);
        private showPopup(e);
        private rowCellSelectionHandler(rowIndex, cellIndex);
        private onCellFocused(e);
        /**
         * Apply ctrl + A key selection
         * @return {void}
         * @hidden
         */
        ctrlPlusA(): void;
        private applySpaceSelection(target);
        private applyDownUpKey(rowIndex?, cellIndex?);
        private applyUpDown(rowIndex);
        private applyRightLeftKey(rowIndex?, cellIndex?);
        private applyHomeEndKey(rowIndex?, cellIndex?);
        /**
         * Apply shift+down key selection
         * @return {void}
         * @hidden
         */
        shiftDownKey(rowIndex?: number, cellIndex?: number): void;
        private applyShiftLeftRightKey(rowIndex?, cellIndex?);
        private applyCtrlHomeEndKey(rowIndex, cellIndex);
        private addRemoveClassesForRow(row, isAdd, clearAll, ...args);
        private isRowType();
        private isCellType();
        private isSingleSel();
        private getRenderer();
        /**
         * Gets the collection of selected records.
         * @return {Object[]}
         */
        getSelectedRecords(): Object[];
        private addEventListener_checkbox();
        removeEventListener_checkbox(): void;
        private actionCompleteHandler(e);
    }
    
    /**
     * The `ShowHide` module is used to control column visibility.
     */
    export class ShowHide {
        private parent;
        /**
         * Constructor for the show hide module.
         * @hidden
         */
        constructor(parent: IGrid);
        /**
         * Shows a column by column name.
         * @param  {string|string[]} columnName - Defines a single or collection of column names to show.
         * @param  {string} showBy - Defines the column key either as field name or header text.
         * @return {void}
         */
        show(columnName: string | string[], showBy?: string): void;
        /**
         * Hides a column by column name.
         * @param  {string|string[]} columnName - Defines a single or collection of column names to hide.
         * @param  {string} hideBy - Defines the column key either as field name or header text.
         * @return {void}
         */
        hide(columnName: string | string[], hideBy?: string): void;
        private getToggleFields(key);
        private getColumns(keys, getKeyBy?);
        /**
         * Shows or hides columns by given column collection.
         * @private
         * @param  {Column[]} columns - Specifies the columns.
         * @return {void}
         */
        setVisible(columns?: Column[]): void;
    }
    
    /**
     *
     * The `Sort` module is used to handle sorting action.
     */
    export class Sort implements IAction {
        private columnName;
        private direction;
        private isMultiSort;
        private lastSortedCol;
        private sortSettings;
        private enableSortMultiTouch;
        private contentRefresh;
        private isRemove;
        private sortedColumns;
        private isModelChanged;
        private aria;
        private focus;
        private parent;
        /**
         * Constructor for Grid sorting module
         * @hidden
         */
        constructor(parent?: IGrid, sortSettings?: SortSettings, sortedColumns?: string[], locator?: ServiceLocator);
        /**
         * The function used to update sortSettings
         * @return {void}
         * @hidden
         */
        updateModel(): void;
        /**
         * The function used to trigger onActionComplete
         * @return {void}
         * @hidden
         */
        onActionComplete(e: NotifyArgs): void;
        /**
         * Sorts a column with the given options.
         * @param {string} columnName - Defines the column name to sort.
         * @param {SortDirection} direction - Defines the direction of sorting field.
         * @param {boolean} isMultiSort - Specifies whether the previously sorted columns are to be maintained.
         * @return {void}
         */
        sortColumn(columnName: string, direction: SortDirection, isMultiSort?: boolean): void;
        private updateSortedCols(columnName, isMultiSort);
        /**
         * @hidden
         */
        onPropertyChanged(e: NotifyArgs): void;
        /**
         * Clears all the sorted columns of the Grid.
         * @return {void}
         */
        clearSorting(): void;
        private isActionPrevent();
        /**
         * Remove sorted column by field name.
         * @param {string} field - Defines the column field name to remove sort.
         * @return {void}
         * @hidden
         */
        removeSortColumn(field: string): void;
        private getSortedColsIndexByField(field, sortedColumns?);
        /**
         * For internal use only - Get the module name.
         * @private
         */
        protected getModuleName(): string;
        private initialEnd();
        /**
         * @hidden
         */
        addEventListener(): void;
        /**
         * @hidden
         */
        removeEventListener(): void;
        /**
         * To destroy the sorting
         * @return {void}
         * @hidden
         */
        destroy(): void;
        private clickHandler(e);
        private keyPressed(e);
        private initiateSort(target, e, column);
        private showPopUp(e);
        private popUpClickHandler(e);
        private addSortIcons();
        private removeSortIcons(position?);
        private getSortColumnFromField(field);
        private updateAriaAttr();
        private refreshSortIcons();
    }
    
    /**
     * The `Toolbar` module is used to handle ToolBar actions.
     * @hidden
     */
    export class Toolbar {
        private element;
        private predefinedItems;
        toolbar: any;
        private searchElement;
        private gridID;
        private parent;
        private serviceLocator;
        private l10n;
        private items;
        private searchBoxObj;
        constructor(parent?: IGrid, serviceLocator?: ServiceLocator);
        private render();
        /**
         * Gets the toolbar of the Grid.
         * @return {Element}
         * @hidden
         */
        getToolbar(): Element;
        /**
         * Destroys the ToolBar.
         * @method destroy
         * @return {void}
         */
        destroy(): void;
        private createToolbar();
        private refreshToolbarItems(args?);
        private getItems();
        private getItem(itemObject);
        private getItemObject(itemName);
        /**
         * Enables or disables ToolBar items.
         * @param {string[]} items - Defines the collection of itemID of ToolBar items.
         * @param {boolean} isEnable - Defines the items to be enabled or disabled.
         * @return {void}
         * @hidden
         */
        enableItems(items: string[], isEnable: boolean): void;
        private toolbarClickHandler(args);
        private modelChanged(e);
        protected onPropertyChanged(e: NotifyArgs): void;
        private keyUpHandler(e);
        private search();
        private updateSearchBox();
        private wireEvent();
        private unWireEvent();
        protected addEventListener(): void;
        protected removeEventListener(): void;
        /**
         * For internal use only - Get the module name.
         */
        private getModuleName();
    }
    
    /**
     * Virtual Scrolling class
     */
    export class VirtualScroll implements IAction {
        private parent;
        private blockSize;
        private locator;
        constructor(parent: IGrid, locator?: ServiceLocator);
        getModuleName(): string;
        private instantiateRenderer();
        ensurePageSize(): void;
        addEventListener(): void;
        removeEventListener(): void;
        private refreshVirtualElement(args);
        destroy(): void;
    }
    
    /** @hidden */
    export const created: string;
    /** @hidden */
    export const destroyed: string;
    /** @hidden */
    export const load: string;
    /** @hidden */
    export const rowDataBound: string;
    /** @hidden */
    export const queryCellInfo: string;
    /** @hidden */
    export const actionBegin: string;
    /** @hidden */
    export const actionComplete: string;
    /** @hidden */
    export const actionFailure: string;
    /** @hidden */
    export const dataBound: string;
    /** @hidden */
    export const rowSelecting: string;
    /** @hidden */
    export const rowSelected: string;
    /** @hidden */
    export const rowDeselecting: string;
    /** @hidden */
    export const rowDeselected: string;
    /** @hidden */
    export const cellSelecting: string;
    /** @hidden */
    export const cellSelected: string;
    /** @hidden */
    export const cellDeselecting: string;
    /** @hidden */
    export const cellDeselected: string;
    /** @hidden */
    export const columnDragStart: string;
    /** @hidden */
    export const columnDrag: string;
    /** @hidden */
    export const columnDrop: string;
    /** @hidden */
    export const rowDragStart: string;
    /** @hidden */
    export const rowDrag: string;
    /** @hidden */
    export const rowDrop: string;
    /** @hidden */
    export const beforePrint: string;
    /** @hidden */
    export const printComplete: string;
    /** @hidden */
    export const detailDataBound: string;
    /** @hidden */
    export const toolbarClick: string;
    /** @hidden */
    export const batchAdd: string;
    /** @hidden */
    export const batchCancel: string;
    /** @hidden */
    export const batchDelete: string;
    /** @hidden */
    export const beforeBatchAdd: string;
    /** @hidden */
    export const beforeBatchDelete: string;
    /** @hidden */
    export const beforeBatchSave: string;
    /** @hidden */
    export const beginEdit: string;
    /** @hidden */
    export const cellEdit: string;
    /** @hidden */
    export const cellSave: string;
    /** @hidden */
    export const endAdd: string;
    /** @hidden */
    export const endDelete: string;
    /** @hidden */
    export const endEdit: string;
    /** @hidden */
    export const recordDoubleClick: string;
    /** @hidden */
    export const recordClick: string;
    /** @hidden */
    export const beforeDataBound: string;
    /** @hidden */
    export const beforeOpenColumnChooser: string;
    /** @hidden */
    export const resizeStart: string;
    /** @hidden */
    export const onResize: string;
    /** @hidden */
    export const resizeStop: string;
    /** @hidden */
    export const checkBoxChange: string;
    /** @hidden */
    export const beforeCopy: string;
    /** @hidden */
    export const filterChoiceRequest: string;
    /** @hidden */
    export const filterAfterOpen: string;
    /** @hidden */
    export const filterBeforeOpen: string;
    /**
     * Specifies grid internal events
     */
    /** @hidden */
    export const initialLoad: string;
    /** @hidden */
    export const initialEnd: string;
    /** @hidden */
    export const dataReady: string;
    /** @hidden */
    export const contentReady: string;
    /** @hidden */
    export const uiUpdate: string;
    /** @hidden */
    export const onEmpty: string;
    /** @hidden */
    export const inBoundModelChanged: string;
    /** @hidden */
    export const modelChanged: string;
    /** @hidden */
    export const colGroupRefresh: string;
    /** @hidden */
    export const headerRefreshed: string;
    /** @hidden */
    export const pageBegin: string;
    /** @hidden */
    export const pageComplete: string;
    /** @hidden */
    export const sortBegin: string;
    /** @hidden */
    export const sortComplete: string;
    /** @hidden */
    export const filterBegin: string;
    /** @hidden */
    export const filterComplete: string;
    /** @hidden */
    export const searchBegin: string;
    /** @hidden */
    export const searchComplete: string;
    /** @hidden */
    export const reorderBegin: string;
    /** @hidden */
    export const reorderComplete: string;
    /** @hidden */
    export const rowDragAndDropBegin: string;
    /** @hidden */
    export const rowDragAndDropComplete: string;
    /** @hidden */
    export const groupBegin: string;
    /** @hidden */
    export const groupComplete: string;
    /** @hidden */
    export const ungroupBegin: string;
    /** @hidden */
    export const ungroupComplete: string;
    /** @hidden */
    export const rowSelectionBegin: string;
    /** @hidden */
    export const rowSelectionComplete: string;
    /** @hidden */
    export const columnSelectionBegin: string;
    /** @hidden */
    export const columnSelectionComplete: string;
    /** @hidden */
    export const cellSelectionBegin: string;
    /** @hidden */
    export const cellSelectionComplete: string;
    /** @hidden */
    export const beforeCellFocused: string;
    /** @hidden */
    export const cellFocused: string;
    /** @hidden */
    export const keyPressed: string;
    /** @hidden */
    export const click: string;
    /** @hidden */
    export const destroy: string;
    /** @hidden */
    export const columnVisibilityChanged: string;
    /** @hidden */
    export const scroll: string;
    /** @hidden */
    export const columnWidthChanged: string;
    /** @hidden */
    export const columnPositionChanged: string;
    /** @hidden */
    export const rowDragAndDrop: string;
    /** @hidden */
    export const rowsAdded: string;
    /** @hidden */
    export const rowsRemoved: string;
    /** @hidden */
    export const columnDragStop: string;
    /** @hidden */
    export const headerDrop: string;
    /** @hidden */
    export const dataSourceModified: string;
    /** @hidden */
    export const refreshComplete: string;
    /** @hidden */
    export const refreshVirtualBlock: string;
    /** @hidden */
    export const dblclick: string;
    /** @hidden */
    export const toolbarRefresh: string;
    /** @hidden */
    export const bulkSave: string;
    /** @hidden */
    export const autoCol: string;
    /** @hidden */
    export const tooltipDestroy: string;
    /** @hidden */
    export const updateData: string;
    /** @hidden */
    export const editBegin: string;
    /** @hidden */
    export const editComplete: string;
    /** @hidden */
    export const addBegin: string;
    /** @hidden */
    export const addComplete: string;
    /** @hidden */
    export const saveComplete: string;
    /** @hidden */
    export const deleteBegin: string;
    /** @hidden */
    export const deleteComplete: string;
    /** @hidden */
    export const preventBatch: string;
    /** @hidden */
    export const dialogDestroy: string;
    /** @hidden */
    export const crudAction: string;
    /** @hidden */
    export const addDeleteAction: string;
    /** @hidden */
    export const destroyForm: string;
    /** @hidden */
    export const doubleTap: string;
    /** @hidden */
    export const beforeExcelExport: string;
    /** @hidden */
    export const excelExportComplete: string;
    /** @hidden */
    export const excelQueryCellInfo: string;
    /** @hidden */
    export const beforePdfExport: string;
    /** @hidden */
    export const pdfExportComplete: string;
    /** @hidden */
    export const pdfQueryCellInfo: string;
    /** @hidden */
    export const accessPredicate: string;
    /** @hidden */
    export const contextMenuClick: string;
    /** @hidden */
    export const freezeRender: string;
    /** @hidden */
    export const freezeRefresh: string;
    /** @hidden */
    export const contextMenuOpen: string;
    /** @hidden */
    export const columnMenuClick: string;
    /** @hidden */
    export const columnMenuOpen: string;
    /** @hidden */
    export const filterOpen: string;
    /** @hidden */
    export const filterDialogCreated: string;
    /** @hidden */
    export const filterMenuClose: string;
    /** @hidden */
    export const initForeignKeyColumn: string;
    /** @hidden */
    export const getForeignKeyData: string;
    /** @hidden */
    export const generateQuery: string;
    /** @hidden */
    export const showEmptyGrid: string;
    /** @hidden */
    export const foreignKeyData: string;
    /** @hidden */
    export const dataStateChange: string;
    /** @hidden */
    export const dataSourceChanged: string;
    /** @hidden */
    export const rtlUpdated: string;
    
    /**
     * Defines Actions of the Grid. They are
     * * paging
     * * refresh
     * * sorting
     * * filtering
     * * selection
     * * rowdraganddrop
     * * reorder
     * * grouping
     * * ungrouping
     */
    export type Action = 'paging' | 'refresh' | 'sorting' | 'selection' | 'filtering' | 'searching' | 'rowdraganddrop' | 'reorder' | 'grouping' | 'ungrouping' | 'batchsave' | 'virtualscroll' | 'print';
    /**
     * Defines directions of Sorting. They are
     * * Ascending
     * * Descending
     */
    export type SortDirection = 'Ascending' | 'Descending';
    /**
     * Defines types of Selection. They are
     * * Single - Allows user to select a row or cell.
     * * Multiple - Allows user to select multiple rows or cells.
     */
    export type SelectionType = 'Single' | 'Multiple';
    /**
     * Defines alignments of text, they are
     * * Left
     * * Right
     * * Center
     * * Justify
     */
    export type TextAlign = 'Left' | 'Right' | 'Center' | 'Justify';
    /**
     * Defines types of Cell
     * @hidden
     */
    export enum CellType {
        /**  Defines CellType as Data */
        Data = 0,
        /**  Defines CellType as Header */
        Header = 1,
        /**  Defines CellType as Summary */
        Summary = 2,
        /**  Defines CellType as GroupSummary */
        GroupSummary = 3,
        /**  Defines CellType as CaptionSummary */
        CaptionSummary = 4,
        /**  Defines CellType as Filter */
        Filter = 5,
        /**  Defines CellType as Indent */
        Indent = 6,
        /**  Defines CellType as GroupCaption */
        GroupCaption = 7,
        /**  Defines CellType as GroupCaptionEmpty */
        GroupCaptionEmpty = 8,
        /**  Defines CellType as Expand */
        Expand = 9,
        /**  Defines CellType as HeaderIndent */
        HeaderIndent = 10,
        /**  Defines CellType as StackedHeader */
        StackedHeader = 11,
        /**  Defines CellType as DetailHeader */
        DetailHeader = 12,
        /**  Defines CellType as DetailExpand */
        DetailExpand = 13,
        /**  Defines CellType as CommandColumn */
        CommandColumn = 14,
    }
    /**
     * Defines modes of GridLine, They are
     * * Both - Displays both the horizontal and vertical grid lines.
     * * None - No grid lines are displayed.
     * * Horizontal - Displays the horizontal grid lines only.
     * * Vertical - Displays the vertical grid lines only.
     * * Default - Displays grid lines based on the theme.
     */
    export type GridLine = 'Both' | 'None' | 'Horizontal' | 'Vertical' | 'Default';
    /**
     * Defines types of Render
     * @hidden
     */
    export enum RenderType {
        /**  Defines RenderType as Header */
        Header = 0,
        /**  Defines RenderType as Content */
        Content = 1,
        /**  Defines RenderType as Summary */
        Summary = 2,
    }
    /**
     * Defines modes of Selection, They are
     * * Row
     * * Cell
     * * Both
     */
    export type SelectionMode = 'Cell' | 'Row' | 'Both';
    /**
     * Print mode options are
     * * AllPages - Print all pages records of the Grid.
     * * CurrentPage - Print current page records of the Grid.
     */
    export type PrintMode = 'AllPages' | 'CurrentPage';
    /**
     * Defines types of Filter
     * * Menu - Specifies the filter type as menu.
     * * Excel - Specifies the filter type as excel.
     * * FilterBar - Specifies the filter type as filter bar.
     * * CheckBox - Specifies the filter type as check box.
     */
    export type FilterType = 'FilterBar' | 'Excel' | 'Menu' | 'CheckBox';
    /**
     * Filter bar mode options are
     * * OnEnter - Initiate filter operation after Enter key is pressed.
     * * Immediate -  Initiate filter operation after certain time interval. By default time interval is 1500 ms.
     */
    export type FilterBarMode = 'OnEnter' | 'Immediate';
    /**
     * Defines the aggregate types.
     */
    export type AggregateType = 'Sum' | 'Average' | 'Max' | 'Min' | 'Count' | 'TrueCount' | 'FalseCount' | 'Custom';
    /**
     * Defines the wrap mode.
     * * Both -  Wraps both header and content.
     * * Header - Wraps header alone.
     * * Content - Wraps content alone.
     */
    export type WrapMode = 'Both' | 'Header' | 'Content';
    /**
     * Defines Multiple Export Type.
     */
    export type MultipleExportType = 'AppendToSheet' | 'NewSheet';
    /**
     * Defines Predefined toolbar items.
     * @hidden
     */
    export type ToolbarItems = 'Add' | 'Delete' | 'Update' | 'Cancel' | 'Edit' | 'Search' | 'ColumnChooser' | 'Print' | 'PdfExport' | 'ExcelExport' | 'CsvExport' | 'WordExport';
    /**
     * Defines the cell content's overflow mode. The available modes are
     * * `Clip` -  Truncates the cell content when it overflows its area.
     * * `Ellipsis` -  Displays ellipsis when the cell content overflows its area.
     * * `EllipsisWithTooltip` - Displays ellipsis when the cell content overflows its area
     * also it will display tooltip while hover on ellipsis applied cell.
     */
    export type ClipMode = 'Clip' | 'Ellipsis' | 'EllipsisWithTooltip';
    /**
     * Defines the Command Buttons type.
     * * Edit -  Edit the current record.
     * * Delete - Delete the current record.
     * * Save - Save the current edited record.
     * * Cancel - Cancel the edited state.
     */
    export type CommandButtonType = 'Edit' | 'Delete' | 'Save' | 'Cancel';
    /**
     * Defines the default items of context menu.
     */
    export type ContextMenuItem = 'AutoFitAll' | 'AutoFit' | 'Group' | 'Ungroup' | 'Edit' | 'Delete' | 'Save' | 'Cancel' | 'Copy' | 'PdfExport' | 'ExcelExport' | 'CsvExport' | 'SortAscending' | 'SortDescending' | 'FirstPage' | 'PrevPage' | 'LastPage' | 'NextPage';
    /**
     * Defines the default items of Column menu.
     */
    export type ColumnMenuItem = 'AutoFitAll' | 'AutoFit' | 'Group' | 'Ungroup' | 'SortAscending' | 'SortDescending' | 'ColumnChooser' | 'Filter';
    /**
     * Defines Predefined toolbar items.
     * @hidden
     */
    export enum ToolbarItem {
        Add = 0,
        Edit = 1,
        Update = 2,
        Delete = 3,
        Cancel = 4,
        Print = 5,
        Search = 6,
        ColumnChooser = 7,
        PdfExport = 8,
        ExcelExport = 9,
        CsvExport = 10,
        WordExport = 11,
    }
    export type PdfPageSize = 'Letter' | 'Note' | 'Legal' | 'A0' | 'A1' | 'A2' | 'A3' | 'A4' | 'A5' | 'A6' | 'A7' | 'A8' | 'A9' | 'B0' | 'B1' | 'B2' | 'B3' | 'B4' | 'B5' | 'Archa' | 'Archb' | 'Archc' | 'Archd' | 'Arche' | 'Flsa' | 'HalfLetter' | 'Letter11x17' | 'Ledger';
    export type PageOrientation = 'Landscape' | 'Portrait';
    export type ContentType = 'Image' | 'Line' | 'PageNumber' | 'Text';
    export type PdfPageNumberType = 'LowerLatin' | 'LowerRoman' | 'UpperLatin' | 'UpperRoman' | 'Numeric' | 'Arabic';
    export type PdfDashStyle = 'Solid' | 'Dash' | 'Dot' | 'DashDot' | 'DashDotDot';
    /**
     * Defines PDF horizontal alignment.
     */
    export type PdfHAlign = 'Left' | 'Right' | 'Center' | 'Justify';
    /**
     * Defines PDF vertical alignment.
     */
    export type PdfVAlign = 'Top' | 'Bottom' | 'Middle';
    /**
     * Defines Export Type.
     */
    export type ExportType = 'CurrentPage' | 'AllPages';
    /**
     * Defines Excel horizontal alignment.
     */
    export type ExcelHAlign = 'Left' | 'Right' | 'Center' | 'Fill';
    /**
     * Defines Excel vertical alignment.
     */
    export type ExcelVAlign = 'Top' | 'Bottom' | 'Center' | 'Justify';
    /**
     * Defines border line style.
     */
    export type BorderLineStyle = 'Thin' | 'Thick';
    export type CheckState = 'Check' | 'Uncheck' | 'Intermediate' | 'None';
    /**
     * Defines mode of cell selection.
     * * Ascending
     * * Descending
     */
    export type CellSelectionMode = 'Flow' | 'Box';
    /**
     * Defines modes of editing.
     * * Ascending
     * * Descending
     */
    export type EditMode = 'Normal' | 'Dialog' | 'Batch';
    
    /**
     * Interface for a class SortDescriptor
     */
    export interface SortDescriptorModel {
    
        /**
         * Defines the field name of sort column. 
         * @default ''
         */
        field?: string;
    
        /**
         * Defines the direction of sort column. 
         * @default ''
         */
        direction?: SortDirection;
    
    }
    
    /**
     * Interface for a class SortSettings
     */
    export interface SortSettingsModel {
    
        /**
         * Specifies the columns to sort at initial rendering of Grid.
         * Also user can get current sorted columns. 
         * @default []
         */
        columns?: SortDescriptorModel[];
    
        /**
         * If `allowUnsort` set to false the user can not get the grid in unsorted state by clicking the sorted column header.
         * @default true
         */
        allowUnsort?: boolean;
    
    }
    
    /**
     * Interface for a class Predicate
     */
    export interface PredicateModel {
    
        /**
         * Defines the field name of the filter column.  
         * @default ''
         */
        field?: string;
    
        /**
         * Defines the operator to filter records. The available operators and its supported data types are:
         * <table> 
         * <tr> 
         * <td colspan=1 rowspan=1> 
         * Operator<br/></td><td colspan=1 rowspan=1> 
         * Description<br/></td><td colspan=1 rowspan=1> 
         * Supported Types<br/></td></tr> 
         * <tr> 
         * <td colspan=1 rowspan=1> 
         * startswith<br/></td><td colspan=1 rowspan=1> 
         * Checks whether the value begins with the specified value.<br/></td><td colspan=1 rowspan=1> 
         * String<br/></td></tr> 
         * <tr> 
         * <td colspan=1 rowspan=1> 
         * endswith<br/></td><td colspan=1 rowspan=1> 
         * Checks whether the value ends with the specified value.<br/><br/></td><td colspan=1 rowspan=1> 
         * <br/>String<br/></td></tr> 
         * <tr> 
         * <td colspan=1 rowspan=1> 
         * contains<br/></td><td colspan=1 rowspan=1> 
         * Checks whether the value contains the specified value.<br/><br/></td><td colspan=1 rowspan=1> 
         * <br/>String<br/></td></tr> 
         * <tr> 
         * <td colspan=1 rowspan=1> 
         * equal<br/></td><td colspan=1 rowspan=1> 
         * Checks whether the value is equal to the specified value.<br/><br/></td><td colspan=1 rowspan=1> 
         * <br/>String | Number | Boolean | Date<br/></td></tr> 
         * <tr> 
         * <td colspan=1 rowspan=1> 
         * notequal<br/></td><td colspan=1 rowspan=1> 
         * Checks for values that are not equal to the specified value.<br/><br/></td><td colspan=1 rowspan=1> 
         * <br/>String | Number | Boolean | Date<br/></td></tr> 
         * <tr> 
         * <td colspan=1 rowspan=1> 
         * greaterthan<br/></td><td colspan=1 rowspan=1> 
         * Checks whether the value is greater than the specified value.<br/><br/></td><td colspan=1 rowspan=1> 
         * Number | Date<br/></td></tr> 
         * <tr> 
         * <td colspan=1 rowspan=1> 
         * greaterthanorequal<br/></td><td colspan=1 rowspan=1> 
         * Checks whether the value is greater than or equal to the specified value.<br/><br/></td><td colspan=1 rowspan=1> 
         * <br/>Number | Date<br/></td></tr> 
         * <tr> 
         * <td colspan=1 rowspan=1> 
         * lessthan<br/></td><td colspan=1 rowspan=1> 
         * Checks whether the value is less than the specified value.<br/><br/></td><td colspan=1 rowspan=1> 
         * <br/>Number | Date<br/></td></tr> 
         * <tr> 
         * <td colspan=1 rowspan=1> 
         * lessthanorequal<br/></td><td colspan=1 rowspan=1> 
         * Checks whether the value is less than or equal to the specified value.<br/><br/></td><td colspan=1 rowspan=1> 
         * <br/>Number | Date<br/></td></tr> 
         * </table> 
         * @default null
         */
        operator?: string;
    
        /**
         * Defines the value used to filter records. 
         * @default ''
         */
        value?: string | number | Date | boolean;
    
        /**
         * If match case set to true, then filter records with exact match or else  
         * filter records with case insensitive(uppercase and lowercase letters treated as same).  
         * @default null
         */
        matchCase?: boolean;
    
        /**
         * If ignoreAccent is set to true, then filter ignores the diacritic characters or accents while filtering.
         * @default false
         */
        ignoreAccent?: boolean;
    
        /**
         * Defines the relationship between one filter query and another by using AND or OR predicate.   
         * @default null
         */
        predicate?: string;
    
        /**
         * @hidden 
         * Defines the actual filter value for the filter column.  
         */
        actualFilterValue?: Object;
    
        /**
         * @hidden 
         * Defines the actual filter operator for the filter column.  
         */
        actualOperator?: Object;
    
        /**
         * @hidden 
         * Defines the type of the filter column.  
         */
        type?: string;
    
        /**
         * @hidden 
         * Defines the predicate of filter column.  
         */
        ejpredicate?: Object;
    
    }
    
    /**
     * Interface for a class FilterSettings
     */
    export interface FilterSettingsModel {
    
        /**
         * Specifies the columns to be filtered at initial rendering of the Grid. You can also get the columns that were currently filtered.
         * @default []
         */
        columns?: PredicateModel[];
    
        /**
         * Defines options for filtering type. The available options are 
         * * `Menu` - Specifies the filter type as menu. 
         * * `CheckBox` - Specifies the filter type as checkbox.      
         * * `FilterBar` - Specifies the filter type as filterbar.  
         * * `Excel` - Specifies the filter type as checkbox.      
         * @default FilterBar 
         */
        type?: FilterType;
    
        /**
         * Defines the filter bar modes. The available options are,
         * * `OnEnter`: Initiates filter operation after Enter key is pressed. 
         * * `Immediate`: Initiates filter operation after a certain time interval. By default, time interval is 1500 ms. 
         * @default OnEnter
         */
        mode?: FilterBarMode;
    
        /**
         * Shows or hides the filtered status message on the pager.  
         * @default true
         */
        showFilterBarStatus?: boolean;
    
        /**
         * Defines the time delay (in milliseconds) in filtering records when the `Immediate` mode of filter bar is set. 
         * @default 1500 
         */
        immediateModeDelay?: number;
    
        /**
         * The `operators` is used to override the default operators in filter menu. This should be defined by type wise
         * (string, number, date and boolean). Based on the column type, this customize operator list will render in filter menu.
         * 
         * > Check the [`Filter Menu Operator`](./how-to.html#customizing-filter-menu-operators-list) customization.
         * @default null
         */
        operators?: ICustomOptr;
    
        /**
         * If ignoreAccent set to true, then filter ignores the diacritic characters or accents while filtering.
         * 
         * > Check the [`Diacritics`](./filtering.html/#diacritics) filtering.
         * @default false
         */
        ignoreAccent?: boolean;
    
    }
    
    /**
     * Interface for a class SelectionSettings
     */
    export interface SelectionSettingsModel {
    
        /**
         * Grid supports row, cell, and both (row and cell) selection mode. 
         * @default Row
         */
        mode?: SelectionMode;
    
        /**
         * The cell selection modes are flow and box. It requires the selection 
         * [`mode`](./api-selectionSettings.html#mode-selectionmode) to be either cell or both.
         * * `Flow`: Selects the range of cells between start index and end index that also includes the other cells of the selected rows.
         * * `Box`: Selects the range of cells within the start and end column indexes that includes in between cells of rows within the range.
         * @default Flow
         */
        cellSelectionMode?: CellSelectionMode;
    
        /**
         * Defines options for selection type. They are 
         * * `Single`: Allows selection of only a row or a cell. 
         * * `Multiple`: Allows selection of multiple rows or cells. 
         * @default Single 
         */
        type?: SelectionType;
    
        /**
         * If 'checkboxOnly' set to true, then the Grid selection is allowed only through checkbox.
         * 
         * > To enable checkboxOnly selection, should specify the column type as`checkbox`.
         * @default false 
         */
        checkboxOnly?: boolean;
    
        /**
         * If 'persistSelection' set to true, then the Grid selection is persisted on all operations.
         * For persisting selection in the Grid, any one of the column should be enabled as a primary key.
         * @default false 
         */
        persistSelection?: boolean;
    
    }
    
    /**
     * Interface for a class SearchSettings
     */
    export interface SearchSettingsModel {
    
        /**
         * Specifies the collection of fields included in search operation. By default, bounded columns of the Grid are included.  
         * @default []
         */
        fields?: string[];
    
        /**
         * Specifies the key value to search Grid records at initial rendering. 
         * You can also get the current search key.
         * @default ''
         */
        key?: string;
    
        /**
         * Defines the operator to search records. The available operators are:
         * <table> 
         * <tr> 
         * <td colspan=1 rowspan=1> 
         * Operator<br/></td><td colspan=1 rowspan=1> 
         * Description<br/></td></tr> 
         * <tr> 
         * <td colspan=1 rowspan=1> 
         * startswith<br/></td><td colspan=1 rowspan=1> 
         * Checks whether the string begins with the specified string.<br/></td></tr> 
         * <tr> 
         * <td colspan=1 rowspan=1> 
         * endswith<br/></td><td colspan=1 rowspan=1> 
         * Checks whether the string ends with the specified string.<br/></td></tr> 
         * <tr> 
         * <td colspan=1 rowspan=1> 
         * contains<br/></td><td colspan=1 rowspan=1> 
         * Checks whether the string contains the specified string. <br/></td></tr> 
         * <tr> 
         * <td colspan=1 rowspan=1> 
         * equal<br/></td><td colspan=1 rowspan=1> 
         * Checks whether the string is equal to the specified string.<br/></td></tr> 
         * <tr> 
         * <td colspan=1 rowspan=1> 
         * notequal<br/></td><td colspan=1 rowspan=1> 
         * Checks for strings not equal to the specified string. <br/></td></tr> 
         * </table> 
         * @default contains 
         */
        operator?: string;
    
        /**
         * If `ignoreCase` is set to false, searches records that match exactly, else  
         * searches records that are case insensitive(uppercase and lowercase letters treated the same).  
         * @default true 
         */
        ignoreCase?: boolean;
    
    }
    
    /**
     * Interface for a class RowDropSettings
     */
    export interface RowDropSettingsModel {
    
        /**
         * Defines the ID of droppable component on which row drop should occur.   
         * @default null
         */
        targetID?: string;
    
    }
    
    /**
     * Interface for a class TextWrapSettings
     */
    export interface TextWrapSettingsModel {
    
        /**
         * Defines the `wrapMode` of the Grid. The available modes are: 
         * * `Both`: Wraps both the header and content. 
         * * `Content`: Wraps the header alone.
         * * `Header`: Wraps the content alone. 
         * @default Both
         */
        wrapMode?: WrapMode;
    
    }
    
    /**
     * Interface for a class GroupSettings
     */
    export interface GroupSettingsModel {
    
        /**
         * If `showDropArea` is set to true, the group drop area element will be visible at the top of the Grid.     
         * @default true 
         */
        showDropArea?: boolean;
    
        /**
         * If `showToggleButton` set to true, then the toggle button will be showed in the column headers which can be used to group
         * or ungroup columns by clicking them.
         * @default false   
         */
        showToggleButton?: boolean;
    
        /**
         * If `showGroupedColumn` is set to false, it hides the grouped column after grouping.  
         * @default false  
         */
        showGroupedColumn?: boolean;
    
        /**
         * If `showUngroupButton` set to false, then ungroup button is hidden in dropped element.  
         * It can be used to ungroup the grouped column when click on ungroup button. 
         * @default true 
         */
        showUngroupButton?: boolean;
    
        /**
         * If `disablePageWiseAggregates` set to true, then the group aggregate value will
         * be calculated from the whole data instead of paged data and two requests will be made for each page
         * when Grid bound with remote service.
         * @default false
         */
        disablePageWiseAggregates?: boolean;
    
        /**
         * Specifies the column names to group at initial rendering of the Grid.  
         * You can also get the currently grouped columns.   
         * @default []  
         */
        columns?: string[];
    
        /**
         * The Caption Template allows user to display the string or HTML element in group caption.
         * > It accepts either the [template string](http://ej2.syncfusion.com/documentation/base/template-engine.html) or the HTML element ID.
         * @default ''
         */
        captionTemplate?: string;
    
    }
    
    /**
     * Interface for a class EditSettings
     */
    export interface EditSettingsModel {
    
        /**
         * If `allowAdding` is set to true, new records can be added to the Grid.  
         * @default false 
         */
        allowAdding?: boolean;
    
        /**
         * If `allowEditing` is set to true, values can be updated in the existing record.  
         * @default false 
         */
        allowEditing?: boolean;
    
        /**
         * If `allowDeleting` is set to true, existing record can be deleted from the Grid.    
         * @default false 
         */
        allowDeleting?: boolean;
    
        /**
         * Defines the mode to edit. The available editing modes are:
         * * Normal
         * * Dialog
         * * Batch
         * @default Normal 
         */
        mode?: EditMode;
    
        /**
         * If `allowEditOnDblClick` is set to false, Grid will not allow editing of a record on double click. 
         * @default true 
         */
        allowEditOnDblClick?: boolean;
    
        /**
         * if `showConfirmDialog` is set to false, confirm dialog does not show when batch changes are saved or discarded.
         * @default true 
         */
        showConfirmDialog?: boolean;
    
        /**
         * If `showDeleteConfirmDialog` is set to true, confirm dialog will show delete action. You can also cancel delete command.
         * @default false 
         */
        showDeleteConfirmDialog?: boolean;
    
    }
    
    /**
     * Interface for a class Grid
     */
    export interface GridModel extends ej.base.ComponentModel{
    
        /**
         * Defines the schema of dataSource. 
         * If the `columns` declaration is empty or undefined then the `columns` are automatically generated from data source.     
         * @default []   
         */
        columns?: Column[] | string[] | ColumnModel[];
    
        /**
         * If `enableAltRow` is set to true, the grid will render with `e-altrow` CSS class to the alternative tr elements.    
         * > Check the [`AltRow`](./row.html#styling-alternate-rows) to customize the styles of alternative rows.
         * @default true 
         */
        enableAltRow?: boolean;
    
        /**
         * If `enableHover` is set to true, the row hover is enabled in the Grid.
         * @default true     
         */
        enableHover?: boolean;
    
        /**
         * Enables or disables the key board interaction of Grid.          
         * @hidden 
         * @default true     
         */
        allowKeyboard?: boolean;
    
        /**
         * If `allowTextWrap` set to true,  
         * then text content will wrap to the next line when its text content exceeds the width of the Column Cells. 
         * @default false     
         */
        allowTextWrap?: boolean;
    
        /**
         * Configures the text wrap in the Grid.  
         * @default {wrapMode:"Both"}     
         */
        textWrapSettings?: TextWrapSettingsModel;
    
        /**
         * If `allowPaging` is set to true, the pager renders at the footer of the Grid. It is used to handle page navigation in the Grid.
         * 
         * > Check the [`Paging`](./paging.html) to configure the grid pager.
         * @default false     
         */
        allowPaging?: boolean;
    
        /**
         * Configures the pager in the Grid.  
         * @default {currentPage: 1, pageSize: 12, pageCount: 8, enableQueryString: false, pageSizes: false, template: null}     
         */
        pageSettings?: PageSettingsModel;
    
        /**
         * If `enableVirtualization` set to true, then the Grid will render only the rows visible within the view-port
         * and load subsequent rows on vertical scrolling. This helps to load large dataset in Grid.
         * @default false
         */
        enableVirtualization?: boolean;
    
        /**
         * If `enableColumnVirtualization` set to true, then the Grid will render only the columns visible within the view-port
         * and load subsequent columns on horizontal scrolling. This helps to load large dataset of columns in Grid.
         * @default false
         */
        enableColumnVirtualization?: boolean;
    
        /**
         * Configures the search behavior in the Grid. 
         * @default { ignoreCase: true, fields: [], operator: 'contains', key: '' }    
         */
        searchSettings?: SearchSettingsModel;
    
        /**
         * If `allowSorting` is set to true, it allows sorting of grid records when column header is clicked.  
         * 
         * > Check the [`Sorting`](./sorting.html) to customize its default behavior.
         * @default false    
         */
        allowSorting?: boolean;
    
        /**
         * If `allowMultiSorting` set to true, then it will allow the user to sort multiple column in the grid.
         * > `allowSorting` should be true.
         * @default false
         */
        allowMultiSorting?: boolean;
    
        /**
         * If `allowExcelExport` set to true, then it will allow the user to export grid to Excel file.
         * 
         * > Check the [`ExcelExport`](./excel-exporting.html) to configure exporting document.
         * @default false    
         */
        allowExcelExport?: boolean;
    
        /**
         * If `allowPdfExport` set to true, then it will allow the user to export grid to Pdf file.
         * 
         * > Check the [`Pdfexport`](./pdf-exporting.html) to configure the exporting document.
         * @default false    
         */
        allowPdfExport?: boolean;
    
        /**
         * Configures the sort settings.  
         * @default {columns:[]}    
         */
        sortSettings?: SortSettingsModel;
    
        /**
         * If `allowSelection` is set to true, it allows selection of (highlight row) Grid records by clicking it.  
         * @default true        
         */
        allowSelection?: boolean;
    
        /**
         * The `selectedRowIndex` allows you to select a row at initial rendering. 
         * You can also get the currently selected row index.
         * @default -1        
         */
        selectedRowIndex?: number;
    
        /**
         * Configures the selection settings.  
         * @default {mode: 'Row', cellSelectionMode: 'Flow', type: 'Single'}    
         */
        selectionSettings?: SelectionSettingsModel;
    
        /**
         * If `allowFiltering` set to true the filter bar will be displayed. 
         * If set to false the filter bar will not be displayed. 
         * Filter bar allows the user to filter grid records with required criteria.   
         * 
         * > Check the [`Filtering`](./filtering.html) to customize its default behavior.     
         * @default false    
         */
        allowFiltering?: boolean;
    
        /**
         * If `allowReordering` is set to true, Grid columns can be reordered. 
         * Reordering can be done by drag and drop of a particular column from one index to another index.  
         * > If Grid is rendered with stacked headers, reordering is allowed only at the same level as the column headers.
         * @default false    
         */
        allowReordering?: boolean;
    
        /**
         * If `allowResizing` is set to true, Grid columns can be resized.      
         * @default false    
         */
        allowResizing?: boolean;
    
        /**
         * If `allowRowDragAndDrop` is set to true, you can drag and drop grid rows at another grid.    
         * @default false    
         */
        allowRowDragAndDrop?: boolean;
    
        /**
         * Configures the row drop settings.  
         * @default {targetID: ''}   
         */
        rowDropSettings?: RowDropSettingsModel;
    
        /**
         * Configures the filter settings of the Grid.  
         * @default {columns: [], type: 'FilterBar', mode: 'Immediate', showFilterBarStatus: true, immediateModeDelay: 1500 , operators: {}}    
         */
        filterSettings?: FilterSettingsModel;
    
        /**
         * If `allowGrouping` set to true, then it will allow the user to dynamically group or ungroup columns.  
         * Grouping can be done by drag and drop columns from column header to group drop area. 
         * 
         * > Check the [`Grouping`](./grouping.html) to customize its default behavior.
         * @default false    
         */
        allowGrouping?: boolean;
    
        /**
         * If `showColumnMenu` set to true, then it will enable the column menu options in each columns.
         * 
         * > Check the [`Column menu`](./columns.html#column-menu) for its configuration.
         * @default false    
         */
        showColumnMenu?: boolean;
    
        /**
         * Configures the group settings. 
         * @default {showDropArea: true, showToggleButton: false, showGroupedColumn: false, showUngroupButton: true, columns: []}    
         */
        groupSettings?: GroupSettingsModel;
    
        /**
         * Configures the edit settings. 
         * @default { allowAdding: false, allowEditing: false, allowDeleting: false, mode:'Normal',
         * allowEditOnDblClick: true, showConfirmDialog: true, showDeleteConfirmDialog: false }    
         */
        editSettings?: EditSettingsModel;
    
        /**
         * Configures the Grid aggregate rows.
         * > Check the [`Aggregates`](./aggregates.html) for its configuration.
         * @default []
         */
        aggregates?: AggregateRowModel[];
    
        /**
         * If `showColumnChooser` is set to true, it allows you to dynamically show or hide columns.  
         * 
         * > Check the [`ColumnChooser`](./columns.html#column-chooser) for its configuration.
         * @default false    
         */
        showColumnChooser?: boolean;
    
        /**
         * Defines the scrollable height of the grid content.    
         * @default auto    
         */
        height?: string | number;
    
        /**
         * Defines the Grid width.    
         * @default auto    
         */
        width?: string | number;
    
        /**
         * Defines the mode of grid lines. The available modes are, 
         * * `Both`: Displays both horizontal and vertical grid lines. 
         * * `None`: No grid lines are displayed.
         * * `Horizontal`: Displays the horizontal grid lines only. 
         * * `Vertical`: Displays the vertical grid lines only.
         * * `Default`: Displays grid lines based on the theme.
         * @default Default
         */
        gridLines?: GridLine;
    
        /**
         * The row template that renders customized rows from the given template. 
         * By default, Grid renders a table row for every data source item.
         * > * It accepts either [template string](../base/template-engine.html) or HTML element ID.   
         * > * The row template must be a table row.  
         * 
         * > Check the [`Row Template`](./row.html) customization.
         */
        rowTemplate?: string;
    
        /**
         * The detail template allows you to show or hide additional information about a particular row.
         *  
         * > It accepts either the [template string](../base/template-engine.html) or the HTML element ID.
         * 
         * {% codeBlock src="grid/detail-template-api/index.ts" %}{% endcodeBlock %}
         */
        detailTemplate?: string;
    
        /**
         * Defines Grid options to render child Grid. 
         * It requires the [`queryString`](./api-grid.html#querystring-string) for parent 
         * and child relationship. 
         * 
         * > Check the [`Child Grid`](./hierarchy-grid.html) for its configuration.
         */
        childGrid?: GridModel;
    
        /**
         * Defines the relationship between parent and child datasource. It acts as the foreign key for parent datasource.       
         */
        queryString?: string;
    
        /**
         * Defines the print modes. The available print modes are   
         * * `AllPages`: Prints all pages of the Grid. 
         * * `CurrentPage`: Prints the current page of the Grid.
         * @default AllPages
         */
        printMode?: PrintMode;
    
        /**
         * It is used to render grid table rows. 
         * If the `dataSource` is an array of JavaScript objects, 
         * then Grid will create instance of [`DataManager`](../data/api-dataManager.html) 
         * from this `dataSource`. 
         * If the `dataSource` is an existing [`DataManager`](../data/api-dataManager.html),
         *  the Grid will not initialize a new one. 
         * 
         * > Check the available [`Adaptors`](../data/adaptors.html) to customize the data operation.
         * @default []    
         */
        dataSource?: Object | ej.data.DataManager | DataResult;
    
        /**
         * Defines the height of Grid rows.
         * @default null
         */
        rowHeight?: number;
    
        /**
         * Defines the external [`Query`](../data/api-query.html) 
         * that will be executed along with data processing.    
         * @default null    
         */
        query?: ej.data.Query;
    
        /**
         * Defines the currencyCode format of the Grid columns
         * @private
         */
        currencyCode?: string;
    
        /**
         * `toolbar` defines the ToolBar items of the Grid. 
         * It contains built-in and custom toolbar items. 
         * If a string value is assigned to the `toolbar` option, it is considered as the template for the whole Grid ToolBar. 
         * If an array value is assigned, it is considered as the list of built-in and custom toolbar items in the Grid's Toolbar. 
         * <br><br>     
         * The available built-in ToolBar items are:
         * * Add: Adds a new record.
         * * Edit: Edits the selected record.
         * * Update: Updates the edited record.
         * * Delete: Deletes the selected record.
         * * Cancel: Cancels the edit state.
         * * Search: Searches records by the given key.
         * * Print: Prints the Grid.
         * * ExcelExport - Export the Grid to Excel(excelExport() method manually to make export.)
         * * PdfExport - Export the Grid to PDF(pdfExport() method manually to make export.)
         * * CsvExport - Export the Grid to CSV(csvExport() method manually to make export.)<br><br>
         * The following code example implements the custom toolbar items.
         * 
         *  > Check the [`Toolbar`](./toolbar.html#custom-toolbar-items) to customize its default items.
         * 
         * {% codeBlock src="grid/toolbar-api/index.ts" %}{% endcodeBlock %}
         * @default null
         */
        toolbar?: ToolbarItems[] | string[] | ej.navigations.ItemModel[] | ToolbarItem[];
    
        /**
         * `contextMenuItems` defines both built-in and custom context menu items.
         * <br><br> 
         * The available built-in items are,  
         * * `AutoFitAll` - Auto fit the size of all columns. 
         * * `AutoFit` - Auto fit the current column.
         * * `Group` - Group by current column. 
         * * `Ungroup` - Ungroup by current column.
         * * `Edit` - Edit the current record.
         * * `Delete` - Delete the current record.
         * * `Save` - Save the edited record.
         * * `Cancel` - Cancel the edited state.
         * * `Copy` - Copy the selected records.
         * * `PdfExport` - Export the grid as Pdf format.
         * * `ExcelExport` - Export the grid as Excel format.
         * * `CsvExport` - Export the grid as CSV format.
         * * `SortAscending` - Sort the current column in ascending order.
         * * `SortDescending` - Sort the current column in descending order.
         * * `FirstPage` - Go to the first page.
         * * `PrevPage` - Go to the previous page.
         * * `LastPage` - Go to the last page.
         * * `NextPage` - Go to the next page.
         * 
         * @default null
         */
        contextMenuItems?: ContextMenuItem[] | ContextMenuItemModel[];
    
        /**
         * `columnMenuItems` defines both built-in and custom column menu items.
         * <br><br> 
         * The available built-in items are,
         * * `AutoFitAll` - Auto fit the size of all columns. 
         * * `AutoFit` - Auto fit the current column.
         * * `Group` - Group by current column. 
         * * `Ungroup` - Ungroup by current column.
         * * `SortAscending` - Sort the current column in ascending order.
         * * `SortDescending` - Sort the current column in descending order.
         * * `Filter` - Filter options will show based on filterSettings property like checkbox filter, excel filter, menu filter.
         * @default null
         */
        columnMenuItems?: ColumnMenuItem[] | ColumnMenuItemModel[];
    
        /**
         * @hidden
         * It used to render toolbar template
         * @default null
         */
        toolbarTemplate?: string;
    
        /**
         * @hidden
         * It used to render pager template
         * @default null
         */
        pagerTemplate?: string;
    
        /**
         * Gets or sets the number of frozen rows.
         * @default 0
         */
        frozenRows?: number;
    
        /**
         * Gets or sets the number of frozen columns.
         * @default 0
         */
        frozenColumns?: number;
    
        /**
         * Triggers when the component is created.
         * @event 
         */
        created?: ej.base.EmitType<Object>;
    
        /**
         * Triggers when the component is destroyed. 
         * @event 
         */
        destroyed?: ej.base.EmitType<Object>;
    
        /**
         * This event allows customization of Grid properties before rendering.
         * @event 
         */
        load?: ej.base.EmitType<Object>;
    
        /**
         * Triggered every time a request is made to access row information, element, or data. 
         * This will be triggered before the row element is appended to the Grid element.
         * @event 
         */
        rowDataBound?: ej.base.EmitType<RowDataBoundEventArgs>;
    
        /**
         * Triggered every time a request is made to access cell information, element, or data.
         * This will be triggered before the cell element is appended to the Grid element.
         * @event 
         */
        queryCellInfo?: ej.base.EmitType<QueryCellInfoEventArgs>;
    
        /**
         * Triggers when Grid actions such as sorting, filtering, paging, grouping etc., starts. 
         * @event
         */
        actionBegin?: ej.base.EmitType<PageEventArgs | GroupEventArgs | FilterEventArgs | SearchEventArgs | SortEventArgs | AddEventArgs | SaveEventArgs | EditEventArgs | DeleteEventArgs>;
    
        /**
         * Triggers when Grid actions such as sorting, filtering, paging, grouping etc. are completed. 
         * @event 
         */
        actionComplete?: ej.base.EmitType<PageEventArgs | GroupEventArgs | FilterEventArgs | SearchEventArgs | SortEventArgs | AddEventArgs | SaveEventArgs | EditEventArgs | DeleteEventArgs>;
    
        /**
         * Triggers when any Grid action failed to achieve the desired results. 
         * @event 
         */
        actionFailure?: ej.base.EmitType<FailureEventArgs>;
    
        /**
         * Triggers when data source is populated in the Grid.
         * @event 
         */
        dataBound?: ej.base.EmitType<Object>;
    
        /**
         * Triggers when record is double clicked.
         * @event 
         */
        recordDoubleClick?: ej.base.EmitType<RecordDoubleClickEventArgs>;
    
        /**
         * Triggers before row selection occurs.
         * @event 
         */
        rowSelecting?: ej.base.EmitType<RowSelectingEventArgs>;
    
        /**
         * Triggers after a row is selected.
         * @event 
         */
        rowSelected?: ej.base.EmitType<RowSelectEventArgs>;
    
        /**
         * Triggers before deselecting the selected row.
         * @event 
         */
        rowDeselecting?: ej.base.EmitType<RowDeselectEventArgs>;
    
        /**
         * Triggers when a selected row is deselected.
         * @event 
         */
        rowDeselected?: ej.base.EmitType<RowDeselectEventArgs>;
    
        /**
         * Triggers before any cell selection occurs.
         * @event 
         */
        cellSelecting?: ej.base.EmitType<CellSelectingEventArgs>;
    
        /**
         * Triggers after a cell is selected.
         * @event 
         */
        cellSelected?: ej.base.EmitType<CellSelectEventArgs>;
    
        /**
         * Triggers before the selected cell is deselecting.
         * @event 
         */
        cellDeselecting?: ej.base.EmitType<CellDeselectEventArgs>;
    
        /**
         * Triggers when a particular selected cell is deselected.
         * @event 
         */
        cellDeselected?: ej.base.EmitType<CellDeselectEventArgs>;
    
        /**
         * Triggers when column header element drag (move) starts. 
         * @event  
         */
        columnDragStart?: ej.base.EmitType<ColumnDragEventArgs>;
    
        /**
         * Triggers when column header element is dragged (moved) continuously. 
         * @event  
         */
        columnDrag?: ej.base.EmitType<ColumnDragEventArgs>;
    
        /**
         * Triggers when a column header element is dropped on the target column. 
         * @event  
         */
        columnDrop?: ej.base.EmitType<ColumnDragEventArgs>;
    
        /**
         * Triggers after print action is completed.  
         * @event 
         */
        printComplete?: ej.base.EmitType<PrintEventArgs>;
    
        /**
         * Triggers before the print action starts.  
         * @event 
         */
        beforePrint?: ej.base.EmitType<PrintEventArgs>;
    
        /**
         * Triggers before exporting each cell to PDF document. You can also customize the PDF cells.
         * @event 
         */
        pdfQueryCellInfo?: ej.base.EmitType<PdfQueryCellInfoEventArgs>;
    
        /**
         * Triggers before exporting each cell to Excel file.
         * You can also customize the Excel cells.
         * @event
         */
        excelQueryCellInfo?: ej.base.EmitType<ExcelQueryCellInfoEventArgs>;
    
        /**
         * Triggers before Grid data is exported to Excel file.
         * @event
         */
        beforeExcelExport?: ej.base.EmitType<Object>;
    
        /**
         * Triggers after Grid data is exported to Excel file.
         * @event
         */
        excelExportComplete?: ej.base.EmitType<ExcelExportCompleteArgs>;
    
        /**
         * Triggers before Grid data is exported to PDF document.
         * @event
         */
        beforePdfExport?: ej.base.EmitType<Object>;
    
        /**
         * Triggers after Grid data is exported to PDF document.
         * @event
         */
        pdfExportComplete?: ej.base.EmitType<PdfExportCompleteArgs>;
    
        /**
         * Triggers after detail row expands.
         * > This event triggers at initial expand.  
         * @event 
         */
        detailDataBound?: ej.base.EmitType<DetailDataBoundEventArgs>;
    
        /**
         * Triggers when row element's drag(move) starts. 
         * @event  
         */
        rowDragStart?: ej.base.EmitType<RowDragEventArgs>;
    
        /**
         * Triggers when row elements are dragged (moved) continuously. 
         * @event  
         */
        rowDrag?: ej.base.EmitType<RowDragEventArgs>;
    
        /**
         * Triggers when row elements are dropped on the target row. 
         * @event  
         */
        rowDrop?: ej.base.EmitType<RowDragEventArgs>;
    
        /**
         * Triggers when toolbar item is clicked.
         * @event
         */
        toolbarClick?: ej.base.EmitType<ej.navigations.ClickEventArgs>;
    
        /**
         * Triggers before the columnChooser open.
         * @event
         */
        beforeOpenColumnChooser?: ej.base.EmitType<ColumnChooserEventArgs>;
    
        /**
         * Triggers when records are added in batch mode.   
         * @event
         */
        batchAdd?: ej.base.EmitType<BatchAddArgs>;
    
        /**
         * Triggers when records are deleted in batch mode.
         * @event
         */
        batchDelete?: ej.base.EmitType<BatchDeleteArgs>;
    
        /**
         * Triggers before records are added in batch mode.
         * @event
         */
        beforeBatchAdd?: ej.base.EmitType<BeforeBatchAddArgs>;
    
        /**
         * Triggers before records are deleted in batch mode.
         * @event
         */
        beforeBatchDelete?: ej.base.EmitType<BeforeBatchDeleteArgs>;
    
        /**
         * Triggers before records are saved in batch mode.
         * @event
         */
        beforeBatchSave?: ej.base.EmitType<BeforeBatchSaveArgs>;
    
        /**
         * Triggers before the record is to be edit.
         * @event
         */
        beginEdit?: ej.base.EmitType<BeginEditArgs>;
    
        /**
         * Triggers when the cell is being edited.
         * @event
         */
        cellEdit?: ej.base.EmitType<CellEditArgs>;
    
        /**
         * Triggers when cell is saved.
         * @event
         */
        cellSave?: ej.base.EmitType<CellSaveArgs>;
    
        /**
         * Triggers when column resize starts.
         * @event
         */
        resizeStart?: ej.base.EmitType<ResizeArgs>;
    
        /**
         * Triggers on column resizing.
         * @event
         */
        resizing?: ej.base.EmitType<ResizeArgs>;
    
        /**
         * Triggers when column resize ends.
         * @event
         */
        resizeStop?: ej.base.EmitType<ResizeArgs>;
    
        /**
         * Triggers before data is bound to Grid.
         * @event
         */
        beforeDataBound?: ej.base.EmitType<BeforeDataBoundArgs>;
    
        /**
         * Triggers before context menu opens.
         * @event
         */
        contextMenuOpen?: ej.base.EmitType<ej.navigations.BeforeOpenCloseMenuEventArgs>;
    
        /**
         * Triggers when click on context menu.
         * @event
         */
        contextMenuClick?: ej.base.EmitType<ej.navigations.MenuEventArgs>;
    
        /**
         * Triggers before column menu opens.
         * @event
         */
        columnMenuOpen?: ej.base.EmitType<ColumnMenuOpenEventArgs>;
    
        /**
         * Triggers when click on column menu.
         * @event
         */
        columnMenuClick?: ej.base.EmitType<ej.navigations.MenuEventArgs>;
    
        /**
         * Triggers when the check box state change in checkbox column.
         * @event
         */
        checkBoxChange?: ej.base.EmitType<CheckBoxChangeEventArgs>;
    
        /**
         * Triggers before Grid copy action.
         * @event
         */
        beforeCopy?: ej.base.EmitType<BeforeCopyEventArgs>;
    
        /**
         * Triggers when the grid actions such as Sorting, Paging, Grouping etc., are done.
         * In this event,the current view data and total record count should be assigned to the `dataSource` based on the action performed.
         * @event
         */
        dataStateChange?: ej.base.EmitType<DataStateChangeEventArgs>;
    
        /**
         * Triggers when the grid data is added, deleted and updated.
         * Invoke the done method from the argument to start render after edit operation.
         * @event
         */
        dataSourceChanged?: ej.base.EmitType<DataSourceChangedEventArgs>;
    
    }
    
    /**
     * Represents the field name and direction of sort column.
     */
    export class SortDescriptor extends ej.base.ChildProperty<SortDescriptor> {
        /**
         * Defines the field name of sort column.
         * @default ''
         */
        field: string;
        /**
         * Defines the direction of sort column.
         * @default ''
         */
        direction: SortDirection;
    }
    /**
     * Configures the sorting behavior of Grid.
     */
    export class SortSettings extends ej.base.ChildProperty<SortSettings> {
        /**
         * Specifies the columns to sort at initial rendering of Grid.
         * Also user can get current sorted columns.
         * @default []
         */
        columns: SortDescriptorModel[];
        /**
         * If `allowUnsort` set to false the user can not get the grid in unsorted state by clicking the sorted column header.
         * @default true
         */
        allowUnsort: boolean;
    }
    /**
     * Represents the predicate for the filter column.
     */
    export class Predicate extends ej.base.ChildProperty<Predicate> {
        /**
         * Defines the field name of the filter column.
         * @default ''
         */
        field: string;
        /**
         * Defines the operator to filter records. The available operators and its supported data types are:
         * <table>
         * <tr>
         * <td colspan=1 rowspan=1>
         * Operator<br/></td><td colspan=1 rowspan=1>
         * Description<br/></td><td colspan=1 rowspan=1>
         * Supported Types<br/></td></tr>
         * <tr>
         * <td colspan=1 rowspan=1>
         * startswith<br/></td><td colspan=1 rowspan=1>
         * Checks whether the value begins with the specified value.<br/></td><td colspan=1 rowspan=1>
         * String<br/></td></tr>
         * <tr>
         * <td colspan=1 rowspan=1>
         * endswith<br/></td><td colspan=1 rowspan=1>
         * Checks whether the value ends with the specified value.<br/><br/></td><td colspan=1 rowspan=1>
         * <br/>String<br/></td></tr>
         * <tr>
         * <td colspan=1 rowspan=1>
         * contains<br/></td><td colspan=1 rowspan=1>
         * Checks whether the value contains the specified value.<br/><br/></td><td colspan=1 rowspan=1>
         * <br/>String<br/></td></tr>
         * <tr>
         * <td colspan=1 rowspan=1>
         * equal<br/></td><td colspan=1 rowspan=1>
         * Checks whether the value is equal to the specified value.<br/><br/></td><td colspan=1 rowspan=1>
         * <br/>String | Number | Boolean | Date<br/></td></tr>
         * <tr>
         * <td colspan=1 rowspan=1>
         * notequal<br/></td><td colspan=1 rowspan=1>
         * Checks for values that are not equal to the specified value.<br/><br/></td><td colspan=1 rowspan=1>
         * <br/>String | Number | Boolean | Date<br/></td></tr>
         * <tr>
         * <td colspan=1 rowspan=1>
         * greaterthan<br/></td><td colspan=1 rowspan=1>
         * Checks whether the value is greater than the specified value.<br/><br/></td><td colspan=1 rowspan=1>
         * Number | Date<br/></td></tr>
         * <tr>
         * <td colspan=1 rowspan=1>
         * greaterthanorequal<br/></td><td colspan=1 rowspan=1>
         * Checks whether the value is greater than or equal to the specified value.<br/><br/></td><td colspan=1 rowspan=1>
         * <br/>Number | Date<br/></td></tr>
         * <tr>
         * <td colspan=1 rowspan=1>
         * lessthan<br/></td><td colspan=1 rowspan=1>
         * Checks whether the value is less than the specified value.<br/><br/></td><td colspan=1 rowspan=1>
         * <br/>Number | Date<br/></td></tr>
         * <tr>
         * <td colspan=1 rowspan=1>
         * lessthanorequal<br/></td><td colspan=1 rowspan=1>
         * Checks whether the value is less than or equal to the specified value.<br/><br/></td><td colspan=1 rowspan=1>
         * <br/>Number | Date<br/></td></tr>
         * </table>
         * @default null
         */
        operator: string;
        /**
         * Defines the value used to filter records.
         * @default ''
         */
        value: string | number | Date | boolean;
        /**
         * If match case set to true, then filter records with exact match or else
         * filter records with case insensitive(uppercase and lowercase letters treated as same).
         * @default null
         */
        matchCase: boolean;
        /**
         * If ignoreAccent is set to true, then filter ignores the diacritic characters or accents while filtering.
         * @default false
         */
        ignoreAccent: boolean;
        /**
         * Defines the relationship between one filter query and another by using AND or OR predicate.
         * @default null
         */
        predicate: string;
        /**
         * @hidden
         * Defines the actual filter value for the filter column.
         */
        actualFilterValue: Object;
        /**
         * @hidden
         * Defines the actual filter operator for the filter column.
         */
        actualOperator: Object;
        /**
         * @hidden
         * Defines the type of the filter column.
         */
        type: string;
        /**
         * @hidden
         * Defines the predicate of filter column.
         */
        ejpredicate: Object;
    }
    /**
     * Configures the filtering behavior of the Grid.
     */
    export class FilterSettings extends ej.base.ChildProperty<FilterSettings> {
        /**
         * Specifies the columns to be filtered at initial rendering of the Grid. You can also get the columns that were currently filtered.
         * @default []
         */
        columns: PredicateModel[];
        /**
         * Defines options for filtering type. The available options are
         * * `Menu` - Specifies the filter type as menu.
         * * `CheckBox` - Specifies the filter type as checkbox.
         * * `FilterBar` - Specifies the filter type as filterbar.
         * * `Excel` - Specifies the filter type as checkbox.
         * @default FilterBar
         */
        type: FilterType;
        /**
         * Defines the filter bar modes. The available options are,
         * * `OnEnter`: Initiates filter operation after Enter key is pressed.
         * * `Immediate`: Initiates filter operation after a certain time interval. By default, time interval is 1500 ms.
         * @default OnEnter
         */
        mode: FilterBarMode;
        /**
         * Shows or hides the filtered status message on the pager.
         * @default true
         */
        showFilterBarStatus: boolean;
        /**
         * Defines the time delay (in milliseconds) in filtering records when the `Immediate` mode of filter bar is set.
         * @default 1500
         */
        immediateModeDelay: number;
        /**
         * The `operators` is used to override the default operators in filter menu. This should be defined by type wise
         * (string, number, date and boolean). Based on the column type, this customize operator list will render in filter menu.
         *
         * > Check the [`Filter Menu Operator`](./how-to.html#customizing-filter-menu-operators-list) customization.
         * @default null
         */
        operators: ICustomOptr;
        /**
         * If ignoreAccent set to true, then filter ignores the diacritic characters or accents while filtering.
         *
         * > Check the [`Diacritics`](./filtering.html/#diacritics) filtering.
         * @default false
         */
        ignoreAccent: boolean;
    }
    /**
     * Configures the selection behavior of the Grid.
     */
    export class SelectionSettings extends ej.base.ChildProperty<SelectionSettings> {
        /**
         * Grid supports row, cell, and both (row and cell) selection mode.
         * @default Row
         */
        mode: SelectionMode;
        /**
         * The cell selection modes are flow and box. It requires the selection
         * [`mode`](./api-selectionSettings.html#mode-selectionmode) to be either cell or both.
         * * `Flow`: Selects the range of cells between start index and end index that also includes the other cells of the selected rows.
         * * `Box`: Selects the range of cells within the start and end column indexes that includes in between cells of rows within the range.
         * @default Flow
         */
        cellSelectionMode: CellSelectionMode;
        /**
         * Defines options for selection type. They are
         * * `Single`: Allows selection of only a row or a cell.
         * * `Multiple`: Allows selection of multiple rows or cells.
         * @default Single
         */
        type: SelectionType;
        /**
         * If 'checkboxOnly' set to true, then the Grid selection is allowed only through checkbox.
         *
         * > To enable checkboxOnly selection, should specify the column type as`checkbox`.
         * @default false
         */
        checkboxOnly: boolean;
        /**
         * If 'persistSelection' set to true, then the Grid selection is persisted on all operations.
         * For persisting selection in the Grid, any one of the column should be enabled as a primary key.
         * @default false
         */
        persistSelection: boolean;
    }
    /**
     * Configures the search behavior of the Grid.
     */
    export class SearchSettings extends ej.base.ChildProperty<SearchSettings> {
        /**
         * Specifies the collection of fields included in search operation. By default, bounded columns of the Grid are included.
         * @default []
         */
        fields: string[];
        /**
         * Specifies the key value to search Grid records at initial rendering.
         * You can also get the current search key.
         * @default ''
         */
        key: string;
        /**
         * Defines the operator to search records. The available operators are:
         * <table>
         * <tr>
         * <td colspan=1 rowspan=1>
         * Operator<br/></td><td colspan=1 rowspan=1>
         * Description<br/></td></tr>
         * <tr>
         * <td colspan=1 rowspan=1>
         * startswith<br/></td><td colspan=1 rowspan=1>
         * Checks whether the string begins with the specified string.<br/></td></tr>
         * <tr>
         * <td colspan=1 rowspan=1>
         * endswith<br/></td><td colspan=1 rowspan=1>
         * Checks whether the string ends with the specified string.<br/></td></tr>
         * <tr>
         * <td colspan=1 rowspan=1>
         * contains<br/></td><td colspan=1 rowspan=1>
         * Checks whether the string contains the specified string. <br/></td></tr>
         * <tr>
         * <td colspan=1 rowspan=1>
         * equal<br/></td><td colspan=1 rowspan=1>
         * Checks whether the string is equal to the specified string.<br/></td></tr>
         * <tr>
         * <td colspan=1 rowspan=1>
         * notequal<br/></td><td colspan=1 rowspan=1>
         * Checks for strings not equal to the specified string. <br/></td></tr>
         * </table>
         * @default contains
         */
        operator: string;
        /**
         * If `ignoreCase` is set to false, searches records that match exactly, else
         * searches records that are case insensitive(uppercase and lowercase letters treated the same).
         * @default true
         */
        ignoreCase: boolean;
    }
    /**
     * Configures the row drop settings of the Grid.
     */
    export class RowDropSettings extends ej.base.ChildProperty<RowDropSettings> {
        /**
         * Defines the ID of droppable component on which row drop should occur.
         * @default null
         */
        targetID: string;
    }
    /**
     * Configures the text wrap settings of the Grid.
     */
    export class TextWrapSettings extends ej.base.ChildProperty<TextWrapSettings> {
        /**
         * Defines the `wrapMode` of the Grid. The available modes are:
         * * `Both`: Wraps both the header and content.
         * * `Content`: Wraps the header alone.
         * * `Header`: Wraps the content alone.
         * @default Both
         */
        wrapMode: WrapMode;
    }
    /**
     * Configures the group behavior of the Grid.
     */
    export class GroupSettings extends ej.base.ChildProperty<GroupSettings> {
        /**
         * If `showDropArea` is set to true, the group drop area element will be visible at the top of the Grid.
         * @default true
         */
        showDropArea: boolean;
        /**
         * If `showToggleButton` set to true, then the toggle button will be showed in the column headers which can be used to group
         * or ungroup columns by clicking them.
         * @default false
         */
        showToggleButton: boolean;
        /**
         * If `showGroupedColumn` is set to false, it hides the grouped column after grouping.
         * @default false
         */
        showGroupedColumn: boolean;
        /**
         * If `showUngroupButton` set to false, then ungroup button is hidden in dropped element.
         * It can be used to ungroup the grouped column when click on ungroup button.
         * @default true
         */
        showUngroupButton: boolean;
        /**
         * If `disablePageWiseAggregates` set to true, then the group aggregate value will
         * be calculated from the whole data instead of paged data and two requests will be made for each page
         * when Grid bound with remote service.
         * @default false
         */
        disablePageWiseAggregates: boolean;
        /**
         * Specifies the column names to group at initial rendering of the Grid.
         * You can also get the currently grouped columns.
         * @default []
         */
        columns: string[];
        /**
         * The Caption Template allows user to display the string or HTML element in group caption.
         * > It accepts either the [template string](http://ej2.syncfusion.com/documentation/base/template-engine.html) or the HTML element ID.
         * @default ''
         */
        captionTemplate: string;
    }
    /**
     * Configures the edit behavior of the Grid.
     */
    export class EditSettings extends ej.base.ChildProperty<EditSettings> {
        /**
         * If `allowAdding` is set to true, new records can be added to the Grid.
         * @default false
         */
        allowAdding: boolean;
        /**
         * If `allowEditing` is set to true, values can be updated in the existing record.
         * @default false
         */
        allowEditing: boolean;
        /**
         * If `allowDeleting` is set to true, existing record can be deleted from the Grid.
         * @default false
         */
        allowDeleting: boolean;
        /**
         * Defines the mode to edit. The available editing modes are:
         * * Normal
         * * Dialog
         * * Batch
         * @default Normal
         */
        mode: EditMode;
        /**
         * If `allowEditOnDblClick` is set to false, Grid will not allow editing of a record on double click.
         * @default true
         */
        allowEditOnDblClick: boolean;
        /**
         * if `showConfirmDialog` is set to false, confirm dialog does not show when batch changes are saved or discarded.
         * @default true
         */
        showConfirmDialog: boolean;
        /**
         * If `showDeleteConfirmDialog` is set to true, confirm dialog will show delete action. You can also cancel delete command.
         * @default false
         */
        showDeleteConfirmDialog: boolean;
    }
    /**
     * Represents the Grid component.
     * ```html
     * <div id="grid"></div>
     * <script>
     *  var gridObj = new Grid({ allowPaging: true });
     *  gridObj.appendTo("#grid");
     * </script>
     * ```
     */
    export class Grid extends ej.base.Component<HTMLElement> implements ej.base.INotifyPropertyChanged {
        private gridPager;
        private isInitial;
        private columnModel;
        private rowTemplateFn;
        private detailTemplateFn;
        private sortedColumns;
        private footerElement;
        private inViewIndexes;
        private mediaCol;
        private getShowHideService;
        private mediaColumn;
        private isMediaQuery;
        private isInitialLoad;
        private dataBoundFunction;
        private freezeRefresh;
        /** @hidden */
        recordsCount: number;
        /**
         * @hidden
         */
        mergeCells: {
            [key: string]: number;
        };
        /**
         * @hidden
         */
        checkAllRows: CheckState;
        /**
         * @hidden
         */
        isCheckBoxSelection: boolean;
        /**
         * @hidden
         */
        isPersistSelection: boolean;
        /**
         * Gets the currently visible records of the Grid.
         */
        currentViewData: Object[];
        /** @hidden */
        parentDetails: ParentDetails;
        /** @hidden */
        currentAction: Action;
        /** @hidden */
        isEdit: boolean;
        /** @hidden */
        filterOperators: IFilterOperator;
        /** @hidden */
        localeObj: ej.base.L10n;
        private defaultLocale;
        private keyConfigs;
        /**
         * @hidden
         */
        renderModule: Render;
        /**
         * @hidden
         */
        headerModule: IRenderer;
        /**
         * @hidden
         */
        contentModule: IRenderer;
        /**
         * @hidden
         */
        valueFormatterService: IValueFormatter;
        /**
         * @hidden
         */
        serviceLocator: ServiceLocator;
        /**
         * @hidden
         */
        ariaService: AriaService;
        /**
         * The `keyboardModule` is used to manipulate keyboard interactions in the Grid.
         */
        keyboardModule: ej.base.KeyboardEvents;
        /**
         * @hidden
         */
        widthService: ColumnWidthService;
        /**
         * The `rowDragAndDropModule` is used to manipulate row reordering in the Grid.
         */
        rowDragAndDropModule: RowDD;
        /**
         * The `pagerModule` is used to manipulate paging in the Grid.
         */
        pagerModule: Page;
        /**
         * The `sortModule` is used to manipulate sorting in the Grid.
         */
        sortModule: Sort;
        /**
         * The `filterModule` is used to manipulate filtering in the Grid.
         */
        filterModule: Filter;
        /**
         * The `selectionModule` is used to manipulate selection behavior in the Grid.
         */
        selectionModule: Selection;
        /**
         * The `showHider` is used to manipulate column's show/hide operation in the Grid.
         */
        showHider: ShowHide;
        /**
         * The `searchModule` is used to manipulate searching in the Grid.
         */
        searchModule: Search;
        /**
         * The `scrollModule` is used to manipulate scrolling in the Grid.
         */
        scrollModule: Scroll;
        /**
         * The `reorderModule` is used to manipulate reordering in the Grid.
         */
        reorderModule: Reorder;
        /**
         * `resizeModule` is used to manipulate resizing in the Grid.
         * @hidden
         */
        resizeModule: Resize;
        /**
         * The `groupModule` is used to manipulate grouping behavior in the Grid.
         */
        groupModule: Group;
        /**
         * The `printModule` is used to handle the printing feature of the Grid.
         */
        printModule: Print;
        /**
         * The `excelExportModule` is used to handle Excel exporting feature in the Grid.
         */
        excelExportModule: ExcelExport;
        /**
         * The `pdfExportModule` is used to handle PDF exporting feature in the Grid.
         */
        pdfExportModule: PdfExport;
        /**
         * `detailRowModule` is used to handle detail rows rendering in the Grid.
         * @hidden
         */
        detailRowModule: DetailRow;
        /**
         * The `toolbarModule` is used to manipulate ToolBar items and its action in the Grid.
         */
        toolbarModule: Toolbar;
        /**
         * The `contextMenuModule` is used to handle context menu items and its action in the Grid.
         */
        contextMenuModule: ContextMenu;
        /**
         * The `columnMenuModule` is used to manipulate column menu items and its action in the Grid.
         */
        columnMenuModule: ColumnMenu;
        /**
         * The `editModule` is used to handle Grid content manipulation.
         */
        editModule: Edit;
        /**
         * `clipboardModule` is used to handle Grid copy action.
         */
        clipboardModule: Clipboard;
        /**
         * `columnchooserModule` is used to dynamically show or hide the Grid columns.
         * @hidden
         */
        columnChooserModule: ColumnChooser;
        private commandColumnModule;
        private focusModule;
        protected needsID: boolean;
        /**
         * Defines the schema of dataSource.
         * If the `columns` declaration is empty or undefined then the `columns` are automatically generated from data source.
         * @default []
         */
        columns: Column[] | string[] | ColumnModel[];
        /**
         * If `enableAltRow` is set to true, the grid will render with `e-altrow` CSS class to the alternative tr elements.
         * > Check the [`AltRow`](./row.html#styling-alternate-rows) to customize the styles of alternative rows.
         * @default true
         */
        enableAltRow: boolean;
        /**
         * If `enableHover` is set to true, the row hover is enabled in the Grid.
         * @default true
         */
        enableHover: boolean;
        /**
         * Enables or disables the key board interaction of Grid.
         * @hidden
         * @default true
         */
        allowKeyboard: boolean;
        /**
         * If `allowTextWrap` set to true,
         * then text content will wrap to the next line when its text content exceeds the width of the Column Cells.
         * @default false
         */
        allowTextWrap: boolean;
        /**
         * Configures the text wrap in the Grid.
         * @default {wrapMode:"Both"}
         */
        textWrapSettings: TextWrapSettingsModel;
        /**
         * If `allowPaging` is set to true, the pager renders at the footer of the Grid. It is used to handle page navigation in the Grid.
         *
         * > Check the [`Paging`](./paging.html) to configure the grid pager.
         * @default false
         */
        allowPaging: boolean;
        /**
         * Configures the pager in the Grid.
         * @default {currentPage: 1, pageSize: 12, pageCount: 8, enableQueryString: false, pageSizes: false, template: null}
         */
        pageSettings: PageSettingsModel;
        /**
         * If `enableVirtualization` set to true, then the Grid will render only the rows visible within the view-port
         * and load subsequent rows on vertical scrolling. This helps to load large dataset in Grid.
         * @default false
         */
        enableVirtualization: boolean;
        /**
         * If `enableColumnVirtualization` set to true, then the Grid will render only the columns visible within the view-port
         * and load subsequent columns on horizontal scrolling. This helps to load large dataset of columns in Grid.
         * @default false
         */
        enableColumnVirtualization: boolean;
        /**
         * Configures the search behavior in the Grid.
         * @default { ignoreCase: true, fields: [], operator: 'contains', key: '' }
         */
        searchSettings: SearchSettingsModel;
        /**
         * If `allowSorting` is set to true, it allows sorting of grid records when column header is clicked.
         *
         * > Check the [`Sorting`](./sorting.html) to customize its default behavior.
         * @default false
         */
        allowSorting: boolean;
        /**
         * If `allowMultiSorting` set to true, then it will allow the user to sort multiple column in the grid.
         * > `allowSorting` should be true.
         * @default false
         */
        allowMultiSorting: boolean;
        /**
         * If `allowExcelExport` set to true, then it will allow the user to export grid to Excel file.
         *
         * > Check the [`ExcelExport`](./excel-exporting.html) to configure exporting document.
         * @default false
         */
        allowExcelExport: boolean;
        /**
         * If `allowPdfExport` set to true, then it will allow the user to export grid to Pdf file.
         *
         * > Check the [`Pdfexport`](./pdf-exporting.html) to configure the exporting document.
         * @default false
         */
        allowPdfExport: boolean;
        /**
         * Configures the sort settings.
         * @default {columns:[]}
         */
        sortSettings: SortSettingsModel;
        /**
         * If `allowSelection` is set to true, it allows selection of (highlight row) Grid records by clicking it.
         * @default true
         */
        allowSelection: boolean;
        /**
         * The `selectedRowIndex` allows you to select a row at initial rendering.
         * You can also get the currently selected row index.
         * @default -1
         */
        selectedRowIndex: number;
        /**
         * Configures the selection settings.
         * @default {mode: 'Row', cellSelectionMode: 'Flow', type: 'Single'}
         */
        selectionSettings: SelectionSettingsModel;
        /**
         * If `allowFiltering` set to true the filter bar will be displayed.
         * If set to false the filter bar will not be displayed.
         * Filter bar allows the user to filter grid records with required criteria.
         *
         * > Check the [`Filtering`](./filtering.html) to customize its default behavior.
         * @default false
         */
        allowFiltering: boolean;
        /**
         * If `allowReordering` is set to true, Grid columns can be reordered.
         * Reordering can be done by drag and drop of a particular column from one index to another index.
         * > If Grid is rendered with stacked headers, reordering is allowed only at the same level as the column headers.
         * @default false
         */
        allowReordering: boolean;
        /**
         * If `allowResizing` is set to true, Grid columns can be resized.
         * @default false
         */
        allowResizing: boolean;
        /**
         * If `allowRowDragAndDrop` is set to true, you can drag and drop grid rows at another grid.
         * @default false
         */
        allowRowDragAndDrop: boolean;
        /**
         * Configures the row drop settings.
         * @default {targetID: ''}
         */
        rowDropSettings: RowDropSettingsModel;
        /**
         * Configures the filter settings of the Grid.
         * @default {columns: [], type: 'FilterBar', mode: 'Immediate', showFilterBarStatus: true, immediateModeDelay: 1500 , operators: {}}
         */
        filterSettings: FilterSettingsModel;
        /**
         * If `allowGrouping` set to true, then it will allow the user to dynamically group or ungroup columns.
         * Grouping can be done by drag and drop columns from column header to group drop area.
         *
         * > Check the [`Grouping`](./grouping.html) to customize its default behavior.
         * @default false
         */
        allowGrouping: boolean;
        /**
         * If `showColumnMenu` set to true, then it will enable the column menu options in each columns.
         *
         * > Check the [`Column menu`](./columns.html#column-menu) for its configuration.
         * @default false
         */
        showColumnMenu: boolean;
        /**
         * Configures the group settings.
         * @default {showDropArea: true, showToggleButton: false, showGroupedColumn: false, showUngroupButton: true, columns: []}
         */
        groupSettings: GroupSettingsModel;
        /**
         * Configures the edit settings.
         * @default { allowAdding: false, allowEditing: false, allowDeleting: false, mode:'Normal',
         * allowEditOnDblClick: true, showConfirmDialog: true, showDeleteConfirmDialog: false }
         */
        editSettings: EditSettingsModel;
        /**
         * Configures the Grid aggregate rows.
         * > Check the [`Aggregates`](./aggregates.html) for its configuration.
         * @default []
         */
        aggregates: AggregateRowModel[];
        /**
         * If `showColumnChooser` is set to true, it allows you to dynamically show or hide columns.
         *
         * > Check the [`ColumnChooser`](./columns.html#column-chooser) for its configuration.
         * @default false
         */
        showColumnChooser: boolean;
        /**
         * Defines the scrollable height of the grid content.
         * @default auto
         */
        height: string | number;
        /**
         * Defines the Grid width.
         * @default auto
         */
        width: string | number;
        /**
         * Defines the mode of grid lines. The available modes are,
         * * `Both`: Displays both horizontal and vertical grid lines.
         * * `None`: No grid lines are displayed.
         * * `Horizontal`: Displays the horizontal grid lines only.
         * * `Vertical`: Displays the vertical grid lines only.
         * * `Default`: Displays grid lines based on the theme.
         * @default Default
         */
        gridLines: GridLine;
        /**
         * The row template that renders customized rows from the given template.
         * By default, Grid renders a table row for every data source item.
         * > * It accepts either [template string](../base/template-engine.html) or HTML element ID.
         * > * The row template must be a table row.
         *
         * > Check the [`Row Template`](./row.html) customization.
         */
        rowTemplate: string;
        /**
         * The detail template allows you to show or hide additional information about a particular row.
         *
         * > It accepts either the [template string](../base/template-engine.html) or the HTML element ID.
         *
         * {% codeBlock src="grid/detail-template-api/index.ts" %}{% endcodeBlock %}
         */
        detailTemplate: string;
        /**
         * Defines Grid options to render child Grid.
         * It requires the [`queryString`](./api-grid.html#querystring-string) for parent
         * and child relationship.
         *
         * > Check the [`Child Grid`](./hierarchy-grid.html) for its configuration.
         */
        childGrid: GridModel;
        /**
         * Defines the relationship between parent and child datasource. It acts as the foreign key for parent datasource.
         */
        queryString: string;
        /**
         * Defines the print modes. The available print modes are
         * * `AllPages`: Prints all pages of the Grid.
         * * `CurrentPage`: Prints the current page of the Grid.
         * @default AllPages
         */
        printMode: PrintMode;
        /**
         * It is used to render grid table rows.
         * If the `dataSource` is an array of JavaScript objects,
         * then Grid will create instance of [`DataManager`](../data/api-dataManager.html)
         * from this `dataSource`.
         * If the `dataSource` is an existing [`DataManager`](../data/api-dataManager.html),
         *  the Grid will not initialize a new one.
         *
         * > Check the available [`Adaptors`](../data/adaptors.html) to customize the data operation.
         * @default []
         */
        dataSource: Object | ej.data.DataManager | DataResult;
        /**
         * Defines the height of Grid rows.
         * @default null
         */
        rowHeight: number;
        /**
         * Defines the external [`Query`](../data/api-query.html)
         * that will be executed along with data processing.
         * @default null
         */
        query: ej.data.Query;
        /**
         * Defines the currencyCode format of the Grid columns
         * @private
         */
        private currencyCode;
        /**
         * `toolbar` defines the ToolBar items of the Grid.
         * It contains built-in and custom toolbar items.
         * If a string value is assigned to the `toolbar` option, it is considered as the template for the whole Grid ToolBar.
         * If an array value is assigned, it is considered as the list of built-in and custom toolbar items in the Grid's Toolbar.
         * <br><br>
         * The available built-in ToolBar items are:
         * * Add: Adds a new record.
         * * Edit: Edits the selected record.
         * * Update: Updates the edited record.
         * * Delete: Deletes the selected record.
         * * Cancel: Cancels the edit state.
         * * Search: Searches records by the given key.
         * * Print: Prints the Grid.
         * * ExcelExport - Export the Grid to Excel(excelExport() method manually to make export.)
         * * PdfExport - Export the Grid to PDF(pdfExport() method manually to make export.)
         * * CsvExport - Export the Grid to CSV(csvExport() method manually to make export.)<br><br>
         * The following code example implements the custom toolbar items.
         *
         *  > Check the [`Toolbar`](./toolbar.html#custom-toolbar-items) to customize its default items.
         *
         * {% codeBlock src="grid/toolbar-api/index.ts" %}{% endcodeBlock %}
         * @default null
         */
        toolbar: ToolbarItems[] | string[] | ej.navigations.ItemModel[] | ToolbarItem[];
        /**
         * `contextMenuItems` defines both built-in and custom context menu items.
         * <br><br>
         * The available built-in items are,
         * * `AutoFitAll` - Auto fit the size of all columns.
         * * `AutoFit` - Auto fit the current column.
         * * `Group` - Group by current column.
         * * `Ungroup` - Ungroup by current column.
         * * `Edit` - Edit the current record.
         * * `Delete` - Delete the current record.
         * * `Save` - Save the edited record.
         * * `Cancel` - Cancel the edited state.
         * * `Copy` - Copy the selected records.
         * * `PdfExport` - Export the grid as Pdf format.
         * * `ExcelExport` - Export the grid as Excel format.
         * * `CsvExport` - Export the grid as CSV format.
         * * `SortAscending` - Sort the current column in ascending order.
         * * `SortDescending` - Sort the current column in descending order.
         * * `FirstPage` - Go to the first page.
         * * `PrevPage` - Go to the previous page.
         * * `LastPage` - Go to the last page.
         * * `NextPage` - Go to the next page.
         *
         * @default null
         */
        contextMenuItems: ContextMenuItem[] | ContextMenuItemModel[];
        /**
         * `columnMenuItems` defines both built-in and custom column menu items.
         * <br><br>
         * The available built-in items are,
         * * `AutoFitAll` - Auto fit the size of all columns.
         * * `AutoFit` - Auto fit the current column.
         * * `Group` - Group by current column.
         * * `Ungroup` - Ungroup by current column.
         * * `SortAscending` - Sort the current column in ascending order.
         * * `SortDescending` - Sort the current column in descending order.
         * * `Filter` - Filter options will show based on filterSettings property like checkbox filter, excel filter, menu filter.
         * @default null
         */
        columnMenuItems: ColumnMenuItem[] | ColumnMenuItemModel[];
        /**
         * @hidden
         * It used to render toolbar template
         * @default null
         */
        toolbarTemplate: string;
        /**
         * @hidden
         * It used to render pager template
         * @default null
         */
        pagerTemplate: string;
        /**
         * Gets or sets the number of frozen rows.
         * @default 0
         */
        frozenRows: number;
        /**
         * Gets or sets the number of frozen columns.
         * @default 0
         */
        frozenColumns: number;
        /**
         * Triggers when the component is created.
         * @event
         */
        created: ej.base.EmitType<Object>;
        /**
         * Triggers when the component is destroyed.
         * @event
         */
        destroyed: ej.base.EmitType<Object>;
        /**
         * This event allows customization of Grid properties before rendering.
         * @event
         */
        load: ej.base.EmitType<Object>;
        /**
         * Triggered every time a request is made to access row information, element, or data.
         * This will be triggered before the row element is appended to the Grid element.
         * @event
         */
        rowDataBound: ej.base.EmitType<RowDataBoundEventArgs>;
        /**
         * Triggered every time a request is made to access cell information, element, or data.
         * This will be triggered before the cell element is appended to the Grid element.
         * @event
         */
        queryCellInfo: ej.base.EmitType<QueryCellInfoEventArgs>;
        /**
         * Triggers when Grid actions such as sorting, filtering, paging, grouping etc., starts.
         * @event
         */
        actionBegin: ej.base.EmitType<PageEventArgs | GroupEventArgs | FilterEventArgs | SearchEventArgs | SortEventArgs | AddEventArgs | SaveEventArgs | EditEventArgs | DeleteEventArgs>;
        /**
         * Triggers when Grid actions such as sorting, filtering, paging, grouping etc. are completed.
         * @event
         */
        actionComplete: ej.base.EmitType<PageEventArgs | GroupEventArgs | FilterEventArgs | SearchEventArgs | SortEventArgs | AddEventArgs | SaveEventArgs | EditEventArgs | DeleteEventArgs>;
        /**
         * Triggers when any Grid action failed to achieve the desired results.
         * @event
         */
        actionFailure: ej.base.EmitType<FailureEventArgs>;
        /**
         * Triggers when data source is populated in the Grid.
         * @event
         */
        dataBound: ej.base.EmitType<Object>;
        /**
         * Triggers when record is double clicked.
         * @event
         */
        recordDoubleClick: ej.base.EmitType<RecordDoubleClickEventArgs>;
        /**
         * Triggers before row selection occurs.
         * @event
         */
        rowSelecting: ej.base.EmitType<RowSelectingEventArgs>;
        /**
         * Triggers after a row is selected.
         * @event
         */
        rowSelected: ej.base.EmitType<RowSelectEventArgs>;
        /**
         * Triggers before deselecting the selected row.
         * @event
         */
        rowDeselecting: ej.base.EmitType<RowDeselectEventArgs>;
        /**
         * Triggers when a selected row is deselected.
         * @event
         */
        rowDeselected: ej.base.EmitType<RowDeselectEventArgs>;
        /**
         * Triggers before any cell selection occurs.
         * @event
         */
        cellSelecting: ej.base.EmitType<CellSelectingEventArgs>;
        /**
         * Triggers after a cell is selected.
         * @event
         */
        cellSelected: ej.base.EmitType<CellSelectEventArgs>;
        /**
         * Triggers before the selected cell is deselecting.
         * @event
         */
        cellDeselecting: ej.base.EmitType<CellDeselectEventArgs>;
        /**
         * Triggers when a particular selected cell is deselected.
         * @event
         */
        cellDeselected: ej.base.EmitType<CellDeselectEventArgs>;
        /**
         * Triggers when column header element drag (move) starts.
         * @event
         */
        columnDragStart: ej.base.EmitType<ColumnDragEventArgs>;
        /**
         * Triggers when column header element is dragged (moved) continuously.
         * @event
         */
        columnDrag: ej.base.EmitType<ColumnDragEventArgs>;
        /**
         * Triggers when a column header element is dropped on the target column.
         * @event
         */
        columnDrop: ej.base.EmitType<ColumnDragEventArgs>;
        /**
         * Triggers after print action is completed.
         * @event
         */
        printComplete: ej.base.EmitType<PrintEventArgs>;
        /**
         * Triggers before the print action starts.
         * @event
         */
        beforePrint: ej.base.EmitType<PrintEventArgs>;
        /**
         * Triggers before exporting each cell to PDF document. You can also customize the PDF cells.
         * @event
         */
        pdfQueryCellInfo: ej.base.EmitType<PdfQueryCellInfoEventArgs>;
        /**
         * Triggers before exporting each cell to Excel file.
         * You can also customize the Excel cells.
         * @event
         */
        excelQueryCellInfo: ej.base.EmitType<ExcelQueryCellInfoEventArgs>;
        /**
         * Triggers before Grid data is exported to Excel file.
         * @event
         */
        beforeExcelExport: ej.base.EmitType<Object>;
        /**
         * Triggers after Grid data is exported to Excel file.
         * @event
         */
        excelExportComplete: ej.base.EmitType<ExcelExportCompleteArgs>;
        /**
         * Triggers before Grid data is exported to PDF document.
         * @event
         */
        beforePdfExport: ej.base.EmitType<Object>;
        /**
         * Triggers after Grid data is exported to PDF document.
         * @event
         */
        pdfExportComplete: ej.base.EmitType<PdfExportCompleteArgs>;
        /**
         * Triggers after detail row expands.
         * > This event triggers at initial expand.
         * @event
         */
        detailDataBound: ej.base.EmitType<DetailDataBoundEventArgs>;
        /**
         * Triggers when row element's drag(move) starts.
         * @event
         */
        rowDragStart: ej.base.EmitType<RowDragEventArgs>;
        /**
         * Triggers when row elements are dragged (moved) continuously.
         * @event
         */
        rowDrag: ej.base.EmitType<RowDragEventArgs>;
        /**
         * Triggers when row elements are dropped on the target row.
         * @event
         */
        rowDrop: ej.base.EmitType<RowDragEventArgs>;
        /**
         * Triggers when toolbar item is clicked.
         * @event
         */
        toolbarClick: ej.base.EmitType<ej.navigations.ClickEventArgs>;
        /**
         * Triggers before the columnChooser open.
         * @event
         */
        beforeOpenColumnChooser: ej.base.EmitType<ColumnChooserEventArgs>;
        /**
         * Triggers when records are added in batch mode.
         * @event
         */
        batchAdd: ej.base.EmitType<BatchAddArgs>;
        /**
         * Triggers when records are deleted in batch mode.
         * @event
         */
        batchDelete: ej.base.EmitType<BatchDeleteArgs>;
        /**
         * Triggers before records are added in batch mode.
         * @event
         */
        beforeBatchAdd: ej.base.EmitType<BeforeBatchAddArgs>;
        /**
         * Triggers before records are deleted in batch mode.
         * @event
         */
        beforeBatchDelete: ej.base.EmitType<BeforeBatchDeleteArgs>;
        /**
         * Triggers before records are saved in batch mode.
         * @event
         */
        beforeBatchSave: ej.base.EmitType<BeforeBatchSaveArgs>;
        /**
         * Triggers before the record is to be edit.
         * @event
         */
        beginEdit: ej.base.EmitType<BeginEditArgs>;
        /**
         * Triggers when the cell is being edited.
         * @event
         */
        cellEdit: ej.base.EmitType<CellEditArgs>;
        /**
         * Triggers when cell is saved.
         * @event
         */
        cellSave: ej.base.EmitType<CellSaveArgs>;
        /**
         * Triggers when column resize starts.
         * @event
         */
        resizeStart: ej.base.EmitType<ResizeArgs>;
        /**
         * Triggers on column resizing.
         * @event
         */
        resizing: ej.base.EmitType<ResizeArgs>;
        /**
         * Triggers when column resize ends.
         * @event
         */
        resizeStop: ej.base.EmitType<ResizeArgs>;
        /**
         * Triggers before data is bound to Grid.
         * @event
         */
        beforeDataBound: ej.base.EmitType<BeforeDataBoundArgs>;
        /**
         * Triggers before context menu opens.
         * @event
         */
        contextMenuOpen: ej.base.EmitType<ej.navigations.BeforeOpenCloseMenuEventArgs>;
        /**
         * Triggers when click on context menu.
         * @event
         */
        contextMenuClick: ej.base.EmitType<ej.navigations.MenuEventArgs>;
        /**
         * Triggers before column menu opens.
         * @event
         */
        columnMenuOpen: ej.base.EmitType<ColumnMenuOpenEventArgs>;
        /**
         * Triggers when click on column menu.
         * @event
         */
        columnMenuClick: ej.base.EmitType<ej.navigations.MenuEventArgs>;
        /**
         * Triggers when the check box state change in checkbox column.
         * @event
         */
        checkBoxChange: ej.base.EmitType<CheckBoxChangeEventArgs>;
        /**
         * Triggers before Grid copy action.
         * @event
         */
        beforeCopy: ej.base.EmitType<BeforeCopyEventArgs>;
        /**
         * Triggers when the grid actions such as Sorting, Paging, Grouping etc., are done.
         * In this event,the current view data and total record count should be assigned to the `dataSource` based on the action performed.
         * @event
         */
        dataStateChange: ej.base.EmitType<DataStateChangeEventArgs>;
        /**
         * Triggers when the grid data is added, deleted and updated.
         * Invoke the done method from the argument to start render after edit operation.
         * @event
         */
        dataSourceChanged: ej.base.EmitType<DataSourceChangedEventArgs>;
        /**
         * Constructor for creating the component
         * @hidden
         */
        constructor(options?: GridModel, element?: string | HTMLElement);
        /**
         * Get the properties to be maintained in the persisted state.
         * @return {string}
         * @hidden
         */
        getPersistData(): string;
        private ignoreInArrays(ignoreOnColumn, columns);
        private ignoreInColumn(ignoreOnColumn, column);
        /**
         * To provide the array of modules needed for component rendering
         * @return {ej.base.ModuleDeclaration[]}
         * @hidden
         */
        requiredModules(): ej.base.ModuleDeclaration[];
        extendRequiredModules(modules: ej.base.ModuleDeclaration[]): void;
        /**
         * For internal use only - Initialize the event handler;
         * @private
         */
        protected preRender(): void;
        private initProperties();
        /**
         * For internal use only - To Initialize the component rendering.
         * @private
         */
        protected render(): void;
        /**
         * By default, grid shows the spinner for all its actions. You can use this method to show spinner at your needed time.
         */
        showSpinner(): void;
        /**
         * Manually showed spinner needs to hide by `hideSpinnner`.
         */
        hideSpinner(): void;
        private updateStackedFilter();
        private getMediaColumns();
        /**
         * @hidden
         */
        mediaQueryUpdate(columnIndex: number, e?: MediaQueryList): void;
        private refreshMediaCol();
        /**
         * For internal use only - Initialize the event handler
         * @private
         */
        protected eventInitializer(): void;
        /**
         * Destroys the component (detaches/removes all event handlers, attributes, classes, and empties the component element).
         * @method destroy
         * @return {void}
         */
        destroy(): void;
        private destroyDependentModules();
        /**
         * For internal use only - Get the module name.
         * @private
         */
        protected getModuleName(): string;
        /**
         * Called internally if any of the property value changed.
         * @hidden
         */
        onPropertyChanged(newProp: GridModel, oldProp: GridModel): void;
        private extendedPropertyChange(prop, newProp);
        private updateDefaultCursor();
        private updateColumnModel(columns);
        private updateFrozenColumns();
        /**
         * Gets the columns from the Grid.
         * @return {Column[]}
         */
        getColumns(isRefresh?: boolean): Column[];
        /**
         * @private
         */
        getColumnIndexesInView(): number[];
        /**
         * @private
         */
        getLocaleConstants(): Object;
        /**
         * @private
         */
        setColumnIndexesInView(indexes: number[]): void;
        /**
         * Gets the visible columns from the Grid.
         * @return {Column[]}
         */
        getVisibleColumns(): Column[];
        /**
         * Gets the header div of the Grid.
         * @return {Element}
         */
        getHeaderContent(): Element;
        /**
         * Sets the header div of the Grid to replace the old header.
         * @param  {Element} element - Specifies the Grid header.
         * @return {void}
         */
        setGridHeaderContent(element: Element): void;
        /**
         * Gets the content table of the Grid.
         * @return {Element}
         */
        getContentTable(): Element;
        /**
         * Sets the content table of the Grid to replace the old content table.
         * @param  {Element} element - Specifies the Grid content table.
         * @return {void}
         */
        setGridContentTable(element: Element): void;
        /**
         * Gets the content div of the Grid.
         * @return {Element}
         */
        getContent(): Element;
        /**
         * Sets the content div of the Grid to replace the old Grid content.
         * @param  {Element} element - Specifies the Grid content.
         * @return {void}
         */
        setGridContent(element: Element): void;
        /**
         * Gets the header table element of the Grid.
         * @return {Element}
         */
        getHeaderTable(): Element;
        /**
         * Sets the header table of the Grid to replace the old one.
         * @param  {Element} element - Specifies the Grid header table.
         * @return {void}
         */
        setGridHeaderTable(element: Element): void;
        /**
         * Gets the footer div of the Grid.
         * @return {Element}
         */
        getFooterContent(): Element;
        /**
         * Gets the footer table element of the Grid.
         * @return {Element}
         */
        getFooterContentTable(): Element;
        /**
         * Gets the pager of the Grid.
         * @return {Element}
         */
        getPager(): Element;
        /**
         * Sets the pager of the Grid to replace the old pager.
         * @param  {Element} element - Specifies the Grid pager.
         * @return {void}
         */
        setGridPager(element: Element): void;
        /**
         * Gets a row by index.
         * @param  {number} index - Specifies the row index.
         * @return {Element}
         */
        getRowByIndex(index: number): Element;
        /**
         * Gets a movable tables row by index.
         * @param  {number} index - Specifies the row index.
         * @return {Element}
         */
        getMovableRowByIndex(index: number): Element;
        /**
         * Gets all the data rows of the Grid.
         * @return {Element[]}
         */
        getRows(): Element[];
        /**
         * Get a row information based on cell
         * @param {Element}
         * @return RowInfo
         */
        getRowInfo(target: Element | EventTarget): RowInfo;
        /**
         * Gets the Grid's movable content rows from frozen grid.
         * @return {Element[]}
         */
        getMovableRows(): Element[];
        /**
         * Gets all the Grid's data rows.
         * @return {Element[]}
         */
        getDataRows(): Element[];
        /**
         * @hidden
         */
        addMovableRows(fRows: HTMLElement[], mrows: HTMLElement[]): HTMLElement[];
        private generateDataRows(rows);
        /**
         * Gets all the Grid's movable table data rows.
         * @return {Element[]}
         */
        getMovableDataRows(): Element[];
        /**
         * Updates particular cell value based on the given primary key value.
         * > Primary key column must be specified using `columns.isPrimaryKey` property.
         * @param {string| number} key - Specifies the PrimaryKey value of dataSource.
         * @param {string } field - Specifies the field name which you want to update.
         * @param {string | number | boolean | Date} value - To update new value for the particular cell.
         */
        setCellValue(key: string | number, field: string, value: string | number | boolean | Date): void;
        /**
         * Updates and refresh the particular row values based on the given primary key value.
         * > Primary key column must be specified using `columns.isPrimaryKey` property.
         *  @param {string| number} key - Specifies the PrimaryKey value of dataSource.
         *  @param {Object} rowData - To update new data for the particular row.
         */
        setRowData(key: string | number, rowData?: Object): void;
        /**
         * Gets a cell by row and column index.
         * @param  {number} rowIndex - Specifies the row index.
         * @param  {number} columnIndex - Specifies the column index.
         * @return {Element}
         */
        getCellFromIndex(rowIndex: number, columnIndex: number): Element;
        /**
         * Gets a movable table cell by row and column index.
         * @param  {number} rowIndex - Specifies the row index.
         * @param  {number} columnIndex - Specifies the column index.
         * @return {Element}
         */
        getMovableCellFromIndex(rowIndex: number, columnIndex: number): Element;
        /**
         * Gets a column header by column index.
         * @param  {number} index - Specifies the column index.
         * @return {Element}
         */
        getColumnHeaderByIndex(index: number): Element;
        /**
         * @hidden
         */
        getRowObjectFromUID(uid: string): Row<Column>;
        private rowObject(rows, uid);
        /**
         * @hidden
         */
        getRowsObject(): Row<Column>[];
        /**
         * @hidden
         */
        getMovableRowsObject(): Row<Column>[];
        /**
         * Gets a column header by column name.
         * @param  {string} field - Specifies the column name.
         * @return {Element}
         */
        getColumnHeaderByField(field: string): Element;
        /**
         * Gets a column header by UID.
         * @param  {string} field - Specifies the column uid.
         * @return {Element}
         */
        getColumnHeaderByUid(uid: string): Element;
        /**
         * Gets a Column by column name.
         * @param  {string} field - Specifies the column name.
         * @return {Column}
         */
        getColumnByField(field: string): Column;
        /**
         * Gets a column index by column name.
         * @param  {string} field - Specifies the column name.
         * @return {number}
         */
        getColumnIndexByField(field: string): number;
        /**
         * Gets a column by UID.
         * @param  {string} uid - Specifies the column UID.
         * @return {Column}
         */
        getColumnByUid(uid: string): Column;
        /**
         * Gets a column index by UID.
         * @param  {string} uid - Specifies the column UID.
         * @return {number}
         */
        getColumnIndexByUid(uid: string): number;
        /**
         * Gets UID by column name.
         * @param  {string} field - Specifies the column name.
         * @return {string}
         */
        getUidByColumnField(field: string): string;
        /**
         * Gets TH index by column uid value.
         * @private
         * @param  {string} uid - Specifies the column uid.
         * @return {number}
         */
        getNormalizedColumnIndex(uid: string): number;
        /**
         * Gets the collection of column fields.
         * @return {string[]}
         */
        getColumnFieldNames(): string[];
        /**
         * Gets a compiled row template.
         * @return {Function}
         * @private
         */
        getRowTemplate(): Function;
        /**
         * Gets a compiled detail row template.
         * @private
         * @return {Function}
         */
        getDetailTemplate(): Function;
        /**
         * Get the names of the primary key columns of the Grid.
         * @return {string[]}
         */
        getPrimaryKeyFieldNames(): string[];
        /**
         * Refreshes the Grid header and content.
         */
        refresh(): void;
        /**
         * Refreshes the Grid header.
         */
        refreshHeader(): void;
        /**
         * Gets the collection of selected rows.
         * @return {Element[]}
         */
        getSelectedRows(): Element[];
        /**
         * Gets the collection of selected row indexes.
         * @return {number[]}
         */
        getSelectedRowIndexes(): number[];
        /**
         * Gets the collection of selected row and cell indexes.
         * @return {number[]}
         */
        getSelectedRowCellIndexes(): ISelectedCell[];
        /**
         * Gets the collection of selected records.
         * @return {Object[]}
         */
        getSelectedRecords(): Object[];
        /**
         * Gets the data module.
         * @return {Data}
         */
        getDataModule(): Data;
        /**
         * Shows a column by its column name.
         * @param  {string|string[]} keys - Defines a single or collection of column names.
         * @param  {string} showBy - Defines the column key either as field name or header text.
         * @return {void}
         */
        showColumns(keys: string | string[], showBy?: string): void;
        /**
         * Hides a column by column name.
         * @param  {string|string[]} keys - Defines a single or collection of column names.
         * @param  {string} hideBy - Defines the column key either as field name or header text.
         * @return {void}
         */
        hideColumns(keys: string | string[], hideBy?: string): void;
        /**
         * @hidden
         */
        getFrozenColumns(): number;
        private getFrozenCount(cols, cnt);
        /**
         * Navigates to the specified target page.
         * @param  {number} pageNo - Defines the page number to navigate.
         * @return {void}
         */
        goToPage(pageNo: number): void;
        /**
         * Defines the text of external message.
         * @param  {string} message - Defines the message to update.
         * @return {void}
         */
        updateExternalMessage(message: string): void;
        /**
         * Sorts a column with the given options.
         * @param {string} columnName - Defines the column name to be sorted.
         * @param {SortDirection} direction - Defines the direction of sorting field.
         * @param {boolean} isMultiSort - Specifies whether the previous sorted columns are to be maintained.
         * @return {void}
         */
        sortColumn(columnName: string, direction: SortDirection, isMultiSort?: boolean): void;
        /**
         * Clears all the sorted columns of the Grid.
         * @return {void}
         */
        clearSorting(): void;
        /**
         * Remove sorted column by field name.
         * @param {string} field - Defines the column field name to remove sort.
         * @return {void}
         * @hidden
         */
        removeSortColumn(field: string): void;
        /**
         * Filters grid row by column name with the given options.
         * @param  {string} fieldName - Defines the field name of the column.
         * @param  {string} filterOperator - Defines the operator to filter records.
         * @param  {string | number | Date | boolean} filterValue - Defines the value used to filter records.
         * @param  {string} predicate - Defines the relationship between one filter query and another by using AND or OR predicate.
         * @param  {boolean} matchCase - If match case is set to true, the grid filters the records with exact match. if false, it filters case
         * insensitive records (uppercase and lowercase letters treated the same).
         * @param  {boolean} ignoreAccent - If ignoreAccent set to true,
         * then filter ignores the diacritic characters or accents while filtering.
         * @param  {string} actualFilterValue - Defines the actual filter value for the filter column.
         * @param  {string} actualOperator - Defines the actual filter operator for the filter column.
         * @return {void}
         */
        filterByColumn(fieldName: string, filterOperator: string, filterValue: string | number | Date | boolean, predicate?: string, matchCase?: boolean, ignoreAccent?: boolean, actualFilterValue?: string, actualOperator?: string): void;
        /**
         * Clears all the filtered rows of the Grid.
         * @return {void}
         */
        clearFiltering(): void;
        /**
         * Removes filtered column by field name.
         * @param  {string} field - Defines column field name to remove filter.
         * @param  {boolean} isClearFilterBar -  Specifies whether the filter bar value needs to be cleared.
         * @return {void}
         * @hidden
         */
        removeFilteredColsByField(field: string, isClearFilterBar?: boolean): void;
        /**
         * Selects a row by given index.
         * @param  {number} index - Defines the row index.
         * @param  {boolean} isToggle - If set to true, then it toggles the selection.
         * @return {void}
         */
        selectRow(index: number, isToggle?: boolean): void;
        /**
         * Selects a collection of rows by indexes.
         * @param  {number[]} rowIndexes - Specifies the row indexes.
         * @return {void}
         */
        selectRows(rowIndexes: number[]): void;
        /**
         * Deselects the current selected rows and cells.
         * @return {void}
         */
        clearSelection(): void;
        /**
         * Selects a cell by the given index.
         * @param  {IIndex} cellIndex - Defines the row and column indexes.
         * @param  {boolean} isToggle - If set to true, then it toggles the selection.
         * @return {void}
         */
        selectCell(cellIndex: IIndex, isToggle?: boolean): void;
        /**
         * Searches Grid records using the given key.
         * You can customize the default search option by using the
         * [`searchSettings`](./api-searchSettings.html).
         * @param  {string} searchString - Defines the key.
         * @return {void}
         */
        search(searchString: string): void;
        /**
         * By default, prints all the pages of the Grid and hides the pager.
         * > You can customize print options using the
         * [`printMode`](./api-grid.html#printmode-string).
         * @return {void}
         */
        print(): void;
        /**
         * Delete a record with Given options. If fieldname and data is not given then grid will delete the selected record.
         * > `editSettings.allowDeleting` should be true.
         * @param {string} fieldname - Defines the primary key field, 'Name of the column'.
         * @param {Object} data - Defines the JSON data of the record to be deleted.
         */
        deleteRecord(fieldname?: string, data?: Object): void;
        /**
         * To edit any particular row by TR element.
         * @param {HTMLTableRowElement} tr - Defines the table row to be edited.
         */
        startEdit(): void;
        /**
         * If Grid is in editable state, you can save a record by invoking endEdit.
         */
        endEdit(): void;
        /**
         * Cancels edited state.
         */
        closeEdit(): void;
        /**
         * Adds a new record to the Grid. Without passing parameters, it adds empty rows.
         * > `editSettings.allowEditing` should be true.
         * @param {Object} data - Defines the new add record data.
         * @param {number} index - Defines the row index to be added
         */
        addRecord(data?: Object, index?: number): void;
        /**
         * Delete any visible row by TR element.
         * @param {HTMLTableRowElement} tr - Defines the table row element.
         */
        deleteRow(tr: HTMLTableRowElement): void;
        /**
         * Copy the selected rows or cells data into clipboard.
         * @param {boolean} withHeader - Specifies whether the column header text needs to be copied along with rows or cells.
         */
        copy(withHeader?: boolean): void;
        /**
         * @hidden
         */
        recalcIndentWidth(): void;
        /**
         * Changes the Grid column positions by field names.
         * @param  {string} fromFName - Defines the origin field name.
         * @param  {string} toFName - Defines the destination field name.
         * @return {void}
         */
        reorderColumns(fromFName: string, toFName: string): void;
        /**
         * Changes the column width to automatically fit its content to ensure that the width shows the content without wrapping/hiding.
         * > * This method ignores the hidden columns.
         * > * Uses the `autoFitColumns` method in the `dataBound` event to resize at initial rendering.
         * @param  {string |string[]} fieldNames - Defines the column names.
         * @return {void}
         *
         *
         * ```typescript
         * <div id="Grid"></div>
         * <script>
         * let gridObj: Grid = new Grid({
         *     dataSource: employeeData,
         *     columns: [
         *         { field: 'OrderID', headerText: 'Order ID', width:100 },
         *         { field: 'EmployeeID', headerText: 'Employee ID' }],
         *     dataBound: () => gridObj.autoFitColumns('EmployeeID')
         * });
         * gridObj.appendTo('#Grid');
         * </script>
         * ```
         *
         */
        autoFitColumns(fieldNames: string | string[]): void;
        /**
         * @hidden
         */
        createColumnchooser(x: number, y: number, target: Element): void;
        private initializeServices();
        private processModel();
        private initForeignColumn();
        private gridRender();
        private dataReady();
        private updateRTL();
        private createGridPopUpElement();
        private updateGridLines();
        private updateResizeLines();
        /**
         * The function is used to apply text wrap
         * @return {void}
         * @hidden
         */
        applyTextWrap(): void;
        /**
         * The function is used to remove text wrap
         * @return {void}
         * @hidden
         */
        removeTextWrap(): void;
        /**
         * The function is used to add Tooltip to the grid cell that has ellipsiswithtooltip clip mode.
         * @return {void}
         * @hidden
         */
        refreshTooltip(): void;
        /**
         * To create table for ellipsiswithtooltip
         * @hidden
         */
        protected createTable(table: Element, tag: string, type: string): HTMLDivElement;
        /**
         * Binding events to the element while component creation.
         * @hidden
         */
        wireEvents(): void;
        /**
         * Unbinding events from the element while component destroy.
         * @hidden
         */
        unwireEvents(): void;
        /**
         * @hidden
         */
        addListener(): void;
        /**
         * @hidden
         */
        removeListener(): void;
        /**
         * Get current visible data of grid.
         * @return {Object[]}
         * @hidden
         */
        getCurrentViewRecords(): Object[];
        private mouseClickHandler(e);
        private checkEdit(e);
        private dblClickHandler(e);
        private focusOutHandler(e);
        private isChildGrid(e);
        private mergePersistGridData();
        private isDetail();
        private isCommandColumn(columns);
        private isForeignKeyEnabled(columns);
        private keyActionHandler(e);
        /**
         * @hidden
         */
        setInjectedModules(modules: Function[]): void;
        private updateColumnObject();
        /**
         * Gets the foreign columns from Grid.
         * @return {Column[]}
         */
        getForeignKeyColumns(): Column[];
        /**
         * Refreshes the Grid column changes.
         */
        refreshColumns(): void;
        /**
         * Export Grid data to Excel file(.xlsx).
         * @param  {ExcelExportProperties} excelExportProperties - Defines the export properties of the Grid.
         * @param  {boolean} isMultipleExport - Define to enable multiple export.
         * @param  {workbook} workbook - Defines the Workbook if multiple export is enabled.
         * @param  {boolean} isBlob - If 'isBlob' set to true, then it will be returned as blob data.
         * @return {Promise<any>}
         */
        excelExport(excelExportProperties?: ExcelExportProperties, isMultipleExport?: boolean, workbook?: any, isBlob?: boolean): Promise<any>;
        /**
         * Export Grid data to CSV file.
         * @param  {ExcelExportProperties} excelExportProperties - Defines the export properties of the Grid.
         * @param  {boolean} isMultipleExport - Define to enable multiple export.
         * @param  {workbook} workbook - Defines the Workbook if multiple export is enabled.
         * @param  {boolean} isBlob - If 'isBlob' set to true, then it will be returned as blob data.
         * @return {Promise<any>}
         *
         */
        csvExport(excelExportProperties?: ExcelExportProperties, isMultipleExport?: boolean, workbook?: any, isBlob?: boolean): Promise<any>;
        /**
         * Export Grid data to PDF document.
         * @param  {pdfExportProperties} PdfExportProperties - Defines the export properties of the Grid.
         * @param  {isMultipleExport} isMultipleExport - Define to enable multiple export.
         * @param  {pdfDoc} pdfDoc - Defined the Pdf Document if multiple export is enabled.
         * @param  {boolean} isBlob - If 'isBlob' set to true, then it will be returned as blob data.
         * @return {Promise<any>}
         *
         */
        pdfExport(pdfExportProperties?: PdfExportProperties, isMultipleExport?: boolean, pdfDoc?: Object, isBlob?: boolean): Promise<Object>;
        /**
         * Groups a column by column name.
         * @param  {string} columnName - Defines the column name to group.
         * @return {void}
         */
        groupColumn(columnName: string): void;
        /**
         * Ungroups a column by column name.
         * @param  {string} columnName - Defines the column name to ungroup.
         * @return {void}
         */
        ungroupColumn(columnName: string): void;
        /**
         * @hidden
         */
        isContextMenuOpen(): boolean;
        /**
         * @hidden
         */
        ensureModuleInjected(module: Function): boolean;
    }
    
    /**
     * Specifies grid interfaces.
     * @hidden
     */
    export interface IGrid extends ej.base.Component<HTMLElement> {
        currentViewData?: Object[];
        /**
         * Specifies the columns for Grid.
         * @default []
         */
        columns?: Column[] | string[] | ColumnModel[];
        /**
         * Specifies whether the enableAltRow is enable or not.
         * @default null
         */
        enableAltRow?: boolean;
        /**
         * Specifies whether the enable row hover is enable or not.
         * @default null
         */
        enableHover?: boolean;
        /**
         * Specifies the allowKeyboard Navigation for the Grid.
         * @default null
         */
        allowKeyboard?: boolean;
        /**
         * Specifies whether the allowTextWrap is enabled or not.
         * @default null
         */
        allowTextWrap?: boolean;
        /**
         * Specifies the 'textWrapSettings' for Grid.
         * @default []
         */
        textWrapSettings?: TextWrapSettingsModel;
        /**
         * Specifies whether the paging is enable or not.
         * @default null
         */
        allowPaging?: boolean;
        /**
         * Specifies the pageSettings for Grid.
         * @default PageSettings
         */
        pageSettings?: PageSettingsModel;
        enableVirtualization: boolean;
        enableColumnVirtualization: boolean;
        /**
         * Specifies whether the sorting is enable or not.
         * @default null
         */
        allowSorting?: boolean;
        /**
         * Specifies whether the multi-sorting is enable or not.
         * @default null
         */
        allowMultiSorting?: boolean;
        /**
         * Specifies the sortSettings for Grid.
         * @default []
         */
        sortSettings?: SortSettingsModel;
        /**
         * Specifies whether the Excel exporting is enable or not.
         * @default null
         */
        allowExcelExport?: boolean;
        /**
         * Specifies whether the Pdf exporting is enable or not.
         * @default null
         */
        allowPdfExport?: boolean;
        /**
         * Specifies whether the selection is enable or not.
         * @default null
         */
        allowSelection?: boolean;
        /**
         * It is used to select the row while initializing the grid.
         * @default -1
         */
        selectedRowIndex?: number;
        /**
         * Specifies the selectionSettings for Grid.
         * @default []
         */
        selectionSettings?: SelectionSettingsModel;
        /**
         * Specifies whether the reordering is enable or not.
         * @default null
         */
        allowReordering?: boolean;
        /**
         * If `allowResizing` set to true, then the Grid columns can be resized.
         * @default false
         */
        allowResizing?: boolean;
        /**
         * Specifies whether the filtering is enable or not.
         * @default null
         */
        allowFiltering?: boolean;
        /**
         * Specifies the filterSettings for Grid.
         * @default []
         */
        filterSettings?: FilterSettingsModel;
        /**
         * Specifies whether the grouping is enable or not.
         * @default null
         */
        allowGrouping?: boolean;
        /**
         * Specifies whether the column menu is show or not.
         * @default null
         */
        showColumnMenu?: boolean;
        /**
         * Specifies the groupSettings for Grid.
         * @default []
         */
        groupSettings?: GroupSettingsModel;
        /**
         * if showColumnChooser is true, then column chooser will be enabled in Grid.
         * @default false
         */
        showColumnChooser?: boolean;
        /**
         * Specifies the editSettings for Grid.
         * @default []
         */
        editSettings?: EditSettingsModel;
        /**
         * Specifies the summaryRows for Grid.
         * @default []
         */
        aggregates?: AggregateRowModel[];
        /**
         * Specifies scrollable height of the grid content.
         * @default auto
         */
        height?: string | number;
        /**
         * Specifies scrollable width of the grid content.
         * @default auto
         */
        width?: string | number;
        /**
         * Specifies the searchSettings for Grid.
         * @default []
         */
        searchSettings?: SearchSettingsModel;
        /**
         * Specifies the rowDropSettings for Grid.
         * @default []
         */
        rowDropSettings?: RowDropSettingsModel;
        /**
         * Specifies whether the allowRowDragAndDrop is enable or not.
         * @default false
         */
        allowRowDragAndDrop?: boolean;
        /**
         * Specifies whether the gridLines mode
         * @default null
         */
        gridLines?: GridLine;
        /**
         * Specifies rowTemplate
         */
        rowTemplate?: string;
        /**
         * Specifies detailTemplate
         */
        detailTemplate?: string;
        /**
         * Defines the child Grid to add inside the data rows of the parent Grid with expand/collapse options.
         */
        childGrid?: GridModel;
        /**
         * Defines the relation between parent and child grid.
         */
        queryString?: string;
        /**
         * Specifies the printMode
         */
        printMode?: PrintMode;
        /**
         * Specifies the dataSource for Grid.
         * @default []
         */
        dataSource?: Object | ej.data.DataManager;
        /**
         * Defines the row height for Grid rows.
         * @default null
         */
        rowHeight?: number;
        /**
         * Specifies the query for Grid.
         * @default []
         */
        query?: ej.data.Query;
        /**
         * @hidden
         * Specifies the toolbar for Grid.
         * @default null
         */
        toolbar?: ToolbarItems[] | string[] | ej.navigations.ItemModel[] | ToolbarItem[];
        /**
         * Specifies the context menu items for Grid.
         * @default null
         */
        contextMenuItems?: ContextMenuItem[] | ContextMenuItemModel[];
        /**
         * Specifies the column menu items for Grid.
         * @default null
         */
        columnMenuItems?: string[] | ContextMenuItemModel[];
        /**
         * @hidden
         * It used to render toolbar template
         * @default null
         */
        toolbarTemplate?: string;
        /**
         * @hidden
         * It used to render pager template
         * @default null
         */
        pagerTemplate?: string;
        /**
         * Defines the frozen rows for the grid content
         * @default 0
         */
        frozenRows?: number;
        /**
         * Defines the frozen columns for the grid content
         * @default 0
         */
        frozenColumns?: number;
        isEdit?: boolean;
        editModule?: Edit;
        mergeCells?: {
            [key: string]: number;
        };
        checkAllRows?: CheckState;
        isCheckBoxSelection?: boolean;
        isPersistSelection?: boolean;
        getHeaderContent?(): Element;
        setGridHeaderContent?(value: Element): void;
        getContentTable?(): Element;
        setGridContentTable?(value: Element): void;
        getContent?(): Element;
        setGridContent?(value: Element): void;
        getHeaderTable?(): Element;
        setGridHeaderTable?(value: Element): void;
        getFooterContent?(): Element;
        getFooterContentTable?(): Element;
        getPager?(): Element;
        setGridPager?(value: Element): void;
        getRowByIndex?(index: number): Element;
        getMovableRowByIndex?(index: number): Element;
        getRowInfo?(target: Element): RowInfo;
        selectRow?(index: number, isToggle?: boolean): void;
        getColumnHeaderByIndex?(index: number): Element;
        getColumnByField?(field: string): Column;
        getColumnIndexByField?(field: string): number;
        getColumnByUid?(uid: string): Column;
        getColumnIndexByUid?(uid: string): number;
        getUidByColumnField?(field: string): string;
        getNormalizedColumnIndex?(uid: string): number;
        getColumnIndexesInView(): number[];
        setColumnIndexesInView(indexes?: number[]): void;
        getRows?(): Element[];
        getMovableRows?(): Element[];
        getCellFromIndex?(rowIndex: number, columnIndex: number): Element;
        getMovableCellFromIndex?(rowIndex: number, columnIndex: number): Element;
        getColumnFieldNames?(): string[];
        getSelectedRows?(): Element[];
        getSelectedRecords?(): Object[];
        getSelectedRowIndexes?(): number[];
        getSelectedRowCellIndexes(): ISelectedCell[];
        getCurrentViewRecords(): Object[];
        selectRows?(indexes: number[]): void;
        clearSelection?(): void;
        updateExternalMessage?(message: string): void;
        getColumns?(isRefresh?: boolean): Column[];
        getRowTemplate?(): Function;
        getDetailTemplate?(): Function;
        sortColumn?(columnName: string, sortDirection: SortDirection, isMultiSort?: boolean): void;
        removeSortColumn?(field: string): void;
        getColumnHeaderByUid?(uid: string): Element;
        getColumnHeaderByField?(field: string): Element;
        showColumns?(keys: string | string[], showBy?: string): void;
        hideColumns?(keys: string | string[], hideBy?: string): void;
        showSpinner?(): void;
        hideSpinner?(): void;
        getVisibleColumns?(): Column[];
        refreshHeader?(): void;
        getDataRows?(): Element[];
        getMovableDataRows?(): Element[];
        addMovableRows?(fRows: HTMLElement[], mrows: HTMLElement[]): HTMLElement[];
        getPrimaryKeyFieldNames?(): string[];
        autoFitColumns(fieldNames: string | string[]): void;
        groupColumn(columnName: string): void;
        ungroupColumn(columnName: string): void;
        ensureModuleInjected(module: Function): Boolean;
        isContextMenuOpen(): Boolean;
        goToPage(pageNo: number): void;
        getFrozenColumns(): number;
        print(): void;
        excelExport(exportProperties?: any, isMultipleExport?: boolean, workbook?: any): Promise<any>;
        csvExport(exportProperties?: any, isMultipleExport?: boolean, workbook?: any): Promise<any>;
        pdfExport(exportProperties?: any, isMultipleExport?: boolean, pdfDoc?: Object): Promise<Object>;
        search(searchString: string): void;
        deleteRecord?(fieldname?: string, data?: Object): void;
        startEdit?(): void;
        endEdit?(): void;
        closeEdit?(): void;
        addRecord?(data?: Object): void;
        deleteRow?(tr: HTMLTableRowElement): void;
        getRowObjectFromUID?(uid: string): Row<Column>;
        addFreezeRows?(fRows: Row<Column>[], mRows?: Row<Column>[]): Row<Column>[];
        getRowsObject?(): Row<Column>[];
        getMovableRowsObject?(): Row<Column>[];
        createColumnchooser(x: number, y: number, target: Element): void;
        getDataModule?(): Data;
        refreshTooltip?(): void;
        copy?(withHeader?: boolean): void;
        getLocaleConstants?(): Object;
        getForeignKeyColumns?(): Column[];
        setCellValue(key: string | number, field: string, value: string | number | boolean | Date): void;
        setRowData(key: string | number, rowData?: Object): void;
        getState?(): Object;
    }
    /** @hidden */
    export interface IRenderer {
        renderPanel(): void;
        renderTable(): void;
        setPanel(panel: Element): void;
        setTable(table: Element): void;
        getPanel(): Element;
        getTable(): Element;
        getRows?(): Row<{}>[] | HTMLCollectionOf<HTMLTableRowElement>;
        getMovableRows?(): Row<{}>[] | HTMLCollectionOf<HTMLTableRowElement>;
        refreshUI?(): void;
        setVisible?(column?: Column[]): void;
        addEventListener?(): void;
        removeEventListener?(): void;
        getRowElements?(): Element[];
        getMovableRowElements?(): Element[];
        setSelection?(uid: string, set: boolean, clearAll: boolean): void;
        getRowByIndex?(index: number): Element;
        getVirtualRowIndex?(index: number): number;
        getMovableRowByIndex?(index: number): Element;
        getRowInfo?(target: Element): RowInfo;
        getState?(): Object;
    }
    /**
     * IAction interface
     * @hidden
     */
    export interface IAction {
        updateModel?(): void;
        onActionBegin?(args?: Object, type?: string): void;
        onActionComplete?(args?: Object, type?: string): void;
        addEventListener?(): void;
        removeEventListener?(): void;
    }
    /**
     * @hidden
     */
    export interface IDataProcessor {
        generateQuery(): ej.data.Query;
        getData(args: Object, query: ej.data.Query): Promise<Object>;
        processData?(): void;
    }
    /**
     * @hidden
     */
    export interface IValueFormatter {
        fromView(value: string, format: Function, target?: string): string | number | Date;
        toView(value: number | Date, format: Function): string | Object;
        setCulture?(cultureName: string): void;
        getFormatFunction?(format: ej.base.NumberFormatOptions | ej.base.DateFormatOptions): Function;
        getParserFunction?(format: ej.base.NumberFormatOptions | ej.base.DateFormatOptions): Function;
    }
    /**
     * @hidden
     */
    export interface ITemplateRender {
        compiled: {
            [x: string]: Function;
        };
        compile(key: string, template: string): Function;
        render(key: string, data: Object, params?: {
            [p: string]: Object;
        }): string;
    }
    /**
     * @hidden
     */
    export interface IEditCell {
        create?: Element | Function;
        read?: Object | Function;
        write?: void | Function;
        params?: ej.calendars.DatePickerModel | ej.inputs.NumericTextBoxModel | ej.dropdowns.DropDownListModel;
        destroy?: Function;
    }
    /**
     * @hidden
     */
    export interface IFilterUI {
        create?: Element | Function;
        read?: Object | Function;
        write?: void | Function;
    }
    /**
     * @hidden
     */
    export interface IFilterMUI {
        create?: void | Function;
        read?: Object | Function;
        write?: void | Function;
    }
    /**
     * @hidden
     */
    export interface ICustomOptr {
        stringOperator?: {
            [key: string]: Object;
        }[];
        numberOperator?: {
            [key: string]: Object;
        }[];
        dateOperator?: {
            [key: string]: Object;
        }[];
        booleanOperator?: {
            [key: string]: Object;
        }[];
    }
    /**
     * @hidden
     */
    export interface ICellRenderer<T> {
        element?: Element;
        getGui?(): string | Element;
        format?(column: T, value: Object, data: Object): string;
        evaluate?(node: Element, column: Cell<T>, data: Object, attributes?: Object): boolean;
        setStyleAndAttributes?(node: Element, attributes: {
            [key: string]: Object;
        }): void;
        render(cell: Cell<T>, data: Object, attributes?: {
            [x: string]: string;
        }): Element;
        appendHtml?(node: Element, innerHtml: string | Element): Element;
        refresh?(cell: Cell<T>, node: Element): Element;
    }
    /**
     * @hidden
     */
    export interface IRowRenderer<T> {
        element?: Element;
        render(row: Row<T>, column: Column[], attributes?: {
            [x: string]: string;
        }, rowTemplate?: string): Element;
    }
    export interface ICellFormatter {
        getValue(column: Column, data: Object): Object;
    }
    /**
     * @hidden
     */
    export interface IIndex {
        rowIndex?: number;
        cellIndex?: number;
    }
    /**
     * @hidden
     */
    export interface ISelectedCell {
        rowIndex: number;
        cellIndexes: number[];
    }
    /**
     * @hidden
     */
    export interface IFilterOperator {
        contains: string;
        endsWith: string;
        equal: string;
        greaterThan: string;
        greaterThanOrEqual: string;
        lessThan: string;
        lessThanOrEqual: string;
        notEqual: string;
        startsWith: string;
    }
    export interface NotifyArgs {
        records?: Object[];
        count?: number;
        requestType?: Action;
        module?: string;
        enable?: boolean;
        properties?: Object;
        virtualInfo?: VirtualInfo;
        cancel?: boolean;
        rows?: Row<Column>[];
        isFrozen?: boolean;
        args?: NotifyArgs;
    }
    /**
     * @hidden
     */
    export interface ICell<T> {
        colSpan?: number;
        rowSpan?: number;
        cellType?: CellType;
        visible?: boolean;
        isTemplate?: boolean;
        isDataCell?: boolean;
        column?: T;
        rowID?: string;
        index?: number;
        colIndex?: number;
        className?: string;
        commands?: CommandModel[];
        isForeignKey?: boolean;
        foreignKeyData?: Object;
    }
    /**
     * @hidden
     */
    export interface IRow<T> {
        uid?: string;
        data?: Object;
        isSelected?: boolean;
        isReadOnly?: boolean;
        isAltRow?: boolean;
        isDataRow?: boolean;
        isExpand?: boolean;
        rowSpan?: number;
        cells?: Cell<T>[];
        index?: number;
        indent?: number;
        subRowDetails?: Object;
        height?: string;
        cssClass?: string;
        foreignKeyData?: Object;
    }
    /**
     * @hidden
     */
    export interface IModelGenerator<T> {
        generateRows(data: Object, args?: Object): Row<T>[];
        refreshRows?(input?: Row<T>[]): Row<T>[];
    }
    export interface RowInfo {
        /** returns particular cell element */
        cell?: Element;
        /** returns particular cell index */
        cellIndex?: number;
        /** returns particular row element */
        row?: Element;
        /** returns particular rowIndex */
        rowIndex?: number;
        /** returns particular row data */
        rowData?: Object;
        /** return particular column information  */
        column?: Object;
    }
    export interface ActionEventArgs {
        /** Defines the current action. */
        requestType?: Action;
        /** Defines the type of event. */
        type?: string;
    }
    export interface FailureEventArgs {
        /** Defines the error information. */
        error?: Error;
    }
    export interface FilterEventArgs extends ActionEventArgs {
        /** Defines the object that is currently filtered. */
        currentFilterObject?: PredicateModel;
        /** Defines the column name that is currently filtered. */
        currentFilteringColumn?: string;
        /** Defines the collection of filtered columns. */
        columns?: PredicateModel[];
    }
    export interface GroupEventArgs extends ActionEventArgs {
        /** Defines the field name of the currently grouped columns. */
        columnName?: string;
    }
    export interface PageEventArgs extends ActionEventArgs {
        /** Defines the previous page number. */
        previousPage?: string;
        /** Defines the current page number. */
        currentPage?: string;
    }
    export interface SortEventArgs extends ActionEventArgs {
        /** Defines the field name of currently sorted column. */
        columnName?: string;
        /** Defines the direction of sort column. */
        direction?: SortDirection;
    }
    export interface SearchEventArgs extends ActionEventArgs {
        /** Defines the string value to search. */
        searchString?: string;
    }
    export interface PrintEventArgs extends ActionEventArgs {
        /** Defines the Grid element. */
        element?: Element;
        /** Defines the currently selected rows. */
        selectedRows?: NodeListOf<Element>;
        /** Cancel the print action */
        cancel?: boolean;
    }
    export interface DetailDataBoundEventArgs {
        /** Defines the details row element. */
        detailElement?: Element;
        /** Defines the selected row data. */
        data?: Object;
    }
    export interface ColumnChooserEventArgs {
        /** Defines the parent element. */
        element?: Element;
        /** Defines the display columns of column chooser. */
        columns?: Column[];
        /** Specifies the instance of column chooser dialog. */
        dialogInstance?: Object;
    }
    export interface RowDeselectEventArgs {
        /** Defines the current selected/deselected row data. */
        data?: Object;
        /** Defines the selected/deselected row index. */
        rowIndex?: number;
        /** Defines the selected/deselected row. */
        row?: Element;
        /** Define the foreignKey row data associated with this column */
        foreignKeyData?: Object;
    }
    export interface RowSelectEventArgs extends RowDeselectEventArgs {
        /** Defines the previously selected row index. */
        previousRowIndex?: number;
        /** Defines the previously selected row. */
        previousRow?: Element;
        /** Defines the target element for selection. */
        target?: Element;
        /** Define the foreignKey row data associated with this column */
        foreignKeyData?: Object;
    }
    export interface RecordDoubleClickEventArgs {
        /** Defines the target element. */
        target?: Element;
        /** Defines the cell element. */
        cell?: Element;
        /** Defines the cell index. */
        cellIndex?: number;
        /** Defines the column object. */
        column?: Column;
        /** Defines the name of the event. */
        name?: string;
        /** Defines the row element. */
        row?: Element;
        /** Defines the current row data. */
        rowData?: Object;
        /** Defines the row index. */
        rowIndex?: number;
        /** Define the foreignKey row data associated with this column */
        foreignKeyData?: Object;
    }
    export interface RowSelectingEventArgs extends RowSelectEventArgs {
        /** Defines whether CTRL key is pressed. */
        isCtrlPressed?: boolean;
        /** Defines whether SHIFT key is pressed. */
        isShiftPressed?: boolean;
    }
    export interface CellDeselectEventArgs {
        /** Defines the currently selected/deselected row data. */
        data?: Object;
        /** Defines the indexes of the current selected/deselected cells. */
        cellIndexes?: ISelectedCell[];
        /** Defines the currently selected/deselected cells. */
        cells?: Element[];
    }
    export interface CellSelectEventArgs extends CellDeselectEventArgs {
        /** Defines the index of the current selected cell. */
        cellIndex?: IIndex;
        /** Defines the previously selected cell index. */
        previousRowCellIndex?: number;
        /** Defines the element. */
        currentCell: Element;
        /** Defines the previously selected cell element. */
        previousRowCell?: Element;
    }
    export interface CellSelectingEventArgs extends CellSelectEventArgs {
        /** Defines whether the CTRL key is pressed or not. */
        isCtrlPressed?: boolean;
        /** Defines whether the SHIFT key is pressed or not. */
        isShiftPressed?: boolean;
    }
    export interface ColumnDragEventArgs {
        /** Defines the target element from which the drag starts. */
        target?: Element;
        /** Defines the type of the element dragged. */
        draggableType?: string;
        /** Defines the column object that is dragged. */
        column?: Column;
    }
    export interface RowDataBoundEventArgs {
        /** Defines the current row data. */
        data?: Object;
        /** Defines the row element. */
        row?: Element;
        /** Defines the row height */
        rowHeight?: number;
    }
    export interface QueryCellInfoEventArgs {
        /** Defines the row data associated with this cell. */
        data?: Object;
        /** Defines the cell element. */
        cell?: Element;
        /** Defines the column object associated with this cell. */
        column?: Column;
        /** Defines the no. of columns to be spanned */
        colSpan?: number;
        /** Define the foreignKey row data associated with this column */
        foreignKeyData?: Object;
    }
    export interface PdfQueryCellInfoEventArgs {
        /** Defines the column of the current cell. */
        column?: Column;
        /** Defines the style of the current cell. */
        style?: PdfStyle;
        /** Defines the value of the current cell. */
        value?: Date | string | number | boolean;
        /** Defines the no. of columns to be spanned */
        colSpan?: number;
    }
    export interface ExcelQueryCellInfoEventArgs {
        /** Defines the row data associated with this cell. */
        data?: Object;
        /** Defines the column of the current cell. */
        column: Column;
        /** Defines the value of the current cell. */
        value?: Date | string | number | boolean;
        /** Defines the style of the current cell. */
        style?: ExcelStyle;
        /** Defines the number of columns to be spanned */
        colSpan?: number;
    }
    export interface MultipleExport {
        /** Indicates whether to append the multiple grid in same sheet or different sheet */
        type?: MultipleExportType;
        /**  Defines the number of blank rows between the multiple grid data */
        blankRows?: number;
    }
    export interface ExcelRow {
        /**  Defines the index for cells */
        index?: number;
        /**  Defines the cells in a row */
        cells?: ExcelCell[];
    }
    export interface Border {
        /**  Defines the color of border */
        color?: string;
        /**  Defines the line style of border */
        lineStyle?: BorderLineStyle;
    }
    export interface ExcelStyle {
        /** Defines the color of font */
        fontColor?: string;
        /** Defines the name of font */
        fontName?: string;
        /** Defines the size of font */
        fontSize?: number;
        /** Defines the horizontal alignment for cell style */
        hAlign?: ExcelHAlign;
        /** Defines the vertical alignment for cell style */
        vAlign?: ExcelVAlign;
        /** Defines the bold style for fonts  */
        bold?: boolean;
        /** Defines the italic style for fonts */
        italic?: boolean;
        /** Defines the underline style for fonts */
        underline?: boolean;
        /** Defines the background color for cell style */
        backColor?: string;
        /** Defines the wrapText for cell style */
        wrapText?: boolean;
        /** Defines the borders for cell style */
        borders?: Border;
    }
    export interface PdfStyle {
        /** Defines the horizontal alignment */
        textAlignment?: PdfHAlign;
        /** Defines the brush color of font */
        textBrushColor?: string;
        /** Defines the pen color of font */
        textPenColor?: string;
        /** Defines the font family */
        fontFamily?: string;
        /** Defines the font size */
        fontSize?: number;
        /** Defines the font bold */
        bold?: boolean;
        /** Defines the italic font */
        italic?: boolean;
        /** Defines the underlined font */
        underline?: boolean;
        /** Defines the strike-out font */
        strikeout?: boolean;
        /** Defines the horizontal alignment */
        verticalAlignment?: PdfVAlign;
        /** Defines the background color */
        backgroundColor?: string;
        /** Defines the grid border */
        border?: PdfBorder;
    }
    export interface PdfBorder {
        /** Defines the border color */
        color?: string;
        /** Defines the border width */
        width?: number;
        /** Defines the border dash style */
        dashStyle?: PdfDashStyle;
    }
    export interface ExcelCell {
        /** Defines the index for the cell */
        index?: number;
        /** Defines the column span for the cell  */
        colSpan?: number;
        /** Defines the value of the cell */
        value?: string | boolean | number | Date;
        /** Defines the hyperlink of the cell */
        hyperlink?: Hyperlink;
        /** Defines the style of the cell */
        style?: ExcelStyle;
    }
    export interface Hyperlink {
        /** Defines the Url for hyperlink */
        target?: string;
        /** Defines the display text for hyperlink */
        displayText?: string;
    }
    export interface ExcelHeader {
        /** Defines the number of rows between the header and grid data */
        headerRows?: number;
        /** Defines the rows in header content */
        rows?: ExcelRow[];
    }
    export interface ExcelFooter {
        /** Defines the number of rows between the grid data and footer */
        footerRows?: number;
        /** Defines the rows in footer content */
        rows?: ExcelRow[];
    }
    export interface ExcelExportProperties {
        /** Defines the data source dynamically before exporting */
        dataSource?: Object | ej.data.DataManager;
        /** Exports multiple grid into the excel document */
        multipleExport?: MultipleExport;
        /** Defines the header content for exported document  */
        header?: ExcelHeader;
        /** Defines the footer content for exported document */
        footer?: ExcelFooter;
        /** Indicates to export current page or all page */
        exportType?: ExportType;
        /** Indicates whether to show the hidden columns in exported excel */
        includeHiddenColumn?: boolean;
        /** Defines the theme for exported data  */
        theme?: Theme;
    }
    export interface RowDragEventArgs {
        /** Defines the selected row's element. */
        rows?: Element;
        /** Defines the target element from which drag starts. */
        target?: Element;
        /** Defines the type of the element to be dragged.
         * @hidden
         */
        draggableType?: string;
        /** Defines the selected row data. */
        data?: Object[];
    }
    /**
     * @hidden
     */
    export interface EJ2Intance extends HTMLElement {
        ej2_instances: Object | Object[];
    }
    /**
     * @hidden
     */
    export interface IPosition {
        x: number;
        y: number;
    }
    /**
     * @hidden
     */
    export interface ParentDetails {
        parentID?: string;
        parentPrimaryKeys?: string[];
        parentKeyField?: string;
        parentKeyFieldValue?: string;
        parentRowData?: Object;
    }
    /**
     * @hidden
     */
    export interface VirtualInfo {
        data?: boolean;
        event?: string;
        block?: number;
        page?: number;
        currentPage?: number;
        direction?: string;
        blockIndexes?: number[];
        columnIndexes?: number[];
        columnBlocks?: number[];
        loadSelf?: boolean;
        loadNext?: boolean;
        nextInfo?: {
            page?: number;
        };
        sentinelInfo?: SentinelType;
        offsets?: Offsets;
    }
    /**
     * @hidden
     */
    export interface InterSection {
        container?: HTMLElement;
        pageHeight?: number;
        debounceEvent?: boolean;
        axes?: string[];
    }
    /**
     * @hidden
     */
    export interface ICancel {
        /** Defines the cancel option value. */
        cancel?: boolean;
    }
    /**
     * @hidden
     */
    export interface IPrimaryKey {
        /** Defines the primaryKey. */
        primaryKey?: string[];
    }
    /**
     * @hidden
     */
    export interface BeforeBatchAddArgs extends ICancel, IPrimaryKey {
        /** Defines the default data object. */
        defaultData?: Object;
    }
    /**
     * @hidden
     */
    export interface BatchDeleteArgs extends IPrimaryKey {
        /** Defines the deleted data. */
        rowData?: Object;
        /** Defines the row index. */
        rowIndex?: number;
    }
    /**
     * @hidden
     */
    export interface BeforeBatchDeleteArgs extends BatchDeleteArgs, ICancel {
        /** Defines the row element. */
        row?: Element;
    }
    /**
     * @hidden
     */
    export interface BeforeBatchSaveArgs extends ICancel {
        /** Defines the changed record object. */
        batchChanges?: Object;
    }
    /**
     * @hidden
     */
    export interface ResizeArgs extends ICancel {
        /** Event argument of point or touch action. */
        e?: MouseEvent | TouchEvent;
        /** Defines the resizing column details */
        column?: Column;
    }
    /**
     * @hidden
     */
    export interface BatchAddArgs extends ICancel, IPrimaryKey {
        /** Defines the added data. */
        defaultData?: Object;
        /** Defines the column index. */
        columnIndex?: number;
        /** Defines the row element. */
        row?: Element;
        /** Defines the cell element. */
        cell?: Element;
        /** Defines the column object. */
        columnObject?: Column;
    }
    /**
     * @hidden
     */
    export interface BeginEditArgs extends ICancel, IPrimaryKey {
        /** Defines the edited data. */
        rowData?: Object;
        /** Defines the edited row index. */
        rowIndex?: number;
        /** Defines the current edited row. */
        row?: Element;
        /** Defines the name of the event. */
        type?: string;
        /** Defines the primary key value. */
        primaryKeyValue?: string[];
    }
    export interface DeleteEventArgs {
        /** Defines the cancel option value. */
        cancel?: boolean;
        /** Defines the request type. */
        requestType?: string;
        /** Defines the foreign key record object (JSON). @hidden */
        foreignKeyData?: Object;
        /** Defines the record objects. */
        data?: Object[];
        /** Defines the selected rows for delete. */
        tr?: Element[];
        /** Defines the name of the event. */
        type?: string;
    }
    export interface AddEventArgs {
        /** If `cancel` is set to true, then the current action will stopped. */
        cancel?: boolean;
        /** Defines the request type. */
        requestType?: string;
        /** Defines the foreign key record object.
         * @hidden
         */
        foreignKeyData?: Object;
        /** Defines the record objects. */
        data?: Object;
        /** Defines the event name. */
        type?: string;
        /** Defines the previous data. */
        previousData?: Object;
        /** Defines the added row. */
        row?: Object;
        /** Added row index */
        index?: number;
    }
    export interface SaveEventArgs extends AddEventArgs {
        /** Defines the previous data. */
        previousData?: Object;
        /** Defines the selected row index. */
        selectedRow?: number;
        /** Defines the current action. */
        action?: string;
        /** Added row index */
        index?: number;
    }
    export interface EditEventArgs extends BeginEditArgs {
        /** Defines the request type. */
        requestType?: string;
        /** Defines foreign data object. */
        foreignKeyData?: Object;
        addRecord?(data?: Object, index?: number): void;
    }
    /**
     * @hidden
     */
    export interface CellEditSameArgs extends ICancel {
        /** Defines the row data object. */
        rowData?: Object;
        /** Defines the column name. */
        columnName?: string;
        /** Defines the cell object. */
        cell?: Element;
        /** Defines the column object. */
        columnObject?: Column;
        /** Defines the cell value. */
        value?: string;
        /** Defines isForeignKey option value. */
        isForeignKey?: boolean;
    }
    /**
     * @hidden
     */
    export interface CellEditArgs extends CellEditSameArgs, IPrimaryKey {
        /** Defines the current row. */
        row?: Element;
        /** Defines the validation rules. */
        validationRules?: Object;
        /** Defines the name of the event. */
        type?: string;
        /** Defines foreign data object */
        foreignKeyData?: Object;
    }
    export interface IFilterCreate {
        column?: Column;
        target?: HTMLElement;
        getOptrInstance?: FlMenuOptrUI;
        localizeText?: ej.base.L10n;
        dialogObj?: ej.popups.Dialog;
    }
    /**
     * @hidden
     */
    export interface CellSaveArgs extends CellEditSameArgs {
        /** Defines the previous value of the cell. */
        previousValue?: string;
    }
    /**
     * @hidden
     */
    export interface BeforeDataBoundArgs {
        /** Defines the data. */
        result?: Object[];
        /** Defines the data count. */
        count?: number;
    }
    /**
     * @hidden
     */
    export interface IEdit {
        formObj?: ej.inputs.FormValidator;
        destroy?: Function;
        closeEdit?(): void;
        deleteRecord?(fieldname?: string, data?: Object): void;
        startEdit?(tr?: Element): void;
        endEdit?(): void;
        closeEdit?(): void;
        addRecord?(data?: Object, index?: number): void;
        deleteRow?(tr: HTMLTableRowElement): void;
        endEdit?(data?: Object): void;
        batchSave?(): void;
        getBatchChanges?(): Object;
        removeRowObjectFromUID?(uid: string): void;
        addRowObject?(row: Row<Column>): void;
        editCell?(index: number, field: string, isAdd?: boolean): void;
        updateCell?(rowIndex: number, field: string, value: string | number | boolean | Date): void;
        updateRow?(index: number, data: Object): void;
        saveCell?(isForceSave?: boolean): void;
    }
    /**
     * @hidden
     */
    export interface CheckBoxChangeEventArgs extends ICancel {
        /** Defines the checked state. */
        checked?: boolean;
        /** Defines the selected row indexes. */
        selectedRowIndexes?: number[];
        /** Defines the target element for selection. */
        target?: Element;
    }
    /**
     * @hidden
     */
    export interface BeforeCopyEventArgs extends ICancel {
        /** Defines the grid copied data. */
        data?: string;
    }
    /**
     * Defines options for custom command buttons.
     */
    export interface CommandButtonOptions extends ej.buttons.ButtonModel {
        /**
         * Defines handler for the click event.
         */
        click?: ej.base.EmitType<Event>;
    }
    /**
     * Define options for custom command buttons.
     */
    export interface CommandModel {
        /**
         * Define the command Button type
         */
        type?: CommandButtonType;
        /**
         * Define the button model
         */
        buttonOption?: CommandButtonOptions;
    }
    /**
     * Defines the pending state for Custom Service Data
     */
    export interface PendingState {
        /**
         * The function which resolves the current action's promise.
         */
        resolver?: Function;
        /**
         * Defines the current state of the action.
         */
        isPending?: Boolean;
        /**
         * Grouping property for Custom data service
         */
        group?: string[];
    }
    /**
     * Sorting property for Custom data Service
     */
    export interface Sorts {
        /** Defines the field to be sorted */
        name?: string;
        /** Defines the direction of sorting */
        direction?: string;
    }
    /** Custom data service event types */
    export interface DataStateChangeEventArgs {
        /** Defines the skip count in datasource record */
        skip?: number;
        /** Defines the page size */
        take?: number;
        /** Defines the filter criteria  */
        where?: PredicateModel[];
        /** Defines the sorted field and direction */
        sorted?: Sorts[];
        /** Defines the grouped field names */
        group?: string[];
        /** Defines the search criteria */
        search?: PredicateModel[];
        /** Defines the grid action details performed by paging, grouping, filtering, searching, sorting */
        action?: PageEventArgs | GroupEventArgs | FilterEventArgs | SearchEventArgs | SortEventArgs;
        /** Defines the remote table name */
        table?: string;
        /** Defines the selected field names */
        select?: string[];
        /** If `count` is set true, then the remote service needs to return records and count */
        count?: boolean;
    }
    export interface DataSourceChangedEventArgs {
        /** Defines the current action type. */
        requestType?: string;
        /** Defines the current action. */
        action?: string;
        /** Defines the primary column field */
        key?: string | string[];
        /** Defines the state of the performed action */
        state?: DataStateChangeEventArgs;
        /** Defines the selected row data. */
        data?: Object | Object[];
        /** Defines the primary key value */
        primaryKeyValues?: Object[];
        /** Defines the index value */
        index?: number;
        /** Defines the end of editing function. */
        endEdit?: Function;
        /** Defines the changes made in batch editing */
        changes?: Object;
        /** Defines the query */
        query?: ej.data.Query;
    }
    /**
     * @hidden
     */
    export interface CheckBoxChangeEventArgs extends ICancel {
        /** Defines the checked state. */
        checked?: boolean;
        /** Defines the selected row indexes. */
        selectedRowIndexes?: number[];
        /** Defines the target element for selection. */
        target?: Element;
    }
    /**
     * @hidden
     */
    export interface BeforeCopyEventArgs extends ICancel {
        /** Defines the grid copied data. */
        data?: string;
    }
    /**
     * @hidden
     */
    export interface IFocus {
        matrix: Matrix;
        onKeyPress?: Function;
        onClick?: Function;
        onFocus?: Function;
        jump?: (action: string, current: number[]) => SwapInfo;
        getFocusInfo?: () => FocusInfo;
        getFocusable?: (element: HTMLElement) => HTMLElement;
        selector?: (row: Row<Column>, cell: Cell<Column>) => boolean;
        generateRows?: (rows: Row<Column>[], optionals?: Object) => void;
        getInfo?: (e?: ej.base.KeyboardEventArgs) => FocusedContainer;
        validator?: () => Function;
        getNextCurrent?: (previous: number[], swap?: SwapInfo, active?: IFocus, action?: string) => number[];
        preventDefault?: (e: ej.base.KeyboardEventArgs, info: FocusInfo) => void;
    }
    /**
     * @hidden
     */
    export interface FocusInfo {
        element?: HTMLElement;
        elementToFocus?: HTMLElement;
        outline?: boolean;
        class?: string;
        skipAction?: boolean;
    }
    /**
     * @hidden
     */
    export interface CellFocusArgs {
        element?: HTMLElement;
        parent?: HTMLElement;
        indexes?: number[];
        byKey?: boolean;
        byClick?: boolean;
        keyArgs?: ej.base.KeyboardEventArgs;
        clickArgs?: Event;
        isJump?: boolean;
        container?: FocusedContainer;
        outline?: boolean;
        cancel?: boolean;
    }
    /**
     * @hidden
     */
    export interface FocusedContainer {
        isContent?: boolean;
        isHeader?: boolean;
        isDataCell?: boolean;
        isFrozen?: boolean;
        isStacked?: boolean;
        isSelectable?: boolean;
        indexes?: number[];
    }
    /**
     * @hidden
     */
    export interface SwapInfo {
        swap?: boolean;
        toHeader?: boolean;
        toFrozen?: boolean;
        current?: number[];
    }
    /**
     * @hidden
     */
    export interface SwapInfo {
        swap?: boolean;
        toHeader?: boolean;
        toFrozen?: boolean;
        current?: number[];
    }
    export interface ContextMenuItemModel extends ej.navigations.MenuItemModel {
        target?: string;
    }
    /**
     * @hidden
     */
    export interface IFilter {
        type?: string;
        dataSource?: Object[] | ej.data.DataManager;
        hideSearchbox?: boolean;
        itemTemplate?: string;
        ui?: IFilterMUI;
    }
    /**
     * @hidden
     */
    export interface IFilterArgs {
        type?: string;
        field?: string;
        displayName?: string;
        query?: ej.data.Query;
        dataSource?: Object[] | ej.data.DataManager;
        format?: string;
        filteredColumns?: Object[];
        sortedColumns?: string[];
        localizedStrings?: Object;
        position?: {
            X: number;
            Y: number;
        };
        formatFn?: Function;
        parserFn?: Function;
        hideSearchbox?: boolean;
        allowCaseSensitive?: boolean;
        handler?: Function;
        template?: Function;
        target?: Element;
        foreignKeyValue?: string;
        column?: Column;
        actualPredicate?: {
            [key: string]: PredicateModel[];
        };
    }
    export interface PdfExportProperties {
        /** Defines the Pdf orientation. */
        pageOrientation?: PageOrientation;
        /** Defines the Pdf page size. */
        pageSize?: PdfPageSize;
        /** Defines the Pdf header. */
        header?: PdfHeader;
        /** Defines the Pdf footer. */
        footer?: PdfFooter;
        /** Indicates whether to show the hidden columns in exported Pdf */
        includeHiddenColumn?: boolean;
        /** Defines the data source dynamically before exporting */
        dataSource?: Object | ej.data.DataManager;
        /** Indicates to export current page or all page */
        exportType?: ExportType;
        /** Defines the theme for exported data  */
        theme?: Theme;
    }
    export interface Theme {
        /** Defines the style of header content. */
        header?: ThemeStyle;
        /** Defines the theme style of record content. */
        record?: ThemeStyle;
        /** Defines the theme style of caption content. */
        caption?: ThemeStyle;
    }
    export interface ThemeStyle {
        /** Defines the font color of theme style. */
        fontColor?: string;
        /** Defines the font name of theme style. */
        fontName?: string;
        /** Defines the font size of theme style. */
        fontSize?: number;
        /** Defines the bold of theme style. */
        bold?: boolean;
        /** Defines the borders of theme style. */
        borders?: Border;
    }
    export interface PdfHeader {
        /** Defines the header content distance from top. */
        fromTop?: number;
        /** Defines the height of header content. */
        height?: number;
        /** Defines the header contents. */
        contents?: PdfHeaderFooterContent[];
    }
    export interface PdfFooter {
        /** Defines the footer content distance from bottom. */
        fromBottom?: number;
        /** Defines the height of footer content. */
        height?: number;
        /** Defines the footer contents */
        contents?: PdfHeaderFooterContent[];
    }
    export interface PdfHeaderFooterContent {
        /** Defines the content type */
        type: ContentType;
        /** Defines the page number type */
        pageNumberType?: PdfPageNumberType;
        /** Defines the style of content */
        style?: PdfContentStyle;
        /** Defines the pdf points for drawing line */
        points?: PdfPoints;
        /** Defines the format for customizing page number */
        format?: string;
        /** Defines the position of the content */
        position?: PdfPosition;
        /** Defines the size of content */
        size?: PdfSize;
        /** Defines the base64 string for image content type */
        src?: string;
        /** Defines the value for content */
        value?: any;
    }
    export interface PdfPosition {
        /** Defines the x position */
        x: number;
        /** Defines the y position */
        y: number;
    }
    export interface PdfSize {
        /** Defines the height */
        height: number;
        /** Defines the width */
        width: number;
    }
    export interface PdfPoints {
        /** Defines the x1 position */
        x1: number;
        /** Defines the y1 position */
        y1: number;
        /** Defines the x2 position */
        x2: number;
        /** Defines the y2 position */
        y2: number;
    }
    export interface PdfContentStyle {
        /** Defines the pen color. */
        penColor?: string;
        /** Defines the pen size. */
        penSize?: number;
        /** Defines the dash style. */
        dashStyle?: PdfDashStyle;
        /** Defines the text brush color. */
        textBrushColor?: string;
        /** Defines the text pen color. */
        textPenColor?: string;
        /** Defines the font size. */
        fontSize?: number;
        /** Defines the horizontal alignment. */
        hAlign?: PdfHAlign;
        /** Defines the vertical alignment. */
        vAlign?: PdfVAlign;
    }
    /**
     * Defines the context menu item model.
     */
    export interface ContextMenuItemModel extends ej.navigations.MenuItemModel {
        /**
         * Define the target to show the menu item.
         */
        target?: string;
    }
    export interface ColumnMenuItemModel extends ej.navigations.MenuItemModel {
        hide?: boolean;
    }
    export interface ColumnMenuOpenEventArgs extends ej.navigations.BeforeOpenCloseMenuEventArgs {
        column?: Column;
    }
    export interface ColumnMenuClickEventArgs extends ej.navigations.MenuEventArgs {
        column?: Column;
    }
    export interface ContextMenuClickEventArgs extends ej.navigations.MenuEventArgs {
        column?: Column;
    }
    export interface ContextMenuOpenEventArgs extends ej.navigations.BeforeOpenCloseMenuEventArgs {
        column?: Column;
    }
    export interface ExcelExportCompleteArgs {
        /** Defines the promise object for blob data. */
        promise?: Promise<{
            blobData: Blob;
        }>;
    }
    export interface PdfExportCompleteArgs {
        /** Defines the promise object for blob data. */
        promise?: Promise<{
            blobData: Blob;
        }>;
    }
    export interface SelectionNotifyArgs extends NotifyArgs {
        row?: HTMLElement;
        CheckState?: boolean;
    }
    export interface DataResult {
        result: Object[] | Group[];
        count: number;
    }
    
    /**
     * Exports types used by Grid.
     */
    export type ValueType = number | string | Date | boolean;
    export type ValueAccessor = (field: string, data: Object, column: ColumnModel) => Object;
    export type SortComparer = (x: ValueType, y: ValueType) => number;
    export type CustomSummaryType = (data: Object[] | Object, column: AggregateColumnModel) => Object;
    export type ReturnType = {
        result: Object[];
        count: number;
        aggregates?: Object;
    };
    export type SentinelType = {
        check?: (rect: ClientRect, info: SentinelType) => boolean;
        top?: number;
        entered?: boolean;
        axis?: string;
    };
    export type SentinelInfo = {
        up?: SentinelType;
        down?: SentinelType;
        right?: SentinelType;
        left?: SentinelType;
    };
    export type Offsets = {
        top?: number;
        left?: number;
    };
    
    /**
     * Function to check whether target object implement specific interface
     * @param  {Object} target
     * @param  {string} checkFor
     * @returns no
     * @hidden
     */
    export function doesImplementInterface(target: Object, checkFor: string): boolean;
    /**
     * Function to get value from provided data
     * @param  {string} field
     * @param  {Object} data
     * @param  {IColumn} column
     * @hidden
     */
    export function valueAccessor(field: string, data: Object, column: ColumnModel): Object;
    /**
     * The function used to update Dom using requestAnimationFrame.
     * @param  {Function} fn - Function that contains the actual action
     * @return {Promise<T>}
     * @hidden
     */
    export function getUpdateUsingRaf<T>(updateFunction: Function, callBack: Function): void;
    /**
     * @hidden
     */
    export function iterateArrayOrObject<T, U>(collection: U[], predicate: (item: Object, index: number) => T): T[];
    /** @hidden */
    export function templateCompiler(template: string): Function;
    /** @hidden */
    export function setStyleAndAttributes(node: Element, customAttributes: {
        [x: string]: Object;
    }): void;
    /** @hidden */
    export function extend(copied: Object, first: Object, second?: Object, exclude?: string[]): Object;
    /** @hidden */
    export function prepareColumns(columns: Column[] | string[] | ColumnModel[], autoWidth?: boolean): Column[];
    /** @hidden */
    export function setCssInGridPopUp(popUp: HTMLElement, e: MouseEvent | TouchEvent, className: string): void;
    /** @hidden */
    export function getActualProperties<T>(obj: T): T;
    /** @hidden */
    export function parentsUntil(elem: Element, selector: string, isID?: boolean): Element;
    /** @hidden */
    export function getElementIndex(element: Element, elements: Element[]): number;
    /** @hidden */
    export function inArray(value: Object, collection: Object[]): number;
    /** @hidden */
    export function getActualPropFromColl(collection: Object[]): Object[];
    /** @hidden */
    export function removeElement(target: Element, selector: string): void;
    /** @hidden */
    export function getPosition(e: MouseEvent | TouchEvent): IPosition;
    /** @hidden */
    export function getUid(prefix: string): string;
    /** @hidden */
    export function appendChildren(elem: Element, children: Element[]): Element;
    /** @hidden */
    export function parents(elem: Element, selector: string, isID?: boolean): Element[];
    /** @hidden */
    export function calculateAggregate(type: AggregateType | string, data: Object, column?: AggregateColumnModel, context?: Object): Object;
    /** @hidden */
    export function getScrollBarWidth(): number;
    /** @hidden */
    export function getRowHeight(element?: HTMLElement): number;
    /** @hidden */
    export function isEditable(col: Column, type: string, elem: Element): boolean;
    /** @hidden */
    export function isActionPrevent(inst: IGrid): boolean;
    /** @hidden */
    export function wrap(elem: any, action: boolean): void;
    export function changeButtonType(target: Element): void;
    /** @hidden */
    export function setFormatter(serviceLocator?: ServiceLocator, column?: Column): void;
    /** @hidden */
    export function addRemoveActiveClasses(cells: Element[], add: boolean, ...args: string[]): void;
    /** @hidden */
    export function distinctStringValues(result: string[]): string[];
    /** @hidden */
    export function getFilterMenuPostion(target: Element, dialogObj: ej.popups.Dialog, grid: IGrid): void;
    /** @hidden */
    export function getZIndexCalcualtion(args: {
        popup: ej.popups.Popup;
    }, dialogObj: ej.popups.Dialog): void;
    /** @hidden */
    export function toogleCheckbox(elem: Element): void;
    /** @hidden */
    export function createCboxWithWrap(uid: string, elem: Element, className?: string): Element;
    /** @hidden */
    export function removeAddCboxClasses(elem: Element, checked: boolean): void;
    /**
     * Refresh the Row model's foreign data.
     * @param row - Grid Row model object.
     * @param columns - Foreign columns array.
     * @param data - Updated Row data.
     * @hidden
     */
    export function refreshForeignData(row: IRow<Column>, columns: Column[], data: Object): void;
    /**
     * Get the foreign data for the corresponding cell value.
     * @param column - Foreign Key column
     * @param data - Row data.
     * @param lValue - cell value.
     * @param foreignData - foreign data source.
     * @hidden
     */
    export function getForeignData(column: Column, data?: Object, lValue?: string | number, foreignKeyData?: Object[]): Object[];
    /**
     * To use to get the column's object by the foreign key value.
     * @param foreignKeyValue - Defines ForeignKeyValue.
     * @param columns - Array of column object.
     * @hidden
     */
    export function getColumnByForeignKeyValue(foreignKeyValue: string, columns: Column[]): Column;
    /**
     * @hidden
     * @param filterObject - Defines predicate model object
     */
    export function getDatePredicate(filterObject: PredicateModel): Predicate;
    /**
     * @hidden
     */
    export function renderMovable(ele: Element, frzCols: number): Element;
    
    /**
     * Interface for a class AggregateColumn
     */
    export interface AggregateColumnModel {
    
        /**
         * Defines the aggregate type of a particular column.
         * To use multiple aggregates for single column, specify the `type` as array.
         * Types of aggregate are,
         * * sum
         * * average
         * * max
         * * min
         * * count
         * * truecount
         * * falsecount
         * * custom
         * > Specify the `type` value as `custom` to use custom aggregation.
         * 
         * @default null
         */
        type?: AggregateType | AggregateType[] | string;
    
        /**
         * Defines the column name to perform aggregation.
         * @default null
         */
        field?: string;
    
        /**
         * Defines the column name to display the aggregate value. If `columnName` is not defined,
         * then `field` name value will be assigned to the `columnName` property.
         * @default null
         */
        columnName?: string;
    
        /**
         * Format is applied to a calculated value before it is displayed.
         * Gets the format from the user, which can be standard or custom
         * [`number`](../base/intl.html#number-formatter-and-parser)
         * and [`date`](../base/intl.html#date-formatter-and-parser) formats.
         * @default null    
         */
        format?: string | ej.base.NumberFormatOptions | ej.base.DateFormatOptions;
    
        /**
         * Defines the footer cell template as a string for the aggregate column.
         * The `type` name should be used to access aggregate values inside the template.
         * 
         * {% codeBlock src="grid/footer-template-api/index.ts" %}{% endcodeBlock %}
         * @default null
         */
        footerTemplate?: string;
    
        /**
         * Defines the group footer cell template as a string for the aggregate column. 
         * The `type` name should be used to access aggregate values inside the template.
         * Additionally, the following fields can be accessed in the template.
         * * **field**: The current grouped field.
         * * **key**: The current grouped value.
         * 
         * {% codeBlock src="grid/group-footer-api/index.ts" %}{% endcodeBlock %}
         * @default null
         */
        groupFooterTemplate?: string;
    
        /**
         * Defines the group caption cell template as a string for the aggregate column.
         * The `type` name should be used to access aggregate values inside the template.
         * Additionally, the following fields can be accessed in the template.
         * * **field**: The current grouped field name.
         * * **key**: The current grouped field value.
         * 
         * {% codeBlock src="grid/group-caption-api/index.ts" %}{% endcodeBlock %}
         * @default null
         */
        groupCaptionTemplate?: string;
    
        /**
         * Defines a function to calculate custom aggregate value. The `type` value should be set to `custom`.
         * To use custom aggregate value in the template, use the key as `${custom}`.
         * **Total aggregation**: The custom function will be called with the whole data and the current `AggregateColumn` object.
         * **Group aggregation**: This will be called with the current group details and the `AggregateColumn` object.
         * 
         * @default null
         */
        customAggregate?: CustomSummaryType;
    
    }
    
    /**
     * Interface for a class AggregateRow
     */
    export interface AggregateRowModel {
    
        /**
         * Configures the aggregate columns. 
         * @default []
         */
        columns?: AggregateColumnModel[];
    
    }
    
    /**
     * Configures the Grid's aggregate column.
     */
    export class AggregateColumn extends ej.base.ChildProperty<AggregateColumn> {
        private formatFn;
        private templateFn;
        /**
         * Defines the aggregate type of a particular column.
         * To use multiple aggregates for single column, specify the `type` as array.
         * Types of aggregate are,
         * * sum
         * * average
         * * max
         * * min
         * * count
         * * truecount
         * * falsecount
         * * custom
         * > Specify the `type` value as `custom` to use custom aggregation.
         *
         * @default null
         */
        type: AggregateType | AggregateType[] | string;
        /**
         * Defines the column name to perform aggregation.
         * @default null
         */
        field: string;
        /**
         * Defines the column name to display the aggregate value. If `columnName` is not defined,
         * then `field` name value will be assigned to the `columnName` property.
         * @default null
         */
        columnName: string;
        /**
         * Format is applied to a calculated value before it is displayed.
         * Gets the format from the user, which can be standard or custom
         * [`number`](../base/intl.html#number-formatter-and-parser)
         * and [`date`](../base/intl.html#date-formatter-and-parser) formats.
         * @default null
         */
        format: string | ej.base.NumberFormatOptions | ej.base.DateFormatOptions;
        /**
         * Defines the footer cell template as a string for the aggregate column.
         * The `type` name should be used to access aggregate values inside the template.
         *
         * {% codeBlock src="grid/footer-template-api/index.ts" %}{% endcodeBlock %}
         * @default null
         */
        footerTemplate: string;
        /**
         * Defines the group footer cell template as a string for the aggregate column.
         * The `type` name should be used to access aggregate values inside the template.
         * Additionally, the following fields can be accessed in the template.
         * * **field**: The current grouped field.
         * * **key**: The current grouped value.
         *
         * {% codeBlock src="grid/group-footer-api/index.ts" %}{% endcodeBlock %}
         * @default null
         */
        groupFooterTemplate: string;
        /**
         * Defines the group caption cell template as a string for the aggregate column.
         * The `type` name should be used to access aggregate values inside the template.
         * Additionally, the following fields can be accessed in the template.
         * * **field**: The current grouped field name.
         * * **key**: The current grouped field value.
         *
         * {% codeBlock src="grid/group-caption-api/index.ts" %}{% endcodeBlock %}
         * @default null
         */
        groupCaptionTemplate: string;
        /**
         * Defines a function to calculate custom aggregate value. The `type` value should be set to `custom`.
         * To use custom aggregate value in the template, use the key as `${custom}`.
         * **Total aggregation**: The custom function will be called with the whole data and the current `AggregateColumn` object.
         * **Group aggregation**: This will be called with the current group details and the `AggregateColumn` object.
         *
         * @default null
         */
        customAggregate: CustomSummaryType;
        /**
         * @hidden
         */
        setFormatter(): void;
        /**
         * @hidden
         */
        getFormatter(): Function;
        /**
         * @hidden
         */
        setTemplate(helper?: Object): void;
        /**
         * @hidden
         */
        getTemplate(type: CellType): {
            fn: Function;
            property: string;
        };
        /**
         * @hidden
         */
        setPropertiesSilent(prop: Object): void;
    }
    /**
     * Configures the aggregate rows.
     */
    export class AggregateRow extends ej.base.ChildProperty<AggregateRow> {
        /**
         * Configures the aggregate columns.
         * @default []
         */
        columns: AggregateColumnModel[];
    }
    
    /**
     * Cell
     * @hidden
     */
    export class Cell<T> {
        colSpan: number;
        rowSpan: number;
        cellType: CellType;
        visible: boolean;
        isTemplate: boolean;
        isDataCell: boolean;
        isSelected: boolean;
        column: T;
        rowID: string;
        index: number;
        colIndex: number;
        className: string;
        attributes: {
            [a: string]: Object;
        };
        isSpanned: boolean;
        cellSpan: number;
        spanText: string | number | boolean | Date;
        commands: CommandModel[];
        isForeignKey: boolean;
        foreignKeyData: Object;
        constructor(options: {
            [x: string]: Object;
        });
        clone(): Cell<T>;
    }
    
    /**
     * Represents Grid `Column` model class.
     */
    export class Column {
        /**
         * Defines the field name of column which is mapped with mapping name of DataSource.
         * The bounded columns can be sort, filter and group etc.,
         * The `field` name must be a valid JavaScript identifier,
         * the first character must be an alphabet and should not contain spaces and special characters.
         * @default undefined
         */
        field: string;
        /**
         * Gets the unique identifier value of the column. It is used to get the column object.
         * @default undefined
         */
        uid: string;
        /**
         * Defines the header text of column which is used to display in column header.
         * If `headerText` is not defined, then field name value will be assigned to header text.
         * @default undefined
         */
        headerText: string;
        /**
         * Defines the width of the column in pixels or percentage.
         * @default undefined
         */
        width: string | number;
        /**
         * Defines the minimum Width of the column in pixels or percentage.
         * @default undefined
         */
        minWidth: string | number;
        /**
         * Defines the maximum width of the column in pixel or percentage, which will restrict resizing beyond this pixel or percentage.
         * @default undefined
         */
        maxWidth: string | number;
        /**
         * Defines the alignment of the column in both header and content cells.
         * @default Left
         */
        textAlign: TextAlign;
        /**
         * Defines the cell content's overflow mode. The available modes are
         * * `Clip` -  Truncates the cell content when it overflows its area.
         * * `Ellipsis` -  Displays ellipsis when the cell content overflows its area.
         * * `EllipsisWithTooltip` - Displays ellipsis when the cell content overflows its area
         * also it will display tooltip while hover on ellipsis applied cell.
         * @default Ellipsis
         */
        clipMode: ClipMode;
        /**
         * Define the alignment of column header which is used to align the text of column header.
         * @default Left
         */
        headerTextAlign: TextAlign;
        /**
         * If `disableHtmlEncode` is set to true, it encodes the HTML of the header and content cells.
         * @default false
         */
        disableHtmlEncode: boolean;
        /**
         * Defines the data type of the column.
         * @default null
         */
        type: string;
        /**
         * It is used to change display value with the given format and does not affect the original data.
         * Gets the format from the user which can be standard or custom
         * [`number`](../base/intl.html#number-formatter-and-parser)
         * and [`date`](../base/intl.html#date-formatter-and-parser) formats.
         * @default null
         */
        format: string | ej.base.NumberFormatOptions | ej.base.DateFormatOptions;
        /**
         * If `visible` is set to false, hides the particular column. By default, columns are displayed.
         * @default true
         */
        visible: boolean;
        /**
         * Defines the column template that renders customized element in each cell of the column.
         * It accepts either [template string](../base/template-engine.html) or HTML element ID.
         * @default null
         */
        template: string;
        /**
         * Defines the header template as string or HTML element ID which is used to add customized element in the column header.
         * @default null
         */
        headerTemplate: string;
        /**
         * You can use this property to freeze selected columns in grid
         * @default false
         */
        isFrozen: boolean;
        /**
         * If `allowSorting` set to false, then it disables sorting option of a particular column.
         * By default all columns are sortable.
         * @default true
         */
        allowSorting: boolean;
        /**
         * If `allowResizing` is set to false, it disables resize option of a particular column.
         * By default all the columns can be resized.
         * @default true
         */
        allowResizing: boolean;
        /**
         * If `allowFiltering` set to false, then it disables filtering option and filter bar element of a particular column.
         * By default all columns are filterable.
         * @default true
         */
        allowFiltering: boolean;
        /**
         * If `allowGrouping` set to false, then it disables grouping of a particular column.
         * By default all columns are groupable.
         * @default true
         */
        allowGrouping: boolean;
        /**
         * If `showColumnMenu` set to false, then it disable the column menu of a particular column.
         * By default column menu will show for all columns
         * @default true
         */
        showColumnMenu: boolean;
        /**
         * If `enableGroupByFormat` set to true, then it groups the particular column by formatted values.
         * @default true
         */
        enableGroupByFormat: boolean;
        /**
         * If `allowEditing` set to false, then it disables editing of a particular column.
         * By default all columns are editable.
         * @default true
         */
        allowEditing: boolean;
        /**
         * The CSS styles and attributes of the content cells of a particular column can be customized.
         *
         * {% codeBlock src="grid/custom-attribute-api/index.ts" %}{% endcodeBlock %}
         * @default null
         */
        customAttributes: {
            [x: string]: Object;
        };
        /**
         * If `displayAsCheckBox` is set to true, it displays the column value as a check box instead of Boolean value.
         * @default false
         */
        displayAsCheckBox: boolean;
        /**
         * Defines the column data source which will act as foreign data source.
         * @default null
         */
        dataSource: Object[] | ej.data.DataManager;
        /**
         * Defines the method which is used to achieve custom formatting from an external function.
         * This function triggers before rendering of each cell.
         * {% codeBlock src="grid/formatter-api/index.ts" %}{% endcodeBlock %}
         * @default null
         */
        formatter: {
            new (): ICellFormatter;
        } | ICellFormatter | Function;
        /**
         * Defines the method used to apply custom cell values from external function and display this on each cell rendered.
         *
         * {% codeBlock src="grid/value-accessor-api/index.ts" %}{% endcodeBlock %}
         *
         * @default null
         */
        valueAccessor: ValueAccessor;
        /**
         * The `filterBarTemplate` is used to add a custom component instead of default input component for filter bar.
         * It have create and read functions.
         * * create: It is used for creating custom components.
         * * read: It is used to perform custom filter action.
         *
         * {% codeBlock src="grid/filter-template-api/index.ts" %}{% endcodeBlock %}
         * @default null
         */
        filterBarTemplate: IFilterUI;
        /**
         *  It is used to customize the default filter options for a specific columns.
         * * type -  Specifies the filter type as menu or checkbox.
         * * ui - to render custom component for specific column it has following functions.
         * * ui.create – It is used for creating custom components.
         * * ui.read -  It is used for read the value from the component.
         * * ui.write - It is used to apply component model as dynamically.
         * {% codeBlock src="grid/filter-menu-api/index.ts" %}{% endcodeBlock %}
         *
         * > Check the [`Filter UI`](./filtering.html#custom-component-in-filter-menu) for its customization.
         *  @default null
         */
        filter: IFilter;
        /**
         * Used to render multiple header rows(stacked headers) on the Grid header.
         * @default null
         */
        columns: Column[] | string[] | ColumnModel[];
        /**
         * Defines the tool tip text for stacked headers.
         * @default null
         * @hidden
         */
        toolTip: string;
        /**
         * If `isPrimaryKey` is set to true, considers this column as the primary key constraint.
         * @default false
         */
        isPrimaryKey: boolean;
        /**
         * Column visibility can change based on [`Media Queries`](http://cssmediaqueries.com/what-are-css-media-queries.html).
         * `hideAtMedia` accepts only valid Media Queries.
         * @default undefined
         */
        hideAtMedia?: string;
        /**
         * If `showInColumnChooser` set to false, then hide the particular column in column chooser.
         *  By default all columns are displayed in column Chooser.
         * @default true
         */
        showInColumnChooser?: boolean;
        /**
         * Defines the type of component for editable.
         * @default stringedit
         */
        editType: string;
        /**
         * Defines rules to validate data before creating and updating.
         * @default null
         */
        validationRules: Object;
        /**
         * Defines default values for the component when adding a new record to the Grid.
         * @default null
         */
        defaultValue: string;
        /**
         * Defines the `IEditCell` object to customize default edit cell.
         * @default {}
         */
        edit: IEditCell;
        /**
         * If `isIdentity` is set to true, then this column is considered as identity column.
         * @default false
         */
        isIdentity: boolean;
        /**
         * Defines the display column name from the foreign data source which will be obtained from comparing local and foreign data.
         * @default null
         */
        foreignKeyValue: string;
        /**
         * Defines the mapping column name of the foreign data source.
         * If it is not defined then the `columns.field` will be considered as mapping column name
         * @default null
         */
        foreignKeyField: string;
        /**
         * @hidden
         * Defines the commands column template as string or HTML element ID which is used to add
         * customized command buttons in each cells of the column.
         */
        commandsTemplate: string;
        /**
         * `commands` provides an option to display command buttons in every cell.
         * The available built-in command buttons are
         * * Edit - Edit the record.
         * * Delete - Delete the record.
         * * Save - Save the record.
         * * Cancel - Cancel the edit state.
         * {% codeBlock src="grid/command-column-api/index.ts" %}{% endcodeBlock %}
         * @default null
         */
        commands: CommandModel[];
        /**
         * @hidden
         * Gets the current view foreign key data.
         * @default []
         */
        columnData: Object[];
        constructor(options: ColumnModel);
        private formatFn;
        private parserFn;
        private templateFn;
        private fltrTemplateFn;
        private sortDirection;
        /** @hidden */
        getSortDirection(): string;
        /** @hidden */
        setSortDirection(direction: string): void;
        /** @hidden */
        setProperties(column: Column): void;
        /**
         * Defines the custom sort comparer function.
         * The sort comparer function has the same functionality like
         * [`Array.sort`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort) sort comparer.
         * {% codeBlock src="grid/sort-comparer-api/index.ts" %}{% endcodeBlock %}
         */
        sortComparer: (x: number | string, y: number | string) => number;
        /**
         * @hidden
         * It defines the column is foreign key column or not.
         */
        isForeignColumn(): boolean;
        /** @hidden */
        getFormatter(): Function;
        /** @hidden */
        setFormatter(value: Function): void;
        /** @hidden */
        getParser(): Function;
        /** @hidden */
        setParser(value: Function): void;
        /** @hidden */
        getColumnTemplate(): Function;
        /** @hidden */
        getFilterItemTemplate(): Function;
        /** @hidden */
        getDomSetter(): string;
    }
    /**
     * Interface for a class Column
     */
    export interface ColumnModel {
        /**
         * Defines the field name of column which is mapped with mapping name of DataSource.
         * The bounded columns can be sort, filter and group etc.,
         * If the `field` name contains “dot”, then it is considered as complex binding.
         * The `field` name must be a valid JavaScript identifier,
         * the first character must be an alphabet and should not contain spaces and special characters.
         * @default undefined
         */
        field?: string;
        /**
         * Gets the unique identifier value of the column. It is used to get the object.
         * @default undefined
         */
        uid?: string;
        /**
         * Defines the header text of column which is used to display in column header.
         * If `headerText` is not defined, then field name value will be assigned to header text.
         * @default undefined
         */
        headerText?: string;
        /**
         * Defines the width of the column in pixels or percentage.
         * @default undefined
         */
        width?: string | number;
        /**
         * Defines the minimum width of the column in pixels or percentage.
         * @default undefined
         */
        minWidth?: string | number;
        /**
         * Defines the maximum width of the column in pixel or percentage, which will restrict resizing beyond this pixel or percentage.
         * @default undefined
         */
        maxWidth?: string | number;
        /**
         * Defines the alignment of the column in both header and content cells.
         * @default Left
         */
        textAlign?: TextAlign;
        /**
         * Defines the cell content's overflow mode. The available modes are
         * * `Clip` -  Truncates the cell content when it overflows its area.
         * * `Ellipsis` -  Displays ellipsis when the cell content overflows its area.
         * * `EllipsisWithTooltip` - Displays ellipsis when the cell content overflows its area
         * also it will display tooltip while hover on ellipsis applied cell.
         * @default Ellipsis
         */
        clipMode?: ClipMode;
        /**
         * Define the alignment of column header which is used to align the text of column header.
         * @default Left
         * @hidden
         */
        headerTextAlign?: TextAlign;
        /**
         * If `disableHtmlEncode` is set to true, it encodes the HTML of the header and content cells.
         * @default false
         */
        disableHtmlEncode?: boolean;
        /**
         * Defines the data type of the column.
         * @default null
         */
        type?: string;
        /**
         * It is used to change display value with the given format and does not affect the original data.
         * Gets the format from the user which can be standard or custom
         * [`number`](../base/intl.html#number-formatter-and-parser)
         * and [`date`](../base/intl.html#date-formatter-and-parser) formats.
         * @default null
         */
        format?: string | ej.base.NumberFormatOptions | ej.base.DateFormatOptions;
        /**
         * If `visible` is set to false, hides the particular column. By default, all columns are displayed.
         * @default true
         */
        visible?: boolean;
        /**
         * Defines the column template that renders customized element in each cell of the column.
         * It accepts either [template string](../base/template-engine.html) or HTML element ID.
         * @default null
         */
        template?: string;
        /**
         * Defines the column template as string or HTML element ID which is used to add customized element in the column header.
         * @default null
         */
        headerTemplate?: string;
        /**
         * You can use this property to freeze selected columns in grid.
         * @default false
         */
        isFrozen?: boolean;
        /**
         * If `allowSorting` set to false, then it disables sorting option of a particular column.
         * By default all columns are sortable.
         * @default true
         */
        allowSorting?: boolean;
        /**
         * If `allowResizing` set to false, it disables resize option of a particular column.
         * @default true
         */
        allowResizing?: boolean;
        /**
         * If `showColumnMenu` set to false, then it disable the column menu of a particular column.
         * By default column menu will show for all columns
         * @default true
         */
        showColumnMenu?: boolean;
        /**
         * If `allowFiltering` set to false, then it disables filtering option and filter bar element of a particular column.
         * By default all columns are filterable.
         * @default true
         */
        allowFiltering?: boolean;
        /**
         * If `allowGrouping` set to false, then it disables grouping of a particular column.
         * By default all columns are groupable.
         * @default true
         */
        allowGrouping?: boolean;
        /**
         * If `enableGroupByFormat` set to true, then it groups the particular column by formatted values.
         * By default no columns are group by format.
         * @default true
         */
        enableGroupByFormat?: boolean;
        /**
         * If `allowEditing` set to false, then it disables editing of a particular column.
         * By default all columns are editable.
         * @default true
         */
        allowEditing?: boolean;
        /**
         * The CSS styles and attributes of the content cells of a particular column can be customized.
         *
         * ```html
         * <div id="Grid"></div>
         * ```
         * ```typescript
         * let gridObj: Grid = new Grid({
         * dataSource: filterData,
         * columns: [
         *    { field: 'OrderID', headerText: 'Order ID' },
         *    {
         *        field: 'EmployeeID', headerText: 'Employee ID', customAttributes: {
         *           class: 'employeeid',
         *           type: 'employee-id-cell'
         *      }
         *   }]
         * });
         * gridObj.appendTo('#Grid');
         * ```
         *
         * @default null
         */
        customAttributes?: {
            [x: string]: Object;
        };
        /**
         * If `displayAsCheckBox` is set to true, it displays the column value as a check box instead of Boolean value.
         * @default false
         */
        displayAsCheckBox?: boolean;
        /**
         * Defines the column data source  which will act as foreign data source.
         * @default null
         */
        dataSource?: Object[] | ej.data.DataManager;
        /**
         * Defines the method which is used to achieve custom formatting from an external function.
         * This function triggers before rendering of each cell.
         *
         * ```html
         * <div id="Grid"></div>
         * ```
         * ```typescript
         * class ExtendedFormatter implements ICellFormatter {
         * public getValue(column: Column, data: Object): Object {
         *   return '<span style="color:' + (data['Verified'] ? 'green' : 'red') + '"><i>' + data['Verified'] + '</i><span>';
         * }
         * }
         * let gridObj: Grid = new Grid({
         *     dataSource: filterData,
         *     columns: [
         *         { field: 'ShipName', headerText: 'Ship Name' },
         *         { field: 'Verified', headerText: 'Verified Status', formatter: ExtendedFormatter }]
         * });
         * gridObj.appendTo('#Grid');
         * ```
         *
         * @default null
         */
        formatter?: {
            new (): ICellFormatter;
        } | ICellFormatter | Function;
        /**
         * Defines the method used to apply custom cell values from external function and display this on each cell rendered.
         *
         * ```html
         * <div id="Grid"></div>
         * ```
         * ```typescript
         * let gridObj: Grid = new Grid({
         * dataSource: [{ EmployeeID: 1, EmployeeName: ['John', 'M'] }, { EmployeeID: 2, EmployeeName: ['Peter', 'A'] }],
         * columns: [
         *     { field: 'EmployeeID', headerText: 'Employee ID' },
         *     { field: 'EmployeeName', headerText: 'Employee First Name',
         *       valueAccessor: (field: string, data: Object, column: Column) => {
         *             return data['EmployeeName'][0];
         *         },
         *     }]
         * });
         * ```
         *
         * @default null
         */
        valueAccessor?: ValueAccessor;
        /**
         * The `filterBarTemplate` is used to add a custom component instead of default input component for filter bar.
         * It have create and read functions.
         * * create: It is used for creating custom components.
         * * read: It is used to perform custom filter action.
         *
         * ```html
         * <div id="Grid"></div>
         * ```
         * ```typescript
         * let gridObj: Grid = new Grid({
         * dataSource: filterData,
         * columns: [
         *   { field: 'OrderID', headerText: 'Order ID' },
         *   {
         *      field: 'EmployeeID', filterBarTemplate: {
         *         create: (args: { element: Element, column: Column }) => {
         *              let input: HTMLInputElement = document.createElement('input');
         *              input.id = 'EmployeeID';
         *              input.type = 'text';
         *              return input;
         *         },
         *         write: (args: { element: Element, column: Column }) => {
         *             args.element.addEventListener('input', args.column.filterBarTemplate.read as EventListener);
         *         },
         *         read: (args: { element: HTMLInputElement, columnIndex: number, column: Column }) => {
         *             gridObj.filterByColumn(args.element.id, 'equal', args.element.value);
         *        }
         *     }
         *  }],
         *   allowFiltering: true
         * });
         * gridObj.appendTo('#Grid');
         * ```
         *
         * @default null
         */
        filterBarTemplate?: IFilterUI;
        /**
         *  Defines the filter options to customize filtering for the particular column.
         *  @default null
         */
        filter?: IFilter;
        /**
         * Used to render multiple header rows(stacked headers) on the Grid header.
         * @default null
         */
        columns?: Column[] | string[] | ColumnModel[];
        /**
         * Defines the tool tip text for stacked headers.
         * @hidden
         * @default null
         */
        toolTip?: string;
        /**
         * If `isPrimaryKey` is set to true, considers this column as the primary key constraint.
         * @default false
         */
        isPrimaryKey?: boolean;
        /**
         * Defines the type of component for editing.
         * @default stringedit
         */
        editType?: string;
        /**
         * Defines rules to validate data before creating and updating.
         * @default null
         */
        validationRules?: Object;
        /**
         * Defines default values for the component when adding a new record to the Grid.
         * @default null
         */
        defaultValue?: string;
        /**
         * Defines the `IEditCell` object to customize default edit cell.
         * @default {}
         */
        edit?: IEditCell;
        /**
         * If `isIdentity` is set to true, then this column is considered as identity column.
         * @default false
         */
        isIdentity?: boolean;
        /**
         * Defines the mapping column name of the foreign data source.
         * If it is not defined then the `columns.field` will be considered as mapping column name
         * @default null
         */
        foreignKeyField?: string;
        /**
         * Defines the display column name from the foreign data source which will be obtained from comparing local and foreign data
         * @default null
         */
        foreignKeyValue?: string;
        /**
         * column visibility can change based on its [`Media Queries`](http://cssmediaqueries.com/what-are-css-media-queries.html).
         * `hideAtMedia` accepts only valid Media Queries.
         * @default undefined
         */
        hideAtMedia?: string;
        /**
         * If `showInColumnChooser` set to false, then hides the particular column in column chooser.
         * By default all columns are displayed in column Chooser.
         * @default true
         */
        showInColumnChooser?: boolean;
        /**
         * @hidden
         * Defines the commands column template as string or HTML element ID which is used to add
         * customized command buttons in each cells of the column.
         */
        commandsTemplate?: string;
        /**
         * `commands` provides an option to display command buttons in every cell.
         * The available built-in command buttons are
         * * Edit - Edit the record.
         * * Delete - Delete the record.
         * * Save - Save the record.
         * * Cancel - Cancel the edit state.
         *
         * The following code example implements the custom command column.
         * ```html
         * <style type="text/css" class="cssStyles">
         * .details-icon:before
         * {
         *    content:"\e74d";
         * }
         * </style>
         * <div id="Grid"></div>
         * ```
         * ```typescript
         * var gridObj = new Grid({
         * datasource: window.gridData,
         * columns : [
         *  { field: 'CustomerID', headerText: 'Customer ID' },
         *  { field: 'CustomerName', headerText: 'Customer Name' },
         *  {commands: [{buttonOption:{content: 'Details', click: onClick, cssClass: details-icon}}], headerText: 'Customer Details'}
         * ]
         * gridObj.appendTo("#Grid");
         * ```
         * @default null
         */
        commands?: CommandModel[];
        /**
         * It defines the custom sort comparer function.
         */
        sortComparer?: (x: number | string, y: number | string) => number;
        /**
         * @hidden
         * It defines the column is foreign key column or not.
         */
        isForeignColumn?: () => boolean;
    }
    
    /**
     * Export model files
     */
    
    /**
     * Interface for a class PageSettings
     */
    export interface PageSettingsModel {
    
        /**
         * Defines the number of records to be displayed per page.
         * @default 12
         */
        pageSize?: number;
    
        /**
         * Defines the number of pages to be displayed in the pager container.  
         * @default 8 
         */
        pageCount?: number;
    
        /**
         * Defines the current page number of the pager.
         * @default 1
         */
        currentPage?: number;
    
        /**
         * @hidden
         * Gets the total records count of the Grid. 
         */
        totalRecordsCount?: number;
    
        /**
         * If `enableQueryString` set to true,   
         * then it pass current page information as a query string along with the URL while navigating to other page.  
         * @default false  
         */
        enableQueryString?: boolean;
    
        /**
         * If `pageSizes` set to true or Array of values,
         * It renders DropDownList in the pager which allow us to select pageSize from DropDownList.      
         * @default false    
         */
        pageSizes?: boolean | number[];
    
        /**
         * Defines the template which renders customized elements in pager instead of default elements.     
         * It accepts either [template string](../base/template-engine.html) or HTML element ID.   
         * @default null    
         */
        template?: string;
    
    }
    
    /**
     * Configures the paging behavior of the Grid.
     */
    export class PageSettings extends ej.base.ChildProperty<PageSettings> {
        /**
         * Defines the number of records to be displayed per page.
         * @default 12
         */
        pageSize: number;
        /**
         * Defines the number of pages to be displayed in the pager container.
         * @default 8
         */
        pageCount: number;
        /**
         * Defines the current page number of the pager.
         * @default 1
         */
        currentPage: number;
        /**
         * @hidden
         * Gets the total records count of the Grid.
         */
        totalRecordsCount: number;
        /**
         * If `enableQueryString` set to true,
         * then it pass current page information as a query string along with the URL while navigating to other page.
         * @default false
         */
        enableQueryString: boolean;
        /**
         * If `pageSizes` set to true or Array of values,
         * It renders DropDownList in the pager which allow us to select pageSize from DropDownList.
         * @default false
         */
        pageSizes: boolean | number[];
        /**
         * Defines the template which renders customized elements in pager instead of default elements.
         * It accepts either [template string](../base/template-engine.html) or HTML element ID.
         * @default null
         */
        template: string;
    }
    
    /**
     * Row
     * @hidden
     */
    export class Row<T> {
        uid: string;
        data: Object;
        changes: Object;
        isDirty: boolean;
        edit: string;
        isSelected: boolean;
        isReadOnly: boolean;
        isAltRow: boolean;
        isDataRow: boolean;
        isExpand: boolean;
        rowSpan: number;
        cells: Cell<T>[];
        index: number;
        indent: number;
        subRowDetails: Object;
        height: string;
        visible: boolean;
        attributes: {
            [x: string]: Object;
        };
        cssClass: string;
        foreignKeyData: Object;
        constructor(options: {
            [x: string]: Object;
        });
        clone(): Row<T>;
    }
    
    /**
     * Edit render module is used to render grid edit row.
     * @hidden
     */
    export class BatchEditRender {
        private parent;
        /**
         * Constructor for render module
         */
        constructor(parent?: IGrid);
        update(elements: Element[], args: {
            columnObject?: Column;
            cell?: Element;
            row?: Element;
        }): void;
        private getEditElement(elements, args);
        removeEventListener(): void;
    }
    
    /**
     * `BooleanEditCell` is used to handle boolean cell type editing.
     * @hidden
     */
    export class BooleanEditCell implements IEditCell {
        private parent;
        private obj;
        private editRow;
        private editType;
        private activeClasses;
        constructor(parent?: IGrid);
        create(args: {
            column: Column;
            value: string;
            type: string;
        }): Element;
        read(element: Element): boolean;
        write(args: {
            rowData: Object;
            element: Element;
            column: Column;
            requestType: string;
            row: Element;
        }): void;
        private checkBoxChange(args);
        destroy(): void;
    }
    
    /**
     * `boolfilterui` render boolean column.
     * @hidden
     */
    export class BooleanFilterUI implements IFilterMUI {
        private parent;
        protected serviceLocator: ServiceLocator;
        private elem;
        private value;
        private filterSettings;
        private dropInstance;
        private dialogObj;
        constructor(parent?: IGrid, serviceLocator?: ServiceLocator, filterSettings?: FilterSettings);
        create(args: {
            column: Column;
            target: HTMLElement;
            getOptrInstance: FlMenuOptrUI;
            localizeText: ej.base.L10n;
            dialogObj: ej.popups.Dialog;
        }): void;
        write(args: {
            column: Column;
            target: Element;
            parent: IGrid;
            filteredValue: number | string | Date | boolean;
        }): void;
        read(element: Element, column: Column, filterOptr: string, filterObj: Filter): void;
        private ddActionComplete(e);
        private openPopup(args);
    }
    
    /**
     * GroupCaptionCellRenderer class which responsible for building group caption cell.
     * @hidden
     */
    export class GroupCaptionCellRenderer extends CellRenderer implements ICellRenderer<Column> {
        element: HTMLElement;
        /**
         * Function to render the cell content based on Column object.
         * @param  {Cell} cell
         * @param  {Object} data
         */
        render(cell: Cell<Column>, data: GroupedData): Element;
    }
    /**
     * GroupCaptionEmptyCellRenderer class which responsible for building group caption empty cell.
     * @hidden
     */
    export class GroupCaptionEmptyCellRenderer extends CellRenderer implements ICellRenderer<Column> {
        element: HTMLElement;
        /**
         * Function to render the cell content based on Column object.
         * @param  {Cell} cell
         * @param  {Object} data
         */
        render(cell: Cell<Column>, data: {
            field: string;
            key: string;
            count: number;
        }): Element;
    }
    
    /**
     * `CellMergeRender` module.
     * @hidden
     */
    export class CellMergeRender<T> {
        private serviceLocator;
        protected parent: IGrid;
        constructor(serviceLocator?: ServiceLocator, parent?: IGrid);
        render(cellArgs: QueryCellInfoEventArgs, row: Row<T>, i: number, td: Element): Element;
        private backupMergeCells(fName, data, span);
        private generteKey(fname, data);
        private splitKey(key);
        private containsKey(fname, data);
        private getMergeCells();
        private setMergeCells(key, span);
        updateVirtualCells(rows: Row<Column>[]): Row<Column>[];
        private getIndexFromAllColumns(field);
    }
    
    /**
     * CellRenderer class which responsible for building cell content.
     * @hidden
     */
    export class CellRenderer implements ICellRenderer<Column> {
        element: HTMLElement;
        private rowChkBox;
        protected localizer: ej.base.L10n;
        protected formatter: IValueFormatter;
        protected parent: IGrid;
        constructor(parent: IGrid, locator?: ServiceLocator);
        /**
         * Function to return the wrapper for the TD content
         * @returns string
         */
        getGui(): string | Element;
        /**
         * Function to format the cell value.
         * @param  {Column} column
         * @param  {Object} value
         * @param  {Object} data
         */
        format(column: Column, value: Object, data?: Object): string;
        evaluate(node: Element, cell: Cell<Column>, data: Object, attributes?: Object, fData?: Object): boolean;
        /**
         * Function to invoke the custom formatter available in the column object.
         * @param  {Column} column
         * @param  {Object} value
         * @param  {Object} data
         */
        invokeFormatter(column: Column, value: Object, data: Object): Object;
        /**
         * Function to render the cell content based on Column object.
         * @param  {Column} column
         * @param  {Object} data
         * @param  {{[x:string]:Object}} attributes?
         * @param  {Element}
         */
        render(cell: Cell<Column>, data: Object, attributes?: {
            [x: string]: Object;
        }): Element;
        /**
         * Function to refresh the cell content based on Column object.
         * @param  {Column} column
         * @param  {Object} data
         * @param  {{[x:string]:Object}} attributes?
         * @param  {Element}
         */
        refreshTD(td: Element, cell: Cell<Column>, data: Object, attributes?: {
            [x: string]: Object;
        }): void;
        private refreshCell(cell, data, attributes?);
        /**
         * Function to specifies how the result content to be placed in the cell.
         * @param  {Element} node
         * @param  {string|Element} innerHtml
         * @returns Element
         */
        appendHtml(node: Element, innerHtml: string | Element, property?: string): Element;
        /**
         * @hidden
         */
        setAttributes(node: HTMLElement, cell: Cell<Column>, attributes?: {
            [x: string]: Object;
        }): void;
        buildAttributeFromCell<Column>(node: HTMLElement, cell: Cell<Column>, isCheckBoxType?: boolean): void;
        getValue(field: string, data: Object, column: Column): Object;
    }
    
    /**
     * `CommandColumn` used to render command column in grid
     * @hidden
     */
    export class CommandColumnRenderer extends CellRenderer implements ICellRenderer<Column> {
        private buttonElement;
        private unbounDiv;
        element: HTMLElement;
        constructor(parent: IGrid, locator?: ServiceLocator);
        /**
         * Function to render the cell content based on Column object.
         * @param  {Column} column
         * @param  {Object} data
         * @param  {{[x:string]:Object}} attributes?
         * @param  {Element}
         */
        render(cell: Cell<Column>, data: Object, attributes?: {
            [x: string]: Object;
        }): Element;
        private renderButton(node, buttonOption, index);
    }
    
    /**
     * Content module is used to render grid content
     * @hidden
     */
    export class ContentRender implements IRenderer {
        private contentTable;
        private contentPanel;
        private rows;
        private freezeRows;
        private movableRows;
        private rowElements;
        private freezeRowElements;
        colgroup: Element;
        private isLoaded;
        private tbody;
        private drop;
        private args;
        private rafCallback;
        protected parent: IGrid;
        private serviceLocator;
        private ariaService;
        protected generator: IModelGenerator<Column>;
        /**
         * Constructor for content renderer module
         */
        constructor(parent?: IGrid, serviceLocator?: ServiceLocator);
        /**
         * The function is used to render grid content div
         */
        renderPanel(): void;
        /**
         * The function is used to render grid content table
         */
        renderTable(): void;
        /**
         * The function is used to create content table elements
         * @return {Element}
         * @hidden
         */
        createContentTable(id: String): Element;
        private splitRows(idx);
        /**
         * Refresh the content of the Grid.
         * @return {void}
         */
        refreshContentRows(args?: NotifyArgs): void;
        appendContent(tbody: Element, frag: DocumentFragment, args: NotifyArgs): void;
        /**
         * Get the content div element of grid
         * @return {Element}
         */
        getPanel(): Element;
        /**
         * Set the content div element of grid
         * @param  {Element} panel
         */
        setPanel(panel: Element): void;
        /**
         * Get the content table element of grid
         * @return {Element}
         */
        getTable(): Element;
        /**
         * Set the content table element of grid
         * @param  {Element} table
         */
        setTable(table: Element): void;
        /**
         * Get the Row collection in the Grid.
         * @returns {Row[] | HTMLCollectionOf<HTMLTableRowElement>}
         */
        getRows(): Row<Column>[] | HTMLCollectionOf<HTMLTableRowElement>;
        /**
         * Get the Movable Row collection in the Freeze pane Grid.
         * @returns {Row[] | HTMLCollectionOf<HTMLTableRowElement>}
         */
        getMovableRows(): Row<Column>[] | HTMLCollectionOf<HTMLTableRowElement>;
        /**
         * Get the content table data row elements
         * @return {Element}
         */
        getRowElements(): Element[];
        /**
         * Get the Freeze pane movable content table data row elements
         * @return {Element}
         */
        getMovableRowElements(): Element[];
        /**
         * Get the content table data row elements
         * @return {Element}
         */
        setRowElements(elements: Element[]): void;
        /**
         * Get the header colgroup element
         * @returns {Element}
         */
        getColGroup(): Element;
        /**
         * Set the header colgroup element
         * @param {Element} colgroup
         * @returns {Element}
         */
        setColGroup(colGroup: Element): Element;
        /**
         * Function to hide content table column based on visible property
         * @param  {Column[]} columns?
         */
        setVisible(columns?: Column[]): void;
        private colGroupRefresh();
        private initializeContentDrop();
        private canSkip(column, row, index);
        getModelGenerator(): IModelGenerator<Column>;
        renderEmpty(tbody: HTMLElement): void;
        setSelection(uid: string, set: boolean, clearAll?: boolean): void;
        getRowByIndex(index: number): Element;
        getVirtualRowIndex(index: number): number;
        getMovableRowByIndex(index: number): Element;
        private enableAfterRender(e);
    }
    
    /**
     * `datefilterui` render date column.
     * @hidden
     */
    export class DateFilterUI implements IFilterMUI {
        private parent;
        protected locator: ServiceLocator;
        private inputElem;
        private value;
        private datePickerObj;
        private fltrSettings;
        private dialogObj;
        constructor(parent?: IGrid, serviceLocator?: ServiceLocator, filterSettings?: FilterSettings);
        create(args: IFilterCreate): void;
        write(args: {
            column: Column;
            target: Element;
            parent: IGrid;
            filteredValue: number | string | Date | boolean;
        }): void;
        read(element: Element, column: Column, filterOptr: string, filterObj: Filter): void;
        private openPopup(args);
    }
    
    /**
     * `DatePickerEditCell` is used to handle datepicker cell type editing.
     * @hidden
     */
    export class DatePickerEditCell implements IEditCell {
        private parent;
        private obj;
        constructor(parent?: IGrid);
        create(args: {
            column: Column;
            value: string;
            type: string;
        }): Element;
        read(element: Element): string | Date;
        write(args: {
            rowData: Object;
            element: Element;
            column: Column;
            type: string;
        }): void;
        destroy(): void;
    }
    
    /**
     * `DefaultEditCell` is used to handle default cell type editing.
     * @hidden
     */
    export class DefaultEditCell implements IEditCell {
        private parent;
        constructor(parent?: IGrid);
        create(args: {
            column: Column;
            value: string;
            requestType: string;
        }): Element;
        read(element: Element): string;
        write(args: {
            rowData: Object;
            element: Element;
            column: Column;
            requestType: string;
        }): void;
    }
    
    /**
     * ExpandCellRenderer class which responsible for building group expand cell.
     * @hidden
     */
    export class DetailExpandCellRenderer extends CellRenderer implements ICellRenderer<Column> {
        element: HTMLElement;
        /**
         * Function to render the detail expand cell
         */
        render(cell: Cell<Column>, data: Object, attributes: Object): Element;
    }
    
    /**
     * DetailHeaderIndentCellRenderer class which responsible for building detail header indent cell.
     * @hidden
     */
    export class DetailHeaderIndentCellRenderer extends CellRenderer implements ICellRenderer<Column> {
        element: HTMLElement;
        /**
         * Function to render the detail indent cell
         * @param  {Cell} cell
         * @param  {Object} data
         */
        render(cell: Cell<Column>, data: Object): Element;
    }
    
    /**
     * Edit render module is used to render grid edit row.
     * @hidden
     */
    export class DialogEditRender {
        private parent;
        private l10n;
        private isEdit;
        private serviceLocator;
        private dialog;
        private dialogObj;
        /**
         * Constructor for render module
         */
        constructor(parent?: IGrid, serviceLocator?: ServiceLocator);
        private setLocaleObj();
        addNew(elements: Element[], args: {
            primaryKeyValue?: string[];
        }): void;
        update(elements: Element[], args: {
            primaryKeyValue?: string[];
        }): void;
        private createDialog(elements, args);
        private btnClick(e);
        private dialogClose();
        private destroy(args?);
        private getEditElement(elements);
        removeEventListener(): void;
    }
    
    /**
     * `DropDownEditCell` is used to handle dropdown cell type editing.
     * @hidden
     */
    export class DropDownEditCell implements IEditCell {
        private parent;
        private obj;
        private column;
        constructor(parent?: IGrid);
        create(args: {
            column: Column;
            value: string;
        }): Element;
        write(args: {
            rowData: Object;
            element: Element;
            column: Column;
            requestType: string;
        }): void;
        read(element: Element): string;
        private ddActionComplete(e);
        private dropDownOpen(args);
        destroy(): void;
    }
    
    /**
     * Edit render module is used to render grid edit row.
     * @hidden
     */
    export class EditRender {
        private editType;
        protected parent: IGrid;
        private renderer;
        protected serviceLocator: ServiceLocator;
        private focus;
        /**
         * Constructor for render module
         */
        constructor(parent?: IGrid, serviceLocator?: ServiceLocator);
        addNew(args: {
            rowData?: Object;
            columnName?: string;
            columnObject?: Column;
            requestType?: string;
            cell?: Element;
            row?: Element;
            primaryKeyValue?: string[];
        }): void;
        update(args: {
            rowData?: Object;
            columnName?: string;
            columnObject?: Column;
            requestType?: string;
            cell?: Element;
            row?: Element;
            primaryKeyValue?: string[];
        }): void;
        private convertWidget(args);
        private focusElement(elem, type?);
        private getEditElements(args);
        destroy(): void;
    }
    
    /**
     * ExpandCellRenderer class which responsible for building group expand cell.
     * @hidden
     */
    export class ExpandCellRenderer extends IndentCellRenderer implements ICellRenderer<Column> {
        /**
         * Function to render the expand cell
         * @param  {Cell} cell
         * @param  {Object} data
         */
        render(cell: Cell<Column>, data: {
            field: string;
            key: string;
        }): Element;
    }
    
    /**
     * FilterCellRenderer class which responsible for building filter cell.
     * @hidden
     */
    export class FilterCellRenderer extends CellRenderer implements ICellRenderer<Column> {
        element: HTMLElement;
        /**
         * Function to return the wrapper for the TH content.
         * @returns string
         */
        getGui(): string | Element;
        /**
         * Function to render the cell content based on Column object.
         * @param  {Cell} cell
         * @param  {Object} data
         */
        render(cell: Cell<Column>, data: Object): Element;
        /**
         * Function to specifies how the result content to be placed in the cell.
         * @param  {Element} node
         * @param  {string|Element} innerHTML
         * @returns Element
         */
        appendHtml(node: Element, innerHtml: string | Element): Element;
    }
    
    /**
     * `filter operators` render boolean column.
     * @hidden
     */
    export class FlMenuOptrUI {
        private parent;
        private customFilterOperators;
        private serviceLocator;
        private filterSettings;
        private dropOptr;
        private customOptr;
        private optrData;
        private dialogObj;
        constructor(parent?: IGrid, customFltrOperators?: Object, serviceLocator?: ServiceLocator, filterSettings?: FilterSettings);
        /**
         * @hidden
         */
        renderOperatorUI(dlgConetntEle: Element, target: Element, column: Column, dlgObj: ej.popups.Dialog): void;
        private dropDownOpen(args);
        private dropSelectedVal(col, optr);
        /**
         * @hidden
         */
        getFlOperator(): string;
    }
    
    /**
     * `filter menu` render boolean column.
     * @hidden
     */
    export class FilterMenuRenderer {
        private parent;
        private filterObj;
        private serviceLocator;
        private dlgDiv;
        private l10n;
        dlgObj: ej.popups.Dialog;
        private valueFormatter;
        private filterSettings;
        private customFilterOperators;
        private dropOptr;
        private flMuiObj;
        private col;
        private isDialogOpen;
        private colTypes;
        constructor(parent?: IGrid, filterSettings?: FilterSettings, serviceLocator?: ServiceLocator, customFltrOperators?: Object, fltrObj?: Filter);
        private openDialog(args);
        private closeDialog();
        private renderDlgContent(target, column);
        private dialogCreated(target, column);
        private renderFilterUI(target, col);
        private renderOperatorUI(dlgConetntEle, target, column);
        private renderFlValueUI(dlgConetntEle, target, column);
        private writeMethod(col, dlgContentEle);
        private filterBtnClick(col);
        private clearBtnClick(column);
        destroy(): void;
    }
    
    /**
     * Footer module is used to render grid content
     * @hidden
     */
    export class FooterRenderer extends ContentRender implements IRenderer {
        private locator;
        protected modelGenerator: SummaryModelGenerator;
        private aggregates;
        private freezeTable;
        private frozenContent;
        private movableContent;
        constructor(gridModule?: IGrid, serviceLocator?: ServiceLocator);
        /**
         * The function is used to render grid footer div
         */
        renderPanel(): void;
        /**
         * The function is used to render grid footer table
         */
        renderTable(): void;
        private renderSummaryContent(e?, table?, cStart?, cEnd?);
        refresh(e?: {
            aggregates?: Object;
        }): void;
        refreshCol(): void;
        private onWidthChange(args);
        private onScroll(e?);
        getColFromIndex(index?: number): HTMLElement;
        private columnVisibilityChanged();
        addEventListener(): void;
        removeEventListener(): void;
        private updateFooterTableWidth(tFoot);
    }
    
    /**
     * Freeze module is used to render grid content with frozen rows and columns
     * @hidden
     */
    export class FreezeContentRender extends ContentRender implements IRenderer {
        private frozenContent;
        private movableContent;
        constructor(parent?: IGrid, locator?: ServiceLocator);
        renderPanel(): void;
        renderEmpty(tbody: HTMLElement): void;
        private setFrozenContent(ele);
        private setMovableContent(ele);
        getFrozenContent(): Element;
        getMovableContent(): Element;
        getModelGenerator(): IModelGenerator<Column>;
        renderTable(): void;
    }
    export class FreezeRender extends HeaderRender implements IRenderer {
        private frozenHeader;
        private movableHeader;
        constructor(parent?: IGrid, locator?: ServiceLocator);
        addEventListener(): void;
        renderTable(): void;
        renderPanel(): void;
        refreshUI(): void;
        private rfshMovable();
        private refreshFreeze(obj);
        private updateResizeHandler();
        private setWrapHeight(fRows, mRows, isModeChg, isContReset?, isStackedHdr?);
        private refreshStackedHdrHgt();
        private getRowSpan(row);
        private updateStackedHdrRowHgt(idx, maxRowSpan, row, rows);
        private setFrozenHeader(ele);
        private setMovableHeader(ele);
        getFrozenHeader(): Element;
        getMovableHeader(): Element;
        private updateColgroup();
    }
    
    /**
     * HeaderCellRenderer class which responsible for building header cell content.
     * @hidden
     */
    export class HeaderCellRenderer extends CellRenderer implements ICellRenderer<Column> {
        element: HTMLElement;
        private ariaService;
        private hTxtEle;
        private sortEle;
        private gui;
        private chkAllBox;
        /**
         * Function to return the wrapper for the TH content.
         * @returns string
         */
        getGui(): string | Element;
        /**
         * Function to render the cell content based on Column object.
         * @param  {Column} column
         * @param  {Object} data
         * @param  {Element}
         */
        render(cell: Cell<Column>, data: Object, attributes?: {
            [x: string]: Object;
        }): Element;
        /**
         * Function to refresh the cell content based on Column object.
         * @param  {Cell} cell
         * @param  {Element} node
         */
        refresh(cell: Cell<Column>, node: Element): Element;
        private clean(node);
        private prepareHeader(cell, node, fltrMenuEle);
        private extendPrepareHeader(column, node);
        /**
         * Function to specifies how the result content to be placed in the cell.
         * @param  {Element} node
         * @param  {string|Element} innerHtml
         * @returns Element
         */
        appendHtml(node: Element, innerHtml: string | Element): Element;
    }
    
    /**
     * HeaderIndentCellRenderer class which responsible for building header indent cell.
     * @hidden
     */
    export class HeaderIndentCellRenderer extends CellRenderer implements ICellRenderer<Column> {
        element: HTMLElement;
        /**
         * Function to render the indent cell
         * @param  {Cell} cell
         * @param  {Object} data
         */
        render(cell: Cell<Column>, data: Object): Element;
    }
    
    /**
     * Content module is used to render grid content
     * @hidden
     */
    export class HeaderRender implements IRenderer {
        private headerTable;
        private headerPanel;
        private colgroup;
        private caption;
        protected colDepth: number;
        private column;
        protected rows: Row<Column>[];
        private frzIdx;
        private helper;
        private dragStart;
        private drag;
        private dragStop;
        private drop;
        protected parent: IGrid;
        protected serviceLocator: ServiceLocator;
        protected widthService: ColumnWidthService;
        protected ariaService: AriaService;
        /**
         * Constructor for header renderer module
         */
        constructor(parent?: IGrid, serviceLocator?: ServiceLocator);
        /**
         * The function is used to render grid header div
         */
        renderPanel(): void;
        /**
         * The function is used to render grid header table
         */
        renderTable(): void;
        /**
         * Get the header content div element of grid
         * @return {Element}
         */
        getPanel(): Element;
        /**
         * Set the header content div element of grid
         * @param  {Element} panel
         */
        setPanel(panel: Element): void;
        /**
         * Get the header table element of grid
         * @return {Element}
         */
        getTable(): Element;
        /**
         * Set the header table element of grid
         * @param  {Element} table
         */
        setTable(table: Element): void;
        /**
         * Get the header colgroup element
         * @returns {Element}
         */
        getColGroup(): Element;
        /**
         * Set the header colgroup element
         * @param {Element} colgroup
         * @returns {Element}
         */
        setColGroup(colGroup: Element): Element;
        /**
         * Get the header row element collection.
         * @return {Element[]}
         */
        getRows(): Row<Column>[] | HTMLCollectionOf<HTMLTableRowElement>;
        /**
         * The function is used to create header table elements
         * @return {Element}
         * @hidden
         */
        private createHeaderTable();
        /**
         * @hidden
         */
        createTable(): Element;
        private createHeaderContent();
        private updateColGroup(colGroup);
        private ensureColumns(rows);
        private getHeaderCells(rows);
        private appendCells(cols, rows, index, isFirstObj, isFirstCol, isLastCol, isMovable);
        private refreshFrozenHdr(cols, frzObj);
        private getColSpan(colSpan, isMovable, frozenCnt);
        private generateRow(index);
        private generateCell(column, cellType?, rowSpan?, className?, rowIndex?, colIndex?);
        /**
         * Function to hide header table column based on visible property
         * @param  {Column[]} columns?
         */
        setVisible(columns?: Column[]): void;
        private colPosRefresh();
        /**
         * Refresh the header of the Grid.
         * @returns {void}
         */
        refreshUI(): void;
        appendContent(table?: Element): void;
        private getObjDepth();
        private checkDepth(col, index);
        private getCellCnt(col, cnt);
        protected initializeHeaderDrag(): void;
        protected initializeHeaderDrop(): void;
    }
    
    /**
     * IndentCellRenderer class which responsible for building group indent cell.
     * @hidden
     */
    export class IndentCellRenderer extends CellRenderer implements ICellRenderer<Column> {
        element: HTMLElement;
        /**
         * Function to render the indent cell
         * @param  {Cell} cell
         * @param  {Object} data
         */
        render(cell: Cell<Column>, data: Object): Element;
    }
    
    /**
     * Edit render module is used to render grid edit row.
     * @hidden
     */
    export class InlineEditRender {
        private parent;
        /**
         * Constructor for render module
         */
        constructor(parent?: IGrid);
        addNew(elements: Object, args: {
            row?: Element;
        }): void;
        private renderMovableform(ele);
        private updateFreezeEdit(row, td);
        update(elements: Object, args: {
            row?: Element;
        }): void;
        private refreshFreezeEdit(row);
        private updateFrozenCont(row, ele, mEle);
        private renderMovable(ele, mEle);
        private getEditElement(elements?, isEdit?, tdElement?);
        removeEventListener(): void;
    }
    
    /**
     * `numberfilterui` render number column.
     * @hidden
     */
    export class NumberFilterUI implements IFilterMUI {
        private parent;
        protected serviceLocator: ServiceLocator;
        private instance;
        private value;
        private numericTxtObj;
        private filterSettings;
        private filter;
        constructor(parent?: IGrid, serviceLocator?: ServiceLocator, filterSettings?: FilterSettings);
        create(args: IFilterCreate): void;
        write(args: {
            column: Column;
            target: Element;
            parent: IGrid;
            filteredValue: number | string | Date | boolean;
        }): void;
        read(element: Element, column: Column, filterOptr: string, filterObj: Filter): void;
    }
    
    /**
     * `NumericEditCell` is used to handle numeric cell type editing.
     * @hidden
     */
    export class NumericEditCell implements IEditCell {
        private parent;
        private obj;
        constructor(parent?: IGrid);
        create(args: {
            column: Column;
            value: string;
        }): Element;
        read(element: Element): number;
        write(args: {
            rowData: Object;
            element: Element;
            column: Column;
            requestType: string;
        }): void;
        destroy(): void;
    }
    
    /**
     * Content module is used to render grid content
     * @hidden
     */
    export class Render {
        private isColTypeDef;
        private parent;
        private locator;
        private headerRenderer;
        private contentRenderer;
        private l10n;
        data: Data;
        private ariaService;
        private renderer;
        private emptyGrid;
        /**
         * Constructor for render module
         */
        constructor(parent?: IGrid, locator?: ServiceLocator);
        /**
         * To initialize grid header, content and footer rendering
         */
        render(): void;
        /**
         * Refresh the entire Grid.
         * @return {void}
         */
        refresh(e?: NotifyArgs): void;
        private refreshComplete(e?);
        /**
         * The function is used to refresh the dataManager
         * @return {void}
         */
        private refreshDataManager(args?);
        private getFData(deferred);
        private isNeedForeignAction();
        private foreignKey(columns);
        private sendBulkRequest(args?);
        private dmSuccess(e, args);
        private dmFailure(e);
        /**
         * Render empty row to Grid which is used at the time to represent to no records.
         * @return {void}
         * @hidden
         */
        renderEmptyRow(): void;
        private emptyRow(isTrigger?);
        private updateColumnType(record);
        private dataManagerSuccess(e, args?);
        private dataManagerFailure(e);
        private updatesOnInitialRender(e);
        private buildColumns(record);
        private instantiateRenderer();
        private addEventListener();
        /** @hidden */
        validateGroupRecords(e: ReturnType): Promise<Object>;
        private getPredicate(key, operator, value);
        private updateGroupInfo(current, untouched);
    }
    
    /**
     * RowRenderer class which responsible for building row content.
     * @hidden
     */
    export class RowRenderer<T> implements IRowRenderer<T> {
        element: Element;
        private cellRenderer;
        private serviceLocator;
        private cellType;
        protected parent: IGrid;
        constructor(serviceLocator?: ServiceLocator, cellType?: CellType, parent?: IGrid);
        /**
         * Function to render the row content based on Column[] and data.
         * @param  {Column[]} columns
         * @param  {Object} data?
         * @param  {{[x:string]:Object}} attributes?
         * @param  {string} rowTemplate?
         */
        render(row: Row<T>, columns: Column[], attributes?: {
            [x: string]: Object;
        }, rowTemplate?: string, cloneNode?: Element): Element;
        /**
         * Function to refresh the row content based on Column[] and data.
         * @param  {Column[]} columns
         * @param  {Object} data?
         * @param  {{[x:string]:Object}} attributes?
         * @param  {string} rowTemplate?
         */
        refresh(row: Row<T>, columns: Column[], isChanged: boolean, attributes?: {
            [x: string]: Object;
        }, rowTemplate?: string): void;
        private refreshRow(row, columns, attributes?, rowTemplate?, cloneNode?);
        private refreshMergeCells(row);
        /**
         * Function to check and add alternative row css class.
         * @param  {Element} tr
         * @param  {{[x:string]:Object}} attr
         */
        buildAttributeFromRow(tr: Element, row: Row<T>): void;
    }
    
    /**
     * StackedHeaderCellRenderer class which responsible for building stacked header cell content.
     * @hidden
     */
    export class StackedHeaderCellRenderer extends CellRenderer implements ICellRenderer<Column> {
        element: HTMLElement;
        /**
         * Function to render the cell content based on Column object.
         * @param  {Column} column
         * @param  {Object} data
         * @param  {Element}
         */
        render(cell: Cell<Column>, data: Object, attributes?: {
            [x: string]: Object;
        }): Element;
    }
    
    /**
     * `string filterui` render string column.
     * @hidden
     */
    export class StringFilterUI implements IFilterMUI {
        private parent;
        protected serLocator: ServiceLocator;
        private instance;
        private value;
        actObj: ej.dropdowns.AutoComplete;
        private filterSettings;
        private filter;
        private dialogObj;
        constructor(parent?: IGrid, serviceLocator?: ServiceLocator, filterSettings?: FilterSettings);
        create(args: IFilterCreate): void;
        private getAutoCompleteOptions(args);
        write(args: {
            column: Column;
            target: Element;
            parent: IGrid;
            filteredValue: number | string | Date | boolean;
        }): void;
        read(element: Element, column: Column, filterOptr: string, filterObj: Filter): void;
        private openPopup(args);
    }
    
    /**
     * SummaryCellRenderer class which responsible for building summary cell content.
     * @hidden
     */
    export class SummaryCellRenderer extends CellRenderer implements ICellRenderer<AggregateColumnModel> {
        element: HTMLElement;
        getValue(field: string, data: Object, column: AggregateColumnModel): Object;
        evaluate(node: Element, cell: Cell<AggregateColumnModel>, data: Object, attributes?: Object): boolean;
    }
    
    /**
     * VirtualContentRenderer
     * @hidden
     */
    export class VirtualContentRenderer extends ContentRender implements IRenderer {
        private count;
        private maxPage;
        private maxBlock;
        private prevHeight;
        private observer;
        private prevInfo;
        private vgenerator;
        private header;
        private locator;
        private preventEvent;
        private actions;
        private content;
        private offsets;
        private tmpOffsets;
        private virtualEle;
        private offsetKeys;
        private isFocused;
        constructor(parent: IGrid, locator?: ServiceLocator);
        renderTable(): void;
        renderEmpty(tbody: HTMLElement): void;
        private scrollListener(scrollArgs);
        private block(blk);
        private getInfoFromView(direction, info, e);
        ensureBlocks(info: VirtualInfo): number[];
        appendContent(target: HTMLElement, newChild: DocumentFragment, e: NotifyArgs): void;
        private onDataReady(e?);
        private setVirtualHeight();
        private getPageFromTop(sTop, info);
        private getTranslateY(sTop, cHeight, info?);
        getOffset(block: number): number;
        private onEntered();
        eventListener(action: string): void;
        getBlockSize(): number;
        getBlockHeight(): number;
        isEndBlock(index: number): boolean;
        private getRowHeight();
        getTotalBlocks(): number;
        getColumnOffset(block: number): number;
        getModelGenerator(): IModelGenerator<Column>;
        private resetScrollPosition(action);
        private onActionBegin(e);
        getRows(): Row<Column>[];
        getRowByIndex(index: number): Element;
        getVirtualRowIndex(index: number): number;
        private refreshOffsets();
        refreshVirtualElement(): void;
    }
    /**
     * @hidden
     */
    export class VirtualHeaderRenderer extends HeaderRender implements IRenderer {
        virtualEle: VirtualElementHandler;
        private gen;
        constructor(parent: IGrid, locator: ServiceLocator);
        renderTable(): void;
        appendContent(table: Element): void;
        refreshUI(): void;
    }
    /**
     * @hidden
     */
    export class VirtualElementHandler {
        wrapper: HTMLElement;
        placeholder: HTMLElement;
        content: HTMLElement;
        table: HTMLElement;
        renderWrapper(): void;
        renderPlaceHolder(position?: string): void;
        adjustTable(xValue: number, yValue: number): void;
        setWrapperWidth(width: string, full?: boolean): void;
        setVirtualHeight(height?: number, width?: string): void;
    }
    
    /**
     * AriaService
     * @hidden
     */
    export class AriaService {
        setOptions(target: HTMLElement, options: IAriaOptions<boolean>): void;
        setExpand(target: HTMLElement, expand: boolean): void;
        setSort(target: HTMLElement, direction?: SortDirection | 'none' | boolean): void;
        setBusy(target: HTMLElement, isBusy: boolean): void;
        setGrabbed(target: HTMLElement, isGrabbed: boolean, remove?: boolean): void;
        setDropTarget(target: HTMLElement, isTarget: boolean): void;
    }
    /**
     * @hidden
     */
    export interface IAriaOptions<T> {
        role?: string;
        expand?: T;
        collapse?: T;
        selected?: T;
        multiselectable?: T;
        sort?: T | 'none';
        busy?: T;
        invalid?: T;
        grabbed?: T;
        dropeffect?: T;
        haspopup?: T;
        level?: T;
        colcount?: string;
    }
    
    /**
     * CellRendererFactory
     * @hidden
     */
    export class CellRendererFactory {
        cellRenderMap: {
            [c: string]: ICellRenderer<{}>;
        };
        addCellRenderer(name: string | CellType, type: ICellRenderer<{}>): void;
        getCellRenderer(name: string | CellType): ICellRenderer<{}>;
    }
    
    /**
     * FocusStrategy class
     * @hidden
     */
    export class FocusStrategy {
        parent: IGrid;
        currentInfo: FocusInfo;
        oneTime: boolean;
        swap: SwapInfo;
        content: IFocus;
        header: IFocus;
        active: IFocus;
        fContent: IFocus;
        fHeader: IFocus;
        private forget;
        private skipFocus;
        private focusByClick;
        private passiveHandler;
        private prevIndexes;
        constructor(parent: IGrid);
        protected focusCheck(e: Event): void;
        protected onFocus(): void;
        protected passiveFocus(e: FocusEvent): void;
        protected onBlur(e?: FocusEvent): void;
        onClick(e: Event | {
            target: Element;
        }, force?: boolean): void;
        protected onKeyPress(e: ej.base.KeyboardEventArgs): void;
        private skipOn(e);
        getFocusedElement(): HTMLElement;
        getContent(): IFocus;
        setActive(content: boolean, isFrozen?: boolean): void;
        setFocusedElement(element: HTMLElement): void;
        focus(e?: ej.base.KeyboardEventArgs): void;
        protected removeFocus(e?: FocusEvent): void;
        protected addFocus(info: FocusInfo, e?: ej.base.KeyboardEventArgs): void;
        protected refreshMatrix(content?: boolean): Function;
        addEventListener(): void;
        removeEventListener(): void;
        destroy(): void;
        restoreFocus(): void;
        clearOutline(): void;
        clearIndicator(): void;
        getPrevIndexes(): IIndex;
        forgetPrevious(): void;
        setActiveByKey(action: string, active: IFocus): void;
        internalCellFocus(e: CellFocusArgs): void;
    }
    /**
     * Create matrix from row collection which act as mental model for cell navigation
     * @hidden
     */
    export class Matrix {
        matrix: number[][];
        current: number[];
        columns: number;
        rows: number;
        set(rowIndex: number, columnIndex: number, allow?: boolean): void;
        get(rowIndex: number, columnIndex: number, navigator: number[], action?: string, validator?: Function): number[];
        first(vector: number[], index: number, navigator: number[], moveTo?: boolean, action?: string): number;
        select(rowIndex: number, columnIndex: number): void;
        generate(rows: Row<Column>[], selector: Function): number[][];
        inValid(value: number): boolean;
    }
    /**
     * @hidden
     */
    export class ContentFocus implements IFocus {
        matrix: Matrix;
        parent: IGrid;
        keyActions: {
            [x: string]: number[];
        };
        indexesByKey: (action: string) => number[];
        constructor(parent: IGrid);
        getTable(): HTMLTableElement;
        onKeyPress(e: ej.base.KeyboardEventArgs): void | boolean;
        getCurrentFromAction(action: string, navigator?: number[], isPresent?: boolean, e?: ej.base.KeyboardEventArgs): number[];
        onClick(e: Event, force?: boolean): void | boolean;
        getFocusInfo(): FocusInfo;
        getFocusable(element: HTMLElement): HTMLElement;
        selector(row: Row<Column>, cell: Cell<Column>): boolean;
        jump(action: string, current: number[]): SwapInfo;
        getNextCurrent(previous?: number[], swap?: SwapInfo, active?: IFocus, action?: string): number[];
        generateRows(rows?: Row<Column>[], optionals?: Object): void;
        getInfo(e?: ej.base.KeyboardEventArgs): FocusedContainer;
        validator(): Function;
        protected shouldFocusChange(e: ej.base.KeyboardEventArgs): boolean;
    }
    /**
     * @hidden
     */
    export class HeaderFocus extends ContentFocus implements IFocus {
        constructor(parent: IGrid);
        getTable(): HTMLTableElement;
        onClick(e: Event): void | boolean;
        getFocusInfo(): FocusInfo;
        selector(row: Row<Column>, cell: Cell<Column>): boolean;
        jump(action: string, current: number[]): SwapInfo;
        getNextCurrent(previous?: number[], swap?: SwapInfo, active?: IFocus, action?: string): number[];
        generateRows(rows?: Row<Column>[]): void;
        getInfo(e?: ej.base.KeyboardEventArgs): FocusedContainer;
        validator(): Function;
        protected shouldFocusChange(e: ej.base.KeyboardEventArgs): boolean;
    }
    export class FixedContentFocus extends ContentFocus {
        getTable(): HTMLTableElement;
        jump(action: string, current: number[]): SwapInfo;
        getNextCurrent(previous?: number[], swap?: SwapInfo, active?: IFocus, action?: string): number[];
    }
    export class FixedHeaderFocus extends HeaderFocus {
        jump(action: string, current: number[]): SwapInfo;
        getTable(): HTMLTableElement;
        getNextCurrent(previous?: number[], swap?: SwapInfo, active?: IFocus, action?: string): number[];
    }
    /** @hidden */
    export class SearchBox {
        searchBox: HTMLElement;
        constructor(searchBox: HTMLElement);
        protected searchFocus(args: Event): void;
        protected searchBlur(args: Event): void;
        wireEvent(): void;
        unWireEvent(): void;
    }
    
    /**
     * FreezeRowModelGenerator is used to generate grid data rows with freeze row and column.
     * @hidden
     */
    export class FreezeRowModelGenerator implements IModelGenerator<Column> {
        private rowModelGenerator;
        private parent;
        private isFrzLoad;
        constructor(parent: IGrid);
        generateRows(data: Object, notifyArgs?: NotifyArgs): Row<Column>[];
    }
    
    /**
     * GroupModelGenerator is used to generate group caption rows and data rows.
     * @hidden
     */
    export class GroupModelGenerator extends RowModelGenerator implements IModelGenerator<Column> {
        private rows;
        private index;
        private summaryModelGen;
        private captionModelGen;
        constructor(parent?: IGrid);
        generateRows(data: {
            length: number;
        }, args?: Object): Row<Column>[];
        private getGroupedRecords(index, data, raw?);
        private getCaptionRowCells(field, indent, data);
        private generateCaptionRow(data, indent);
        private getForeignKeyData(row);
        private generateDataRows(data, indent);
        private generateIndentCell();
        refreshRows(input?: Row<Column>[]): Row<Column>[];
    }
    export interface GroupedData {
        GroupGuid?: string;
        items?: GroupedData;
        field?: string;
        isDataRow?: boolean;
        level?: number;
        key?: string;
        foreignKey?: string;
        count?: number;
    }
    
    export type ScrollDirection = 'up' | 'down' | 'right' | 'left';
    /**
     * InterSectionObserver - class watch whether it enters the viewport.
     * @hidden
     */
    export class InterSectionObserver {
        private containerRect;
        private element;
        private fromWheel;
        private touchMove;
        private options;
        private sentinelInfo;
        constructor(element: HTMLElement, options: InterSection);
        observe(callback: Function, onEnterCallback: Function): void;
        check(direction: ScrollDirection): boolean;
        private virtualScrollHandler(callback, onEnterCallback);
        setPageHeight(value: number): void;
    }
    
    /**
     * RendererFactory
     * @hidden
     */
    export class RendererFactory {
        rendererMap: {
            [c: string]: IRenderer;
        };
        addRenderer(name: RenderType, type: IRenderer): void;
        getRenderer(name: RenderType): IRenderer;
    }
    
    /**
     * RowModelGenerator is used to generate grid data rows.
     * @hidden
     */
    export class RowModelGenerator implements IModelGenerator<Column> {
        protected parent: IGrid;
        /**
         * Constructor for header renderer module
         */
        constructor(parent?: IGrid);
        generateRows(data: Object, args?: {
            startIndex?: number;
        }): Row<Column>[];
        protected ensureColumns(): Cell<Column>[];
        protected generateRow(data: Object, index: number, cssClass?: string, indent?: number): Row<Column>;
        protected refreshForeignKeyRow(options: IRow<Column>): void;
        protected generateCells(options: IRow<Column>): Cell<Column>[];
        protected generateCell(column: Column, rowId?: string, cellType?: CellType, colSpan?: number, oIndex?: number, foreignKeyData?: Object): Cell<Column>;
        refreshRows(input?: Row<Column>[]): Row<Column>[];
    }
    
    /**
     * ServiceLocator
     * @hidden
     */
    export class ServiceLocator {
        private services;
        register<T>(name: string, type: T): void;
        getService<T>(name: string): T;
    }
    
    /**
     * Summary row model generator
     * @hidden
     */
    export class SummaryModelGenerator implements IModelGenerator<AggregateColumnModel> {
        protected parent: IGrid;
        /**
         * Constructor for Summary row model generator
         */
        constructor(parent?: IGrid);
        getData(): Object;
        columnSelector(column: AggregateColumnModel): boolean;
        getColumns(start?: number, end?: number): Column[];
        generateRows(input: Object[] | Group, args?: Object, start?: number, end?: number): Row<AggregateColumnModel>[];
        getGeneratedRow(summaryRow: AggregateRowModel, data: Object, raw: number, start: number, end: number): Row<AggregateColumnModel>;
        getGeneratedCell(column: Column, summaryRow: AggregateRowModel, cellType?: CellType, indent?: string): Cell<AggregateColumnModel>;
        private buildSummaryData(data, args?);
        protected getIndentByLevel(data?: number): string[];
        protected setTemplate(column: AggregateColumn, data: Object[], single: Object | Group): Object;
        protected getCellType(): CellType;
    }
    export class GroupSummaryModelGenerator extends SummaryModelGenerator implements IModelGenerator<AggregateColumnModel> {
        columnSelector(column: AggregateColumnModel): boolean;
        protected getIndentByLevel(level?: number): string[];
        protected getCellType(): CellType;
    }
    export class CaptionSummaryModelGenerator extends SummaryModelGenerator implements IModelGenerator<AggregateColumnModel> {
        columnSelector(column: AggregateColumnModel): boolean;
        getData(): Object;
        isEmpty(): boolean;
        protected getCellType(): CellType;
    }
    
    /**
     * ValueFormatter class to globalize the value.
     * @hidden
     */
    export class ValueFormatter implements IValueFormatter {
        private intl;
        constructor(cultureName?: string);
        getFormatFunction(format: ej.base.NumberFormatOptions | ej.base.DateFormatOptions): Function;
        getParserFunction(format: ej.base.NumberFormatOptions | ej.base.DateFormatOptions): Function;
        fromView(value: string, format: Function, type?: string): string | number | Date;
        toView(value: number | Date, format: Function): string | Object;
        setCulture(cultureName: string): void;
    }
    
    /**
     * Content module is used to render grid content
     */
    export class VirtualRowModelGenerator implements IModelGenerator<Column> {
        private model;
        rowModelGenerator: IModelGenerator<Column>;
        parent: IGrid;
        cOffsets: {
            [x: number]: number;
        };
        cache: {
            [x: number]: Row<Column>[];
        };
        data: {
            [x: number]: Object[];
        };
        groups: {
            [x: number]: Object;
        };
        constructor(parent: IGrid);
        generateRows(data: Object[], notifyArgs?: NotifyArgs): Row<Column>[];
        getBlockIndexes(page: number): number[];
        getPage(block: number): number;
        isBlockAvailable(value: number): boolean;
        getData(): VirtualInfo;
        private getStartIndex(blk, data, full?);
        getColumnIndexes(content?: HTMLElement): number[];
        checkAndResetCache(action: string): boolean;
        refreshColOffsets(): void;
        updateGroupRow(current: Row<Column>[], block: number): Row<Column>[];
        private iterateGroup(current, rows);
        getRows(): Row<Column>[];
    }
    
    /**
     * ColumnWidthService
     * @hidden
     */
    export class ColumnWidthService {
        private parent;
        constructor(parent: IGrid);
        setWidthToColumns(): void;
        setColumnWidth(column: Column, index?: number, module?: string): void;
        private setWidth(width, index);
        getSiblingsHeight(element: HTMLElement): number;
        private getHeightFromDirection(element, direction);
        getWidth(column: Column): string | number;
        getTableWidth(columns: Column[]): number;
        private setWidthToFrozenTable();
        private setWidthToMovableTable();
        setWidthToTable(): void;
    }
    
    /**
     * `ExternalMessage` module is used to display user provided message.
     */
    export class ExternalMessage implements IRender {
        private element;
        private pagerModule;
        /**
         * Constructor for externalMessage module
         * @param  {Pager} pagerModule?
         * @returns defaultType
         * @hidden
         */
        constructor(pagerModule?: Pager);
        /**
         * For internal use only - Get the module name.
         * @private
         */
        protected getModuleName(): string;
        /**
         * The function is used to render pager externalMessage
         * @hidden
         */
        render(): void;
        /**
         * Refreshes the external message of Pager.
         */
        refresh(): void;
        /**
         * Hides the external message of Pager.
         */
        hideMessage(): void;
        /**
         * Shows the external message of the Pager.
         */
        showMessage(): void;
        /**
         * To destroy the PagerMessage
         * @method destroy
         * @return {void}
         * @hidden
         */
        destroy(): void;
    }
    
    /**
     * `NumericContainer` module handles rendering and refreshing numeric container.
     */
    export class NumericContainer implements IRender {
        private element;
        private first;
        private prev;
        private PP;
        private NP;
        private next;
        private last;
        private links;
        private pagerElement;
        private pagerModule;
        /**
         * Constructor for numericContainer module
         * @hidden
         */
        constructor(pagerModule?: Pager);
        /**
         * The function is used to render numericContainer
         * @hidden
         */
        render(): void;
        /**
         * Refreshes the numeric container of Pager.
         */
        refresh(): void;
        /**
         * The function is used to refresh refreshNumericLinks
         * @hidden
         */
        refreshNumericLinks(): void;
        /**
         * Binding events to the element while component creation
         * @hidden
         */
        wireEvents(): void;
        /**
         * Unbinding events from the element while component destroy
         * @hidden
         */
        unwireEvents(): void;
        /**
         * To destroy the PagerMessage
         * @method destroy
         * @return {void}
         * @hidden
         */
        destroy(): void;
        private renderNumericContainer();
        private renderFirstNPrev(pagerContainer);
        private renderPrevPagerSet(pagerContainer);
        private renderNextPagerSet(pagerContainer);
        private renderNextNLast(pagerContainer);
        private clickHandler(e);
        private updateLinksHtml();
        private updateStyles();
        private updateFirstNPrevStyles();
        private updatePrevPagerSetStyles();
        private updateNextPagerSetStyles();
        private updateNextNLastStyles();
    }
    
    /**
     * `PagerDropDown` module handles selected pageSize from DropDownList.
     */
    export class PagerDropDown {
        private pagerCons;
        private dropDownListObject;
        private pagerDropDownDiv;
        private pagerModule;
        /**
         * Constructor for pager module
         * @hidden
         */
        constructor(pagerModule?: Pager);
        /**
         * For internal use only - Get the module name.
         * @private
         * @hidden
         */
        protected getModuleName(): string;
        /**
         * The function is used to render pager dropdown
         * @hidden
         */
        render(): void;
        /**
         * For internal use only - Get the pagesize.
         * @private
         * @hidden
         */
        private onChange(e);
        /**
         * To destroy the Pagerdropdown
         * @method destroy
         * @return {void}
         * @hidden
         */
        destroy(args?: {
            requestType: string;
        }): void;
    }
    
    /**
     * `PagerMessage` module is used to display pager information.
     */
    export class PagerMessage implements IRender {
        private pageNoMsgElem;
        private pageCountMsgElem;
        private pagerModule;
        /**
         * Constructor for externalMessage module
         * @hidden
         */
        constructor(pagerModule?: Pager);
        /**
         * The function is used to render pager message
         * @hidden
         */
        render(): void;
        /**
         * Refreshes the pager information.
         */
        refresh(): void;
        /**
         * Hides the Pager information.
         */
        hideMessage(): void;
        /**
         * Shows the Pager information.
         */
        showMessage(): void;
        /**
         * To destroy the PagerMessage
         * @method destroy
         * @return {void}
         * @hidden
         */
        destroy(): void;
        private format(str, args);
    }
    
    /**
     * Interface for a class Pager
     */
    export interface PagerModel extends ej.base.ComponentModel{
    
        /**
         * If `enableQueryString` set to true,   
         * then it pass current page information as a query string along with the URL while navigating to other page.  
         * @default false  
         */
        enableQueryString?: boolean;
    
        /**
         * If `enableExternalMessage` set to true, then it adds the message to Pager.  
         * @default false  
         */
        enableExternalMessage?: boolean;
    
        /**
         * If `enablePagerMessage` set to true, then it adds the pager information.  
         * @default true  
         */
        enablePagerMessage?: boolean;
    
        /**
         * Defines the records count of visible page.  
         * @default 12  
         */
        pageSize?: number;
    
        /**
         * Defines the number of pages to display in pager container.   
         * @default 10  
         */
        pageCount?: number;
    
        /**
         * Defines the current page number of pager.   
         * @default 1  
         */
        currentPage?: number;
    
        /**
         * Gets or Sets the total records count which is used to render numeric container.   
         * @default null  
         */
        totalRecordsCount?: number;
    
        /**
         * Defines the external message of Pager.  
         * @default null  
         */
        externalMessage?: string;
    
        /**
         * If `pageSizes` set to true or Array of values,
         * It renders DropDownList in the pager which allow us to select pageSize from DropDownList.    
         * @default false    
         */
        pageSizes?: boolean | number[];
    
        /**
         *  Defines the template as string or HTML element ID which renders customized elements in pager instead of default elements.    
         * @default null    
         */
        template?: string;
    
        /**
         * Defines the customized text to append with numeric items.  
         * @default null  
         */
        customText?: string;
    
        /**
         * Triggers when click on the numeric items.   
         * @default null  
         */
        click?: ej.base.EmitType<Object>;
    
        /**
         * Triggers after pageSize is selected in DropDownList.   
         * @default null  
         */
        dropDownChanged?: ej.base.EmitType<Object>;
    
        /**
         * Triggers when Pager is created.   
         * @default null  
         */
        created?: ej.base.EmitType<Object>;
    
    }
    
    /** @hidden */
    export interface IRender {
        render(): void;
        refresh(): void;
    }
    /**
     * Represents the `Pager` component.
     * ```html
     * <div id="pager"/>
     * ```
     * ```typescript
     * <script>
     *   var pagerObj = new Pager({ totalRecordsCount: 50, pageSize:10 });
     *   pagerObj.appendTo("#pager");
     * </script>
     * ```
     */
    export class Pager extends ej.base.Component<HTMLElement> implements ej.base.INotifyPropertyChanged {
        /*** @hidden */
        totalPages: number;
        private templateFn;
        /*** @hidden */
        previousPageNo: number;
        private defaultConstants;
        /*** @hidden */
        localeObj: ej.base.L10n;
        /**
         * `containerModule` is used to manipulate numeric container behavior of Pager.
         */
        containerModule: NumericContainer;
        /**
         * `pagerMessageModule` is used to manipulate pager message of Pager.
         */
        pagerMessageModule: PagerMessage;
        /**
         * `externalMessageModule` is used to manipulate external message of Pager.
         */
        externalMessageModule: ExternalMessage;
        /**
         * `pagerdropdownModule` is used to manipulate pageSizes of Pager.
         *  @hidden
         */
        pagerdropdownModule: PagerDropDown;
        /**
         * If `enableQueryString` set to true,
         * then it pass current page information as a query string along with the URL while navigating to other page.
         * @default false
         */
        enableQueryString: boolean;
        /**
         * If `enableExternalMessage` set to true, then it adds the message to Pager.
         * @default false
         */
        enableExternalMessage: boolean;
        /**
         * If `enablePagerMessage` set to true, then it adds the pager information.
         * @default true
         */
        enablePagerMessage: boolean;
        /**
         * Defines the records count of visible page.
         * @default 12
         */
        pageSize: number;
        /**
         * Defines the number of pages to display in pager container.
         * @default 10
         */
        pageCount: number;
        /**
         * Defines the current page number of pager.
         * @default 1
         */
        currentPage: number;
        /**
         * Gets or Sets the total records count which is used to render numeric container.
         * @default null
         */
        totalRecordsCount: number;
        /**
         * Defines the external message of Pager.
         * @default null
         */
        externalMessage: string;
        /**
         * If `pageSizes` set to true or Array of values,
         * It renders DropDownList in the pager which allow us to select pageSize from DropDownList.
         * @default false
         */
        pageSizes: boolean | number[];
        /**
         *  Defines the template as string or HTML element ID which renders customized elements in pager instead of default elements.
         * @default null
         */
        template: string;
        /**
         * Defines the customized text to append with numeric items.
         * @default null
         */
        customText: string;
        /**
         * Triggers when click on the numeric items.
         * @default null
         */
        click: ej.base.EmitType<Object>;
        /**
         * Triggers after pageSize is selected in DropDownList.
         * @default null
         */
        dropDownChanged: ej.base.EmitType<Object>;
        /**
         * Triggers when Pager is created.
         * @default null
         */
        created: ej.base.EmitType<Object>;
        /**
         * Constructor for creating the component.
         * @hidden
         */
        constructor(options?: PagerModel, element?: string | HTMLElement);
        /**
         * To provide the array of modules needed for component rendering
         * @hidden
         */
        protected requiredModules(): ej.base.ModuleDeclaration[];
        /**
         * Initialize the event handler
         * @hidden
         */
        protected preRender(): void;
        /**
         * To Initialize the component rendering
         */
        protected render(): void;
        /**
         * Get the properties to be maintained in the persisted state.
         * @hidden
         */
        getPersistData(): string;
        /**
         * To destroy the Pager component.
         * @method destroy
         * @return {void}
         */
        destroy(): void;
        /**
         * For internal use only - Get the module name.
         * @private
         */
        protected getModuleName(): string;
        /**
         * Called internally if any of the property value changed.
         * @hidden
         */
        onPropertyChanged(newProp: PagerModel, oldProp: PagerModel): void;
        /**
         * Gets the localized label by locale keyword.
         * @param  {string} key
         * @return {string}
         */
        getLocalizedLabel(key: string): string;
        /**
         * Navigate to target page by given number.
         * @param  {number} pageNo - Defines page number.
         * @return {void}
         */
        goToPage(pageNo: number): void;
        private checkpagesizes();
        private checkGoToPage(newPageNo, oldPageNo?);
        private currentPageChanged();
        private pagerTemplate();
        /** @hidden */
        updateTotalPages(): void;
        /** @hidden */
        getPagerTemplate(): Function;
        private compile(template);
        /**
         * Refreshes page count, pager information and external message.
         * @return {void}
         */
        refresh(): void;
        private updateRTL();
        private initLocalization();
        private updateQueryString(value);
        private getUpdatedURL(uri, key, value);
        private renderFirstPrevDivForDevice();
        private renderNextLastDivForDevice();
        private addAriaLabel();
    }
    
  }
  export namespace inputs {
    
    /**
     * Interface for a class FormValidator
     */
    export interface FormValidatorModel {
    
        /**
         * Ignores input fields based on the class name
         * @default 'e-hidden';
         */
        ignore?: string;
    
        /**
         * Maps the input fields with validation rules
         * @default {};
         */
        rules?: { [name: string]: { [rule: string]: Object } };
    
        /**
         * Sets the defined css class to error fields 
         * @default 'e-error';
         */
        errorClass?: string;
    
        /**
         * Sets the defined css class to valid fields 
         * @default : 'e-valid';
         */
        validClass?: string;
    
        /**
         * Specify HTML element for error
         * @default : 'label';
         */
        errorElement?: string;
    
        /**
         * Specify HTML element for error container 
         * @default : 'div';
         */
        errorContainer?: string;
    
        /**
         * Option to display the error
         * @default : ErrorOption.Label;
         */
        errorOption?: ErrorOption;
    
        /**
         * Triggers when a field's focused  out
         * @event
         */
        focusout?: ej.base.EmitType<Event>;
    
        /**
         * Trigger when keyup is triggered in any fields
         * @event
         */
        keyup?: ej.base.EmitType<KeyboardEvent>;
    
        /**
         * Triggers when a check box field is clicked
         * @event
         */
        click?: ej.base.EmitType<Event>;
    
        /**
         * Trigger when a select/drop-down field is changed
         * @event
         */
        change?: ej.base.EmitType<Event>;
    
        /**
         * Triggers before form is being submitted
         * @event
         */
        submit?: ej.base.EmitType<Event>;
    
        /**
         * Triggers before validation starts
         * @event
         */
        validationBegin?: ej.base.EmitType<Object>;
    
        /**
         * Triggers after validation is completed
         * @event
         */
        validationComplete?: ej.base.EmitType<Object>;
    
        /**
         * Assigns the custom function to place the error message in the page.
         * @event
         */
        customPlacement?: ej.base.EmitType<Object>;
    
    }
    
    /**
     * ErrorOption values
     * @private
     */
    export enum ErrorOption {
        Message = 0,
        Label = 1,
    }
    /**
     * FormValidator class enables you to validate the form fields based on your defined rules
     * ```html
     * <form id='formId'>
     *  <input type='text' name='Name' />
     *  <input type='text' name='Age' />
     * </form>
     * <script>
     *   let formObject = new FormValidator('#formId', {
     *      rules: { Name: { required: true }, Age: { range: [18, 30] } };
     *   });
     *   formObject.validate();
     * </script>
     * ```
     */
    export class FormValidator extends ej.base.Base<HTMLFormElement> implements ej.base.INotifyPropertyChanged {
        private validated;
        private errorRules;
        private allowSubmit;
        private required;
        private infoElement;
        private inputElement;
        private selectQuery;
        private inputElements;
        /**
         * Ignores input fields based on the class name
         * @default 'e-hidden';
         */
        ignore: string;
        /**
         * Maps the input fields with validation rules
         * @default {};
         */
        rules: {
            [name: string]: {
                [rule: string]: Object;
            };
        };
        /**
         * Sets the defined css class to error fields
         * @default 'e-error';
         */
        errorClass: string;
        /**
         * Sets the defined css class to valid fields
         * @default : 'e-valid';
         */
        validClass: string;
        /**
         * Specify HTML element for error
         * @default : 'label';
         */
        errorElement: string;
        /**
         * Specify HTML element for error container
         * @default : 'div';
         */
        errorContainer: string;
        /**
         * Option to display the error
         * @default : ErrorOption.Label;
         */
        errorOption: ErrorOption;
        /**
         * Triggers when a field's focused  out
         * @event
         */
        focusout: ej.base.EmitType<Event>;
        /**
         * Trigger when keyup is triggered in any fields
         * @event
         */
        keyup: ej.base.EmitType<KeyboardEvent>;
        /**
         * Triggers when a check box field is clicked
         * @event
         */
        click: ej.base.EmitType<Event>;
        /**
         * Trigger when a select/drop-down field is changed
         * @event
         */
        change: ej.base.EmitType<Event>;
        /**
         * Triggers before form is being submitted
         * @event
         */
        submit: ej.base.EmitType<Event>;
        /**
         * Triggers before validation starts
         * @event
         */
        validationBegin: ej.base.EmitType<Object>;
        /**
         * Triggers after validation is completed
         * @event
         */
        validationComplete: ej.base.EmitType<Object>;
        /**
         * Assigns the custom function to place the error message in the page.
         * @event
         */
        customPlacement: ej.base.EmitType<Object>;
        /**
         * Add validation rules to the corresponding input element based on `name` attribute.
         * @param {string} name `name` of form field.
         * @param {Object} rules Validation rules for the corresponding element.
         * @return {void}
         */
        addRules(name: string, rules: Object): void;
        /**
         * Remove validation to the corresponding field based on name attribute.
         * When no parameter is passed, remove all the validations in the form.
         * @param {string} name Input name attribute value.
         * @param {string[]} rules List of validation rules need to be remove from the corresponding element.
         * @return {void}
         */
        removeRules(name?: string, rules?: string[]): void;
        /**
         * Validate the current form values using defined rules.
         * Returns `true` when the form is valid otherwise `false`
         * @param {string} selected - Optional parameter to validate specified element.
         * @return {boolean}
         */
        validate(selected?: string): boolean;
        /**
         * Reset the value of all the fields in form.
         * @return {void}
         */
        reset(): void;
        /**
         * Get input element by name.
         * @param {string} name - Input element name attribute value.
         * @return {HTMLInputElement}
         */
        getInputElement(name: string): HTMLInputElement;
        /**
         * Destroy the form validator object and error elements.
         * @return {void}
         */
        destroy(): void;
        /**
         * Specifies the default messages for validation rules.
         * @default : { List of validation message };
         */
        defaultMessages: {
            [rule: string]: string;
        };
        /**
         * @private
         */
        onPropertyChanged(newProp: FormValidatorModel, oldProp?: FormValidatorModel): void;
        /**
         * @private
         */
        getModuleName(): string;
        constructor(element: string | HTMLFormElement, options?: FormValidatorModel);
        private clearForm();
        private createHTML5Rules();
        private annotationRule(input, ruleCon, ruleName, value);
        private defRule(input, ruleCon, ruleName, value);
        private wireEvents();
        private unwireEvents();
        private focusOutHandler(e);
        private keyUpHandler(e);
        private clickHandler(e);
        private changeHandler(e);
        private submitHandler(e);
        private resetHandler();
        private validateRules(name);
        private isValid(name, rule);
        private getErrorMessage(ruleValue, rule);
        private createErrorElement(name, message, input);
        private getErrorElement(name);
        private removeErrorRules(name);
        private showMessage(errorRule);
        private hideMessage(name);
        private checkRequired(name);
        private static checkValidator;
        private static isCheckable(input);
    }
    
    /**
     * Defines floating label type of the input and decides how the label should float on the input.
     */
    export type FloatLabelType = 'Never' | 'Always' | 'Auto';
    /**
     * Base for Input creation through util methods.
     */
    export namespace Input {
        /**
         * Create a wrapper to input element with multiple span elements and set the basic properties to input based components.
         * ```
         * E.g : Input.createInput({ element: element, floatLabelType : "Auto", properties: { placeholder: 'Search' } });
         * ```
         * @param args
         */
        function createInput(args: InputArgs): ej.inputs.InputObject;
        /**
         * Sets the value to the input element.
         * ```
         * E.g : Input.setValue('content', element, "Auto", true );
         * ```
         * @param value - Specify the value of the input element.
         * @param element - The element on which the specified value is updated.
         * @param floatLabelType - Specify the float label type of the input element.
         * @param clearButton - Boolean value to specify whether the clear icon is enabled / disabled on the input.
         */
        function setValue(value: string, element: HTMLInputElement, floatLabelType?: string, clearButton?: boolean): void;
        /**
         * Sets the single or multiple cssClass to wrapper of input element.
         * ```
         * E.g : Input.setCssClass('e-custom-class', [element]);
         * ```
         * @param cssClass - Css class names which are needed to add.
         * @param elements - The elements which are needed to add / remove classes.
         * @param oldClass - Css class names which are needed to remove. If old classes are need to remove, can give this optional parameter.
         */
        function setCssClass(cssClass: string, elements: Element[] | NodeList, oldClass?: string): void;
        /**
         * Set the placeholder attribute to the input element.
         * ```
         * E.g : Input.setPlaceholder('Search here', element);
         * ```
         * @param placeholder - Placeholder value which is need to add.
         * @param element - The element on which the placeholder is need to add.
         */
        function setPlaceholder(placeholder: string, element: HTMLInputElement): void;
        /**
         * Set the read only attribute to the input element
         * ```
         * E.g : Input.setReadonly(true, element);
         * ```
         * @param isReadonly
         * - Boolean value to specify whether to set read only. Setting "True" value enables read only.
         * @param element
         * - The element which is need to enable read only.
         */
        function setReadonly(isReadonly: boolean, element: HTMLInputElement, floatLabelType?: string): void;
        /**
         * Displays the element direction from right to left when its enabled.
         * ```
         * E.g : Input.setEnableRtl(true, [inputObj.container]);
         * ```
         * @param isRtl
         * - Boolean value to specify whether to set RTL. Setting "True" value enables the RTL mode.
         * @param elements
         * - The elements that are needed to enable/disable RTL.
         */
        function setEnableRtl(isRtl: boolean, elements: Element[] | NodeList): void;
        /**
         * Enables or disables the given input element.
         * ```
         * E.g : Input.setEnabled(false, element);
         * ```
         * @param isEnable
         * - Boolean value to specify whether to enable or disable.
         * @param element
         * - Element to be enabled or disabled.
         */
        function setEnabled(isEnable: boolean, element: HTMLInputElement, floatLabelType?: string): void;
        /**
         * Removing the multiple attributes from the given element such as "disabled","id" , etc.
         * ```
         * E.g : Input.removeAttributes({ 'disabled': 'disabled', 'aria-disabled': 'true' }, element);
         * ```
         * @param attrs
         *  - Array of attributes which are need to removed from the element.
         * @param element
         *  - Element on which the attributes are needed to be removed.
         */
        function removeAttributes(attrs: {
            [key: string]: string;
        }, element: HTMLInputElement | HTMLElement): void;
        /**
         * Adding the multiple attributes to the given element such as "disabled","id" , etc.
         * ```
         * E.g : Input.addAttributes({ 'id': 'inputpopup' }, element);
         * ```
         * @param attrs
         * - Array of attributes which is added to element.
         * @param element
         * - Element on which the attributes are needed to be added.
         */
        function addAttributes(attrs: {
            [key: string]: string;
        }, element: HTMLInputElement | HTMLElement): void;
        function removeFloating(input: ej.inputs.InputObject): void;
        function addFloating(input: HTMLInputElement, type: ej.inputs.FloatLabelType, placeholder: string): void;
        /**
         * Creates a new span element with the given icons added and append it in container element.
         * ```
         * E.g : Input.appendSpan('e-icon-spin', inputObj.container);
         * ```
         * @param iconClass - Icon classes which are need to add to the span element which is going to created.
         * Span element acts as icon or button element for input.
         * @param container - The container on which created span element is going to append.
         */
        function appendSpan(iconClass: string, container: HTMLElement): HTMLElement;
    }
    export interface InputObject {
        container?: HTMLElement;
        buttons?: HTMLElement[];
        clearButton?: HTMLElement;
    }
    /**
     * Arguments to create input element for input text boxes utility.These properties are optional.
     */
    export interface InputArgs {
        /**
         * Element which is needed to add to the container.
         * ```
         * E.g : Input.createInput({ element: element });
         * ```
         */
        element: HTMLInputElement;
        /**
         * ```
         * E.g : Input.createInput({ element: element, buttons: ['e-icon-up', 'e-icon-down'] });
         * ```
         * Specifies the icon classes for span element which will be append to the container.
         */
        buttons?: string[];
        /**
         * ```
         * E.g : Input.createInput({ element: element, customTag: 'ej2-custom-input' });
         * ```
         * Specifies the custom tag which is acts as container to the input.
         */
        customTag?: string;
        /**
         * ```
         * E.g : Input.createInput({ element: element, floatLabelType : "Always" });
         * ```
         * Specifies how the floating label works.
         * Possible values are:
         * * Never - Never float the label in the input when the placeholder is available.
         * * Always - The floating label will always float above the input.
         * * Auto - The floating label will float above the input after focusing or entering a value in the input.
         */
        floatLabelType?: ej.inputs.FloatLabelType;
        /**
         * ```
         * E.g : Input.createInput({ element: element, properties: { readonly: true, placeholder: 'Search here' } });
         * ```
         * To specifies the properties such as readonly,enable rtl,etc.
         */
        properties?: {
            readonly?: boolean;
            placeholder?: string;
            cssClass?: string;
            enableRtl?: boolean;
            enabled?: boolean;
            showClearButton?: boolean;
        };
    }
    /**
     * Default required properties for input components.
     */
    export interface IInput {
        /**
         *  Sets the placeholder value to input.
         */
        placeholder: string;
        /**
         *  Sets the css class value to input.
         */
        cssClass: string;
        /**
         *  Sets the enabled value to input.
         */
        enabled?: boolean;
        /**
         *  Sets the readonly value to input.
         */
        readonly: boolean;
        /**
         *  Sets the enable rtl value to input.
         */
        enableRtl: boolean;
        /**
         *  Specifies whether to display the Clear button in the input.
         */
        showClearButton?: boolean;
        /**
         * Specifies how the floating label works.
         * Possible values are:
         * * Never - Never float the label in the input when the placeholder is available.
         * * Always - The floating label will always float above the input.
         * * Auto - The floating label will float above the input after focusing or entering a value in the input.
         */
        floatLabelType?: ej.inputs.FloatLabelType;
        /**
         *  Sets the change event mapping function to input.
         */
        change: Function;
    }
    
    /**
     * @hidden
     * Built-in masking elements collection.
     */
    export let regularExpressions: {
        [key: string]: string;
    };
    /**
     * @hidden
     * Generate required masking elements to the MaskedTextBox from user mask input.
     */
    export function createMask(): void;
    /**
     * @hidden
     * Apply mask ability with masking elements to the MaskedTextBox.
     */
    export function applyMask(): void;
    /**
     * @hidden
     * To wire required events to the MaskedTextBox.
     */
    export function wireEvents(): void;
    /**
     * @hidden
     * To unwire events attached to the MaskedTextBox.
     */
    export function unwireEvents(): void;
    /**
     * @hidden
     * To get masked value from the MaskedTextBox.
     */
    export function unstrippedValue(element: HTMLInputElement): string;
    /**
     * @hidden
     * To extract raw value from the MaskedTextBox.
     */
    export function strippedValue(element: HTMLInputElement): string;
    export function maskInputFocusHandler(event: KeyboardEvent): void;
    export function maskInputBlurHandler(event: KeyboardEvent): void;
    export function maskInputDropHandler(event: MouseEvent): void;
    export function mobileRemoveFunction(): void;
    /**
     * @hidden
     * To set updated values in the MaskedTextBox.
     */
    export function setMaskValue(val?: string): void;
    /**
     * @hidden
     * To set updated values in the input element.
     */
    export function setElementValue(val: string, element?: HTMLInputElement): void;
    /**
     * @hidden
     * Provide mask support to input textbox through utility method.
     */
    export function maskInput(args: MaskInputArgs): void;
    /**
     * @hidden
     * Gets raw value of the textbox which has been masked through utility method.
     */
    export function getVal(args: GetValueInputArgs): string;
    /**
     * @hidden
     * Gets masked value of the textbox which has been masked through utility method.
     */
    export function getMaskedVal(args: GetValueInputArgs): string;
    /**
     * @hidden
     * Arguments to get the raw and masked value of MaskedTextBox which has been masked through utility method.
     */
    export interface GetValueInputArgs {
        element: HTMLInputElement;
        mask: string;
        promptChar?: string;
        customCharacters?: {
            [x: string]: Object;
        };
    }
    /**
     * @hidden
     * Arguments to mask input textbox through utility method.
     */
    export interface MaskInputArgs extends GetValueInputArgs {
        value?: string;
    }
    /**
     * @hidden
     * Arguments to perform undo and redo functionalities.
     */
    export class MaskUndo {
        value: string;
        startIndex: Number;
        endIndex: Number;
    }
    
    /**
     * Interface for a class MaskedTextBox
     */
    export interface MaskedTextBoxModel extends ej.base.ComponentModel{
    
        /**
         * Gets or sets the CSS classes to root element of the MaskedTextBox which helps to customize the
         * complete UI styles.
         * @default null
         */
        cssClass?: string;
    
        /**
         * Sets the width of the MaskedTextBox.
         * @default null
         */
        width?: number | string;
    
        /**
         * Gets or sets the string shown as a hint/placeholder when the MaskedTextBox is empty.
         * It acts as a label and floats above the MaskedTextBox based on the
         * <b><a href="#floatlabeltype-string" target="_blank">floatLabelType.</a></b>
         * @default null
         */
        placeholder?: string;
    
        /**
         * Sets the type of floating label which specifies whether to display the floating label above the MaskedTextBox.
         * The <b><a href="#placeholder-string" target="_blank">placeholder</a></b> acts as a label
         * and floats above the MaskedTextBox based on the below values.
         * Possible values are:
         * * Never - Never floats the label in the MaskedTextBox when the placeholder is available.
         * * Always - The floating label always floats above the MaskedTextBox.
         * * Auto - The floating label floats above the MaskedTextBox after focusing it or when enters the value in it.
         * @default Never
         */
        floatLabelType?: ej.inputs.FloatLabelType;
    
        /**
         * Sets a value that enables or disables the MaskedTextBox component.
         * @default true
         */
        enabled?: boolean;
    
        /**
         * Sets a value that enables or disables the persisting state of the MaskedTextBox after reloading the page.
         * If enabled, the 'value' state will be persisted.
         * @default false
         */
        enablePersistence?: boolean;
    
        /**
         * Sets a value that enables or disables the RTL mode on the MaskedTextBox. If it is true, 
         * MaskedTextBox will display the content in the right to left direction.
         * @default false
         */
        enableRtl?: boolean;
    
        /**
         * Sets a value that masks the MaskedTextBox to allow/validate the user input.
         * * Mask allows <b><a href="../maskedtextbox/mask-configuration.html#standard-mask-elements" target="_blank">standard mask elements
         * </a></b>, <b><a href="../maskedtextbox/mask-configuration.html#custom-characters" target="_blank">custom characters</a></b> and
         * <b><a href="../maskedtextbox/mask-configuration.html#regular-expression" target="_blank">regular expression</a></b> as mask elements.
         * * If the mask value is empty, the MaskedTextBox will behave as an input element with text type.
         * @default null
         */
        mask?: string;
    
        /**
         * Gets or sets a value that will be shown as a prompting symbol for the masked value.
         * The symbol used to show input positions in the MaskedTextBox.
         * @default _
         */
        promptChar?: string;
    
        /**
         * Gets or sets the value of the MaskedTextBox. It is a raw value of the MaskedTextBox excluding literals
         * and prompt characters.
         * ```html
         * <input id="mask" type="text" />
         * ```
         * ```typescript
         * <script>
         * var maskObj = new MaskedTextBox({ mask: "(999) 9999-999", value: "8674321756" });
         * maskObj.appendTo('#mask');
         * </script>
         * ```
         * @default null
         */
        value?: string;
    
        /**
         * Sets the collection of values to be mapped for non-mask elements(literals)
         * which have been set in the mask of MaskedTextBox.
         * * In the below example, non-mask elements "P" accepts values
         * "P" , "A" , "p" , "a" and "M" accepts values "M", "m" mentioned in the custom characters collection.
         * ```html
         * <input id="mask" type="text" />
         * ```
         * ```typescript
         * <script>
         * var customChar = { P: 'P,A,p,a', M: 'M,m'};
         * var maskObj = new MaskedTextBox({ mask: "99 : 99 PM", customCharacters: customChar });
         * maskObj.appendTo('#mask');
         * </script>
         * ```
         * @default null
         */
        customCharacters?: { [x: string]: Object };
    
        /**
         * Triggers when the MaskedTextBox component is created.
         * @event
         */
        created?: ej.base.EmitType<Object>;
    
        /**
         * Triggers when the MaskedTextBox component is destroyed.
         * @event
         */
        destroyed?: ej.base.EmitType<Object>;
    
        /**
         * Triggers when the value of the MaskedTextBox changes.
         * @event
         */
        change?: ej.base.EmitType <MaskChangeEventArgs>;
    
        /**
         * Triggers when the MaskedTextBox while got focus in.
         * @event
         */
        focus?: ej.base.EmitType<MaskFocusEventArgs>;
    
    }
    
    /**
     * The MaskedTextBox allows the user to enter the valid input only based on the provided mask.
     * ```html
     * <input id="mask" type="text" />
     * ```
     * ```typescript
     * <script>
     * var maskObj = new MaskedTextBox({ mask: "(999) 9999-999" });
     * maskObj.appendTo('#mask');
     * </script>
     * ```
     */
    export class MaskedTextBox extends ej.base.Component<HTMLInputElement> implements ej.base.INotifyPropertyChanged {
        private cloneElement;
        private promptMask;
        private hiddenMask;
        private escapeMaskValue;
        private regExpCollec;
        private customRegExpCollec;
        private inputObj;
        private undoCollec;
        private redoCollec;
        private changeEventArgs;
        private focusEventArgs;
        private maskKeyPress;
        private angularTagName;
        private prevValue;
        private isFocus;
        private isInitial;
        private isIosInvalid;
        /**
         * Gets or sets the CSS classes to root element of the MaskedTextBox which helps to customize the
         * complete UI styles.
         * @default null
         */
        cssClass: string;
        /**
         * Sets the width of the MaskedTextBox.
         * @default null
         */
        width: number | string;
        /**
         * Gets or sets the string shown as a hint/placeholder when the MaskedTextBox is empty.
         * It acts as a label and floats above the MaskedTextBox based on the
         * <b><a href="#floatlabeltype-string" target="_blank">floatLabelType.</a></b>
         * @default null
         */
        placeholder: string;
        /**
         * Sets the type of floating label which specifies whether to display the floating label above the MaskedTextBox.
         * The <b><a href="#placeholder-string" target="_blank">placeholder</a></b> acts as a label
         * and floats above the MaskedTextBox based on the below values.
         * Possible values are:
         * * Never - Never floats the label in the MaskedTextBox when the placeholder is available.
         * * Always - The floating label always floats above the MaskedTextBox.
         * * Auto - The floating label floats above the MaskedTextBox after focusing it or when enters the value in it.
         * @default Never
         */
        floatLabelType: ej.inputs.FloatLabelType;
        /**
         * Sets a value that enables or disables the MaskedTextBox component.
         * @default true
         */
        enabled: boolean;
        /**
         * Sets a value that enables or disables the persisting state of the MaskedTextBox after reloading the page.
         * If enabled, the 'value' state will be persisted.
         * @default false
         */
        enablePersistence: boolean;
        /**
         * Sets a value that enables or disables the RTL mode on the MaskedTextBox. If it is true,
         * MaskedTextBox will display the content in the right to left direction.
         * @default false
         */
        enableRtl: boolean;
        /**
         * Sets a value that masks the MaskedTextBox to allow/validate the user input.
         * * Mask allows <b><a href="../maskedtextbox/mask-configuration.html#standard-mask-elements" target="_blank">standard mask elements
         * </a></b>, <b><a href="../maskedtextbox/mask-configuration.html#custom-characters" target="_blank">custom characters</a></b> and
         * <b><a href="../maskedtextbox/mask-configuration.html#regular-expression" target="_blank">regular expression</a></b> as mask elements.
         * * If the mask value is empty, the MaskedTextBox will behave as an input element with text type.
         * @default null
         */
        mask: string;
        /**
         * Gets or sets a value that will be shown as a prompting symbol for the masked value.
         * The symbol used to show input positions in the MaskedTextBox.
         * @default _
         */
        promptChar: string;
        /**
         * Gets or sets the value of the MaskedTextBox. It is a raw value of the MaskedTextBox excluding literals
         * and prompt characters.
         * ```html
         * <input id="mask" type="text" />
         * ```
         * ```typescript
         * <script>
         * var maskObj = new MaskedTextBox({ mask: "(999) 9999-999", value: "8674321756" });
         * maskObj.appendTo('#mask');
         * </script>
         * ```
         * @default null
         */
        value: string;
        /**
         * Sets the collection of values to be mapped for non-mask elements(literals)
         * which have been set in the mask of MaskedTextBox.
         * * In the below example, non-mask elements "P" accepts values
         * "P" , "A" , "p" , "a" and "M" accepts values "M", "m" mentioned in the custom characters collection.
         * ```html
         * <input id="mask" type="text" />
         * ```
         * ```typescript
         * <script>
         * var customChar = { P: 'P,A,p,a', M: 'M,m'};
         * var maskObj = new MaskedTextBox({ mask: "99 : 99 PM", customCharacters: customChar });
         * maskObj.appendTo('#mask');
         * </script>
         * ```
         * @default null
         */
        customCharacters: {
            [x: string]: Object;
        };
        /**
         * Triggers when the MaskedTextBox component is created.
         * @event
         */
        created: ej.base.EmitType<Object>;
        /**
         * Triggers when the MaskedTextBox component is destroyed.
         * @event
         */
        destroyed: ej.base.EmitType<Object>;
        /**
         * Triggers when the value of the MaskedTextBox changes.
         * @event
         */
        change: ej.base.EmitType<MaskChangeEventArgs>;
        /**
         * Triggers when the MaskedTextBox while got focus in.
         * @event
         */
        focus: ej.base.EmitType<MaskFocusEventArgs>;
        constructor(options?: MaskedTextBoxModel, element?: string | HTMLElement | HTMLInputElement);
        /**
         * Gets the component name
         * @private
         */
        protected getModuleName(): string;
        /**
         * Initializes the event handler
         * @private
         */
        protected preRender(): void;
        /**
         * Gets the properties to be maintained in the persisted state.
         * @return {string}
         */
        getPersistData(): string;
        /**
         * Initializes the component rendering.
         * @private
         */
        render(): void;
        private resetMaskedTextBox();
        private setMaskPlaceholder(setVal);
        private setCssClass(cssClass, element);
        private setWidth(width);
        private createWrapper();
        /**
         * Calls internally if any of the property value is changed.
         * @hidden
         */
        onPropertyChanged(newProp: MaskedTextBoxModel, oldProp: MaskedTextBoxModel): void;
        private updateValue(strippedVal);
        /**
         * Gets the value of the MaskedTextBox with the masked format.
         * @return {string}
         */
        getMaskedValue(): string;
        /**
         * Removes the component from the DOM and detaches all its related event handlers.
         * Also it maintains the initial input element from the DOM.
         * @method destroy
         * @return {void}
         */
        destroy(): void;
    }
    export interface MaskChangeEventArgs extends ej.base.BaseEventArgs {
        /** Returns the value of the MaskedTextBox with the masked format. */
        maskedValue?: string;
        /** Returns the raw value of MaskedTextBox by removing the prompt characters and literals(non-mask elements)
         * which have been set in the mask of MaskedTextBox.
         */
        value?: string;
        /** Returns true when the value of MaskedTextBox is changed by user interaction. Otherwise, it returns false */
        isInteraction?: boolean;
        /** Returns the original event arguments. */
        event?: Event;
    }
    export interface MaskFocusEventArgs extends ej.base.BaseEventArgs {
        /** Returns selectionStart value as zero by default */
        selectionStart?: number;
        /** Returns selectionEnd value depends on mask length */
        selectionEnd?: number;
    }
    
    /**
     * Interface for a class NumericTextBox
     */
    export interface NumericTextBoxModel extends ej.base.ComponentModel{
    
        /**
         * Gets or Sets the CSS classes to root element of the NumericTextBox which helps to customize the
         * complete UI styles.
         * @default null
         */
        cssClass?: string;
    
        /**
         * Sets the value of the NumericTextBox.
         * @default null
         */
        value?: number;
    
        /**
         * Specifies a minimum value that is allowed a user can enter.
         * @default null
         */
        min?: number;
    
        /**
         * Specifies a maximum value that is allowed a user can enter.
         * @default null
         */
        max?: number;
    
        /**
         * Specifies the incremental or decremental step size for the NumericTextBox.
         * @default 1
         */
        step?: number;
    
        /**
         * Specifies the width of the NumericTextBox.
         * @default null
         */
        width?: number | string;
    
        /**
         * Gets or sets the string shown as a hint/placeholder when the NumericTextBox is empty.
         * It acts as a label and floats above the NumericTextBox based on the
         * <b><a href="#floatlabeltype-string" target="_blank">floatLabelType.</a></b>
         * @default null
         */
        placeholder?: string;
    
        /**
         * Specifies whether the up and down spin buttons should be displayed in NumericTextBox.
         * @default true
         */
        showSpinButton?: boolean;
    
        /**
         * Sets a value that enables or disables the readonly state on the NumericTextBox. If it is true, 
         * NumericTextBox will not allow your input.
         * @default false
         */
        readonly?: boolean;
    
        /**
         * Sets a value that enables or disables the NumericTextBox control.
         * @default true
         */
        enabled?: boolean;
    
        /**
         * Sets a value that enables or disables the RTL mode on the NumericTextBox. If it is true, 
         * NumericTextBox will display the content in the right to left direction.
         * @default false
         */
        enableRtl?: boolean;
    
        /**
         * Enable or disable persisting NumericTextBox state between page reloads. If enabled, the `value` state will be persisted.
         * @default false
         */
        enablePersistence?: boolean;
    
        /**
         * Specifies the number format that indicates the display format for the value of the NumericTextBox.
         * @default 'n2'
         */
        format?: string;
    
        /**
         * Specifies the number precision applied to the textbox value when the NumericTextBox is focused.
         * @default null
         */
        decimals?: number;
    
        /**
         * Specifies the currency code to use in currency formatting.
         * Possible values are the ISO 4217 currency codes, such as 'USD' for the US dollar,'EUR' for the euro.
         * @default null
         */
        currency?: string;
    
        /**
         * Specifies the currency code to use in currency formatting.
         * Possible values are the ISO 4217 currency codes, such as 'USD' for the US dollar,'EUR' for the euro.
         * @default null
         * @private
         */
        currencyCode?: string;
    
        /**
         * Specifies a value that indicates whether the NumericTextBox control allows the value for the specified range.
         * * If it is true, the input value will be restricted between the min and max range.
         * The typed value gets modified to fit the range on focused out state.
         * ```html
         * <input type='text' id="numeric"/>
         * ```
         * ```typescript
         * <script>
         *   var numericObj = new NumericTextBox({ min: 10, max: 20, value: 15 });
         *   numericObj.appendTo("#numeric");
         * </script>
         * ```
         * * Else, it allows any value even out of range value,
         * At that time of wrong value entered, the error class will be added to the component to highlight the error.
         * ```html
         * <input type='text' id="numeric"/>
         * ```
         * ```typescript
         * <script>
         *   var numericObj = new NumericTextBox({ strictMode: false, min: 10, max: 20, value: 15 });
         *   numericObj.appendTo("#numeric");
         * </script>
         * ```
         * @default true
         */
        strictMode?: boolean;
    
        /**
         * Specifies whether the decimals length should be restricted during typing.
         * @default false
         */
        validateDecimalOnType?: boolean;
    
        /**
         * Sets the type of floating label which enables or disables the floating label in the NumericTextBox.
         * The <b><a href="#placeholder-string" target="_blank">placeholder</a></b> acts as a label
         * and floats above the NumericTextBox based on the below values.
         * Possible values are:
         * * `Never` - Never floats the label in the NumericTextBox when the placeholder is available.
         * * `Always` - The floating label always floats above the NumericTextBox.
         * * `Auto` - The floating label floats above the NumericTextBox after focusing it or when enters the value in it.
         * @default Never
         */
        floatLabelType?: ej.inputs.FloatLabelType;
    
        /**
         * Triggers when the NumericTextBox component is created.
         * @event
         */
        created?: ej.base.EmitType<Object>;
    
        /**
         * Triggers when the NumericTextBox component is destroyed.
         * @event
         */
        destroyed?: ej.base.EmitType<Object>;
    
        /**
         * Triggers when the value of the NumericTextBox changes.
         * @event
         */
        change?: ej.base.EmitType<ChangeEventArgs>;
    
    }
    
    /**
     * Represents the NumericTextBox component that allows the user to enter only numeric values.
     * ```html
     * <input type='text' id="numeric"/>
     * ```
     * ```typescript
     * <script>
     *   var numericObj = new NumericTextBox({ value: 10 });
     *   numericObj.appendTo("#numeric");
     * </script>
     * ```
     */
    export class NumericTextBox extends ej.base.Component<HTMLInputElement> implements ej.base.INotifyPropertyChanged {
        private container;
        private cloneElement;
        private hiddenInput;
        private spinUp;
        private spinDown;
        private timeOut;
        private prevValue;
        private isValidState;
        private isFocused;
        private isPrevFocused;
        private instance;
        private cultureInfo;
        private inputStyle;
        private inputName;
        private decimalSeparator;
        private angularTagName;
        private intRegExp;
        private l10n;
        private isCalled;
        private changeEventArgs;
        private isInteract;
        /**
         * Gets or Sets the CSS classes to root element of the NumericTextBox which helps to customize the
         * complete UI styles.
         * @default null
         */
        cssClass: string;
        /**
         * Sets the value of the NumericTextBox.
         * @default null
         */
        value: number;
        /**
         * Specifies a minimum value that is allowed a user can enter.
         * @default null
         */
        min: number;
        /**
         * Specifies a maximum value that is allowed a user can enter.
         * @default null
         */
        max: number;
        /**
         * Specifies the incremental or decremental step size for the NumericTextBox.
         * @default 1
         */
        step: number;
        /**
         * Specifies the width of the NumericTextBox.
         * @default null
         */
        width: number | string;
        /**
         * Gets or sets the string shown as a hint/placeholder when the NumericTextBox is empty.
         * It acts as a label and floats above the NumericTextBox based on the
         * <b><a href="#floatlabeltype-string" target="_blank">floatLabelType.</a></b>
         * @default null
         */
        placeholder: string;
        /**
         * Specifies whether the up and down spin buttons should be displayed in NumericTextBox.
         * @default true
         */
        showSpinButton: boolean;
        /**
         * Sets a value that enables or disables the readonly state on the NumericTextBox. If it is true,
         * NumericTextBox will not allow your input.
         * @default false
         */
        readonly: boolean;
        /**
         * Sets a value that enables or disables the NumericTextBox control.
         * @default true
         */
        enabled: boolean;
        /**
         * Sets a value that enables or disables the RTL mode on the NumericTextBox. If it is true,
         * NumericTextBox will display the content in the right to left direction.
         * @default false
         */
        enableRtl: boolean;
        /**
         * Enable or disable persisting NumericTextBox state between page reloads. If enabled, the `value` state will be persisted.
         * @default false
         */
        enablePersistence: boolean;
        /**
         * Specifies the number format that indicates the display format for the value of the NumericTextBox.
         * @default 'n2'
         */
        format: string;
        /**
         * Specifies the number precision applied to the textbox value when the NumericTextBox is focused.
         * @default null
         */
        decimals: number;
        /**
         * Specifies the currency code to use in currency formatting.
         * Possible values are the ISO 4217 currency codes, such as 'USD' for the US dollar,'EUR' for the euro.
         * @default null
         */
        currency: string;
        /**
         * Specifies the currency code to use in currency formatting.
         * Possible values are the ISO 4217 currency codes, such as 'USD' for the US dollar,'EUR' for the euro.
         * @default null
         * @private
         */
        private currencyCode;
        /**
         * Specifies a value that indicates whether the NumericTextBox control allows the value for the specified range.
         * * If it is true, the input value will be restricted between the min and max range.
         * The typed value gets modified to fit the range on focused out state.
         * ```html
         * <input type='text' id="numeric"/>
         * ```
         * ```typescript
         * <script>
         *   var numericObj = new NumericTextBox({ min: 10, max: 20, value: 15 });
         *   numericObj.appendTo("#numeric");
         * </script>
         * ```
         * * Else, it allows any value even out of range value,
         * At that time of wrong value entered, the error class will be added to the component to highlight the error.
         * ```html
         * <input type='text' id="numeric"/>
         * ```
         * ```typescript
         * <script>
         *   var numericObj = new NumericTextBox({ strictMode: false, min: 10, max: 20, value: 15 });
         *   numericObj.appendTo("#numeric");
         * </script>
         * ```
         * @default true
         */
        strictMode: boolean;
        /**
         * Specifies whether the decimals length should be restricted during typing.
         * @default false
         */
        validateDecimalOnType: boolean;
        /**
         * Sets the type of floating label which enables or disables the floating label in the NumericTextBox.
         * The <b><a href="#placeholder-string" target="_blank">placeholder</a></b> acts as a label
         * and floats above the NumericTextBox based on the below values.
         * Possible values are:
         * * `Never` - Never floats the label in the NumericTextBox when the placeholder is available.
         * * `Always` - The floating label always floats above the NumericTextBox.
         * * `Auto` - The floating label floats above the NumericTextBox after focusing it or when enters the value in it.
         * @default Never
         */
        floatLabelType: ej.inputs.FloatLabelType;
        /**
         * Triggers when the NumericTextBox component is created.
         * @event
         */
        created: ej.base.EmitType<Object>;
        /**
         * Triggers when the NumericTextBox component is destroyed.
         * @event
         */
        destroyed: ej.base.EmitType<Object>;
        /**
         * Triggers when the value of the NumericTextBox changes.
         * @event
         */
        change: ej.base.EmitType<ChangeEventArgs>;
        constructor(options?: NumericTextBoxModel, element?: string | HTMLInputElement);
        protected preRender(): void;
        /**
         * To Initialize the control rendering
         * @private
         */
        render(): void;
        private checkAttributes();
        private updatePlaceholder();
        private initCultureFunc();
        private initCultureInfo();
        private createWrapper();
        private spinBtnCreation();
        private validateMinMax();
        private formattedValue(decimals, value);
        private validateStep();
        private action(operation, event);
        private checkErrorClass();
        private wireEvents();
        private wireSpinBtnEvents();
        private unwireEvents();
        private unwireSpinBtnEvents();
        private changeHandler(event);
        private raiseChangeEvent(event?);
        private pasteHandler();
        private keyDownHandler(event);
        private performAction(value, step, operation);
        private correctRounding(value, step, result);
        private roundValue(result, precision);
        private updateValue(value, event?);
        private updateCurrency(prop, propVal);
        private changeValue(value);
        private modifyText();
        private setElementValue(val, element?);
        private validateState();
        private formatNumber();
        private trimValue(value);
        private roundNumber(value, precision);
        private cancelEvent(event);
        private keyPressHandler(event);
        private numericRegex();
        private mouseWheel(event);
        private focusIn(event);
        private focusOut(event);
        private mouseDownOnSpinner(event);
        private touchMoveOnSpinner(event);
        private mouseUpOnSpinner(event);
        private getElementData(event);
        private mouseUpClick(event);
        /**
         * Increments the NumericTextBox value with the specified step value.
         * @param  {number} step - Specifies the value used to increment the NumericTextBox value.
         * if its not given then numeric value will be incremented based on the step property value.
         */
        increment(step?: number): void;
        /**
         * Decrements the NumericTextBox value with specified step value.
         * @param  {number} step - Specifies the value used to decrement the NumericTextBox value.
         * if its not given then numeric value will be decremented based on the step property value.
         */
        decrement(step?: number): void;
        /**
         * Removes the component from the DOM and detaches all its related event handlers.
         * Also it maintains the initial input element from the DOM.
         * @method destroy
         * @return {void}
         */
        destroy(): void;
        /**
         * Returns the value of NumericTextBox with the format applied to the NumericTextBox.
         */
        getText(): string;
        /**
         * Gets the properties to be maintained in the persisted state.
         * @return {string}
         */
        getPersistData(): string;
        /**
         * Calls internally if any of the property value is changed.
         * @private
         */
        onPropertyChanged(newProp: NumericTextBoxModel, oldProp: NumericTextBoxModel): void;
        /**
         * Gets the component name
         * @private
         */
        getModuleName(): string;
    }
    export interface ChangeEventArgs extends ej.base.BaseEventArgs {
        /** Returns the entered value of the NumericTextBox. */
        value?: number;
        /** Returns the previously entered value of the NumericTextBox. */
        previousValue?: number;
        /** Returns the event parameters from NumericTextBox. */
        event?: Event;
        /** Returns the original event arguments. */
        isInteraction?: boolean;
    }
    
    /**
     * Interface for a class TicksData
     */
    export interface TicksDataModel {
    
        /**
         * It is used to denote the position of the ticks in the Slider. The available options are:
         *
         *  * before - Ticks are placed in the top of the horizontal slider bar or at the left of the vertical slider bar.
         *  * after - Ticks are placed in the bottom of the horizontal slider bar or at the right of the vertical slider bar.
         *  * both - Ticks are placed on the both side of the Slider bar.
         *  * none - Ticks are not shown.
         *
         * @default : 'None'
         */
        placement?: Placement;
    
        /**
         * It is used to denote the distance between two major (large) ticks from the scale of the Slider.
         * @default : 10
         */
        largeStep?: number;
    
        /**
         * It is used to denote the distance between two minor (small) ticks from the scale of the Slider.
         * @default : 1
         */
        smallStep?: number;
    
        /**
         * We can show or hide the small ticks in the Slider, which will be appeared in between the largeTicks.
         * @default : false
         */
        showSmallTicks?: boolean;
    
        /**
         * It is used to customize the Slider scale value to the desired format using Internationalization or events(custom formatting).
         */
        format?: string;
    
    }
    
    /**
     * Interface for a class TooltipData
     */
    export interface TooltipDataModel {
    
        /**
         * It is used to customize the Tooltip which accepts custom CSS class names that define
         *  specific user-defined styles and themes to be applied on the Tooltip element.
         * @default ''
         */
        cssClass?: string;
    
        /**
         * It is used to denote the position for the tooltip element in the Slider. The available options are:
         *
         *  * Before - Tooltip is shown in the top of the horizontal slider bar or at the left of the vertical slider bar.
         *  * After - Tooltip is shown in the bottom of the horizontal slider bar or at the right of the vertical slider bar.
         */
        placement?: TooltipPlacement;
    
        /**
         * It is used to determine the device mode to show the Tooltip.
         * If it is in desktop, it will show the Tooltip content when hovering on the target element.
         * If it is in touch device. It will show the Tooltip content when tap and holding on the target element.
         * @default 'Auto'
         */
        showOn?: TooltipShowOn;
    
        /**
         * It is used to show or hide the Tooltip of Slider Component.
         */
        isVisible?: boolean;
    
        /**
         * It is used to customize the Tooltip content to the desired format
         *  using internationalization or events (custom formatting).
         */
        format?: string;
    
    }
    
    /**
     * Interface for a class Slider
     */
    export interface SliderModel extends ej.base.ComponentModel{
    
        /**
         * It is used to denote the current value of the Slider.
         * The value should be specified in array of number when render Slider type as range.
         * @default null
         */
        value?: number | number[];
    
        /**
         * It is used to denote the step value of Slider component which is the amount of Slider value change
         *  when increase / decrease button is clicked or press arrow keys or drag the thumb.
         *  Refer the documentation
         *  {@link http://ej2.syncfusion.com/documentation/slider/ticks.html?lang=typescript#step here}
         *  to know more about this property with demo.
         * @default 1
         */
        step?: number;
    
        /**
         * It sets the minimum value of Slider Component
         * @default 0
         */
        min?: number;
    
        /**
         * It sets the maximum value of Slider Component
         * @default 100
         */
        max?: number;
    
        /**
         * It is used to render the Slider component in read-only mode.
         * The slider rendered with user defined values and can’t be interacted with user actions.
         * @default false
         */
        readOnly?: boolean;
    
        /**
         * It is used to denote the type of the Slider. The available options are:
         *
         *  * default - Used to select a single value in the Slider.
         *  * minRange - Used to select a single value in the Slider. It displays shadow from the start value to the current value.
         *  * range - Used to select a range of values in the Slider. It displays shadow in-between the selection range.
         */
        type?: SliderType;
    
        /**
         * It is used to render the slider ticks options such as placement and step values.
         * Refer the documentation
         *  {@link http://ej2.syncfusion.com/documentation/slider/ticks.html?lang=typescript here}
         *  to know more about this property with demo.
         * @default { placement: 'before' }
         */
        ticks?: TicksDataModel;
    
        /**
         * It is used to enable or disable the slider.
         * @default true
         */
        enabled?: boolean;
    
        /**
         * It is used to render the Slider component from right to left direction.
         * @default false
         */
        enableRtl?: boolean;
    
        /**
         * It is used to denote the slider tooltip and it's position.
         * @default { placement: 'Before', isVisible: false, showOn: 'Focus', format: null }
         */
        tooltip?: TooltipDataModel;
    
        /**
         * It is used to show or hide the increase and decrease button of Slider Component,
         *  which is used to change the slider value.
         * Refer the documentation
         *  {@link http://ej2.syncfusion.com/documentation/slider/getting-started.html?lang=typescript#buttons here}
         *  to know more about this property with demo.
         * @default false
         */
        showButtons?: boolean;
    
        /**
         * It is used to enable or disable the Slider handle moving animation.
         * @default true
         */
        enableAnimation?: boolean;
    
        /**
         * It is used to render Slider in either horizontal or vertical orientation.
         *  Refer the documentation
         *  {@link http://ej2.syncfusion.com/documentation/slider/getting-started.html?lang=typescript#orientation here}
         *  to know more about this property with demo.
         * @default 'Horizontal'
         */
        orientation?: SliderOrientation;
    
        /**
         * This property sets the CSS classes to root element of the Slider
         *  which helps to customize the UI styles.
         * @default ''
         */
        cssClass?: string;
    
        /**
         * We can trigger created event when the Slider is created.
         * @event
         */
        created?: ej.base.EmitType<Object>;
    
        /**
         * We can trigger change event whenever Slider value is changed.
         *  In other term, this event will be triggered while drag the slider thumb.
         * @event
         */
        change?: ej.base.EmitType<Object>;
    
        /**
         * We can trigger changed event when Slider component action is completed while we change the Slider value.
         *  In other term, this event will be triggered, while drag the slider thumb completed.
         * @event
         */
        changed?: ej.base.EmitType<Object>;
    
        /**
         * We can trigger renderingTicks event when the ticks rendered on Slider,
         *  which is used to customize the ticks labels dynamically.
         * @event
         */
        renderingTicks?: ej.base.EmitType<Object>;
    
        /**
         * We can trigger renderedTicks event when the ticks are rendered on the Slider.
         * @event
         */
        renderedTicks?: ej.base.EmitType<Object>;
    
        /**
         * We can trigger tooltipChange event when we change the Sider tooltip value.
         * @event
         */
        tooltipChange?: ej.base.EmitType<SliderTooltipEventArgs>;
    
    }
    
    /**
     * Configures the ticks data of the Slider.
     */
    export class TicksData extends ej.base.ChildProperty<TicksData> {
        /**
         * It is used to denote the position of the ticks in the Slider. The available options are:
         *
         *  * before - Ticks are placed in the top of the horizontal slider bar or at the left of the vertical slider bar.
         *  * after - Ticks are placed in the bottom of the horizontal slider bar or at the right of the vertical slider bar.
         *  * both - Ticks are placed on the both side of the Slider bar.
         *  * none - Ticks are not shown.
         *
         * @default : 'None'
         */
        placement: Placement;
        /**
         * It is used to denote the distance between two major (large) ticks from the scale of the Slider.
         * @default : 10
         */
        largeStep: number;
        /**
         * It is used to denote the distance between two minor (small) ticks from the scale of the Slider.
         * @default : 1
         */
        smallStep: number;
        /**
         * We can show or hide the small ticks in the Slider, which will be appeared in between the largeTicks.
         * @default : false
         */
        showSmallTicks: boolean;
        /**
         * It is used to customize the Slider scale value to the desired format using Internationalization or events(custom formatting).
         */
        format: string;
    }
    /**
     * It is used to denote the TooltipChange Event arguments.
     */
    export interface SliderTooltipEventArgs {
        /**
         * It is used to get the value of the Slider.
         */
        value: number | number[];
        /**
         * It is used to get the text shown in the Slider tooltip.
         */
        text: string;
    }
    /**
     * It is used to denote the Slider Change/Changed Event arguments.
     */
    export interface SliderChangeEventArgs {
        /**
         * It is used to get the current value of the Slider.
         */
        value: number | number[];
        /**
         * It is used to get the previous value of the Slider.
         */
        previousValue: number | number[];
        /**
         * It is used to get the current text or formatted text of the Slider, which is placed in tooltip.
         */
        text?: string;
        /**
         * It is used to get the action applied on the Slider.
         */
        action: string;
    }
    /**
     * It is used to denote the TicksRender Event arguments.
     */
    export interface SliderTickEventArgs {
        /**
         * It is used to get the value of the tick.
         */
        value: number;
        /**
         * It is used to get the label text of the tick.
         */
        text: string;
        /**
         * It is used to get the current tick element.
         */
        tickElement: Element;
    }
    /**
     * It is used t denote the ticks rendered Event arguments.
     */
    export interface SliderTickRenderedEventArgs {
        /**
         * It returns the wrapper of the ticks element.
         */
        ticksWrapper: HTMLElement;
        /**
         * It returns the collection of tick elements.
         */
        tickElements: HTMLElement[];
    }
    /**
     * It illustrates the tooltip data in slider.
     */
    export class TooltipData extends ej.base.ChildProperty<TooltipData> {
        /**
         * It is used to customize the Tooltip which accepts custom CSS class names that define
         *  specific user-defined styles and themes to be applied on the Tooltip element.
         * @default ''
         */
        cssClass: string;
        /**
         * It is used to denote the position for the tooltip element in the Slider. The available options are:
         *
         *  * Before - Tooltip is shown in the top of the horizontal slider bar or at the left of the vertical slider bar.
         *  * After - Tooltip is shown in the bottom of the horizontal slider bar or at the right of the vertical slider bar.
         */
        placement: TooltipPlacement;
        /**
         * It is used to determine the device mode to show the Tooltip.
         * If it is in desktop, it will show the Tooltip content when hovering on the target element.
         * If it is in touch device. It will show the Tooltip content when tap and holding on the target element.
         * @default 'Auto'
         */
        showOn: TooltipShowOn;
        /**
         * It is used to show or hide the Tooltip of Slider Component.
         */
        isVisible: boolean;
        /**
         * It is used to customize the Tooltip content to the desired format
         *  using internationalization or events (custom formatting).
         */
        format: string;
    }
    /**
     * Ticks Placement.
     */
    export type Placement = 'Before' | 'After' | 'Both' | 'None';
    /**
     * Tooltip Placement.
     */
    export type TooltipPlacement = 'Before' | 'After';
    /**
     * Tooltip ShowOn.
     */
    export type TooltipShowOn = 'Focus' | 'Hover' | 'Always' | 'Auto';
    /**
     * Slider type.
     */
    export type SliderType = 'Default' | 'MinRange' | 'Range';
    /**
     * Slider orientation.
     */
    export type SliderOrientation = 'Horizontal' | 'Vertical';
    /**
     * The Slider component allows the user to select a value or range
     * of values in-between a min and max range, by dragging the handle over the slider bar.
     * ```html
     * <div id='slider'></div>
     * ```
     * ```typescript
     * <script>
     *   var sliderObj = new Slider({ value: 10 });
     *   sliderObj.appendTo('#slider');
     * </script>
     * ```
     */
    export class Slider extends ej.base.Component<HTMLElement> implements ej.base.INotifyPropertyChanged {
        private hiddenInput;
        private firstHandle;
        private sliderContainer;
        private secondHandle;
        private rangeBar;
        private onresize;
        private currentVal;
        private handlePos1;
        private handlePos2;
        private rtl;
        private preHandlePos1;
        private preHandlePos2;
        private handleVal1;
        private handleVal2;
        private val;
        private activeHandle;
        private sliderTrack;
        private firstMaterialHandle;
        private secondMaterialHandle;
        private firstBtn;
        private firstTooltipObj;
        private secondTooltipObj;
        private firstTooltipElement;
        private secondTooltipElement;
        private secondBtn;
        private ul;
        private firstChild;
        private firstHandleTooltipPosition;
        private secondHandleTooltipPosition;
        private lastChild;
        private previousTooltipClass;
        private horDir;
        private verDir;
        private transition;
        private transitionOnMaterialTooltip;
        private scaleTransform;
        private previousVal;
        private previousChanged;
        private repeatInterval;
        private isMaterial;
        private zIndex;
        private l10n;
        private internationalization;
        private tooltipFormatInfo;
        private ticksFormatInfo;
        private customAriaText;
        private noOfDecimals;
        private tickElementCollection;
        /**
         * It is used to denote the current value of the Slider.
         * The value should be specified in array of number when render Slider type as range.
         * @default null
         */
        value: number | number[];
        /**
         * It is used to denote the step value of Slider component which is the amount of Slider value change
         *  when increase / decrease button is clicked or press arrow keys or drag the thumb.
         *  Refer the documentation
         *  {@link http://ej2.syncfusion.com/documentation/slider/ticks.html?lang=typescript#step here}
         *  to know more about this property with demo.
         * @default 1
         */
        step: number;
        /**
         * It sets the minimum value of Slider Component
         * @default 0
         */
        min: number;
        /**
         * It sets the maximum value of Slider Component
         * @default 100
         */
        max: number;
        /**
         * It is used to render the Slider component in read-only mode.
         * The slider rendered with user defined values and can’t be interacted with user actions.
         * @default false
         */
        readOnly: boolean;
        /**
         * It is used to denote the type of the Slider. The available options are:
         *
         *  * default - Used to select a single value in the Slider.
         *  * minRange - Used to select a single value in the Slider. It displays shadow from the start value to the current value.
         *  * range - Used to select a range of values in the Slider. It displays shadow in-between the selection range.
         */
        type: SliderType;
        /**
         * It is used to render the slider ticks options such as placement and step values.
         * Refer the documentation
         *  {@link http://ej2.syncfusion.com/documentation/slider/ticks.html?lang=typescript here}
         *  to know more about this property with demo.
         * @default { placement: 'before' }
         */
        ticks: TicksDataModel;
        /**
         * It is used to enable or disable the slider.
         * @default true
         */
        enabled: boolean;
        /**
         * It is used to render the Slider component from right to left direction.
         * @default false
         */
        enableRtl: boolean;
        /**
         * It is used to denote the slider tooltip and it's position.
         * @default { placement: 'Before', isVisible: false, showOn: 'Focus', format: null }
         */
        tooltip: TooltipDataModel;
        /**
         * It is used to show or hide the increase and decrease button of Slider Component,
         *  which is used to change the slider value.
         * Refer the documentation
         *  {@link http://ej2.syncfusion.com/documentation/slider/getting-started.html?lang=typescript#buttons here}
         *  to know more about this property with demo.
         * @default false
         */
        showButtons: boolean;
        /**
         * It is used to enable or disable the Slider handle moving animation.
         * @default true
         */
        enableAnimation: boolean;
        /**
         * It is used to render Slider in either horizontal or vertical orientation.
         *  Refer the documentation
         *  {@link http://ej2.syncfusion.com/documentation/slider/getting-started.html?lang=typescript#orientation here}
         *  to know more about this property with demo.
         * @default 'Horizontal'
         */
        orientation: SliderOrientation;
        /**
         * This property sets the CSS classes to root element of the Slider
         *  which helps to customize the UI styles.
         * @default ''
         */
        cssClass: string;
        /**
         * We can trigger created event when the Slider is created.
         * @event
         */
        created: ej.base.EmitType<Object>;
        /**
         * We can trigger change event whenever Slider value is changed.
         *  In other term, this event will be triggered while drag the slider thumb.
         * @event
         */
        change: ej.base.EmitType<Object>;
        /**
         * We can trigger changed event when Slider component action is completed while we change the Slider value.
         *  In other term, this event will be triggered, while drag the slider thumb completed.
         * @event
         */
        changed: ej.base.EmitType<Object>;
        /**
         * We can trigger renderingTicks event when the ticks rendered on Slider,
         *  which is used to customize the ticks labels dynamically.
         * @event
         */
        renderingTicks: ej.base.EmitType<Object>;
        /**
         * We can trigger renderedTicks event when the ticks are rendered on the Slider.
         * @event
         */
        renderedTicks: ej.base.EmitType<Object>;
        /**
         * We can trigger tooltipChange event when we change the Sider tooltip value.
         * @event
         */
        tooltipChange: ej.base.EmitType<SliderTooltipEventArgs>;
        constructor(options?: SliderModel, element?: string | HTMLElement);
        protected preRender(): void;
        private initCultureFunc();
        private initCultureInfo();
        private formatString(value, formatInfo);
        private formatNumber(value);
        private numberOfDecimals(value);
        private makeRoundNumber(value, precision);
        private fractionalToInteger(value);
        /**
         * To Initialize the control rendering
         * @private
         */
        render(): void;
        private initialize();
        private setCSSClass(oldCSSClass?);
        private setEnabled();
        private getTheme(container);
        /**
         * Initialize the rendering
         * @private
         */
        private initRender();
        private createRangeBar();
        private setOrientClass();
        private setAriaAttributes(element);
        private createSecondHandle();
        private createFirstHandle();
        private wireFirstHandleEvt(destroy);
        private wireSecondHandleEvt(destroy);
        private handleStart();
        private transitionEnd(e);
        private handleFocusOut();
        private handleFocus(e);
        private handleOver(e);
        private handleLeave(e);
        private setHandler();
        private setEnableRTL();
        private tooltipValue();
        private setTooltipContent();
        private formatContent(formatInfo, ariaContent);
        private addTooltipClass(content);
        private tooltipPlacement();
        private tooltipBeforeOpen(args);
        private wireMaterialTooltipEvent(destroy);
        private tooltipPositionCalculation(position);
        private getTooltipTransformProperties(className);
        private openMaterialTooltip();
        private checkTooltipPosition(args);
        private renderTooltip();
        private tooltipAfterClose(args);
        private setButtons();
        private buttonTitle();
        private buttonFocusOut();
        private repeatButton(args);
        private repeatHandlerMouse(args);
        private materialChange();
        private repeatHandlerUp(e);
        private renderScale();
        private createTick(li, start);
        private scaleAlignment();
        private tickValuePosition();
        private setAriaAttrValue(element);
        private handleValueUpdate();
        private buttonClick(args);
        private tooltipAnimation();
        private buttonUp(args);
        private setRangeBar();
        private setValue();
        private rangeValueUpdate();
        private validateRangeValue();
        private modifyZindex();
        private setHandlePosition();
        private getHandle();
        private setRangeValue();
        private changeEvent(eventName);
        private changeEventArgs(eventName);
        private setPreviousVal(eventName, value);
        private updateRangeValue();
        private checkHandlePosition(value);
        private checkHandleValue(value);
        private onResize();
        private changeHandleValue(value);
        private tempStartEnd();
        private xyToPosition(position);
        private stepValueCalculation(value);
        private add(a, b, addition);
        private round(a);
        private positionToValue(pos);
        private sliderBarClick(evt);
        private refreshTooltipOnMove();
        private sliderDown(event);
        private sliderBarUp();
        private sliderBarMove(evt);
        private checkRepeatedValue(currentValue);
        private refreshTooltip();
        private openTooltip();
        private keyDown(event);
        private wireButtonEvt(destroy);
        private wireEvents();
        private unwireEvents();
        private keyUp(event);
        private hover(event);
        private sliderFocusOut(event);
        private closeTooltip();
        private removeElement(element);
        private changeSliderType(type);
        private changeRtl();
        private changeOrientation();
        private updateConfig();
        /**
         * Get the properties to be maintained in the persisted state.
         * @private
         */
        protected getPersistData(): string;
        /**
         * Prepares the slider for safe removal from the DOM.
         * Detaches all event handlers, attributes, and classes to avoid memory leaks.
         * @method destroy
         * @return {void}
         */
        destroy(): void;
        /**
         * Calls internally if any of the property value is changed.
         * @private
         */
        onPropertyChanged(newProp: SliderModel, oldProp: SliderModel): void;
        private setReadOnly();
        private setMinMaxValue();
        private setZindex();
        setTooltip(): void;
        /**
         * Gets the component name
         * @private
         */
        getModuleName(): string;
    }
    
    /**
     * Interface for a class FilesProp
     */
    export interface FilesPropModel {
    
        /**
         * Specifies the name of the file
         * @default ''
         */
        name?: string;
    
        /**
         * Specifies the size of the file
         * @default null
         */
        size?: number;
    
        /**
         * Specifies the type of the file
         * @default ''
         */
        type?: string;
    
    }
    
    /**
     * Interface for a class ButtonsProps
     */
    export interface ButtonsPropsModel {
    
        /**
         * Specifies the text or html content to browse button
         * @default 'Browse'
         */
        browse?: string | HTMLElement;
    
        /**
         * Specifies the text or html content to upload button
         * @default 'Upload'
         */
        upload?: string | HTMLElement;
    
        /**
         * Specifies the text or html content to clear button
         * @default 'Clear'
         */
        clear?: string | HTMLElement;
    
    }
    
    /**
     * Interface for a class AsyncSettings
     */
    export interface AsyncSettingsModel {
    
        /**
         * Specifies the handler for file save action
         */
        saveUrl?: string;
    
        /**
         * Specifies the handler for file remove action
         */
        removeUrl?: string;
    
    }
    
    /**
     * Interface for a class Uploader
     */
    export interface UploaderModel extends ej.base.ComponentModel{
    
        /**
         * Gets or sets values that indicates about asynchronous upload.
         * @default { saveUrl: '', removeUrl: '' }
         */
        asyncSettings?: AsyncSettingsModel;
    
        /**
         * Gets or sets a value that indicates to align content in the Uploader control from right to left by setting the property as true.
         * @default false
         */
        enableRtl?: boolean;
    
        /**
         * Gets or sets the value that indicates whether the component is in enable or disable.
         * @default true
         */
        enabled?: boolean;
    
        /**
         * Accept the template design and assign it to each file presented in upload.
         * @default null
         */
        template?: string;
    
        /**
         * Gets or sets a value that indicates whether the multiple file selection is enabled.
         * @default true
         */
        multiple?: boolean;
    
        /**
         * After the file selection is done, that file will upload automatically without any interaction.
         * If it as false means, after the file selected, need to upload the file by click on the upload button
         * @default true
         */
        autoUpload?: boolean;
    
        /**
         * Gets or sets the text/HTML content for browse, upload and cancel button
         * @default { browse : 'Browse', clear: 'Clear', upload: 'Upload' }
         */
        buttons?: ButtonsPropsModel;
    
        /**
         * Gets or sets the value that indicate to what type of the files can upload based on the file extension.
         * @default ''
         */
        allowedExtensions?: string;
    
        /**
         * Gets or sets the minimum file size to select for upload.
         * @default 0
         */
        minFileSize?: number;
    
        /**
         * Gets or sets the maximum file size to select for upload.
         * @default 30000000
         */
        maxFileSize?: number;
    
        /**
         * Gets or sets the value that indicates whether to enable the drag and drop support for file upload and
         * specify the drag area to drop and select that file
         * @default null
         */
        dropArea?: string | HTMLElement;
    
        /**
         * For already uploaded files removing purpose, the list of files that will be initially rendered in the files
         * list with uploaded successfully.
         * The files option is available only when the upload is in async mode.
         * @default { name: '', size: null, type: '' }
         */
        files?: FilesPropModel[];
    
        /**
         * To show or hide the file list.
         * @default true
         */
        showFileList?: boolean;
    
        /**
         * Triggers after select the files which need to be upload.
         * @event
         */
        selected?: ej.base.EmitType<SelectedEventArgs>;
    
        /**
         * Triggers when start to upload the selected file.
         * @event
         */
        uploading?: ej.base.EmitType<Object>;
    
        /**
         * Triggers when the selected file uploaded/removed successfully.
         * @event
         */
        success?: ej.base.EmitType<Object>;
    
        /**
         * Triggers when Ajax request fails to upload files or to remove files.
         * @event
         */
        failure?: ej.base.EmitType<Object>;
    
        /**
         * Triggers before remove the items in the file list.
         * @event
         */
        removing?: ej.base.EmitType<RemovingEventArgs>;
    
        /**
         * Triggers before clear all the items in the file list.
         * @event
         */
        clearing?: ej.base.EmitType<ClearingEventArgs>;
    
        /**
         * Triggers when Ajax request is in progress for upload a file to server from local.
         * @event
         */
        progress?: ej.base.EmitType<Object>;
    
        /**
         * Triggers when changes occurs in uploaded file list.
         * @event
         */
        change?: ej.base.EmitType<Object>;
    
    }
    
    export class FilesProp extends ej.base.ChildProperty<FilesProp> {
        /**
         * Specifies the name of the file
         * @default ''
         */
        name: string;
        /**
         * Specifies the size of the file
         * @default null
         */
        size: number;
        /**
         * Specifies the type of the file
         * @default ''
         */
        type: string;
    }
    export class ButtonsProps extends ej.base.ChildProperty<ButtonsProps> {
        /**
         * Specifies the text or html content to browse button
         * @default 'Browse'
         */
        browse: string | HTMLElement;
        /**
         * Specifies the text or html content to upload button
         * @default 'Upload'
         */
        upload: string | HTMLElement;
        /**
         * Specifies the text or html content to clear button
         * @default 'Clear'
         */
        clear: string | HTMLElement;
    }
    export class AsyncSettings extends ej.base.ChildProperty<AsyncSettings> {
        /**
         * Specifies the handler for file save action
         */
        saveUrl: string;
        /**
         * Specifies the handler for file remove action
         */
        removeUrl: string;
    }
    export interface FileInfo {
        name: string;
        rawFile: string | Blob;
        size: number;
        status: string;
        type: string;
        validationMessages: ValidationMessages;
        statusCode: string;
    }
    export interface ValidationMessages {
        minSize?: string;
        maxSize?: string;
    }
    export interface SelectedEventArgs {
        cancel: boolean;
        filesData: FileInfo[];
        isModified: boolean;
        modifiedFilesData: FileInfo[];
        progressInterval: string;
    }
    export interface RemovingEventArgs {
        cancel: boolean;
        filesData: FileInfo[];
    }
    export interface ClearingEventArgs {
        cancel: boolean;
        filesData: FileInfo[];
    }
    export interface UploadingEventArgs {
        fileData: FileInfo;
        customFormData: {
            [key: string]: Object;
        }[];
    }
    /**
     * The Uploader component allows the user to upload the files to server.
     * ```html
     * <input type='file' name='images[]' id='upload'/>
     * ```
     * ```typescript
     * <script>
     *   var uploadObj = new Uploader();
     *   uploadObj.appendTo('#upload');
     * </script>
     * ```
     */
    export class Uploader extends ej.base.Component<HTMLInputElement> implements ej.base.INotifyPropertyChanged {
        private initialAttr;
        private uploadWrapper;
        private browseButton;
        private listParent;
        private cloneElement;
        private fileList;
        private actionButtons;
        private uploadButton;
        private clearButton;
        private dropAreaWrapper;
        private filesData;
        private uploadedFilesData;
        private dropZoneElement;
        private currentStatus;
        private l10n;
        private preLocaleObj;
        private uploadTemplateFn;
        private keyboardModule;
        private progressInterval;
        private progressAnimation;
        private isForm;
        private keyConfigs;
        private localeText;
        /**
         * Gets or sets values that indicates about asynchronous upload.
         * @default { saveUrl: '', removeUrl: '' }
         */
        asyncSettings: AsyncSettingsModel;
        /**
         * Gets or sets a value that indicates to align content in the Uploader control from right to left by setting the property as true.
         * @default false
         */
        enableRtl: boolean;
        /**
         * Gets or sets the value that indicates whether the component is in enable or disable.
         * @default true
         */
        enabled: boolean;
        /**
         * Accept the template design and assign it to each file presented in upload.
         * @default null
         */
        template: string;
        /**
         * Gets or sets a value that indicates whether the multiple file selection is enabled.
         * @default true
         */
        multiple: boolean;
        /**
         * After the file selection is done, that file will upload automatically without any interaction.
         * If it as false means, after the file selected, need to upload the file by click on the upload button
         * @default true
         */
        autoUpload: boolean;
        /**
         * Gets or sets the text/HTML content for browse, upload and cancel button
         * @default { browse : 'Browse', clear: 'Clear', upload: 'Upload' }
         */
        buttons: ButtonsPropsModel;
        /**
         * Gets or sets the value that indicate to what type of the files can upload based on the file extension.
         * @default ''
         */
        allowedExtensions: string;
        /**
         * Gets or sets the minimum file size to select for upload.
         * @default 0
         */
        minFileSize: number;
        /**
         * Gets or sets the maximum file size to select for upload.
         * @default 30000000
         */
        maxFileSize: number;
        /**
         * Gets or sets the value that indicates whether to enable the drag and drop support for file upload and
         * specify the drag area to drop and select that file
         * @default null
         */
        dropArea: string | HTMLElement;
        /**
         * For already uploaded files removing purpose, the list of files that will be initially rendered in the files
         * list with uploaded successfully.
         * The files option is available only when the upload is in async mode.
         * @default { name: '', size: null, type: '' }
         */
        files: FilesPropModel[];
        /**
         * To show or hide the file list.
         * @default true
         */
        showFileList: boolean;
        /**
         * Triggers after select the files which need to be upload.
         * @event
         */
        selected: ej.base.EmitType<SelectedEventArgs>;
        /**
         * Triggers when start to upload the selected file.
         * @event
         */
        uploading: ej.base.EmitType<Object>;
        /**
         * Triggers when the selected file uploaded/removed successfully.
         * @event
         */
        success: ej.base.EmitType<Object>;
        /**
         * Triggers when Ajax request fails to upload files or to remove files.
         * @event
         */
        failure: ej.base.EmitType<Object>;
        /**
         * Triggers before remove the items in the file list.
         * @event
         */
        removing: ej.base.EmitType<RemovingEventArgs>;
        /**
         * Triggers before clear all the items in the file list.
         * @event
         */
        clearing: ej.base.EmitType<ClearingEventArgs>;
        /**
         * Triggers when Ajax request is in progress for upload a file to server from local.
         * @event
         */
        progress: ej.base.EmitType<Object>;
        /**
         * Triggers when changes occurs in uploaded file list.
         * @event
         */
        change: ej.base.EmitType<Object>;
        /**
         * Triggers when change the Uploader value.
         */
        constructor(options?: UploaderModel, element?: string | HTMLInputElement);
        /**
         * Calls internally if any of the property value is changed.
         * @private
         */
        onPropertyChanged(newProp: UploaderModel, oldProp: UploaderModel): void;
        private setLocalizedTexts();
        private getKeyValue(val);
        private updateFileList();
        private reRenderFileList();
        protected preRender(): void;
        protected getPersistData(): string;
        /**
         * Return the module name of the component.
         */
        getModuleName(): string;
        /**
         * To Initialize the control rendering
         * @private
         */
        render(): void;
        private renderBrowseButton();
        private renderActionButtons();
        private wireActionButtonEvents();
        private unwireActionButtonEvents();
        private removeActionButtons();
        private renderButtonTemplates();
        private initializeUpload();
        private renderPreLoadFiles();
        private checkActionButtonStatus();
        private setDropArea();
        private setMultipleSelection();
        private checkAutoUpload(fileData);
        private wireEvents();
        private unWireEvents();
        private resetForm();
        private keyActionHandler(e);
        private setReverseFocus(e);
        private setTabFocus(e);
        private removeFocus();
        private browseButtonClick();
        private uploadButtonClick();
        private clearButtonClick();
        private bindDropEvents();
        private unBindDropEvents();
        private onDragLeave(e);
        private dragHover(e);
        private dropElement(e);
        private removeFiles(args);
        private removeFilesData(file, customTemplate);
        private removeUploadedFile(file, custom);
        private removeCompleted(e, files, customTemplate);
        private removeFailed(e, files, customTemplate);
        private onSelectFiles(args);
        private clearData();
        private updateSortedFileList(filesData);
        private checkExtension(files);
        private validatedFileSize(fileSize);
        private createCustomfileList(fileData);
        private createParentUL();
        private createFileList(fileData);
        private truncateName(name);
        private getFileType(name);
        private getFileNameOnly(name);
        private setInitialAttributes();
        private filterfileList(files);
        private updateStatus(files, status?, statusCode?);
        private getLiElement(files);
        private createProgressBar(liElement);
        private updateProgressbar(e, li);
        private changeProgressValue(li, progressValue);
        private uploadInProgress(e, files, customUI?);
        private uploadComplete(e, files, customUI?);
        private uploadFailed(e, files);
        private updateProgressBarClasses(li, className);
        private removeProgressbar(li, callType);
        private animateProgressBar(li, callType);
        private setExtensions(extensions);
        private templateComplier(uploadTemplate);
        private setRTL();
        private localizedTexts(localeText);
        private setControlStatus();
        private checkHTMLAttributes();
        /**
         * Convert the file size from bytes to kilo bytes or mega bytes.
         * @param { number } bytes - specifies the file size in bytes.
         * @returns string
         */
        bytesToSize(bytes: number): string;
        /**
         * Sort the files data alphabetically.
         * @param { FileList } filesData - specifies the files data for upload.
         * @returns File[]
         */
        sortFileList(filesData: FileList): File[];
        /**
         * Removes the component from the DOM and detaches all its related event handlers. Also it removes the attributes and classes.
         * @method destroy
         * @return {void}.
         */
        destroy(): void;
        /**
         * Upload all the selected files if pass empty argument to this method.
         * If we pass specific file_data as argument to this method, that file only will get upload.
         * @param { FileInfo[] } files - specifies the files data for upload.
         * @returns void
         */
        upload(files: FileInfo[], custom?: boolean): void;
        /**
         * All the selected/uploaded files are remove if pass empty argument to this method.
         * if we pass specific file_data as argument to this method, that corresponding file only remove.
         * @param { FileInfo | FileInfo[] } fileData - specifies the files data to remove from file list/server.
         * @returns void
         */
        remove(fileData?: FileInfo | FileInfo[], customTemplate?: boolean): void;
        /**
         * Clear the file list from upload.
         * @returns void
         */
        clearAll(): void;
        getFilesData(): FileInfo[];
    }
    
  }
  export namespace lineargauge {
    
    /**
     * Interface for a class LinearGauge
     */
    export interface LinearGaugeModel extends ej.base.ComponentModel{
    
        /**
         * The width of the Linear gauge as a string in order to provide input as both like '100px' or '100%'.
         * If specified as '100%, gauge will render to the full width of its parent element.
         * @default null
         */
    
        width?: string;
    
        /**
         * The height of the Linear gauge as a string in order to provide input as both like '100px' or '100%'.
         * If specified as '100%, gauge will render to the full height of its parent element.
         * @default null
         */
    
        height?: string;
    
        /**
         * Specifies the gauge will rendered either horizontal or vertical orientation.
         */
        orientation?: Orientation;
    
        /**
         *  Options to customize the left, right, top and bottom margins of the gauge.
         */
    
        margin?: MarginModel;
    
        /**
         * Options for customizing the color and width of the gauge border.
         */
    
        border?: BorderModel;
    
        /**
         * The background color of the gauge, which accepts value in hex, rgba as a valid CSS color string.
         * @default 'transparent'
         */
        background?: string;
    
        /**
         * Specifies the title for linear gauge.
         */
    
        title?: string;
    
        /**
         * Options for customizing the title appearance of linear gauge.
         */
    
        titleStyle?: FontModel;
    
        /**
         * Options for customizing the container linear gauge.
         */
    
        container?: ContainerModel;
    
        /**
         *  Options for customizing the axes of linear gauge.
         */
    
        axes?: AxisModel[];
    
        /**
         * Options for customizing the tooltip in linear gauge.
         */
    
        tooltip?: TooltipSettingsModel;
    
        /**
         *  Options for customizing the annotation of linear gauge.
         */
        annotations?: AnnotationModel[];
    
        /**
         * Specifies color palette for axis ranges.
         * @default []
         */
        rangePalettes?: string[];
    
        /**
         * Specifies whether a grouping separator should be used for a number.
         * @default false
         */
        useGroupingSeparator?: boolean;
    
        /**
         * Specifies the description for linear gauge.
         * @default null
         */
        description?: string;
    
        /**
         * TabIndex value for the gauge.
         * @default 1
         */
        tabIndex?: number;
    
        /**
         * Specifies the theme for the maps.
         */
        theme?: LinearGaugeTheme;
    
        /**
         * Triggers after gauge loaded.
         * @event
         */
        loaded?: ej.base.EmitType<ILoadedEventArgs>;
    
        /**
         * Triggers before gauge load.
         * @event
         */
        load?: ej.base.EmitType<ILoadEventArgs>;
    
        /**
         * Triggers after complete the animation for pointer.
         * @event
         */
        animationComplete?: ej.base.EmitType<IAnimationCompleteEventArgs>;
    
        /**
         * Triggers before each axis label gets rendered.
         * @event
         */
        axisLabelRender?: ej.base.EmitType<IAxisLabelRenderEventArgs>;
    
        /**
         * Triggers before each annotation gets rendered.
         * @event
         */
        annotationRender?: ej.base.EmitType<IAnnotationRenderEventArgs>;
    
        /**
         * Triggers before the tooltip get rendered.
         * @event
         */
    
        tooltipRender?: ej.base.EmitType<ITooltipRenderEventArgs>;
    
        /**
         * Triggers when mouse move on gauge area.
         * @event
         */
    
        gaugeMouseMove?: ej.base.EmitType<IMouseEventArgs>;
    
        /**
         * Triggers when mouse leave from the gauge area .
         * @event
         */
    
        gaugeMouseLeave?: ej.base.EmitType<IMouseEventArgs>;
    
        /**
         * Triggers when mouse down on gauge area.
         * @event
         */
    
        gaugeMouseDown?: ej.base.EmitType<IMouseEventArgs>;
    
        /**
         * Triggers when mouse up on gauge area.
         * @event
         */
    
        gaugeMouseUp?: ej.base.EmitType<IMouseEventArgs>;
    
        /**
         * Triggers while drag the pointer.
         * @event
         */
    
        valueChange?: ej.base.EmitType<IValueChangeEventArgs>;
    
        /**
         * Triggers after window resize.
         * @event
         */
    
        resized?: ej.base.EmitType<IResizeEventArgs>;
    
    }
    
    /**
     * Represents the EJ2 Linear gauge control.
     * ```html
     * <div id="container"/>
     * <script>
     *   var gaugeObj = new LinearGauge({ });
     *   gaugeObj.appendTo("#container");
     * </script>
     * ```
     */
    export class LinearGauge extends ej.base.Component<HTMLElement> implements ej.base.INotifyPropertyChanged {
        /**
         *  annotationModule is used to place the any text or images into the gauge.
         */
        annotationsModule: Annotations;
        /**
         * tooltipModule is used to display the pointer value.
         */
        tooltipModule: GaugeTooltip;
        /**
         * The width of the Linear gauge as a string in order to provide input as both like '100px' or '100%'.
         * If specified as '100%, gauge will render to the full width of its parent element.
         * @default null
         */
        width: string;
        /**
         * The height of the Linear gauge as a string in order to provide input as both like '100px' or '100%'.
         * If specified as '100%, gauge will render to the full height of its parent element.
         * @default null
         */
        height: string;
        /**
         * Specifies the gauge will rendered either horizontal or vertical orientation.
         */
        orientation: Orientation;
        /**
         *  Options to customize the left, right, top and bottom margins of the gauge.
         */
        margin: MarginModel;
        /**
         * Options for customizing the color and width of the gauge border.
         */
        border: BorderModel;
        /**
         * The background color of the gauge, which accepts value in hex, rgba as a valid CSS color string.
         * @default 'transparent'
         */
        background: string;
        /**
         * Specifies the title for linear gauge.
         */
        title: string;
        /**
         * Options for customizing the title appearance of linear gauge.
         */
        titleStyle: FontModel;
        /**
         * Options for customizing the container linear gauge.
         */
        container: ContainerModel;
        /**
         *  Options for customizing the axes of linear gauge.
         */
        axes: AxisModel[];
        /**
         * Options for customizing the tooltip in linear gauge.
         */
        tooltip: TooltipSettingsModel;
        /**
         *  Options for customizing the annotation of linear gauge.
         */
        annotations: AnnotationModel[];
        /**
         * Specifies color palette for axis ranges.
         * @default []
         */
        rangePalettes: string[];
        /**
         * Specifies whether a grouping separator should be used for a number.
         * @default false
         */
        useGroupingSeparator: boolean;
        /**
         * Specifies the description for linear gauge.
         * @default null
         */
        description: string;
        /**
         * TabIndex value for the gauge.
         * @default 1
         */
        tabIndex: number;
        /**
         * Specifies the theme for the maps.
         */
        theme: LinearGaugeTheme;
        /**
         * Triggers after gauge loaded.
         * @event
         */
        loaded: ej.base.EmitType<ILoadedEventArgs>;
        /**
         * Triggers before gauge load.
         * @event
         */
        load: ej.base.EmitType<ILoadEventArgs>;
        /**
         * Triggers after complete the animation for pointer.
         * @event
         */
        animationComplete: ej.base.EmitType<IAnimationCompleteEventArgs>;
        /**
         * Triggers before each axis label gets rendered.
         * @event
         */
        axisLabelRender: ej.base.EmitType<IAxisLabelRenderEventArgs>;
        /**
         * Triggers before each annotation gets rendered.
         * @event
         */
        annotationRender: ej.base.EmitType<IAnnotationRenderEventArgs>;
        /**
         * Triggers before the tooltip get rendered.
         * @event
         */
        tooltipRender: ej.base.EmitType<ITooltipRenderEventArgs>;
        /**
         * Triggers when mouse move on gauge area.
         * @event
         */
        gaugeMouseMove: ej.base.EmitType<IMouseEventArgs>;
        /**
         * Triggers when mouse leave from the gauge area .
         * @event
         */
        gaugeMouseLeave: ej.base.EmitType<IMouseEventArgs>;
        /**
         * Triggers when mouse down on gauge area.
         * @event
         */
        gaugeMouseDown: ej.base.EmitType<IMouseEventArgs>;
        /**
         * Triggers when mouse up on gauge area.
         * @event
         */
        gaugeMouseUp: ej.base.EmitType<IMouseEventArgs>;
        /**
         * Triggers while drag the pointer.
         * @event
         */
        valueChange: ej.base.EmitType<IValueChangeEventArgs>;
        /**
         * Triggers after window resize.
         * @event
         */
        resized: ej.base.EmitType<IResizeEventArgs>;
        /** @private */
        renderer: ej.base.SvgRenderer;
        /** @private */
        svgObject: Element;
        /** @private */
        availableSize: Size;
        /** @private */
        actualRect: Rect;
        /** @private */
        intl: ej.base.Internationalization;
        /** @private* */
        containerBounds: Rect;
        /**
         * @private
         * Calculate the axes bounds for gauge.
         * @hidden
         */
        gaugeAxisLayoutPanel: AxisLayoutPanel;
        /**
         * @private
         * Render the axis elements for gauge.
         * @hidden
         */
        axisRenderer: AxisRenderer;
        /** @private */
        private resizeTo;
        /** @private */
        containerObject: Element;
        /** @private */
        pointerDrag: boolean;
        /** @private */
        mouseX: number;
        /** @private */
        mouseY: number;
        /** @private */
        mouseElement: Element;
        /** @private */
        gaugeResized: boolean;
        /** @private */
        nearSizes: number[];
        /** @private */
        farSizes: number[];
        /**
         * @private
         * Constructor for creating the widget
         * @hidden
         */
        constructor(options?: LinearGaugeModel, element?: string | HTMLElement);
        /**
         * Initialize the preRender method.
         */
        protected preRender(): void;
        private themeEffect();
        private setThemeColors(labelcolor, others);
        private initPrivateVariable();
        /**
         * Method to set culture for chart
         */
        private setCulture();
        /**
         * Methods to create svg element
         */
        private createSvg();
        /**
         * To Remove the SVG.
         * @return {boolean}
         * @private
         */
        removeSvg(): void;
        /**
         * Method to calculate the size of the gauge
         */
        private calculateSize();
        /**
         * To Initialize the control rendering
         */
        protected render(): void;
        /**
         * @private
         * To render the gauge elements
         */
        renderGaugeElements(): void;
        private appendSecondaryElement();
        /**
         * @private
         * To calculate axes bounds
         */
        calculateBounds(): void;
        /**
         * @private
         * To render axis elements
         */
        renderAxisElements(): void;
        private renderBorder();
        private renderTitle();
        private unWireEvents();
        private wireEvents();
        private setStyle(element);
        /**
         * Handles the gauge resize.
         * @return {boolean}
         * @private
         */
        gaugeResize(e: Event): boolean;
        /**
         * To destroy the gauge element from the DOM.
         */
        destroy(): void;
        /**
         * @private
         * To render the gauge container
         */
        renderContainer(): void;
        /**
         * Handles the mouse down on gauge.
         * @return {boolean}
         * @private
         */
        gaugeOnMouseDown(e: PointerEvent): boolean;
        /**
         * Handles the mouse move.
         * @return {boolean}
         * @private
         */
        mouseMove(e: PointerEvent): boolean;
        /**
         * To find the mouse move on pointer.
         * @param element
         */
        private moveOnPointer(element);
        /**
         * @private
         * Handle the right click
         * @param event
         */
        gaugeRightClick(event: MouseEvent | PointerEvent): boolean;
        /**
         * Handles the mouse leave.
         * @return {boolean}
         * @private
         */
        mouseLeave(e: PointerEvent): boolean;
        /**
         * Handles the mouse move on gauge.
         * @return {boolean}
         * @private
         */
        gaugeOnMouseMove(e: PointerEvent | TouchEvent): boolean;
        /**
         * Handles the mouse up.
         * @return {boolean}
         * @private
         */
        mouseEnd(e: PointerEvent): boolean;
        /**
         * Handles the mouse event arguments.
         * @return {IMouseEventArgs}
         * @private
         */
        private getMouseArgs(e, type, name);
        /**
         * @private
         * @param axis
         * @param pointer
         */
        markerDrag(axis: Axis, pointer: Pointer): void;
        /**
         * @private
         * @param axis
         * @param pointer
         */
        barDrag(axis: Axis, pointer: Pointer): void;
        /**
         * Triggers when drag the pointer
         * @param activeElement
         */
        private triggerDragEvent(activeElement);
        /**
         * To set the pointer value using this method
         * @param axisIndex
         * @param pointerIndex
         * @param value
         */
        setPointerValue(axisIndex: number, pointerIndex: number, value: number): void;
        /**
         * To set the annotation value using this method.
         * @param annotationIndex
         * @param content
         */
        setAnnotationValue(annotationIndex: number, content: string): void;
        /**
         * To provide the array of modules needed for control rendering
         * @return {ej.base.ModuleDeclaration[]}
         * @private
         */
        requiredModules(): ej.base.ModuleDeclaration[];
        /**
         * Get the properties to be maintained in the persisted state.
         * @private
         */
        getPersistData(): string;
        /**
         * Get component name
         */
        getModuleName(): string;
        /**
         * Called internally if any of the property value changed.
         * @private
         */
        onPropertyChanged(newProp: LinearGaugeModel, oldProp: LinearGaugeModel): void;
    }
    
    /**
     * Represent the annotation rendering for gauge
     */
    export class Annotations {
        private gauge;
        constructor(gauge: LinearGauge);
        /**
         * To render annotation elements
         */
        renderAnnotationElements(): void;
        /**
         * To create annotation elements
         */
        createAnnotationTemplate(element: HTMLElement, annotationIndex: number): void;
        protected getModuleName(): string;
        /**
         * To destroy the annotation.
         * @return {void}
         * @private
         */
        destroy(gauge: LinearGauge): void;
    }
    
    /**
     * @private
     * To handle the animation for gauge
     */
    export class Animations {
        gauge: LinearGauge;
        constructor(gauge: LinearGauge);
        /**
         * To do the marker pointer animation.
         * @return {void}
         * @private
         */
        performMarkerAnimation(element: Element, axis: Axis, pointer: Pointer): void;
        /**
         * Perform the bar pointer animation
         * @param element
         * @param axis
         * @param pointer
         */
        performBarAnimation(element: Element, axis: Axis, pointer: Pointer): void;
    }
    
    /**
     * Interface for a class Line
     */
    export interface LineModel {
    
        /**
         * The dash array of the axis line.
         */
    
        dashArray?: string;
    
        /**
         * Height of the axis line.
         */
        height?: number;
    
        /**
         * Width of the axis line.
         * @default 2
         */
        width?: number;
    
        /**
         * Color of the axis line.
         */
        color?: string;
    
        /**
         * Specifies to move the axis line.
         */
        offset?: number;
    
    }
    
    /**
     * Interface for a class Label
     */
    export interface LabelModel {
    
        /**
         * The font of the axis labels.
         */
    
        font?: FontModel;
    
        /**
         * The color of the label, based on range color.
         * @default false
         */
    
        useRangeColor?: boolean;
    
        /**
         * To format the axis label, which accepts any global format string like 'C', 'n1', 'P' etc.
         * Also accepts placeholder like '{value}°C' in which value represent the axis label e.g. 20°C.
         */
    
        format?: string;
    
        /**
         * To move the axis labels.
         * @default 0
         */
        offset?: number;
    
    }
    
    /**
     * Interface for a class Range
     */
    export interface RangeModel {
    
        /**
         * Start of the axis range.
         */
        start?: number;
    
        /**
         * End of the axis range.
         */
        end?: number;
    
        /**
         * Specifies to position the axis range.
         * @default 'Outside'
         */
        position?: Position;
    
        /**
         * Color of the axis range.
         */
        color?: string;
    
        /**
         * Starting width of axis range.
         * @default 10
         */
        startWidth?: number;
    
        /**
         * Ending width of axis range.
         * @default 10
         */
        endWidth?: number;
    
        /**
         * Specifies to move the axis range.
         * @default 0
         */
        offset?: number;
    
        /**
         * Specifies the border of axis range.
         */
        border?: BorderModel;
    
    }
    
    /**
     * Interface for a class Tick
     */
    export interface TickModel {
    
        /**
         * Height of the tick line.
         */
        height?: number;
    
        /**
         * Width of the tick line. 
         * @default 2
         */
        width?: number;
    
        /**
         * Specifies the interval for ticks.
         */
        interval?: number;
    
        /**
         * The color of the major or minor tick line, which accepts value in hex, rgba as a valid CSS color string.
         */
    
        color?: string;
    
        /**
         * Specifies to move the axis ticks.
         */
        offset?: number;
    
    }
    
    /**
     * Interface for a class Pointer
     */
    export interface PointerModel {
    
        /**
         * Specifies the type of pointer.
         * @default 'Marker'
         */
        type?: Point;
    
        /**
         * Specifies value of the pointer.
         * @default null
         */
    
        value?: number;
    
        /**
         * Specifies the marker shape in pointer.
         * @default InvertedTriangle
         */
        markerType?: MarkerType;
    
        /**
         * Specifies the path of image.
         * @default null
         */
        imageUrl?: string;
    
        /**
         * Specifies the border of pointer.
         */
        border?: BorderModel;
    
        /**
         * Specifies the corner radius for rounded rectangle.
         * @default 10
         */
        roundedCornerRadius?: number;
    
        /**
         * Specifies the place of the pointer.
         * @default 'Far'
         */
        placement?: Placement;
    
        /**
         * Specifies the height of pointer.
         * @default 20
         */
        height?: number;
    
        /**
         * Specifies the width of pointer.
         * @default 20
         */
        width?: number;
    
        /**
         * Specifies the color of the pointer.
         */
        color?: string;
    
        /**
         * Specifies the opacity for pointer.
         * @default 1
         */
        opacity?: number;
    
        /**
         * Specifies the animating duration of pointer in milliseconds.
         * @default 0
         */
        animationDuration?: number;
    
        /**
         * Specifies the enable or disable the pointer drag.
         * @default false
         */
        enableDrag?: boolean;
    
        /**
         * Specifies to move the pointer.
         * @default 0
         */
        offset?: number;
    
        /**
         * Description of the pointer.
         * @default null
         */
        description?: string;
    
    }
    
    /**
     * Interface for a class Axis
     * @private
     */
    export interface AxisModel {
    
        /**
         * Specifies the minimum value of an axis.
         * @default 0
         */
    
        minimum?: number;
    
        /**
         * Specifies the maximum value of an axis.
         * @default 100
         */
    
        maximum?: number;
    
        /**
         * Specifies the axis rendering direction.
         */
    
        isInversed?: boolean;
    
        /**
         * Specifies the axis rendering position.
         */
        opposedPosition?: boolean;
    
        /**
         * Options for customizing the axis line.
         */
        line?: LineModel;
    
        /**
         * Options for customizing the ranges of an axis
         */
    
        ranges?: RangeModel[];
    
        /**
         * Options for customizing the pointers of an axis
         */
    
        pointers?: PointerModel[];
    
        /**
         * Options for customizing the major tick lines.
         */
    
        majorTicks?: TickModel;
    
        /**
         * Options for customizing the minor tick lines.
         */
    
        minorTicks?: TickModel;
    
        /**
         * Options for customizing the axis label appearance.
         */
    
        labelStyle?: LabelModel;
    
    }
    
    /**
     * @private
     * To calculate the overall axis bounds for gauge.
     */
    export class AxisLayoutPanel {
        private gauge;
        private htmlObject;
        constructor(gauge: LinearGauge);
        /**
         * To calculate the axis bounds
         */
        calculateAxesBounds(): void;
        /**
         * Calculate axis line bounds
         * @param axis
         * @param axisIndex
         */
        calculateLineBounds(axis: Axis, axisIndex: number): void;
        /**
         * Calculate axis tick bounds
         * @param axis
         * @param axisIndex
         */
        calculateTickBounds(axis: Axis, axisIndex: number): void;
        /**
         * To Calculate axis label bounds
         * @param axis
         * @param axisIndex
         */
        calculateLabelBounds(axis: Axis, axisIndex: number): void;
        /**
         * Calculate pointer bounds
         * @param axis
         * @param axisIndex
         */
        calculatePointerBounds(axis: Axis, axisIndex: number): void;
        /**
         * Calculate marker pointer bounds
         * @param axisIndex
         * @param axis
         * @param pointerIndex
         * @param pointer
         */
        calculateMarkerBounds(axisIndex: number, axis: Axis, pointerIndex: number, pointer: Pointer): void;
        /**
         * Calculate bar pointer bounds
         * @param axisIndex
         * @param axis
         * @param pointerIndex
         * @param pointer
         */
        calculateBarBounds(axisIndex: number, axis: Axis, pointerIndex: number, pointer: Pointer): void;
        /**
         * Calculate ranges bounds
         * @param axis
         * @param axisIndex
         */
        calculateRangesBounds(axis: Axis, axisIndex: number): void;
        private checkPreviousAxes(currentAxis, axisIndex);
        /**
         *
         * @param axis To calculate the visible labels
         */
        calculateVisibleLabels(axis: Axis): void;
        /**
         * Calculate maximum label width for the axis.
         * @return {void}
         * @private
         */
        private getMaxLabelWidth(gauge, axis);
        private checkThermometer();
    }
    
    /**
     * @private
     * To render the axis elements
     */
    export class AxisRenderer extends Animations {
        private htmlObject;
        private axisObject;
        private axisElements;
        constructor(gauge: LinearGauge);
        renderAxes(): void;
        axisAlign(axes: AxisModel[]): void;
        drawAxisLine(axis: Axis, axisObject: Element, axisIndex: number): void;
        drawTicks(axis: Axis, ticks: Tick, axisObject: Element, tickID: string, tickBounds: Rect): void;
        drawAxisLabels(axis: Axis, axisObject: Element): void;
        drawPointers(axis: Axis, axisObject: Element, axisIndex: number): void;
        drawMarkerPointer(axis: Axis, axisIndex: number, pointer: Pointer, pointerIndex: number, parentElement: Element): void;
        drawBarPointer(axis: Axis, axisIndex: number, pointer: Pointer, pointerIndex: number, parentElement: Element): void;
        drawRanges(axis: Axis, axisObject: Element, axisIndex: number): void;
    }
    
    /** Options for customizing the axis line. */
    export class Line extends ej.base.ChildProperty<Line> {
        /**
         * The dash array of the axis line.
         */
        dashArray: string;
        /**
         * Height of the axis line.
         */
        height: number;
        /**
         * Width of the axis line.
         * @default 2
         */
        width: number;
        /**
         * Color of the axis line.
         */
        color: string;
        /**
         * Specifies to move the axis line.
         */
        offset: number;
    }
    /**
     * Options for customizing the axis labels appearance.
     */
    export class Label extends ej.base.ChildProperty<Label> {
        /**
         * The font of the axis labels.
         */
        font: FontModel;
        /**
         * The color of the label, based on range color.
         * @default false
         */
        useRangeColor: boolean;
        /**
         * To format the axis label, which accepts any global format string like 'C', 'n1', 'P' etc.
         * Also accepts placeholder like '{value}°C' in which value represent the axis label e.g. 20°C.
         */
        format: string;
        /**
         * To move the axis labels.
         * @default 0
         */
        offset: number;
    }
    /**
     * Options for customizing the ranges of an axis.
     */
    export class Range extends ej.base.ChildProperty<Range> {
        /**
         * Start of the axis range.
         */
        start: number;
        /**
         * End of the axis range.
         */
        end: number;
        /**
         * Specifies to position the axis range.
         * @default 'Outside'
         */
        position: Position;
        /**
         * Color of the axis range.
         */
        color: string;
        /**
         * Starting width of axis range.
         * @default 10
         */
        startWidth: number;
        /**
         * Ending width of axis range.
         * @default 10
         */
        endWidth: number;
        /**
         * Specifies to move the axis range.
         * @default 0
         */
        offset: number;
        /**
         * Specifies the border of axis range.
         */
        border: BorderModel;
        /** @private */
        bounds: Rect;
        /** @private */
        path: string;
        /** @private */
        interior: string;
    }
    /**
     * Options for customizing the minor tick lines.
     */
    export class Tick extends ej.base.ChildProperty<Tick> {
        /**
         * Height of the tick line.
         */
        height: number;
        /**
         * Width of the tick line.
         * @default 2
         */
        width: number;
        /**
         * Specifies the interval for ticks.
         */
        interval: number;
        /**
         * The color of the major or minor tick line, which accepts value in hex, rgba as a valid CSS color string.
         */
        color: string;
        /**
         * Specifies to move the axis ticks.
         */
        offset: number;
    }
    /**
     * Options for customizing the pointers of an axis.
     */
    export class Pointer extends ej.base.ChildProperty<Pointer> {
        /**
         * Specifies the type of pointer.
         * @default 'Marker'
         */
        type: Point;
        /**
         * Specifies value of the pointer.
         * @default null
         */
        value: number;
        /**
         * Specifies the marker shape in pointer.
         * @default InvertedTriangle
         */
        markerType: MarkerType;
        /**
         * Specifies the path of image.
         * @default null
         */
        imageUrl: string;
        /**
         * Specifies the border of pointer.
         */
        border: BorderModel;
        /**
         * Specifies the corner radius for rounded rectangle.
         * @default 10
         */
        roundedCornerRadius: number;
        /**
         * Specifies the place of the pointer.
         * @default 'Far'
         */
        placement: Placement;
        /**
         * Specifies the height of pointer.
         * @default 20
         */
        height: number;
        /**
         * Specifies the width of pointer.
         * @default 20
         */
        width: number;
        /**
         * Specifies the color of the pointer.
         */
        color: string;
        /**
         * Specifies the opacity for pointer.
         * @default 1
         */
        opacity: number;
        /**
         * Specifies the animating duration of pointer in milliseconds.
         * @default 0
         */
        animationDuration: number;
        /**
         * Specifies the enable or disable the pointer drag.
         * @default false
         */
        enableDrag: boolean;
        /**
         * Specifies to move the pointer.
         * @default 0
         */
        offset: number;
        /**
         * Description of the pointer.
         * @default null
         */
        description: string;
        /** @private */
        bounds: Rect;
        /** @private */
        startValue: number;
        /** @private */
        animationComplete: boolean;
        /** @private */
        currentValue: number;
    }
    export class Axis extends ej.base.ChildProperty<Axis> {
        /**
         * Specifies the minimum value of an axis.
         * @default 0
         */
        minimum: number;
        /**
         * Specifies the maximum value of an axis.
         * @default 100
         */
        maximum: number;
        /**
         * Specifies the axis rendering direction.
         */
        isInversed: boolean;
        /**
         * Specifies the axis rendering position.
         */
        opposedPosition: boolean;
        /**
         * Options for customizing the axis line.
         */
        line: LineModel;
        /**
         * Options for customizing the ranges of an axis
         */
        ranges: RangeModel[];
        /**
         * Options for customizing the pointers of an axis
         */
        pointers: PointerModel[];
        /**
         * Options for customizing the major tick lines.
         */
        majorTicks: TickModel;
        /**
         * Options for customizing the minor tick lines.
         */
        minorTicks: TickModel;
        /**
         * Options for customizing the axis label appearance.
         */
        labelStyle: LabelModel;
        /** @private */
        visibleLabels: VisibleLabels[];
        /** @private */
        maxLabelSize: Size;
        /** @private */
        visibleRange: VisibleRange;
        /** @private */
        lineBounds: Rect;
        /** @private */
        majorTickBounds: Rect;
        /** @private */
        minorTickBounds: Rect;
        /** @private */
        labelBounds: Rect;
        /** @private */
        pointerBounds: Rect;
        /** @private */
        bounds: Rect;
        /** @private */
        maxTickLength: number;
        /** @private */
        checkAlign: Align;
        /** @private */
        majorInterval: number;
        /** @private */
        minorInterval: number;
    }
    
    /**
     * Interface for a class Font
     */
    export interface FontModel {
    
        /**
         * Font size for text.
         */
        size?: string;
    
        /**
         * Color for text.
         */
        color?: string;
    
        /**
         * FontFamily for text.
         */
        fontFamily?: string;
    
        /**
         * FontWeight for text.
         */
        fontWeight?: string;
    
        /**
         * FontStyle for text.
         */
        fontStyle?: string;
    
        /**
         * Opacity for text.
         */
        opacity?: number;
    
    }
    
    /**
     * Interface for a class Margin
     */
    export interface MarginModel {
    
        /**
         * Left margin in pixels.
         * @default 10
         */
        left?: number;
    
        /**
         * Right margin in pixels.
         * @default 10
         */
        right?: number;
    
        /**
         * Top margin in pixels.
         * @default 10
         */
        top?: number;
    
        /**
         * Bottom margin in pixels.
         * @default 10
         */
        bottom?: number;
    
    }
    
    /**
     * Interface for a class Border
     */
    export interface BorderModel {
    
        /**
         * The color of the border, which accepts value in hex, rgba as a valid CSS color string.
         */
        color?: string;
    
        /**
         * The width of the border in pixels.
         * @default '0'
         */
        width?: number;
    
    }
    
    /**
     * Interface for a class Annotation
     */
    export interface AnnotationModel {
    
        /**
         * Specifies the id of html element.
         */
        content?: string;
    
        /**
         * Specifies the position of x.
         */
        x?: number;
    
        /**
         * Specifies the position of y.
         */
        y?: number;
    
        /**
         * Specifies the vertical alignment of annotation.
         */
        verticalAlignment?: Placement;
    
        /**
         * Specifies the horizontal alignment of annotation.
         */
        horizontalAlignment?: Placement;
    
        /**
         * Specifies the zIndex of the annotation.
         * @default '-1'
         */
        zIndex?: string;
    
        /**
         * The font of the axis labels.
         */
    
        font?: FontModel;
    
        /**
         * Specifies the index of axis.
         */
        axisIndex?: number;
    
        /**
         * Specifies the value of axis.
         */
        axisValue?: number;
    
    }
    
    /**
     * Interface for a class Container
     */
    export interface ContainerModel {
    
        /**
         * Specifies the type of container.
         * @default 'Normal'
         */
        type?: ContainerType;
    
        /**
         * Specifies the height of the container.
         * @default 0
         */
        height?: number;
    
        /**
         * Specifies the width of the container.
         * @default 0
         */
        width?: number;
    
        /**
         * Specifies the corner radius for rounded rectangle.
         * @default 10
         */
        roundedCornerRadius?: number;
    
        /**
         * Specifies the background of the color.
         */
        backgroundColor?: string;
    
        /**
         * Specifies the border of container.
         */
        border?: BorderModel;
    
        /**
         * Specifies to move the container.
         */
        offset?: number;
    
    }
    
    /**
     * Interface for a class TooltipSettings
     */
    export interface TooltipSettingsModel {
    
        /**
         * Enable / Disable the visibility of tooltip.
         * @default false
         */
    
        enable?: boolean;
    
        /**
         * The fill color of the tooltip, which accepts value in hex, rgba as a valid CSS color string. 
         */
    
        fill?: string;
    
        /**
         * Options to customize the tooltip text.
         */
    
        textStyle?: FontModel;
    
        /**
         * Format of the tooltip content.
         * @default null
         */
    
        format?: string;
    
        /**
         * Custom template to format the tooltip content. Use ${x} and ${y} as a placeholder text to display the corresponding data point.
         * @default null
         */
    
        template?: string;
    
        /**
         * If set true, tooltip will animate, while moving from one point to another.
         * @default true
         */
        enableAnimation?: boolean;
    
        /**
         * Options to customize the border for tooltip.
         */
        border?: BorderModel;
    
    }
    
    /**
     * Options for customizing the fonts.
     */
    export class Font extends ej.base.ChildProperty<Font> {
        /**
         * Font size for text.
         */
        size: string;
        /**
         * Color for text.
         */
        color: string;
        /**
         * FontFamily for text.
         */
        fontFamily: string;
        /**
         * FontWeight for text.
         */
        fontWeight: string;
        /**
         * FontStyle for text.
         */
        fontStyle: string;
        /**
         * Opacity for text.
         */
        opacity: number;
    }
    /**
     * Configures the margin of linear gauge.
     */
    export class Margin extends ej.base.ChildProperty<Margin> {
        /**
         * Left margin in pixels.
         * @default 10
         */
        left: number;
        /**
         * Right margin in pixels.
         * @default 10
         */
        right: number;
        /**
         * Top margin in pixels.
         * @default 10
         */
        top: number;
        /**
         * Bottom margin in pixels.
         * @default 10
         */
        bottom: number;
    }
    /**
     * Configures the border in linear gauge.
     */
    export class Border extends ej.base.ChildProperty<Border> {
        /**
         * The color of the border, which accepts value in hex, rgba as a valid CSS color string.
         */
        color: string;
        /**
         * The width of the border in pixels.
         * @default '0'
         */
        width: number;
    }
    /**
     * Options for customizing the annotation.
     */
    export class Annotation extends ej.base.ChildProperty<Annotation> {
        /**
         * Specifies the id of html element.
         */
        content: string;
        /**
         * Specifies the position of x.
         */
        x: number;
        /**
         * Specifies the position of y.
         */
        y: number;
        /**
         * Specifies the vertical alignment of annotation.
         */
        verticalAlignment: Placement;
        /**
         * Specifies the horizontal alignment of annotation.
         */
        horizontalAlignment: Placement;
        /**
         * Specifies the zIndex of the annotation.
         * @default '-1'
         */
        zIndex: string;
        /**
         * The font of the axis labels.
         */
        font: FontModel;
        /**
         * Specifies the index of axis.
         */
        axisIndex: number;
        /**
         * Specifies the value of axis.
         */
        axisValue: number;
    }
    /**
     * Options for customizing the container of linear gauge.
     */
    export class Container extends ej.base.ChildProperty<Container> {
        /**
         * Specifies the type of container.
         * @default 'Normal'
         */
        type: ContainerType;
        /**
         * Specifies the height of the container.
         * @default 0
         */
        height: number;
        /**
         * Specifies the width of the container.
         * @default 0
         */
        width: number;
        /**
         * Specifies the corner radius for rounded rectangle.
         * @default 10
         */
        roundedCornerRadius: number;
        /**
         * Specifies the background of the color.
         */
        backgroundColor: string;
        /**
         * Specifies the border of container.
         */
        border: BorderModel;
        /**
         * Specifies to move the container.
         */
        offset: number;
    }
    /**
     * Options for customizing the tooltip in linear gauge.
     */
    export class TooltipSettings extends ej.base.ChildProperty<TooltipSettings> {
        /**
         * Enable / Disable the visibility of tooltip.
         * @default false
         */
        enable: boolean;
        /**
         * The fill color of the tooltip, which accepts value in hex, rgba as a valid CSS color string.
         */
        fill: string;
        /**
         * Options to customize the tooltip text.
         */
        textStyle: FontModel;
        /**
         * Format of the tooltip content.
         * @default null
         */
        format: string;
        /**
         * Custom template to format the tooltip content. Use ${x} and ${y} as a placeholder text to display the corresponding data point.
         * @default null
         */
        template: string;
        /**
         * If set true, tooltip will animate, while moving from one point to another.
         * @default true
         */
        enableAnimation: boolean;
        /**
         * Options to customize the border for tooltip.
         */
        border: BorderModel;
    }
    
    /**
     * Specifies the linear gauge constant value
     */
    /** @private */
    export const loaded: string;
    /** @private */
    export const load: string;
    /** @private */
    export const animationComplete: string;
    /** @private */
    export const axisLabelRender: string;
    /** @private */
    export const tooltipRender: string;
    /** @private */
    export const annotationRender: string;
    /** @private */
    export const gaugeMouseMove: string;
    /** @private */
    export const gaugeMouseLeave: string;
    /** @private */
    export const gaugeMouseDown: string;
    /** @private */
    export const gaugeMouseUp: string;
    /** @private */
    export const valueChange: string;
    /** @private */
    export const resized: string;
    
    /**
     * @private
     * Specifies LienarGauge Events
     */
    /** @private */
    export interface ILinearGaugeEventArgs {
        name: string;
        cancel: boolean;
    }
    /**
     * Gauge Loaded event arguments
     */
    export interface ILoadedEventArgs extends ILinearGaugeEventArgs {
        /**
         * event argument gauge
         */
        gauge: LinearGauge;
    }
    /**
     * Gauge Load event arguments
     */
    export interface ILoadEventArgs extends ILinearGaugeEventArgs {
        /**
         * event argument gauge
         */
        gauge: LinearGauge;
    }
    /**
     * Gauge animation completed event arguments
     */
    export interface IAnimationCompleteEventArgs extends ILinearGaugeEventArgs {
        /**
         * event argument axis
         */
        axis: Axis;
        /**
         * event argument pointer
         */
        pointer: Pointer;
    }
    /**
     * Gauge axis label rendering event arguments
     */
    export interface IAxisLabelRenderEventArgs extends ILinearGaugeEventArgs {
        /**
         * event argument axis
         */
        axis: Axis;
        /**
         * event argument text
         */
        text: string;
        /**
         * event argument value
         */
        value: number;
    }
    /**
     * Gauge tooltip event arguments
     */
    export interface ITooltipRenderEventArgs extends ILinearGaugeEventArgs {
        /**
         * event argument tooltip content
         */
        content?: string | HTMLElement;
        /**
         * event argument border
         */
        border?: BorderModel;
        /**
         * event argument text style
         */
        textStyle?: FontModel;
        /**
         * event argument axis
         */
        axis: Axis;
        /**
         * event argument pointer
         */
        pointer: Pointer;
    }
    /**
     * Gauge annotation render event arguments
     */
    export interface IAnnotationRenderEventArgs extends ILinearGaugeEventArgs {
        /**
         * event argument content
         */
        content?: string;
        /**
         * event argument text style
         */
        textStyle?: FontModel;
        /**
         * event argument annotation
         */
        annotation: Annotation;
    }
    /**
     * Gauge mouse events args
     */
    export interface IMouseEventArgs extends ILinearGaugeEventArgs {
        /**
         * event argument linear gauge model
         */
        model: LinearGauge;
        /**
         * event argument target
         */
        target: Element;
        /**
         * event argument x position
         */
        x: number;
        /**
         * event argument y position
         */
        y: number;
    }
    /**
     * Gauge resize event arguments
     */
    export interface IResizeEventArgs {
        /**
         * event name
         */
        name: string;
        /**
         * event argument previous size
         */
        previousSize: Size;
        /**
         * event argument current size
         */
        currentSize: Size;
        /**
         * event argument gauge
         */
        gauge: LinearGauge;
    }
    /**
     * Gauge value change event arguments
     */
    export interface IValueChangeEventArgs {
        /**
         * event name
         */
        name: string;
        /**
         * event argument gauge
         */
        gauge: LinearGauge;
        /**
         * event argument element
         */
        element: Element;
        /**
         * event argument axis index
         */
        axisIndex: number;
        /**
         * event argument axis
         */
        axis: Axis;
        /**
         * event argument pointer index
         */
        pointerIndex: number;
        /**
         * event argument pointer
         */
        pointer: Pointer;
        /**
         * event argument value
         */
        value: number;
    }
    /** @private */
    export interface IVisiblePointer {
        axis?: Axis;
        axisIndex?: number;
        pointer?: Pointer;
        pointerIndex?: number;
    }
    /** @private */
    export interface IMoveCursor {
        pointer?: boolean;
        style?: string;
    }
    
    /**
     * Represent the tooltip rendering for gauge
     */
    export class GaugeTooltip {
        private gauge;
        private element;
        private currentAxis;
        private axisIndex;
        private currentPointer;
        /**
         * EJ2 tooltip instance
         */
        ejTooltip: ej.popups.Tooltip;
        private textStyle;
        private borderStyle;
        private pointerElement;
        private tooltip;
        constructor(gauge: LinearGauge);
        /**
         * Internal use for tooltip rendering
         * @param pointerElement
         */
        renderTooltip(pointerElement: Element): void;
        private appendTargetElement();
        private getTooltipPosition();
        private getTooltipLocation();
        private onBeforeRender(args);
        private tooltipCustomization(args);
        protected getModuleName(): string;
        /**
         * To destroy the tooltip.
         * @return {void}
         * @private
         */
        destroy(gauge: LinearGauge): void;
    }
    
    /**
     * Defines Position of axis. They are
     * * Inside
     * * Outside
     * @private
     */
    export type Position = 'Inside' | 'Outside';
    /**
     * Defines type of pointer. They are
     * * Marker
     * * Bar
     * @private
     */
    export type Point = 'Marker' | 'Bar';
    /**
     * Defines Theme of the gauge. They are
     * * Material
     * * Fabric
     * @private
     */
    export type LinearGaugeTheme = 'Material' | 'Bootstrap' | 'Highcontrast' | 'Fabric';
    /**
     * Defines the type of marker. They are
     * Traingle
     * Diamond
     * Rectangle
     * Circle
     * Image
     * @private
     */
    export type MarkerType = 'Triangle' | 'InvertedTriangle' | 'Diamond' | 'Rectangle' | 'Circle' | 'Arrow' | 'InvertedArrow' | 'Image';
    /**
     * Defines the place of the pointer. They are
     * None
     * Near
     * Center
     * Far
     * @private
     */
    export type Placement = 'Near' | 'Center' | 'Far' | 'None';
    /**
     * Defines the type of gauge orientation. They are
     * Horizontal
     * Vertical
     * @private
     */
    export type Orientation = 'Horizontal' | 'Vertical';
    /**
     * Defines the container type. They are
     * Normal
     * Thermometer
     * Rounded Rectangle
     */
    export type ContainerType = 'Normal' | 'Thermometer' | 'RoundedRectangle';
    
    /**
     * Specifies Linear-Gauge Helper methods
     */
    /** @private */
    export function stringToNumber(value: string, containerSize: number): number;
    /**
     * Function to measure the height and width of the text.
     * @param  {string} text
     * @param  {FontModel} font
     * @param  {string} id
     * @returns no
     * @private
     */
    export function measureText(text: string, font: FontModel): Size;
    /** @private */
    export function withInRange(value: number, start: number, end: number, max: number, min: number, type: string): boolean;
    export function convertPixelToValue(parentElement: HTMLElement, pointerElement: Element, orientation: Orientation, axis: Axis, type: string, location: GaugeLocation): number;
    export function getPathToRect(path: SVGPathElement, size: Size, parentElement: HTMLElement): Rect;
    /** @private */
    export function getElement(id: string): HTMLElement;
    /** @private */
    export function removeElement(id: string): void;
    /** @private */
    export function isPointerDrag(axes: AxisModel[]): boolean;
    /** @private */
    export function valueToCoefficient(value: number, axis: Axis, orientation: Orientation, range: VisibleRange): number;
    export function getFontStyle(font: FontModel): string;
    /** @private */
    export function getLabelFormat(format: string): string;
    /** @private */
    export function getTemplateFunction(template: string): Function;
    /** @private */
    export function getElementOffset(childElement: HTMLElement, parentElement: HTMLElement): Size;
    /** @private */
    export class VisibleRange {
        min?: number;
        max?: number;
        interval?: number;
        delta?: number;
        constructor(min: number, max: number, interval: number, delta: number);
    }
    /** @private */
    export class GaugeLocation {
        x: number;
        y: number;
        constructor(x: number, y: number);
    }
    /**
     * Internal class size for height and width
     */
    export class Size {
        /**
         * height of the size
         */
        height: number;
        /**
         * width of the size
         */
        width: number;
        constructor(width: number, height: number);
    }
    /** @private */
    export class Rect {
        x: number;
        y: number;
        height: number;
        width: number;
        constructor(x: number, y: number, width: number, height: number);
    }
    /** @private */
    export class CustomizeOption {
        id: string;
        constructor(id?: string);
    }
    /** @private */
    export class PathOption extends CustomizeOption {
        opacity: number;
        fill: string;
        stroke: string;
        ['stroke-width']: number;
        ['stroke-dasharray']: string;
        d: string;
        transform: string;
        constructor(id: string, fill: string, width: number, color: string, opacity?: number, dashArray?: string, d?: string, transform?: string);
    }
    /** @private */
    export class RectOption {
        x: number;
        y: number;
        id: string;
        height: number;
        width: number;
        rx: number;
        ry: number;
        opacity: number;
        transform: string;
        stroke: string;
        fill: string;
        ['stroke-width']: number;
        constructor(id: string, fill: string, border: BorderModel, opacity: number, rect: Rect, transform?: string, dashArray?: string);
    }
    /** @private */
    export class TextOption extends CustomizeOption {
        anchor: string;
        text: string;
        transform: string;
        x: number;
        y: number;
        baseLine: string;
        constructor(id?: string, x?: number, y?: number, anchor?: string, text?: string, transform?: string, baseLine?: string);
    }
    /** @private */
    export class VisibleLabels {
        text: string;
        value: number;
        size: Size;
        angle: number;
        constructor(text: string, value: number, size: Size);
    }
    /** @private */
    export class Align {
        axisIndex: number;
        align: string;
        constructor(axisIndex: number, align: string);
    }
    /** @private */
    export function textElement(options: TextOption, font: FontModel, color: string, parent: HTMLElement | Element): Element;
    export function calculateNiceInterval(min: number, max: number, size: number, orientation: Orientation): number;
    export function getActualDesiredIntervalsCount(size: number, orientation: Orientation): number;
    /** @private */
    export function getPointer(target: HTMLElement, gauge: LinearGauge): IVisiblePointer;
    /** @private */
    export function getRangeColor(value: number, ranges: Range[]): string;
    /** @private */
    export function getRangePalette(): string[];
    /** @private */
    export function calculateShapes(location: Rect, shape: MarkerType, size: Size, url: string, options: PathOption, orientation: Orientation, axis: Axis, pointer: Pointer): PathOption;
    /** @private */
    export function getBox(location: Rect, boxName: string, orientation: Orientation, size: Size, type: string, containerWidth: number, axis: Axis, cornerRadius: number): string;
    
  }
  export namespace lists {
    
    export let cssClass: ClassList;
    export interface ClassList {
        li: string;
        ul: string;
        group: string;
        icon: string;
        text: string;
        check: string;
        checked: string;
        selected: string;
        expanded: string;
        textContent: string;
        hasChild: string;
        level: string;
        url: string;
        collapsible: string;
        disabled: string;
        image: string;
        iconWrapper: string;
    }
    /**
     * Sorting Order
     */
    export type SortOrder = 'None' | 'Ascending' | 'Descending';
    /**
     * Base List Generator
     */
    export namespace ListBase {
        /**
         * Default mapped fields.
         */
        let defaultMappedFields: FieldsMapping;
        /**
         * Function helps to created and return the UL Li element based on your data.
         * @param  {{[key:string]:Object}[]|string[]} dataSource - Specifies an array of JSON or String data.
         * @param  {ListBaseOptions} options? - Specifies the list options that need to provide.
         */
        function createList(dataSource: {
            [key: string]: Object;
        }[] | string[], options?: ListBaseOptions, isSingleLevel?: boolean): HTMLElement;
        /**
         * Function helps to created an element list based on string array input .
         * @param  {string[]} dataSource - Specifies an array of string data
         */
        function createListFromArray(dataSource: string[], isSingleLevel?: boolean, options?: ListBaseOptions): HTMLElement;
        /**
         * Function helps to created an element list based on string array input .
         * @param  {string[]} dataSource - Specifies an array of string data
         */
        function createListItemFromArray(dataSource: string[], isSingleLevel?: boolean, options?: ListBaseOptions): HTMLElement[];
        /**
         * Function helps to created an element list based on array of JSON input .
         * @param  {{[key:string]:Object}[]} dataSource - Specifies an array of JSON data.
         * @param  {ListBaseOptions} options? - Specifies the list options that need to provide.
         */
        function createListItemFromJson(dataSource: {
            [key: string]: Object;
        }[], options?: ListBaseOptions, level?: number, isSingleLevel?: boolean): HTMLElement[];
        /**
         * Function helps to created an element list based on array of JSON input .
         * @param  {{[key:string]:Object}[]} dataSource - Specifies an array of JSON data.
         * @param  {ListBaseOptions} options? - Specifies the list options that need to provide.
         */
        function createListFromJson(dataSource: {
            [key: string]: Object;
        }[], options?: ListBaseOptions, level?: number, isSingleLevel?: boolean): HTMLElement;
        /**
         * Return the next or previous visible element.
         * @param  {Element[]|NodeList} elementArray - An element array to find next or previous element.
         * @param  {Element} li - An element to find next or previous after this element.
         * @param  {boolean} isPrevious? - Specify when the need get previous element from array.
         */
        function getSiblingLI(elementArray: Element[] | NodeList, element: Element, isPrevious?: boolean): Element;
        /**
         * Return the index of the li element
         * @param  {Element} item - An element to find next or previous after this element.
         * @param  {Element[]|NodeList} elementArray - An element array to find index of given li.
         */
        function indexOf(item: Element, elementArray: Element[] | NodeList): number;
        /**
         * Returns the grouped data from given dataSource.
         * @param  {{[key:string]:Object}[]} dataSource - The JSON data which is necessary to process.
         * @param  {FieldsMapping} fields - Fields that are mapped from the data source.
         * @param  {SortOrder='None'} sortOrder- Specifies final result sort order.
         */
        function groupDataSource(dataSource: {
            [key: string]: Object;
        }[], fields: FieldsMapping, sortOrder?: SortOrder): {
            [key: string]: Object;
        }[];
        /**
         * Returns a sorted query object.
         * @param  {SortOrder} sortOrder - Specifies that sort order.
         * @param  {string} sortBy - Specifies sortBy fields.
         * @param  {Query=new Query()} query - Pass if any existing query.
         */
        function addSorting(sortOrder: SortOrder, sortBy: string, query?: ej.data.Query): ej.data.Query;
        /**
         * Return an array of JSON Data that processed based on queries.
         * @param  {{[key:string]:Object}[]} dataSource - Specifies local JSON data source.
         * @param  {Query} query - Specifies query that need to process.
         */
        function getDataSource(dataSource: {
            [key: string]: Object;
        }[], query: ej.data.Query): {
            [key: string]: Object;
        }[];
        /**
         * Created JSON data based the UL and LI element
         * @param  {HTMLElement|Element} element - UL element that need to convert as a JSON
         * @param  {ListBaseOptions} options? - Specifies listbase option for fields.
         */
        function createJsonFromElement(element: HTMLElement | Element, options?: ListBaseOptions): {
            [key: string]: Object;
        }[];
        /**
         * Created UL element from content template.
         * @param  {string} template - that need to convert and generate li element.
         * @param  {{[key:string]:Object}[]} dataSource - Specifies local JSON data source.
         * @param  {ListBaseOptions} options? - Specifies listbase option for fields.
         */
        function renderContentTemplate(template: string, dataSource: {
            [key: string]: Object;
        }[], fields?: FieldsMapping, options?: ListBaseOptions): HTMLElement;
        /**
         * Created header items from group template.
         * @param  {string} template - that need to convert and generate li element.
         * @param  {{[key:string]:Object}[]} dataSource - Specifies local JSON data source.
         * @param  {FieldsMapping} fields - Specifies fields for mapping the dataSource.
         * @param  {Element[]} headerItems? - Specifies listbase header items.
         */
        function renderGroupTemplate(groupTemplate: string, groupDataSource: {
            [key: string]: Object;
        }[], fields: FieldsMapping, headerItems: Element[]): Element[];
        /**
         * Returns UL element based on the given LI element.
         * @param  {HTMLElement[]} liElement - Specifies array of LI element.
         * @param  {string} className? - Specifies class name that need to be added in UL element.
         * @param  {ListBaseOptions} options? - Specifies ListBase options.
         */
        function generateUL(liElement: HTMLElement[], className?: string, options?: ListBaseOptions): HTMLElement;
        /**
         * Returns LI element with additional DIV tag based on the given LI element.
         * @param  {liElement} liElement - Specifies LI element.
         * @param  {string} className? - Specifies class name that need to be added in created DIV element.
         * @param  {ListBaseOptions} options? - Specifies ListBase options.
         */
        function generateIcon(liElement: HTMLElement, className?: string, options?: ListBaseOptions): HTMLElement;
    }
    export interface FieldsMapping {
        id?: string;
        text?: string;
        value?: string;
        isChecked?: string;
        isVisible?: string;
        url?: string;
        enabled?: string;
        groupBy?: string;
        expanded?: string;
        selected?: string;
        iconCss?: string;
        child?: string;
        tooltip?: string;
        hasChildren?: string;
        htmlAttributes?: string;
        urlAttributes?: string;
        imageUrl?: string;
        imageAttributes?: string;
    }
    export type Position = 'Right' | 'Left';
    export interface AriaAttributesMapping {
        level?: number;
        listRole?: string;
        itemRole?: string;
        groupItemRole?: string;
        itemText?: string;
        wrapperRole?: string;
    }
    /**
     * Basic ListBase Options
     */
    export interface ListBaseOptions {
        /**
         * Specifies that fields that mapped in dataSource
         */
        fields?: FieldsMapping;
        /**
         * Specifies the aria attributes
         */
        ariaAttributes?: AriaAttributesMapping;
        /**
         * Specifies to show checkBox
         */
        showCheckBox?: boolean;
        /**
         * Specifies to show icon
         */
        showIcon?: boolean;
        /**
         * Specifies to show collapsible icon
         */
        expandCollapse?: boolean;
        /**
         * Specifies when need to add additional UL list class
         */
        listClass?: string;
        /**
         * Specifies when need to add additional LI item class
         */
        itemClass?: string;
        /**
         * Enables when need process depth child processing.
         */
        processSubChild?: boolean;
        /**
         * Specifies the sort order
         */
        sortOrder?: SortOrder;
        /**
         * Specifies the item template
         */
        template?: string;
        /**
         * Specifies the group header template
         */
        groupTemplate?: string;
        /**
         * Specifies the callback function that triggered before each list creation
         */
        itemCreating?: Function;
        /**
         * Specifies the callback function that triggered after each list creation
         */
        itemCreated?: Function;
        /**
         * Specifies the customizable expand icon class
         */
        expandIconClass?: string;
        /**
         * Specifies the customized class name based on their module name
         */
        moduleName?: string;
        /**
         * Specifies the expand/collapse icon position
         */
        expandIconPosition?: Position;
    }
    /**
     * Used to get dataSource item from complex data using fields.
     * @param {{[key:string]:Object}|string[]|string} dataSource - Specifies an  JSON or String data.
     * @param {FieldsMapping} fields - Fields that are mapped from the dataSource.
     */
    export function getFieldValues(dataItem: {
        [key: string]: Object;
    } | string | string[], fields: FieldsMapping): {
        [key: string]: Object;
    } | string | string[];
    
    /**
     * Interface for a class FieldSettings
     */
    export interface FieldSettingsModel {
    
        /**
         * ID attribute of specific list-item.
         */
        id?: string;
    
        /**
         * It is used to map the text value of list item from the dataSource.
         */
        text?: string;
    
        /**
         * This property used to check whether the list item is in checked state or not.
         */
        isChecked?: string;
    
        /**
         * To check whether the visibility state of list item.
         */
        isVisible?: string;
    
        /**
         * It is used to enable the list item
         */
        enabled?: string;
    
        /**
         * It is used to customize the icon to the list items dynamically.
         *  We can add specific image to the icons using iconCss property.
         */
        iconCss?: string;
    
        /**
         * This property used for nested navigation of list-items.
         * Refer the documentation
         *  {@link http://ej2.syncfusion.com/documentation/list-view/nested-list.html?lang=typescript here}
         *  to know more about this property with demo.
         */
        child?: string;
    
        /**
         * It is used to display `tooltip content of text` while hovering on list items.
         */
        tooltip?: string;
    
        /**
         * It wraps the list view element into a group based on the value of groupBy property.
         * Refer the documentation
         *  {@link http://ej2.syncfusion.com/documentation/list-view/grouping.html?lang=typescript here}
         *  to know more about this property with demo.
         */
        groupBy?: string;
    
        /**
         * It is used to enable the sorting of list items to be ascending or descending.
         */
        sortBy?: string;
    
        /**
         * Defines the HTML attributes such as id, class, etc,. for the specific list item.
         */
        htmlAttributes?: string;
    
        /**
         * It is used to fetch a specified named table data while using serviceUrl of DataManager
         *  in dataSource property.
         * Refer the documentation
         *  {@link http://ej2.syncfusion.com/documentation/data/getting-started.html?lang=typescript here}
         *  to know more about this property with demo.
         */
        tableName?: string;
    
    }
    
    /**
     * Interface for a class ListView
     */
    export interface ListViewModel extends ej.base.ComponentModel{
    
        /**
         * This cssClass property helps to use custom skinning option for ListView component,
         *  by adding the mentioned class name into root element of ListView.
         * @default ''
         */
        cssClass?: string;
    
        /**
         * Defines the HTML attributes such as id, class, etc., for the ListView.
         * @default {}
         */
        htmlAttributes?: { [key: string]: string; };
    
        /**
         * It specifies enabled state of ListView component.
         * @default true
         */
        enable?: boolean;
    
        /**
         * It provides the data to render the ListView component which is mapped
         *  with the fields of ListView.
         * @default []
         */
        dataSource?: { [key: string]: Object }[] | string[] | ej.data.DataManager;
    
        /**
         * It is used to fetch the specific data from dataSource by using where, select key words.
         * Refer the documentation
         *  {@link http://ej2.syncfusion.com/documentation/list-view/data-binding.html?lang=typescript#bind-to-remote-data here}
         *  to know more about this property with demo.
         * @default null
         */
        query?: ej.data.Query;
    
        /**
         * It is used to map keys from the dataSource which extracts the appropriate data from the dataSource
         *  with specified mapped with the column fields to render the ListView.
         * @default ListBase.defaultMappedFields
         */
        fields?: FieldSettingsModel;
    
        /**
         * It is used to apply the animation to sub list navigation of list items.
         * @default { effect: 'SlideLeft', duration: 400, easing: 'ease' }
         */
        animation?: AnimationSettings;
    
        /**
         * It is used to enable the sorting of list items to be ascending or descending.
         * @default 'None'
         */
        sortOrder?: SortOrder;
    
        /**
         * Using this property, we can show or hide the icon of list item.
         * @default false
         */
        showIcon?: boolean;
    
        /**
         * Using this property, we can show or hide the `checkbox`.
         * @default false
         */
        showCheckBox?: boolean;
    
        /**
         * It is used to set the position of check box in an item.
         * @default 'Left'
         */
        checkBoxPosition?: checkBoxPosition;
    
        /**
         * It is used to set the title of ListView component.
         * @default ""
         */
        headerTitle?: string;
    
        /**
         * Using this property, we can show or hide the header of ListView component.
         * @default false
         */
        showHeader?: boolean;
    
        /**
         * It is used to set the height of the ListView component.
         * @default ''
         */
        height?: number | string;
    
        /**
         * It sets the width to the ListView component.
         * @default ''
         */
        width?: number | string;
    
        /**
         * The ListView supports to customize the content of each list items with the help of template property.
         * Refer the documentation
         *  {@link http://ej2.syncfusion.com/documentation/list-view/customizing-templates.html?lang=typescript here}
         *  to know more about this property with demo.
         * @default null
         */
        template?: string;
    
        /**
         * The ListView has an option to custom design the group header title with the help of groupTemplate property.
         * Refer the documentation
         *  {@link http://ej2.syncfusion.com/15.4.23/documentation/list-view/customizing-templates.html?lang=typescript#group-template here}
         *  to know more about this property with demo.
         * @default null
         */
        groupTemplate?: string;
    
        /**
         * We can trigger the `select` event when we select the list item in the component.
         * @event
         */
        select?: ej.base.EmitType<SelectEventArgs>;
    
        /**
         * We can trigger `actionBegin` event before every ListView action starts.
         * @event
         */
        actionBegin?: ej.base.EmitType<Object>;
    
        /**
         * We can trigger `actionComplete` event for every ListView action success event
         *  with the dataSource parameter.
         * @event
         */
        actionComplete?: ej.base.EmitType<Object>;
    
        /**
         * We can trigger `actionFailure` event for every ListView action failure event
         *  with the dataSource parameter.
         * @event
         */
        actionFailure?: ej.base.EmitType<Object>;
    
    }
    
    export interface Fields {
        /**
         * ID attribute of specific list-item.
         */
        id?: string;
        /**
         * It is used to map the text value of list item from the dataSource.
         */
        text?: string;
    }
    export class FieldSettings extends ej.base.ChildProperty<FieldSettings> {
        /**
         * ID attribute of specific list-item.
         */
        id: string;
        /**
         * It is used to map the text value of list item from the dataSource.
         */
        text: string;
        /**
         * This property used to check whether the list item is in checked state or not.
         */
        isChecked: string;
        /**
         * To check whether the visibility state of list item.
         */
        isVisible: string;
        /**
         * It is used to enable the list item
         */
        enabled: string;
        /**
         * It is used to customize the icon to the list items dynamically.
         *  We can add specific image to the icons using iconCss property.
         */
        iconCss: string;
        /**
         * This property used for nested navigation of list-items.
         * Refer the documentation
         *  {@link http://ej2.syncfusion.com/documentation/list-view/nested-list.html?lang=typescript here}
         *  to know more about this property with demo.
         */
        child: string;
        /**
         * It is used to display `tooltip content of text` while hovering on list items.
         */
        tooltip: string;
        /**
         * It wraps the list view element into a group based on the value of groupBy property.
         * Refer the documentation
         *  {@link http://ej2.syncfusion.com/documentation/list-view/grouping.html?lang=typescript here}
         *  to know more about this property with demo.
         */
        groupBy: string;
        /**
         * It is used to enable the sorting of list items to be ascending or descending.
         */
        sortBy: string;
        /**
         * Defines the HTML attributes such as id, class, etc,. for the specific list item.
         */
        htmlAttributes: string;
        /**
         * It is used to fetch a specified named table data while using serviceUrl of DataManager
         *  in dataSource property.
         * Refer the documentation
         *  {@link http://ej2.syncfusion.com/documentation/data/getting-started.html?lang=typescript here}
         *  to know more about this property with demo.
         */
        tableName: string;
    }
    /**
     * Animation configuration settings.
     */
    export interface AnimationSettings {
        /**
         * It is used to specify the effect which is shown in sub list transform.
         */
        effect?: ListViewEffect;
        /**
         * It is used to specify the time duration of transform object.
         */
        duration?: number;
        /**
         * It is used to specify the easing effect applied while transform
         */
        easing?: string;
    }
    /**
     * ListView animation effects
     */
    export type ListViewEffect = 'None' | 'SlideLeft' | 'SlideDown' | 'Zoom' | 'Fade';
    /**
     * ListView check box positions
     */
    export type checkBoxPosition = 'Left' | 'Right';
    /**
     * Represents the EJ2 ListView control.
     * ```html
     * <div id="listview">
     * <ul>
     * <li>Favourite</li>
     * <li>Documents</li>
     * <li>Downloads</li>
     * </ul>
     * </div>
     * ```
     * ```typescript
     *   var lvObj = new ListView({});
     *   lvObj.appendTo("#listview");
     * ```
     */
    export class ListView extends ej.base.Component<HTMLElement> implements ej.base.INotifyPropertyChanged {
        private ulElement;
        private selectedLI;
        private curUL;
        private curDSLevel;
        private curViewDS;
        private curDSJSON;
        localData: {
            [key: string]: Object;
        }[];
        private liCollection;
        private headerEle;
        private contentContainer;
        private keyboardModule;
        private touchModule;
        private keyConfigs;
        private listBaseOption;
        private animateOptions;
        private rippleFn;
        private isNestedList;
        private currentLiElements;
        private resetList;
        private selectedData;
        private selectedId;
        private aniObj;
        /**
         * This cssClass property helps to use custom skinning option for ListView component,
         *  by adding the mentioned class name into root element of ListView.
         * @default ''
         */
        cssClass: string;
        /**
         * Defines the HTML attributes such as id, class, etc., for the ListView.
         * @default {}
         */
        htmlAttributes: {
            [key: string]: string;
        };
        /**
         * It specifies enabled state of ListView component.
         * @default true
         */
        enable: boolean;
        /**
         * It provides the data to render the ListView component which is mapped
         *  with the fields of ListView.
         * @default []
         */
        dataSource: {
            [key: string]: Object;
        }[] | string[] | ej.data.DataManager;
        /**
         * It is used to fetch the specific data from dataSource by using where, select key words.
         * Refer the documentation
         *  {@link http://ej2.syncfusion.com/documentation/list-view/data-binding.html?lang=typescript#bind-to-remote-data here}
         *  to know more about this property with demo.
         * @default null
         */
        query: ej.data.Query;
        /**
         * It is used to map keys from the dataSource which extracts the appropriate data from the dataSource
         *  with specified mapped with the column fields to render the ListView.
         * @default ListBase.defaultMappedFields
         */
        fields: FieldSettingsModel;
        /**
         * It is used to apply the animation to sub list navigation of list items.
         * @default { effect: 'SlideLeft', duration: 400, easing: 'ease' }
         */
        animation: AnimationSettings;
        /**
         * It is used to enable the sorting of list items to be ascending or descending.
         * @default 'None'
         */
        sortOrder: SortOrder;
        /**
         * Using this property, we can show or hide the icon of list item.
         * @default false
         */
        showIcon: boolean;
        /**
         * Using this property, we can show or hide the `checkbox`.
         * @default false
         */
        showCheckBox: boolean;
        /**
         * It is used to set the position of check box in an item.
         * @default 'Left'
         */
        checkBoxPosition: checkBoxPosition;
        /**
         * It is used to set the title of ListView component.
         * @default ""
         */
        headerTitle: string;
        /**
         * Using this property, we can show or hide the header of ListView component.
         * @default false
         */
        showHeader: boolean;
        /**
         * It is used to set the height of the ListView component.
         * @default ''
         */
        height: number | string;
        /**
         * It sets the width to the ListView component.
         * @default ''
         */
        width: number | string;
        /**
         * The ListView supports to customize the content of each list items with the help of template property.
         * Refer the documentation
         *  {@link http://ej2.syncfusion.com/documentation/list-view/customizing-templates.html?lang=typescript here}
         *  to know more about this property with demo.
         * @default null
         */
        template: string;
        /**
         * The ListView has an option to custom design the group header title with the help of groupTemplate property.
         * Refer the documentation
         *  {@link http://ej2.syncfusion.com/15.4.23/documentation/list-view/customizing-templates.html?lang=typescript#group-template here}
         *  to know more about this property with demo.
         * @default null
         */
        groupTemplate: string;
        /**
         * We can trigger the `select` event when we select the list item in the component.
         * @event
         */
        select: ej.base.EmitType<SelectEventArgs>;
        /**
         * We can trigger `actionBegin` event before every ListView action starts.
         * @event
         */
        actionBegin: ej.base.EmitType<Object>;
        /**
         * We can trigger `actionComplete` event for every ListView action success event
         *  with the dataSource parameter.
         * @event
         */
        actionComplete: ej.base.EmitType<Object>;
        /**
         * We can trigger `actionFailure` event for every ListView action failure event
         *  with the dataSource parameter.
         * @event
         */
        actionFailure: ej.base.EmitType<Object>;
        /**
         * Constructor for creating the widget
         */
        constructor(options?: ListViewModel, element?: string | HTMLElement);
        onPropertyChanged(newProp: ListViewModel, oldProp: ListViewModel): void;
        private setHTMLAttribute();
        private setCSSClass(oldCSSClass?);
        private setSize();
        private setEnable();
        private setEnableRTL();
        private enableElement(element, isEnabled?);
        private header(text?, showBack?);
        private switchView(fromView, toView, reverse?);
        protected preRender(): void;
        private renderCheckbox(args);
        private checkItem(args, checkboxElement);
        private checkboxRevert();
        private setCheckbox();
        private clickHandler(e);
        private removeElement(element);
        private hoverHandler(e);
        private leaveHandler(e);
        private homeKeyHandler(e, end?);
        private arrowKeyHandler(e, prev?);
        private enterKeyHandler(e);
        private spaceKeyHandler(e);
        private keyActionHandler(e);
        private swipeActionHandler(e);
        private focusout();
        private wireEvents();
        private unWireEvents();
        private tabFocus(e);
        private removeHover();
        private removeSelect();
        private isValidLI(li);
        private setCheckboxLI(li, e?);
        private selectEventData(li, e?);
        private setSelectLI(li, e?);
        private setHoverLI(li);
        private hoverSiblingLI(prev?);
        private getSubDS();
        private getItemData(li);
        private findItemFromDS(dataSource, fields, parent?);
        private getQuery();
        private setViewDataSource(dataSource?);
        private isInAnimation();
        private setLocalData();
        private reRender();
        private resetCurrentList();
        private createList();
        private renderSubList(li);
        private renderIntoDom(ele);
        private renderList();
        private getElementUID(obj);
        /**
         * It is used to Initialize the control rendering.
         */
        render(): void;
        /**
         * It is used to destroy the ListView component.
         */
        destroy(): void;
        /**
         * It helps to switch back from navigated sub list.
         */
        back(): void;
        /**
         * It is used to select the list item from the ListView.
         * @param  {Fields|HTMLElement} obj - We can pass element Object or Fields as Object with ID and Text fields.
         */
        selectItem(obj: Fields | HTMLElement): void;
        private getLiFromObjOrElement(obj);
        selectMultipleItems(obj: Fields[] | HTMLElement[]): void;
        /**
         * It is used to get the currently
         *  {@link http://ej2.syncfusion.com/documentation/list-view/api-selectedItem.html?lang=typescript selected}
         *  item details from the list items.
         */
        getSelectedItems(): SelectedItem | SelectedCollection;
        /**
         * It is used to find out an item details from the current list.
         * @param  {Fields|HTMLElement} obj - We can pass element Object or Fields as Object with ID and Text fields.
         */
        findItem(fields: Fields): SelectedItem;
        /**
         * A function that used to enable the disabled list items based on passed element.
         * @param  {Fields|HTMLElement} obj - We can pass element Object or Fields as Object with ID and Text fields.
         */
        enableItem(obj: Fields | HTMLElement): void;
        /**
         * It is used to disable the list items based on passed element.
         * @param  {Fields|HTMLElement} obj - We can pass element Object or Fields as Object with ID and Text fields.
         */
        disableItem(obj: Fields | HTMLElement): void;
        private setItemState(obj, isEnable);
        /**
         * It is used to show an list item from the ListView.
         * @param  {Fields|HTMLElement} obj - We can pass element Object or Fields as Object with ID and Text fields.
         */
        showItem(obj: Fields | HTMLElement): void;
        /**
         * It is used to hide an item from the ListView.
         * @param  {Fields|HTMLElement} obj - We can pass element Object or Fields as Object with ID and Text fields.
         */
        hideItem(obj: Fields | HTMLElement): void;
        private showHideItem(obj, isHide, display);
        /**
         * It adds new item to current ListView.
         * To add a new item in the list view, we need to pass ‘data’ as array or object and ‘fields’ as object.
         * For example fields: { text: 'Name', tooltip: 'Name', id:'id'}
         * @param  {{[key:string]:Object}[]} data - Array JSON Data that need to add.
         * @param  {Fields} fields - Fields as an Object with ID and Text fields.
         */
        addItem(data: {
            [key: string]: Object;
        }[], fields: Fields): void;
        /**
         * A function that removes the item from data source based on passed element like fields: { text: 'Name', tooltip: 'Name', id:'id'}
         * @param  {Fields|HTMLElement} obj - We can pass element Object or Fields as Object with ID and Text fields.
         */
        removeItem(obj: Element | Fields): void;
        private removeItemFromList(obj, resetList?);
        /**
         * A function that removes multiple item from list view based on given input.
         * @param  {Fields[] | HTMLElement[]} obj - We can pass array of elements or array of field Object with ID and Text fields.
         */
        removeMultipleItems(obj: HTMLElement[] | Fields[]): void;
        protected getModuleName(): string;
        /**
         * Get the properties to be maintained in the persisted state.
         */
        protected getPersistData(): string;
    }
    export interface SelectedItem {
        /**
         * It denotes the Selected Item text.
         */
        text: string;
        /**
         * It denotes the Selected Item list element.
         */
        item: HTMLElement | Element;
        /**
         * It denotes the Selected Item dataSource JSON object.
         */
        data: {
            [key: string]: Object;
        } | string[];
    }
    export interface SelectedCollection {
        /**
         * It denotes the Selected Item text data or collection.
         */
        text: string | string[];
        /**
         * It denotes the Selected Item list element or element collection.
         */
        item: HTMLElement | Element[] | HTMLCollection;
        /**
         * It denotes the Selected Item dataSource JSON object or object collection.
         */
        data: {
            [key: string]: Object;
        } | {
            [key: string]: Object;
        }[] | string[];
    }
    export interface SelectEventArgs extends ej.base.BaseEventArgs, SelectedItem {
        /**
         * Specifies that event has triggered by user interaction.
         */
        isInteracted: boolean;
        /**
         * Specifies that event argument when event raised by other event.
         */
        event: MouseEvent | KeyboardEvent;
        /**
         * It is used to denote the index of the selected element.
         */
        index: number;
        /**
         * It is used to check whether the element is checked or not.
         */
        isChecked?: boolean;
    }
    export interface ItemCreatedArgs {
        curData: {
            [key: string]: Object;
        };
        dataSource: {
            [key: string]: Object;
        } | string[];
        fields: FieldsMapping;
        item: HTMLElement;
        options: ListBaseOptions;
        text: string;
    }
    
  }
  export namespace maps {
    
    /**
     * Interface for a class Maps
     */
    export interface MapsModel extends ej.base.ComponentModel{
    
        /**
         * To configure the background of the maps container.
         * @default null
         */
        background?: string;
    
        /**
         * To enable the separator
         * @default false
         */
        useGroupingSeparator?: boolean;
    
        /**
         * To apply internationalization for maps
         * @default null
         */
        format?: string;
    
        /**
         * To configure width of maps.
         * @default null
         */
        width?: string;
    
        /**
         * To configure height of maps.
         * @default null
         */
        height?: string;
    
        /**
         * To configure the title settings of the maps.
         */
        titleSettings?: TitleSettingsModel;
    
        /**
         * To configure the zoom settings of the maps.
         */
        zoomSettings?: ZoomSettingsModel;
    
        /**
         * To configure the legend settings of the maps.
         */
        legendSettings?: LegendSettingsModel;
    
        /**
         * To configure the layers settings of the maps.
         */
        layers?: LayerSettingsModel[];
    
        /**
         *  Options for customizing the annotation of maps.
         */
        annotations?: AnnotationModel[];
    
        /**
         *  Options to customize left, right, top and bottom margins of the maps.
         */
        margin?: MarginModel;
    
        /**
         * Options for customizing the color and width of the maps border.
         */
        border?: BorderModel;
    
        /**
         * Specifies the theme for the maps.
         */
        theme?: MapsTheme;
    
        /**
         * Specifies the ProjectionType for the maps.
         */
        projectionType?: ProjectionType;
    
        /**
         * To configure baseMapIndex of maps. Option to select which layer to be visible.
         * @default 0
         */
        baseLayerIndex?: number;
    
        /**
         * Description for maps.
         * @default null
         */
        description?: string;
    
        /**
         * TabIndex value for the maps.
         * @default 1
         */
        tabIndex?: number;
    
        /**
         * To configure the zoom level of maps.
         * @default { latitude: null, longitude: null}
         */
        centerPosition?: { latitude: number, longitude: number };
    
        /**
         * To customization Maps area
         */
        mapsArea?: MapsAreaSettingsModel;
    
        /**
         * Triggers before maps rendered.
         * @event
         */
        load?: ej.base.EmitType<ILoadEventArgs>;
    
        /**
         * Triggers after maps rendered.
         * @event
         */
        loaded?: ej.base.EmitType<ILoadedEventArgs>;
    
        /**
         * Triggers on clicking the maps.
         * @event
         */
        click?: ej.base.EmitType<IMouseEventArgs>;
    
        /**
         * Triggers on double clicking the maps.
         * @event
         */
        doubleClick?: ej.base.EmitType<IMouseEventArgs>;
    
        /**
         * Triggers on right clicking the maps.
         * @event
         */
        rightClick?: ej.base.EmitType<IMouseEventArgs>;
    
        /**
         * Triggers on resizing the maps.
         * @event
         */
        resize?: ej.base.EmitType<IResizeEventArgs>;
    
        /**
         * Triggers before the maps tooltip rendered.
         * @event
         */
        tooltipRender?: ej.base.EmitType<ITooltipRenderEventArgs>;
    
        /**
         * Triggers while clicking the shape
         * @event
         */
        shapeSelected?: ej.base.EmitType<IShapeSelectedEventArgs>;
    
        /**
         * Triggers before selection applied
         * @event
         */
        itemSelection?: ej.base.EmitType<ISelectionEventArgs>;
    
        /**
         * Trigger before highlight applied
         * @event
         */
        itemHighlight?: ej.base.EmitType<ISelectionEventArgs>;
    
        /**
         * Triggers before highlight applied for shape
         * @event
         */
        shapeHighlight?: ej.base.EmitType<IShapeSelectedEventArgs>;
    
        /**
         * Triggers before the maps layer rendered.
         * @event
         */
        layerRendering?: ej.base.EmitType<ILayerRenderingEventArgs>;
    
        /**
         * Triggers before the maps shape rendered.
         * @event
         */
        shapeRendering?: ej.base.EmitType<IShapeRenderingEventArgs>;
    
        /**
         * Triggers before the maps marker rendered.
         * @event
         */
        markerRendering?: ej.base.EmitType<IMarkerRenderingEventArgs>;
    
        /**
         * Triggers event mouse clicking on the maps marker element.
         * @event
         */
        markerClick?: ej.base.EmitType<IMarkerClickEventArgs>;
    
        /**
         * Triggers event mouse moving on the maps marker element.
         * @event
         */
        markerMouseMove?: ej.base.EmitType<IMarkerMoveEventArgs>;
    
        /**
         * Triggers before the data label get rendered.
         * @event
         */
        dataLabelRendering?: ej.base.EmitType<ILabelRenderingEventArgs>;
    
        /**
         * Triggers before the maps bubble rendered.
         * @event
         */
        bubbleRendering?: ej.base.EmitType<IBubbleRenderingEventArgs>;
    
        /**
         * Triggers event mouse clicking on the maps bubble element.
         * @event
         */
        bubbleClick?: ej.base.EmitType<IBubbleClickEventArgs>;
    
        /**
         * Triggers event mouse moving on the maps bubble element.
         * @event
         */
        bubbleMouseMove?: ej.base.EmitType<IBubbleMoveEventArgs>;
    
        /**
         * Triggers after the animation completed.
         * @event
         */
        animationComplete?: ej.base.EmitType<IAnimationCompleteEventArgs>;
    
        /**
         * Triggers before annotation rendering.
         * @event
         */
        annotationRendering?: ej.base.EmitType<IAnnotationRenderingEventArgs>;
    
    }
    /**
     * Maps Component file
     */
    
    /**
     * Represents the Maps control.
     * ```html
     * <div id="maps"/>
     * <script>
     *   var maps = new Maps();
     *   maps.appendTo("#maps");
     * </script>
     * ```
     */
    export class Maps extends ej.base.Component<HTMLElement> implements ej.base.INotifyPropertyChanged {
        /**
         * `bubbleModule` is used to add bubble to the maps.
         */
        bubbleModule: Bubble;
        /**
         * `markerModule` is used to add marker to the maps.
         */
        markerModule: Marker;
        /**
         * `dataLabelModule` is used to add datalabel to the maps.
         */
        dataLabelModule: DataLabel;
        /**
         * `highlightModule` is used to add highlight to the maps.
         */
        highlightModule: Highlight;
        /**
         * `navigationLineModule` is used to add navigationLine to the maps.
         */
        navigationLineModule: NavigationLine;
        /**
         * `legendModule` is used to add legend to the maps.
         */
        legendModule: Legend;
        /**
         * `selectionModule` is used to add selection to the maps.
         */
        selectionModule: Selection;
        /**
         * `mapsTooltipModule` is used to add tooltip to the maps.
         */
        mapsTooltipModule: MapsTooltip;
        /**
         * `zoomModule` is used to add zoom to the maps.
         */
        zoomModule: Zoom;
        /**
         *  annotationModule is used to place the any text or images into the maps.
         */
        annotationsModule: Annotations;
        /**
         * To configure the background of the maps container.
         * @default null
         */
        background: string;
        /**
         * To enable the separator
         * @default false
         */
        useGroupingSeparator: boolean;
        /**
         * To apply internationalization for maps
         * @default null
         */
        format: string;
        /**
         * To configure width of maps.
         * @default null
         */
        width: string;
        /**
         * To configure height of maps.
         * @default null
         */
        height: string;
        /**
         * To configure the title settings of the maps.
         */
        titleSettings: TitleSettingsModel;
        /**
         * To configure the zoom settings of the maps.
         */
        zoomSettings: ZoomSettingsModel;
        /**
         * To configure the legend settings of the maps.
         */
        legendSettings: LegendSettingsModel;
        /**
         * To configure the layers settings of the maps.
         */
        layers: LayerSettingsModel[];
        /**
         *  Options for customizing the annotation of maps.
         */
        annotations: AnnotationModel[];
        /**
         *  Options to customize left, right, top and bottom margins of the maps.
         */
        margin: MarginModel;
        /**
         * Options for customizing the color and width of the maps border.
         */
        border: BorderModel;
        /**
         * Specifies the theme for the maps.
         */
        theme: MapsTheme;
        /**
         * Specifies the ProjectionType for the maps.
         */
        projectionType: ProjectionType;
        /**
         * To configure baseMapIndex of maps. Option to select which layer to be visible.
         * @default 0
         */
        baseLayerIndex: number;
        /**
         * Description for maps.
         * @default null
         */
        description: string;
        /**
         * TabIndex value for the maps.
         * @default 1
         */
        tabIndex: number;
        /**
         * To configure the zoom level of maps.
         * @default { latitude: null, longitude: null}
         */
        centerPosition: {
            latitude: number;
            longitude: number;
        };
        /**
         * To customization Maps area
         */
        mapsArea: MapsAreaSettingsModel;
        /**
         * Triggers before maps rendered.
         * @event
         */
        load: ej.base.EmitType<ILoadEventArgs>;
        /**
         * Triggers after maps rendered.
         * @event
         */
        loaded: ej.base.EmitType<ILoadedEventArgs>;
        /**
         * Triggers on clicking the maps.
         * @event
         */
        click: ej.base.EmitType<IMouseEventArgs>;
        /**
         * Triggers on double clicking the maps.
         * @event
         */
        doubleClick: ej.base.EmitType<IMouseEventArgs>;
        /**
         * Triggers on right clicking the maps.
         * @event
         */
        rightClick: ej.base.EmitType<IMouseEventArgs>;
        /**
         * Triggers on resizing the maps.
         * @event
         */
        resize: ej.base.EmitType<IResizeEventArgs>;
        /**
         * Triggers before the maps tooltip rendered.
         * @event
         */
        tooltipRender: ej.base.EmitType<ITooltipRenderEventArgs>;
        /**
         * Triggers while clicking the shape
         * @event
         */
        shapeSelected: ej.base.EmitType<IShapeSelectedEventArgs>;
        /**
         * Triggers before selection applied
         * @event
         */
        itemSelection: ej.base.EmitType<ISelectionEventArgs>;
        /**
         * Trigger before highlight applied
         * @event
         */
        itemHighlight: ej.base.EmitType<ISelectionEventArgs>;
        /**
         * Triggers before highlight applied for shape
         * @event
         */
        shapeHighlight: ej.base.EmitType<IShapeSelectedEventArgs>;
        /**
         * Triggers before the maps layer rendered.
         * @event
         */
        layerRendering: ej.base.EmitType<ILayerRenderingEventArgs>;
        /**
         * Triggers before the maps shape rendered.
         * @event
         */
        shapeRendering: ej.base.EmitType<IShapeRenderingEventArgs>;
        /**
         * Triggers before the maps marker rendered.
         * @event
         */
        markerRendering: ej.base.EmitType<IMarkerRenderingEventArgs>;
        /**
         * Triggers event mouse clicking on the maps marker element.
         * @event
         */
        markerClick: ej.base.EmitType<IMarkerClickEventArgs>;
        /**
         * Triggers event mouse moving on the maps marker element.
         * @event
         */
        markerMouseMove: ej.base.EmitType<IMarkerMoveEventArgs>;
        /**
         * Triggers before the data label get rendered.
         * @event
         */
        dataLabelRendering: ej.base.EmitType<ILabelRenderingEventArgs>;
        /**
         * Triggers before the maps bubble rendered.
         * @event
         */
        bubbleRendering: ej.base.EmitType<IBubbleRenderingEventArgs>;
        /**
         * Triggers event mouse clicking on the maps bubble element.
         * @event
         */
        bubbleClick: ej.base.EmitType<IBubbleClickEventArgs>;
        /**
         * Triggers event mouse moving on the maps bubble element.
         * @event
         */
        bubbleMouseMove: ej.base.EmitType<IBubbleMoveEventArgs>;
        /**
         * Triggers after the animation completed.
         * @event
         */
        animationComplete: ej.base.EmitType<IAnimationCompleteEventArgs>;
        /**
         * Triggers before annotation rendering.
         * @event
         */
        annotationRendering: ej.base.EmitType<IAnnotationRenderingEventArgs>;
        /**
         * Format method
         * @private
         */
        formatFunction: Function;
        /**
         * svg renderer object.
         * @private
         */
        renderer: ej.base.SvgRenderer;
        /**
         * maps svg element's object
         * @private
         */
        svgObject: Element;
        /**
         * Maps available height, width
         * @private
         */
        availableSize: Size;
        /**
         * localization object
         * @private
         */
        localeObject: ej.base.L10n;
        /**
         * It contains default values of localization values
         */
        private defaultLocalConstants;
        /**
         * Internal use of internationalization instance.
         * @private
         */
        intl: ej.base.Internationalization;
        /**
         * Check layer whether is normal or tile
         * @private
         */
        isTileMap: boolean;
        /**
         * Resize the map
         */
        private resizeTo;
        /**
         * @private
         * Stores the map area rect
         */
        mapAreaRect: Rect;
        /**
         * @private
         * Stores layers collection for rendering
         */
        layersCollection: LayerSettings[];
        /**
         * @private
         * Calculate the axes bounds for map.
         * @hidden
         */
        mapLayerPanel: LayerPanel;
        /**
         * @private
         * Render the data label.
         * @hidden
         */
        dataLabel: DataLabel;
        /** @private */
        isTouch: boolean;
        /** @private */
        baseSize: Size;
        /** @private */
        scale: number;
        /** @private */
        baseScale: number;
        /** @private */
        baseMapBounds: GeoLocation;
        /** @private */
        baseMapRectBounds: Object;
        /** @private */
        translatePoint: Point;
        /** @private */
        baseTranslatePoint: Point;
        /** @private */
        tileTranslatePoint: Point;
        /** @private */
        baseTileTranslatePoint: Point;
        /** @private */
        isDevice: Boolean;
        /** @private */
        zoomLevel: number;
        /**
         * Constructor for creating the widget
         */
        constructor(options?: MapsModel, element?: string | HTMLElement);
        /**
         * Gets the localized label by locale keyword.
         * @param  {string} key
         * @return {string}
         */
        getLocalizedLabel(key: string): string;
        /**
         * Initializing pre-required values.
         */
        protected preRender(): void;
        private setTextStyle(theme, font);
        /**
         * To change font styles of map based on themes
         */
        private themeEffect();
        /**
         * To change datalabel font
         * @param layers
         * @param style
         */
        private setLabelFont(layers, style);
        /**
         * To Initialize the control rendering.
         */
        protected render(): void;
        /**
         * Render the map area border
         */
        private renderArea();
        /**
         * To add tab index for map element
         */
        private addTabIndex();
        private zoomingChange();
        /**
         * To place map on center position
         */
        private createSecondaryElement();
        private arrangeTemplate();
        private createTile();
        /**
         * To initilize the private varibales of maps.
         */
        private initPrivateVariable();
        private findBaseAndSubLayers();
        /**
         * @private
         * Render the map border
         */
        private renderBorder();
        /**
         * @private
         * Render the title and subtitle
         */
        private renderTitle(title, type, bounds, groupEle);
        /**
         * To create svg element for maps
         */
        private createSVG();
        /**
         * To Remove the SVG
         */
        private removeSvg();
        /**
         * To bind event handlers for maps.
         */
        private wireEVents();
        /**
         * To unbind event handlers from maps.
         */
        private unWireEVents();
        /**
         * To handle the click event for the maps.
         */
        mapsOnClick(e: PointerEvent): void;
        /**
         * To handle the right click event for the maps.
         */
        /**
         *
         */
        mouseEndOnMap(e: PointerEvent): boolean;
        /**
         *
         */
        mouseDownOnMap(e: PointerEvent): void;
        /**
         * To handle the double click event for the maps.
         */
        mapsOnDoubleClick(e: PointerEvent): void;
        /**
         *
         */
        mouseMoveOnMap(e: PointerEvent): void;
        /**
         * To handle the window resize event on maps.
         */
        mapsOnResize(e: Event): boolean;
        zoomByPosition(centerPosition: {
            latitude: number;
            longitude: number;
        }, zoomFactor: number): void;
        /**
         * To add layers to maps
         */
        addLayer(layer: LayerSettingsModel): void;
        /**
         * To remove layers from maps
         */
        removeLayer(index: number): void;
        /**
         * To add marker to layers
         */
        addMarker(layerIndex: number, marker: MarkerSettingsModel): void;
        /**
         * Method to set culture for maps
         */
        private setCulture();
        /**
         * Method to set locale constants
         */
        private setLocaleConstants();
        /**
         * To destroy maps control.
         */
        destroy(): void;
        /**
         * Get component name
         */
        getModuleName(): string;
        /**
         * Get the properties to be maintained in the persisted state.
         * @private
         */
        getPersistData(): string;
        /**
         * Called internally if any of the property value changed.
         * @private
         */
        onPropertyChanged(newProp: MapsModel, oldProp: MapsModel): void;
        /**
         * To provide the array of modules needed for maps rendering
         * @return {ej.base.ModuleDeclaration[]}
         * @private
         */
        requiredModules(): ej.base.ModuleDeclaration[];
        /**
         * To find marker visibility
         */
        private isMarkersVisible();
        /**
         * To find DataLabel visibility
         */
        private isDataLabelVisible();
        /**
         * To find navigation line visibility
         */
        private isNavigationVisible();
        /**
         * To find marker visibility
         */
        private isBubbleVisible();
        /**
         * To find the bubble visibility from layer
         * @private
         */
        getBubbleVisible(layer: LayerSettingsModel): boolean;
        /**
         * To find visibility of layers and markers for required modules load.
         */
        private findVisibleLayers(layers, isLayerVisible?, isBubblevisible?, istooltipVisible?, isSelection?, isHighlight?);
    }
    
    /**
     * Bing map src doc
     */
    export class BingMap {
        /**
         * map instance
         */
        private maps;
        constructor(maps: Maps);
        getBingMap(tile: Tile, key: string, type: BingMapType, language: string): string;
    }
    
    /**
     * Bubble module class
     */
    export class Bubble {
        private maps;
        bubbleCollection: Object[];
        /**
         * Bubble Id for current layer
         */
        id: string;
        constructor(maps: Maps);
        /**
         * To render bubble
         */
        renderBubble(bubbleSettings: BubbleSettingsModel, shapeData: object, color: string, range: {
            min: number;
            max: number;
        }, bubbleIndex: number, dataIndex: number, layerIndex: number, layer: LayerSettings, group: Element): void;
        private getPoints(shape, points);
        private getRatioOfBubble(min, max, value, minValue, maxValue);
        /**
         * To check and trigger bubble click event
         */
        bubbleClick(e: PointerEvent): void;
        /**
         * To get bubble from target id
         */
        private getbubble(target);
        /**
         * To check and trigger bubble move event
         */
        bubbleMove(e: PointerEvent): void;
        /**
         * Get module name.
         */
        protected getModuleName(): string;
        /**
         * To destroy the bubble.
         * @return {void}
         * @private
         */
        destroy(maps: Maps): void;
    }
    
    /**
     * ColorMapping class
     */
    export class ColorMapping {
        private maps;
        constructor(maps: Maps);
        /**
         * To get color based on shape settings.
         * @private
         */
        getShapeColorMapping(shapeSettings: ShapeSettingsModel, layerData: object, color: string): string;
        /**
         * To color by value and color mapping
         */
        getColorByValue(colorMapping: ColorMappingSettingsModel[], colorValue: number, equalValue: string): string;
    }
    
    /**
     * DataLabel class
     */
    export class DataLabel {
        private maps;
        private dataLabelObject;
        dataLabelCollections: Object[];
        private intersect;
        private value;
        constructor(maps: Maps);
        private getDataLabel(dataSource, labelPath, shapeName, shapeDataPath);
        renderLabel(layer: LayerSettings, layerIndex: number, shape: object, layerData: object[], group: Element, labelTemplateElement: HTMLElement, index: number): void;
        private getPoint(shapes, points);
        /**
         * Get module name.
         */
        protected getModuleName(): string;
        /**
         * To destroy the layers.
         * @return {void}
         * @private
         */
        destroy(maps: Maps): void;
    }
    
    /**
     * To calculate and render the shape layer
     */
    export class LayerPanel {
        private mapObject;
        private currentFactor;
        private groupElements;
        private layerObject;
        private currentLayer;
        private rectBounds;
        private tiles;
        private clipRectElement;
        private layerGroup;
        private tileTranslatePoint;
        private urlTemplate;
        private isMapCoordinates;
        private exactBounds;
        private tileSvgObject;
        constructor(map: Maps);
        measureLayerPanel(): void;
        private bubbleCalculation(bubbleSettings, range);
        calculatePathCollection(layerIndex: number, renderData: Object[]): void;
        /**
         *  render datalabel
         */
        private renderLabel(layer, layerIndex, shape, group, shapeIndex, labelTemplateEle);
        /**
         * To render path for multipolygon
         */
        private generateMultiPolygonPath(currentShapeData);
        /**
         * To render bubble
         */
        private renderBubble(layer, bubbleData, color, range, bubbleIndex, dataIndex, group, layerIndex, bubbleSettings);
        /**
         * To get the shape color from color mapping module
         */
        private getShapeColorMapping(layer, shape, color);
        generatePoints(type: string, coordinates: Object[], data: Object, properties: Object): void;
        calculateFactor(layer: LayerSettings): number;
        translateLayerElements(layerElement: Element, index: number): void;
        calculateRectBounds(layerData: Object[]): void;
        calculatePolygonBox(coordinates: Object[], data: Object, properties: Object): Object;
        calculateRectBox(coordinates: Object[]): void;
        generateTiles(zoomLevel: number, tileTranslatePoint: Point): void;
        arrangeTiles(): void;
        private templateCompiler(tiles);
        private panTileMap(factorX, factorY, centerPosition);
    }
    
    /**
     * Legend module class
     */
    export class Legend {
        legendCollection: Object[];
        legendRenderingCollections: Object[];
        private legendHeight;
        private legendWidth;
        private translate;
        private legendBorderRect;
        private maps;
        private totalPages;
        private page;
        private currentPage;
        private interactiveLocation;
        private legendItemRect;
        private heightIncrement;
        private widthIncrement;
        private textMaxWidth;
        private legendGroup;
        private previousId;
        private areaRect;
        constructor(maps: Maps);
        renderLegend(): void;
        calculateLegendBounds(): void;
        /**
         *
         */
        private getLegends(layerIndex, layerData, colorMapping, dataSource, dataPath, colorValuePath, propertyPath);
        private getPageChanged();
        drawLegend(): void;
        private drawLegendItem(page);
        private renderLegendBorder();
        changeNextPage(e: PointerEvent): void;
        private getLegendAlignment(map, width, height, legend);
        private getMarkersLegendCollections(layerIndex, markers);
        private getRangeLegendCollection(layerIndex, layerData, colorMapping, dataSource, dataPath, colorValuePath, propertyPath);
        private getOverallLegendItemsCollection(legendText, legendFill, legendData);
        private getEqualLegendCollection(layerIndex, layerData, colorMapping, dataSource, dataPath, colorValuePath, propertyPath);
        private getDataLegendCollection(layerIndex, layerData, colorMapping, dataSource, dataPath, colorValuePath, propertyPath);
        interactiveHandler(e: PointerEvent): void;
        private renderInteractivePointer(legend, fill, stroke, id, strokeWidth, rect);
        wireEvents(element: Element): void;
        addEventListener(): void;
        removeEventListener(): void;
        private getLegendData(layerIndex, dataIndex, data, dataPath, layerData, shapePropertyPath, value);
        /**
         * Get module name.
         */
        protected getModuleName(): string;
        /**
         * To destroy the legend.
         * @return {void}
         * @private
         */
        destroy(maps: Maps): void;
    }
    
    /**
     * Marker class
     */
    export class Marker {
        private maps;
        private isMarkerExplode;
        private trackElements;
        private markerSVGObject;
        private previousExplodeId;
        constructor(maps: Maps);
        markerRender(layerElement: Element, layerIndex: number, factor: number): void;
        markerExplode(targetId: string, targetElement: Element): void;
        /**
         * @private
         */
        removeMarkerExplode(): void;
        private removeTrackElements();
        drawSymbol(shape: MarkerType, imageUrl: string, location: Point, markerID: string, shapeCustom: Object): Element;
        /**
         * To check and trigger marker click event
         */
        markerClick(e: PointerEvent): void;
        /**
         * To get marker from target id
         */
        private getMarker(target);
        /**
         * To check and trigger marker move event
         */
        markerMove(e: PointerEvent): void;
        /**
         * Get module name.
         */
        protected getModuleName(): string;
        /**
         * To destroy the layers.
         * @return {void}
         * @private
         */
        destroy(maps: Maps): void;
    }
    
    /**
     * navigation-selected-line
     */
    export class NavigationLine {
        private maps;
        constructor(maps: Maps);
        renderNavigation(layer: LayerSettings, factor: number, layerIndex: number): Element;
        private convertRadius(point1, point2);
        /**
         * Get module name.
         */
        protected getModuleName(): string;
        /**
         * To destroy the layers.
         * @return {void}
         * @private
         */
        destroy(maps: Maps): void;
    }
    
    /**
     * Interface for a class Annotation
     */
    export interface AnnotationModel {
    
        /**
         * Specifies the id of html element.
         */
        content?: string;
    
        /**
         * Specifies the position of x.
         */
        x?: string;
    
        /**
         * Specifies the position of y.
         */
        y?: string;
    
        /**
         * Specifies the vertical alignment of annotation.
         */
        verticalAlignment?: AnnotationAlignment;
    
        /**
         * Specifies the horizontal alignment of annotation.
         */
        horizontalAlignment?: AnnotationAlignment;
    
        /**
         * Specifies the zIndex of the annotation.
         * @default '-1'
         */
        zIndex?: string;
    
    }
    
    /**
     * Interface for a class Arrow
     */
    export interface ArrowModel {
    
        /**
         * arrowPosition
         */
        position?: string;
    
        /**
         * show
         */
        showArrow?: boolean;
    
        /**
         * size
         */
        size?: number;
    
        /**
         * color
         */
        color?: string;
    
    }
    
    /**
     * Interface for a class Font
     */
    export interface FontModel {
    
        /**
         * Font size for the text.
         */
        size?: string;
    
        /**
         * Color for the text.
         */
        color?: string;
    
        /**
         * FontFamily for the text.
         */
        fontFamily?: string;
    
        /**
         * FontWeight for the text.
         */
        fontWeight?: string;
    
        /**
         * FontStyle for the text.
         */
        fontStyle?: string;
    
        /**
         * Opacity for the text.
         */
        opacity?: number;
    
    }
    
    /**
     * Interface for a class Border
     */
    export interface BorderModel {
    
        /**
         * The color of the border that accepts value in hex and rgba as a valid CSS color string.
         */
        color?: string;
    
        /**
         * The width of the border in pixels.
         */
        width?: number;
    
    }
    
    /**
     * Interface for a class TooltipSettings
     */
    export interface TooltipSettingsModel {
    
        /**
         * Toggle the tooltip visibility.
         * @default false
         */
        visible?: boolean;
    
        /**
         * To customize the tooltip template.
         * @default ''
         */
        template?: string;
    
        /**
         * To customize the fill color of the tooltip.
         * @default '#363F4C'
         */
        fill?: string;
    
        /**
         * Options for customizing the color and width of the tooltip.
         */
        border?: BorderModel;
    
        /**
         * Options for customizing text styles of the tooltip.
         */
        textStyle?: FontModel;
    
        /**
         * To customize the format of the tooltip.
         * @default null
         */
        format?: string;
    
        /**
         * To customize the value of the tooltip.
         * @default null
         */
        valuePath?: string;
    
    }
    
    /**
     * Interface for a class Margin
     */
    export interface MarginModel {
    
        /**
         * Left margin in pixels.
         * @default 10
         */
        left?: number;
    
        /**
         * Right margin in pixels.
         * @default 10
         */
        right?: number;
    
        /**
         * Top margin in pixels.
         * @default 10
         */
        top?: number;
    
        /**
         * Bottom margin in pixels.
         * @default 10
         */
        bottom?: number;
    
    }
    
    /**
     * Interface for a class ColorMappingSettings
     */
    export interface ColorMappingSettingsModel {
    
        /**
         * To configure from
         * @default null
         */
        from?: number;
    
        /**
         * To configure to
         * @default null
         */
        to?: number;
    
        /**
         * To configure value
         * @default null
         */
        value?: string;
    
        /**
         * To configure color
         * @default null
         */
        color?: string;
    
        /**
         * To configure labels
         * @default null
         */
        label?: string;
    
    }
    
    /**
     * Interface for a class SelectionSettings
     */
    export interface SelectionSettingsModel {
    
        /**
         * Toggle the selection settings.
         * @default false
         */
        enable?: boolean;
    
        /**
         * To customize the fill color of the Selection.
         * @default '#D2691E'
         */
        fill?: string;
    
        /**
         * To customize the opacity of the Selection.
         * @default 1
         */
        opacity?: number;
    
        /**
         * Toggle the multi selection.
         * @default false
         */
        enableMultiSelect?: boolean;
    
        /**
         * Options for customizing the color and width of the selection.
         */
        border?: BorderModel;
    
    }
    
    /**
     * Interface for a class HighlightSettings
     */
    export interface HighlightSettingsModel {
    
        /**
         * To customize the fill color of the highlight.
         * @default '#6B8E23'
         */
        fill?: string;
    
        /**
         * Toggle the highlight settings.
         * @default false
         */
        enable?: boolean;
    
        /**
         * To customize the opacity of the highlight.
         * @default 1
         */
        opacity?: number;
    
        /**
         * Options for customizing the color and width of the highlight.
         */
        border?: BorderModel;
    
    }
    
    /**
     * Interface for a class NavigationLineSettings
     */
    export interface NavigationLineSettingsModel {
    
        /**
         * NavigationSelectedLine visible
         *  @default false
         */
        visible?: boolean;
    
        /**
         * Configures the label border
         * @default 1
         */
        width?: number;
    
        /**
         * NavigationSelectedLine longitude
         *  @default 0
         */
        longitude?: number[];
    
        /**
         * NavigationSelectedLine latitude
         */
        latitude?: number[];
    
        /**
         * dashArray
         */
        dashArray?: string;
    
        /**
         * NavigationSelectedLine color
         */
        color?: string;
    
        /**
         * angle
         */
        angle?: number;
    
        /**
         * arrow
         */
        arrowSettings?: ArrowModel;
    
        /**
         * To configure the selection settings of the maps.
         */
        selectionSettings?: SelectionSettingsModel;
    
        /**
         * To configure the highlight settings of the maps.
         */
        highlightSettings?: HighlightSettingsModel;
    
    }
    
    /**
     * Interface for a class BubbleSettings
     */
    export interface BubbleSettingsModel {
    
        /**
         * Configures the bubble border
         */
        border?: BorderModel;
    
        /**
         * Toggle the visibility of bubble
         * @default false
         */
        visible?: boolean;
    
        /**
         * Specifies the data source for bubble.
         * @default []
         */
        dataSource?: object[];
    
        /**
         * To configure bubble animation duration
         * @default 1000
         */
        animationDuration?: number;
    
        /**
         * Animation duration
         * @default 0
         */
        animationDelay?: number;
    
        /**
         * To configure bubble fill color
         * @default ''
         */
        fill?: string;
    
        /**
         * To configure bubble minRadius
         * @default 10
         */
        minRadius?: number;
    
        /**
         * To configure bubble maxRadius
         * @default 20
         */
        maxRadius?: number;
    
        /**
         * To configure bubble opacity
         * @default 1
         */
        opacity?: number;
    
        /**
         * To configure bubble valuePath
         * @default null
         */
        valuePath?: string;
    
        /**
         * To configure bubble shape type
         * @default Circle
         */
        bubbleType?: BubbleType;
    
        /**
         * To configure bubble colorValuePath
         * @default null
         */
        colorValuePath?: string;
    
        /**
         * To configure bubble colorMapping
         * @default []
         */
        colorMapping?: ColorMappingSettingsModel[];
    
        /**
         * To configure the tooltip settings of the bubble .
         */
        tooltipSettings?: TooltipSettingsModel;
    
        /**
         * To configure the selection settings of the maps.
         */
        selectionSettings?: SelectionSettingsModel;
    
        /**
         * To configure the highlight settings of the maps.
         */
        highlightSettings?: HighlightSettingsModel;
    
    }
    
    /**
     * Interface for a class CommonTitleSettings
     */
    export interface CommonTitleSettingsModel {
    
        /**
         * To customize the text of the title.
         * @default ''
         */
        text?: string;
    
        /**
         * To customize title description for the accessibility.
         * @default ''
         */
        description?: string;
    
    }
    
    /**
     * Interface for a class SubTitleSettings
     */
    export interface SubTitleSettingsModel extends CommonTitleSettingsModel{
    
        /**
         * Options for customizing title styles of the Maps.
         */
        textStyle?: FontModel;
    
        /**
         * text alignment
         */
        alignment?: Alignment;
    
    }
    
    /**
     * Interface for a class TitleSettings
     */
    export interface TitleSettingsModel extends CommonTitleSettingsModel{
    
        /**
         * Options for customizing title styles of the Maps.
         */
        textStyle?: FontModel;
    
        /**
         * text alignment
         */
        alignment?: Alignment;
    
        /**
         * To configure sub title of maps.
         */
        subtitleSettings?: SubTitleSettingsModel;
    
    }
    
    /**
     * Interface for a class ZoomSettings
     */
    export interface ZoomSettingsModel {
    
        /**
         * Toggle the visibility of zooming.
         * @default false
         */
        enable?: boolean;
    
        /**
         * Configures tool bar orientation
         */
        toolBarOrientation?: Orientation;
    
        /**
         * Configures vertical placement of tool bar 
         */
        horizontalAlignment?: Alignment;
    
        /**
         * Configures vertical placement of tool bar 
         */
        verticalAlignment?: Alignment;
    
        /**
         * To configure zooming items.
         */
        toolbars?: string[];
    
        /**
         * Toggle the mouse wheel zooming.
         * @default true
         */
        mouseWheelZoom?: boolean;
    
        /**
         * Double tab zooming
         * @default false
         */
        doubleClickZoom?: boolean;
    
        /**
         * Toggle the pinch zooming.
         * @default true
         */
        pinchZooming?: boolean;
    
        /**
         * Toggle the selection on zooming.
         * @default false
         */
        zoomOnClick?: boolean;
    
        /**
         * Configures zoom factor.
         * @default 1
         */
        zoomFactor?: number;
    
        /**
         * Configures max zooming.
         * @default 10
         */
        maxZoom?: number;
    
        /**
         * Configures minimum zooming.
         * @default 1
         */
        minZoom?: number;
    
    }
    
    /**
     * Interface for a class LegendSettings
     */
    export interface LegendSettingsModel {
    
        /**
         * Toggle the legend selection
         * @default false
         */
        toggleVisibility?: boolean;
    
        /**
         * Toggle the legend visibility.
         * @default false
         */
        visible?: boolean;
    
        /**
         * Customize the legend background
         * @default transparent
         */
        background?: string;
    
        /**
         * Type of the legend rendering
         */
        type?: LegendType;
    
        /**
         * Inverted pointer for interactive legend
         */
        invertedPointer?: boolean;
    
        /**
         * To place the label position for interactive legend.
         */
        labelPosition?: LabelPosition;
    
        /**
         * Specifies the label intersect action.
         */
        labelDisplayMode?: LabelIntersectAction;
    
        /**
         * Customize the legend shape of the maps.
         * @default Circle
         */
        shape?: LegendShape;
    
        /**
         * Customize the legend width of the maps.
         * @default ''
         */
        width?: string;
    
        /**
         * Customize the legend height of the maps.
         * @default ''
         */
        height?: string;
    
        /**
         * Options for customizing text styles of the legend.
         */
        textStyle?: FontModel;
    
        /**
         * Customize the legend width of the maps.
         * @default 15
         */
        shapeWidth?: number;
    
        /**
         * Customize the legend height of the maps.
         * @default 15
         */
        shapeHeight?: number;
    
        /**
         * Customize the shape padding
         * @default 10
         */
        shapePadding?: number;
    
        /**
         * Options for customizing the color and width of the legend border.
         */
        border?: BorderModel;
    
        /**
         * Options for customizing the color and width of the shape border.
         */
        shapeBorder?: BorderModel;
    
        /**
         * To configure the title of the legend.
         */
        title?: CommonTitleSettingsModel;
    
        /**
         * Options for customizing text styles of the legend.
         */
        titleStyle?: FontModel;
    
        /**
         * Customize the legend position of the maps.
         * @default Bottom
         */
        position?: LegendPosition;
    
        /**
         * Customize the legend alignment of the maps.
         * @default Center
         */
        alignment?: Alignment;
    
        /**
         * Customize the legend items placed
         */
        orientation?: LegendArrangement;
    
        /**
         * Customize the legend placed by given x and y values. 
         */
        location?: Point;
    
        /**
         * Specifies the legend shape color
         */
        fill?: string;
    
        /**
         * Customize the legend mode.
         * @default Default
         */
        mode?: LegendMode;
    
    }
    
    /**
     * Interface for a class DataLabelSettings
     */
    export interface DataLabelSettingsModel {
    
        /**
         * Toggle the data label visibility.
         * @default false
         */
        visible?: boolean;
    
        /**
         * Configures the label border
         */
        border?: BorderModel;
    
        /**
         * configure the fill
         */
        fill?: string;
    
        /**
         * configure the label opacity
         */
        opacity?: number;
    
        /**
         * rectangle rx 
         * @default 10
         */
        rx?: number;
    
        /**
         * ry value
         * @default 10
         */
        ry?: number;
    
        /**
         * Options for customizing text styles of the data label.
         */
        textStyle?: FontModel;
    
        /**
         * To customize the label path values.
         * @default ''
         */
        labelPath?: string;
    
        /**
         * To customize the smartLabels.
         * @default none
         */
        smartLabelMode?: SmartLabelMode;
    
        /**
         * intersection action
         */
        intersectionAction?: IntersectAction;
    
        /**
         * To customize the data label template.
         * @default ''
         */
        template?: string;
    
    }
    
    /**
     * Interface for a class ShapeSettings
     */
    export interface ShapeSettingsModel {
    
        /**
         * To customize the fill color of the shape.
         * @default '#A6A6A6'
         */
        fill?: string;
    
        /**
         * To customize the palette of the shape.
         * @default []
         */
        palette?: string[];
    
        /**
         * Customize the radius for points
         */
        circleRadius?: number;
    
        /**
         * Options for customizing the color and width of the shape.
         */
        border?: BorderModel;
    
        /**
         * Dash array of line
         */
        dashArray?: string;
    
        /**
         * To customize the opacity of the shape.
         * @default 1
         */
        opacity?: number;
    
        /**
         * To customize the colorValuePath of the shape.
         * @default null
         */
        colorValuePath?: string;
    
        /**
         * To customize the valuePath of the shape.
         * @default null
         */
        valuePath?: string;
    
        /**
         * To configure shape colorMapping
         * @default []
         */
        colorMapping?: ColorMappingSettingsModel[];
    
        /**
         * Toggle the auto fill.
         * @default false
         */
        autofill?: boolean;
    
    }
    
    /**
     * Interface for a class MarkerSettings
     */
    export interface MarkerSettingsModel {
    
        /**
         * Options for customizing the color and width of the marker.
         */
        border?: BorderModel;
    
        /**
         * Options for customizing the dash array options
         */
        dashArray?: string;
    
        /**
         * Toggle the visibility of the marker.
         * @default false
         */
        visible?: boolean;
    
        /**
         * To customize the fill color of the marker.
         * @default '#FF471A'
         */
        fill?: string;
    
        /**
         * To customize the height of the marker.
         * @default 1
         */
        height?: number;
    
        /**
         * To customize the width of the marker.
         * @default 1
         */
        width?: number;
    
        /**
         * To customize the opacity of the marker.
         * @default 1
         */
        opacity?: number;
    
        /**
         * To customize the shape of the marker.
         * @default Balloon
         */
        shape?: MarkerType;
    
        /**
         * To provide the dataSource field to display legend text
         * @default ''
         */
        legendText?: string;
    
        /**
         * To move the marker by setting offset values
         */
        offset?: Point;
    
        /**
         * To provide the image url for rendering marker image
         */
        imageUrl?: string;
    
        /**
         * To customize the template of the marker.
         * @default null
         */
        template?: string;
    
        /**
         * To configure the dataSource of the marker.
         * @default []
         */
        dataSource?: Object[];
    
        /**
         * To configure the tooltip settings of the maps marker.
         */
        tooltipSettings?: TooltipSettingsModel;
    
        /**
         * Animation duration time
         * @default 1000
         */
        animationDuration?: number;
    
        /**
         * Animation delay time
         * @default 0
         */
        animationDelay?: number;
    
        /**
         * To configure the selection settings of the maps.
         */
        selectionSettings?: SelectionSettingsModel;
    
        /**
         * To configure the highlight settings of the maps.
         */
        highlightSettings?: HighlightSettingsModel;
    
    }
    
    /**
     * Interface for a class LayerSettings
     */
    export interface LayerSettingsModel {
    
        /**
         * Specifies the shape data for the layer.
         * @default null
         */
        shapeData?: Object | ej.data.DataManager;
    
        /**
         * Specifies the shape properties 
         */
        shapeSettings?: ShapeSettingsModel;
    
        /**
         * Specifies the data source for the layer.
         * @default []
         */
        dataSource?: object[];
    
        /**
         * Specifies the type for the layer.
         * @default Layer
         */
        type?: Type;
    
        /**
         * Specifies the geometry type
         */
        geometryType?: GeometryType;
    
        /**
         * Specifies the type for the bing map.
         * @default Aerial
         */
        bingMapType?: BingMapType;
    
        /**
         * Specifies the key for the layer.
         * @default ''
         */
        key?: string;
    
        /**
         * Specifies the layerType for the layer.
         * @default Geometry
         */
        layerType?: ShapeLayerType;
    
        /**
         * Specifies the urlTemplate for the layer.
         * @default 'http://a.tile.openstreetmap.org/level/tileX/tileY.png'
         */
        urlTemplate?: string;
    
        /**
         * Toggle the visibility of the layers.
         * @default false
         */
        visible?: boolean;
    
        /**
         * Specifies the shapeDataPath for the layer.
         * @default 'name'
         */
        shapeDataPath?: string;
    
        /**
         * Specifies the shapePropertyPath for the layer.
         * @default 'name'
         */
        shapePropertyPath?: string;
    
        /**
         * To configure the marker settings.
         */
        markerSettings?: MarkerSettingsModel[];
    
        /**
         * To configure the datalabel settings of the maps.
         */
        dataLabelSettings?: DataLabelSettingsModel;
    
        /**
         * To configure the bubble settings of the maps.
         */
        bubbleSettings?: BubbleSettingsModel[];
    
        /**
         * navigationLineSetting
         */
        navigationLineSettings?: NavigationLineSettingsModel[];
    
        /**
         * To configure the tooltip settings of the maps layer.
         */
        tooltipSettings?: TooltipSettingsModel;
    
        /**
         * To configure the selection settings of the maps.
         */
        selectionSettings?: SelectionSettingsModel;
    
        /**
         * To configure the highlight settings of the maps.
         */
        highlightSettings?: HighlightSettingsModel;
    
    }
    
    /**
     * Interface for a class Tile
     */
    export interface TileModel {
    
    }
    
    /**
     * Interface for a class MapsAreaSettings
     */
    export interface MapsAreaSettingsModel {
    
        /**
         * To configure maps area background color
         */
        background?: string;
    
        /**
         * Options for customizing the color and width of maps area.
         */
        border?: BorderModel;
    
    }
    /**
     * Maps base doc
     */
    
    /**
     * Options for customizing the annotation.
     */
    export class Annotation extends ej.base.ChildProperty<Annotation> {
        /**
         * Specifies the id of html element.
         */
        content: string;
        /**
         * Specifies the position of x.
         */
        x: string;
        /**
         * Specifies the position of y.
         */
        y: string;
        /**
         * Specifies the vertical alignment of annotation.
         */
        verticalAlignment: AnnotationAlignment;
        /**
         * Specifies the horizontal alignment of annotation.
         */
        horizontalAlignment: AnnotationAlignment;
        /**
         * Specifies the zIndex of the annotation.
         * @default '-1'
         */
        zIndex: string;
    }
    export class Arrow extends ej.base.ChildProperty<Arrow> {
        /**
         * arrowPosition
         */
        position: string;
        /**
         * show
         */
        showArrow: boolean;
        /**
         * size
         */
        size: number;
        /**
         * color
         */
        color: string;
    }
    /**
     * Configures the fonts in maps.
     */
    export class Font extends ej.base.ChildProperty<Font> {
        /**
         * Font size for the text.
         */
        size: string;
        /**
         * Color for the text.
         */
        color: string;
        /**
         * FontFamily for the text.
         */
        fontFamily: string;
        /**
         * FontWeight for the text.
         */
        fontWeight: string;
        /**
         * FontStyle for the text.
         */
        fontStyle: string;
        /**
         * Opacity for the text.
         */
        opacity: number;
    }
    /**
     * Configures the borders in the maps.
     */
    export class Border extends ej.base.ChildProperty<Border> {
        /**
         * The color of the border that accepts value in hex and rgba as a valid CSS color string.
         */
        color: string;
        /**
         * The width of the border in pixels.
         */
        width: number;
    }
    /**
     * To configure the tooltip settings of the maps.
     */
    export class TooltipSettings extends ej.base.ChildProperty<TooltipSettings> {
        /**
         * Toggle the tooltip visibility.
         * @default false
         */
        visible: boolean;
        /**
         * To customize the tooltip template.
         * @default ''
         */
        template: string;
        /**
         * To customize the fill color of the tooltip.
         * @default '#363F4C'
         */
        fill: string;
        /**
         * Options for customizing the color and width of the tooltip.
         */
        border: BorderModel;
        /**
         * Options for customizing text styles of the tooltip.
         */
        textStyle: FontModel;
        /**
         * To customize the format of the tooltip.
         * @default null
         */
        format: string;
        /**
         * To customize the value of the tooltip.
         * @default null
         */
        valuePath: string;
    }
    /**
     * Configures the maps margins.
     */
    export class Margin extends ej.base.ChildProperty<Margin> {
        /**
         * Left margin in pixels.
         * @default 10
         */
        left: number;
        /**
         * Right margin in pixels.
         * @default 10
         */
        right: number;
        /**
         * Top margin in pixels.
         * @default 10
         */
        top: number;
        /**
         * Bottom margin in pixels.
         * @default 10
         */
        bottom: number;
    }
    /**
     * To configure ColorMapping in Maps
     */
    export class ColorMappingSettings extends ej.base.ChildProperty<ColorMappingSettings> {
        /**
         * To configure from
         * @default null
         */
        from: number;
        /**
         * To configure to
         * @default null
         */
        to: number;
        /**
         * To configure value
         * @default null
         */
        value: string;
        /**
         * To configure color
         * @default null
         */
        color: string;
        /**
         * To configure labels
         * @default null
         */
        label: string;
    }
    /**
     * To configure the selection settings
     */
    export class SelectionSettings extends ej.base.ChildProperty<SelectionSettings> {
        /**
         * Toggle the selection settings.
         * @default false
         */
        enable: boolean;
        /**
         * To customize the fill color of the Selection.
         * @default '#D2691E'
         */
        fill: string;
        /**
         * To customize the opacity of the Selection.
         * @default 1
         */
        opacity: number;
        /**
         * Toggle the multi selection.
         * @default false
         */
        enableMultiSelect: boolean;
        /**
         * Options for customizing the color and width of the selection.
         */
        border: BorderModel;
    }
    /**
     * To configure the highlight settings
     */
    export class HighlightSettings extends ej.base.ChildProperty<HighlightSettings> {
        /**
         * To customize the fill color of the highlight.
         * @default '#6B8E23'
         */
        fill: string;
        /**
         * Toggle the highlight settings.
         * @default false
         */
        enable: boolean;
        /**
         * To customize the opacity of the highlight.
         * @default 1
         */
        opacity: number;
        /**
         * Options for customizing the color and width of the highlight.
         */
        border: BorderModel;
    }
    /**
     * NavigationSelectedLine
     */
    export class NavigationLineSettings extends ej.base.ChildProperty<NavigationLineSettings> {
        /**
         * NavigationSelectedLine visible
         *  @default false
         */
        visible: boolean;
        /**
         * Configures the label border
         * @default 1
         */
        width: number;
        /**
         * NavigationSelectedLine longitude
         *  @default 0
         */
        longitude: number[];
        /**
         * NavigationSelectedLine latitude
         */
        latitude: number[];
        /**
         * dashArray
         */
        dashArray: string;
        /**
         * NavigationSelectedLine color
         */
        color: string;
        /**
         * angle
         */
        angle: number;
        /**
         * arrow
         */
        arrowSettings: ArrowModel;
        /**
         * To configure the selection settings of the maps.
         */
        selectionSettings: SelectionSettingsModel;
        /**
         * To configure the highlight settings of the maps.
         */
        highlightSettings: HighlightSettingsModel;
    }
    /**
     * Bubble settings model class
     */
    export class BubbleSettings extends ej.base.ChildProperty<BubbleSettings> {
        /**
         * Configures the bubble border
         */
        border: BorderModel;
        /**
         * Toggle the visibility of bubble
         * @default false
         */
        visible: boolean;
        /**
         * Specifies the data source for bubble.
         * @default []
         */
        dataSource: object[];
        /**
         * To configure bubble animation duration
         * @default 1000
         */
        animationDuration: number;
        /**
         * Animation duration
         * @default 0
         */
        animationDelay: number;
        /**
         * To configure bubble fill color
         * @default ''
         */
        fill: string;
        /**
         * To configure bubble minRadius
         * @default 10
         */
        minRadius: number;
        /**
         * To configure bubble maxRadius
         * @default 20
         */
        maxRadius: number;
        /**
         * To configure bubble opacity
         * @default 1
         */
        opacity: number;
        /**
         * To configure bubble valuePath
         * @default null
         */
        valuePath: string;
        /**
         * To configure bubble shape type
         * @default Circle
         */
        bubbleType: BubbleType;
        /**
         * To configure bubble colorValuePath
         * @default null
         */
        colorValuePath: string;
        /**
         * To configure bubble colorMapping
         * @default []
         */
        colorMapping: ColorMappingSettingsModel[];
        /**
         * To configure the tooltip settings of the bubble .
         */
        tooltipSettings: TooltipSettingsModel;
        /**
         * To configure the selection settings of the maps.
         */
        selectionSettings: SelectionSettingsModel;
        /**
         * To configure the highlight settings of the maps.
         */
        highlightSettings: HighlightSettingsModel;
    }
    /**
     * To configure title of the maps.
     */
    export class CommonTitleSettings extends ej.base.ChildProperty<CommonTitleSettings> {
        /**
         * To customize the text of the title.
         * @default ''
         */
        text: string;
        /**
         * To customize title description for the accessibility.
         * @default ''
         */
        description: string;
    }
    /**
     * To configure subtitle of the maps.
     */
    export class SubTitleSettings extends CommonTitleSettings {
        /**
         * Options for customizing title styles of the Maps.
         */
        textStyle: FontModel;
        /**
         * text alignment
         */
        alignment: Alignment;
    }
    /**
     * To configure title of the maps.
     */
    export class TitleSettings extends CommonTitleSettings {
        /**
         * Options for customizing title styles of the Maps.
         */
        textStyle: FontModel;
        /**
         * text alignment
         */
        alignment: Alignment;
        /**
         * To configure sub title of maps.
         */
        subtitleSettings: SubTitleSettingsModel;
    }
    /**
     * Options to configure maps Zooming Settings.
     */
    export class ZoomSettings extends ej.base.ChildProperty<ZoomSettings> {
        /**
         * Toggle the visibility of zooming.
         * @default false
         */
        enable: boolean;
        /**
         * Configures tool bar orientation
         */
        toolBarOrientation: Orientation;
        /**
         * Configures vertical placement of tool bar
         */
        horizontalAlignment: Alignment;
        /**
         * Configures vertical placement of tool bar
         */
        verticalAlignment: Alignment;
        /**
         * To configure zooming items.
         */
        toolbars: string[];
        /**
         * Toggle the mouse wheel zooming.
         * @default true
         */
        mouseWheelZoom: boolean;
        /**
         * Double tab zooming
         * @default false
         */
        doubleClickZoom: boolean;
        /**
         * Toggle the pinch zooming.
         * @default true
         */
        pinchZooming: boolean;
        /**
         * Toggle the selection on zooming.
         * @default false
         */
        zoomOnClick: boolean;
        /**
         * Configures zoom factor.
         * @default 1
         */
        zoomFactor: number;
        /**
         * Configures max zooming.
         * @default 10
         */
        maxZoom: number;
        /**
         * Configures minimum zooming.
         * @default 1
         */
        minZoom: number;
    }
    /**
     * Configures the legend settings.
     */
    export class LegendSettings extends ej.base.ChildProperty<LegendSettings> {
        /**
         * Toggle the legend selection
         * @default false
         */
        toggleVisibility: boolean;
        /**
         * Toggle the legend visibility.
         * @default false
         */
        visible: boolean;
        /**
         * Customize the legend background
         * @default transparent
         */
        background: string;
        /**
         * Type of the legend rendering
         */
        type: LegendType;
        /**
         * Inverted pointer for interactive legend
         */
        invertedPointer: boolean;
        /**
         * To place the label position for interactive legend.
         */
        labelPosition: LabelPosition;
        /**
         * Specifies the label intersect action.
         */
        labelDisplayMode: LabelIntersectAction;
        /**
         * Customize the legend shape of the maps.
         * @default Circle
         */
        shape: LegendShape;
        /**
         * Customize the legend width of the maps.
         * @default ''
         */
        width: string;
        /**
         * Customize the legend height of the maps.
         * @default ''
         */
        height: string;
        /**
         * Options for customizing text styles of the legend.
         */
        textStyle: FontModel;
        /**
         * Customize the legend width of the maps.
         * @default 15
         */
        shapeWidth: number;
        /**
         * Customize the legend height of the maps.
         * @default 15
         */
        shapeHeight: number;
        /**
         * Customize the shape padding
         * @default 10
         */
        shapePadding: number;
        /**
         * Options for customizing the color and width of the legend border.
         */
        border: BorderModel;
        /**
         * Options for customizing the color and width of the shape border.
         */
        shapeBorder: BorderModel;
        /**
         * To configure the title of the legend.
         */
        title: CommonTitleSettingsModel;
        /**
         * Options for customizing text styles of the legend.
         */
        titleStyle: FontModel;
        /**
         * Customize the legend position of the maps.
         * @default Bottom
         */
        position: LegendPosition;
        /**
         * Customize the legend alignment of the maps.
         * @default Center
         */
        alignment: Alignment;
        /**
         * Customize the legend items placed
         */
        orientation: LegendArrangement;
        /**
         * Customize the legend placed by given x and y values.
         */
        location: Point;
        /**
         * Specifies the legend shape color
         */
        fill: string;
        /**
         * Customize the legend mode.
         * @default Default
         */
        mode: LegendMode;
    }
    /**
     * Customization for Data label settings.
     */
    export class DataLabelSettings extends ej.base.ChildProperty<DataLabelSettings> {
        /**
         * Toggle the data label visibility.
         * @default false
         */
        visible: boolean;
        /**
         * Configures the label border
         */
        border: BorderModel;
        /**
         * configure the fill
         */
        fill: string;
        /**
         * configure the label opacity
         */
        opacity: number;
        /**
         * rectangle rx
         * @default 10
         */
        rx: number;
        /**
         * ry value
         * @default 10
         */
        ry: number;
        /**
         * Options for customizing text styles of the data label.
         */
        textStyle: FontModel;
        /**
         * To customize the label path values.
         * @default ''
         */
        labelPath: string;
        /**
         * To customize the smartLabels.
         * @default none
         */
        smartLabelMode: SmartLabelMode;
        /**
         * intersection action
         */
        intersectionAction: IntersectAction;
        /**
         * To customize the data label template.
         * @default ''
         */
        template: string;
    }
    /**
     * To configure the shapeSettings in the maps.
     */
    export class ShapeSettings extends ej.base.ChildProperty<ShapeSettings> {
        /**
         * To customize the fill color of the shape.
         * @default '#A6A6A6'
         */
        fill: string;
        /**
         * To customize the palette of the shape.
         * @default []
         */
        palette: string[];
        /**
         * Customize the radius for points
         */
        circleRadius: number;
        /**
         * Options for customizing the color and width of the shape.
         */
        border: BorderModel;
        /**
         * Dash array of line
         */
        dashArray: string;
        /**
         * To customize the opacity of the shape.
         * @default 1
         */
        opacity: number;
        /**
         * To customize the colorValuePath of the shape.
         * @default null
         */
        colorValuePath: string;
        /**
         * To customize the valuePath of the shape.
         * @default null
         */
        valuePath: string;
        /**
         * To configure shape colorMapping
         * @default []
         */
        colorMapping: ColorMappingSettingsModel[];
        /**
         * Toggle the auto fill.
         * @default false
         */
        autofill: boolean;
    }
    /**
     * To configure the marker settings for the maps.
     */
    export class MarkerSettings extends ej.base.ChildProperty<MarkerSettings> {
        /**
         * Options for customizing the color and width of the marker.
         */
        border: BorderModel;
        /**
         * Options for customizing the dash array options
         */
        dashArray: string;
        /**
         * Toggle the visibility of the marker.
         * @default false
         */
        visible: boolean;
        /**
         * To customize the fill color of the marker.
         * @default '#FF471A'
         */
        fill: string;
        /**
         * To customize the height of the marker.
         * @default 1
         */
        height: number;
        /**
         * To customize the width of the marker.
         * @default 1
         */
        width: number;
        /**
         * To customize the opacity of the marker.
         * @default 1
         */
        opacity: number;
        /**
         * To customize the shape of the marker.
         * @default Balloon
         */
        shape: MarkerType;
        /**
         * To provide the dataSource field to display legend text
         * @default ''
         */
        legendText: string;
        /**
         * To move the marker by setting offset values
         */
        offset: Point;
        /**
         * To provide the image url for rendering marker image
         */
        imageUrl: string;
        /**
         * To customize the template of the marker.
         * @default null
         */
        template: string;
        /**
         * To configure the dataSource of the marker.
         * @default []
         */
        dataSource: Object[];
        /**
         * To configure the tooltip settings of the maps marker.
         */
        tooltipSettings: TooltipSettingsModel;
        /**
         * Animation duration time
         * @default 1000
         */
        animationDuration: number;
        /**
         * Animation delay time
         * @default 0
         */
        animationDelay: number;
        /**
         * To configure the selection settings of the maps.
         */
        selectionSettings: SelectionSettingsModel;
        /**
         * To configure the highlight settings of the maps.
         */
        highlightSettings: HighlightSettingsModel;
    }
    /**
     * To configure the layers of the maps.
     */
    export class LayerSettings extends ej.base.ChildProperty<LayerSettings> {
        /**
         * Specifies the shape data for the layer.
         * @default null
         */
        shapeData: Object | ej.data.DataManager;
        /**
         * Specifies the shape properties
         */
        shapeSettings: ShapeSettingsModel;
        /**
         * Specifies the data source for the layer.
         * @default []
         */
        dataSource: object[];
        /**
         * Specifies the type for the layer.
         * @default Layer
         */
        type: Type;
        /**
         * Specifies the geometry type
         */
        geometryType: GeometryType;
        /**
         * Specifies the type for the bing map.
         * @default Aerial
         */
        bingMapType: BingMapType;
        /**
         * Specifies the key for the layer.
         * @default ''
         */
        key: string;
        /**
         * Specifies the layerType for the layer.
         * @default Geometry
         */
        layerType: ShapeLayerType;
        /**
         * Specifies the urlTemplate for the layer.
         * @default 'http://a.tile.openstreetmap.org/level/tileX/tileY.png'
         */
        urlTemplate: string;
        /**
         * Toggle the visibility of the layers.
         * @default false
         */
        visible: boolean;
        /**
         * Specifies the shapeDataPath for the layer.
         * @default 'name'
         */
        shapeDataPath: string;
        /**
         * Specifies the shapePropertyPath for the layer.
         * @default 'name'
         */
        shapePropertyPath: string;
        /**
         * To configure the marker settings.
         */
        markerSettings: MarkerSettingsModel[];
        /**
         * To configure the datalabel settings of the maps.
         */
        dataLabelSettings: DataLabelSettingsModel;
        /**
         * To configure the bubble settings of the maps.
         */
        bubbleSettings: BubbleSettingsModel[];
        /**
         * navigationLineSetting
         */
        navigationLineSettings: NavigationLineSettingsModel[];
        /**
         * To configure the tooltip settings of the maps layer.
         */
        tooltipSettings: TooltipSettingsModel;
        /**
         * To configure the selection settings of the maps.
         */
        selectionSettings: SelectionSettingsModel;
        /**
         * To configure the highlight settings of the maps.
         */
        highlightSettings: HighlightSettingsModel;
        /** @private */
        layerData: Object[];
        /**
         * @private
         */
        isBaseLayer: boolean;
        /**
         * @private
         */
        factor: number;
        /**
         * @private
         * Stores the layer bounds
         */
        layerBounds: GeoLocation;
        /**
         * @private
         * Stores the rect bounds
         */
        rectBounds: Object;
        /**
         * @private
         */
        translatePoint: Point;
    }
    /**
     * Internal use for bing type layer rendering
     */
    export class Tile {
        x: number;
        y: number;
        top: number;
        left: number;
        height: number;
        width: number;
        src: string;
        constructor(x: number, y: number, height?: number, width?: number, top?: number, left?: number, src?: string);
    }
    /**
     * Maps area configuration
     */
    export class MapsAreaSettings extends ej.base.ChildProperty<MapsAreaSettings> {
        /**
         * To configure maps area background color
         */
        background: string;
        /**
         * Options for customizing the color and width of maps area.
         */
        border: BorderModel;
    }
    
    /**
     * Maps constants doc
     */
    /**
     * Specifies maps load event name.
     * @private
     */
    export const load: string;
    /**
     * Specifies maps loaded event name.
     * @private
     */
    export const loaded: string;
    /**
     * Specifies maps click event name.
     * @private
     */
    export const click: string;
    /**
     * Specifies maps loaded event name.
     * @private
     */
    export const rightClick: string;
    /**
     * Specifies maps double click event name.
     * @private
     */
    export const doubleClick: string;
    /**
     * Specifies maps resize event name.
     * @private
     */
    export const resize: string;
    /**
     * Specifies the map tooltip render event
     */
    export const tooltipRender: string;
    /**
     * Specifies the map shapeSelected event
     */
    export const shapeSelected: string;
    /**
     * Specifies the map shapeHighlight event
     */
    export const shapeHighlight: string;
    /**
     * Specifies maps mousemove event name.
     * @private
     */
    export const mousemove: string;
    /**
     * Specifies maps mouseup event name.
     * @private
     */
    export const mouseup: string;
    /**
     * Specifies maps mousedown event name.
     * @private
     */
    export const mousedown: string;
    /**
     * Specifies maps layerRendering event name.
     * @private
     */
    export const layerRendering: string;
    /**
     * Specifies maps shapeRendering event name.
     * @private
     */
    export const shapeRendering: string;
    /**
     * Specifies maps markerRendering event name.
     * @private
     */
    export const markerRendering: string;
    /**
     * Specifies maps markerClick event name.
     * @private
     */
    export const markerClick: string;
    /**
     * Specifies maps markerMouseMove event name.
     * @private
     */
    export const markerMouseMove: string;
    /**
     * Specifies maps dataLabelRendering event name.
     * @private
     */
    export const dataLabelRendering: string;
    /**
     * Specifies maps bubbleRendering event name.
     * @private
     */
    export const bubbleRendering: string;
    /**
     * Specifies maps bubbleClick event name.
     * @private
     */
    export const bubbleClick: string;
    /**
     * Specifies maps bubbleMouseMove event name.
     * @private
     */
    export const bubbleMouseMove: string;
    /**
     * Specifies maps animationComplete event name.
     * @private
     */
    export const animationComplete: string;
    /**
     * Specifies maps legendRendering event name.
     * @private
     */
    export const legendRendering: string;
    /**
     * Specifies maps annotationRendering event name.
     * @private
     */
    export const annotationRendering: string;
    /**
     * Specifies maps itemSelection event name
     * @private
     */
    export const itemSelection: string;
    /**
     * Specifies maps itemHighlight event name
     */
    export const itemHighlight: string;
    
    /**
     * Maps interfaces doc
     */
    
    /**
     * Specifies Maps Events
     * @private
     */
    export interface IMapsEventArgs {
        /** Defines the name of the event */
        name: string;
        /** Defines the event cancel status */
        cancel: boolean;
    }
    /**
     * Specifies the Loaded Event arguments.
     */
    export interface ILoadedEventArgs extends IMapsEventArgs {
        /** Defines the current Maps instance */
        maps: Maps;
    }
    /**
     * Specifies the Load Event arguments.
     */
    export interface ILoadEventArgs extends IMapsEventArgs {
        /** Defines the current Maps instance */
        maps: Maps;
    }
    /**
     * Specifies the data label Event arguments.
     */
    export interface IDataLabelArgs extends IMapsEventArgs {
        /** Defines the current Maps instance */
        maps: Maps;
        /**
         * define event
         */
        dataLabel: DataLabelSettingsModel;
    }
    /**
     * Specifies the Chart Mouse Event arguments.
     */
    export interface IMouseEventArgs extends IMapsEventArgs {
        /** Defines current mouse event target id */
        target: string;
        /** Defines current mouse x location */
        x: number;
        /** Defines current mouse y location */
        y: number;
    }
    /**
     * Maps Resize event arguments.
     */
    export interface IResizeEventArgs {
        /** Defines the name of the Event */
        name: string;
        /** Defines the previous size of the maps */
        previousSize: Size;
        /** Defines the current size of the maps */
        currentSize: Size;
        /** Defines the Maps instance */
        maps: Maps;
    }
    /** @private */
    export interface IFontMapping {
        size?: string;
        color?: string;
        fontWeight?: string;
        fontStyle?: string;
        fontFamily?: string;
    }
    /**
     * Specifies TooltipRender event arguments for maps.
     */
    export interface ITooltipRenderEventArgs extends IMapsEventArgs {
        /**
         * content event argument
         */
        content?: string | HTMLElement;
        /**
         * textStyle event argument
         */
        textStyle?: FontModel;
        /**
         * border event argument
         */
        border?: BorderModel;
        /**
         * fill color event argument
         */
        fill?: string;
    }
    /**
     * Specifies itemSelection event arguments for maps.
     */
    export interface ISelectionEventArgs extends IMapsEventArgs {
        /**
         * fill event argument
         */
        fill?: string;
        /**
         * opacity event argument
         */
        opacity?: number;
        /**
         * border event argument
         */
        border?: BorderModel;
        /**
         * Defines current mouse event target id
         */
        target?: string;
        /**
         * shape data event argument
         */
        shapeData?: object;
        /**
         * data from data source
         */
        data?: object;
    }
    /**
     * Specifies shapeSelected event arguments for maps.
     */
    export interface IShapeSelectedEventArgs extends IMapsEventArgs {
        /**
         * fill event argument
         */
        fill?: string;
        /**
         * opacity event argument
         */
        opacity?: number;
        /**
         * border event argument
         */
        border?: BorderModel;
        /**
         * shapeData event argument
         */
        shapeData?: object;
        /**
         * data source event argument
         */
        data?: object;
        /** Defines current mouse event target id */
        target?: string;
    }
    /** @private */
    export interface ITouches {
        pageX?: number;
        pageY?: number;
        pointerId?: number;
    }
    /** @private */
    export interface IShapes {
        renderOption?: Object;
        functionName?: string;
    }
    /**
     * Specifies layerRendering event arguments for maps.
     */
    export interface ILayerRenderingEventArgs extends IMapsEventArgs {
        /**
         * layer index event argument
         */
        index?: number;
        /**
         * maps instance event argument
         */
        maps?: Maps;
        /**
         * layer options event argument
         */
        layer?: LayerSettingsModel;
    }
    /**
     * Specifies shapeRendering event arguments for maps.
     */
    export interface IShapeRenderingEventArgs extends IMapsEventArgs {
        /**
         * shape index event argument
         */
        index?: number;
        /**
         * maps instance event argument
         */
        maps?: Maps;
        /**
         * current shape settings
         */
        shape?: ShapeSettingsModel;
        /**
         * current shape fill
         */
        fill?: string;
        /**
         * current shape border
         */
        border?: BorderModel;
        /**
         * shape data source event argument
         */
        data?: object;
    }
    /**
     * Specifies markerRendering event arguments for maps.
     */
    export interface IMarkerRenderingEventArgs extends IMapsEventArgs {
        /**
         * maps instance event argument
         */
        maps?: Maps;
        /**
         * marker instance. This is Read Only option.
         */
        marker?: MarkerSettingsModel;
        /**
         * Marker fill.
         */
        fill?: string;
        /**
         * To customize the height of the marker.
         */
        height?: number;
        /**
         * To customize the width of the marker.
         */
        width?: number;
        /**
         * To customize the shape of the marker.
         */
        shape?: MarkerType;
        /**
         * To provide the image url for rendering marker image
         */
        imageUrl?: string;
        /**
         * To customize the template of the marker.
         */
        template?: string;
        /**
         * Configures the marker border
         */
        border?: BorderModel;
        /**
         * marker data event argument
         */
        data?: object;
    }
    /**
     * Specifies markerClick event arguments for maps.
     */
    export interface IMarkerClickEventArgs extends IMouseEventArgs {
        /**
         * maps instance event argument
         */
        maps?: Maps;
        /**
         * marker instance event argument
         */
        marker?: MarkerSettingsModel;
        /**
         * marker data event argument
         */
        data?: object;
    }
    /**
     * Specifies markerMove event arguments for maps.
     */
    export interface IMarkerMoveEventArgs extends IMouseEventArgs {
        /**
         * maps instance event argument
         */
        maps?: Maps;
        /**
         * marker data event argument. This is Read Only option.
         */
        data?: object;
    }
    /**
     * Specifies labelRendering event arguments for maps.
     */
    export interface ILabelRenderingEventArgs extends IMapsEventArgs {
        /**
         * maps instance event argument
         */
        maps?: Maps;
        /**
         * data label text event argument
         */
        text?: string;
        /**
         * Configures the label border
         */
        border?: BorderModel;
        /**
         * configure the fill
         */
        fill?: string;
        /**
         * To customize the data label template.
         */
        template?: string;
        /**
         * label instance event argument
         */
        datalabel?: DataLabelSettingsModel;
    }
    /**
     * Specifies bubbleRendering event arguments for maps.
     */
    export interface IBubbleRenderingEventArgs extends IMapsEventArgs {
        /**
         * maps instance event argument
         */
        maps?: Maps;
        /**
         * bubble fill event argument
         */
        fill?: string;
        /**
         * bubble border event argument
         */
        border?: BorderModel;
        /**
         * current bubble center x
         */
        cx?: number;
        /**
         * current bubble center y
         */
        cy?: number;
        /**
         * current bubble radius
         */
        radius?: number;
        /**
         * current bubble data
         */
        data?: object;
    }
    /**
     * Specifies bubbleClick event arguments for maps.
     */
    export interface IBubbleClickEventArgs extends IMouseEventArgs {
        /**
         * maps instance event argument
         */
        maps?: Maps;
        /**
         * bubble current data event argument
         */
        data?: object;
    }
    /**
     * Specifies bubbleMove event arguments for maps.
     */
    export interface IBubbleMoveEventArgs extends IMouseEventArgs {
        /**
         * maps instance event argument
         */
        maps?: Maps;
        /**
         * bubble current data event argument
         */
        data?: object;
    }
    /**
     * Specifies animationComplete event arguments for maps.
     */
    export interface IAnimationCompleteEventArgs extends IMapsEventArgs {
        /**
         * maps instance event argument
         */
        maps?: Maps;
        /**
         * animation element type event argument
         */
        element: string;
    }
    /**
     * Specifies legendRendering event arguments for maps.
     */
    export interface ILegendRenderingEventArgs extends IMapsEventArgs {
        /**
         * maps instance event argument
         */
        maps?: Maps;
        /**
         * Specifies the legend shape color
         */
        fill?: string;
        /**
         * Options for customizing the color and width of the shape border.
         */
        shapeBorder?: BorderModel;
        /**
         * Customize the legend shape of the maps.
         */
        shape?: LegendShape;
    }
    /**
     * Specifies annotationRendering event arguments for maps.
     */
    export interface IAnnotationRenderingEventArgs extends IMapsEventArgs {
        /**
         * maps instance event argument
         */
        maps?: Maps;
        /**
         * Specifies the annotation content
         */
        content?: string;
        /**
         * Specifies the annotation instance
         */
        annotation?: Annotation;
    }
    
    /**
     * Maps Themes doc
     */
    
    /**
     * Specifies Maps Themes
     */
    export namespace Theme {
        /** @private */
        let mapsTitleFont: IFontMapping;
        /** @private */
        let mapsSubTitleFont: IFontMapping;
        /** @private */
        let tooltipLabelFont: IFontMapping;
        /** @private */
        let legendTitleFont: IFontMapping;
        /** @private */
        let legendLabelFont: IFontMapping;
        /** @private */
        let dataLabelFont: IFontMapping;
    }
    export namespace FabricTheme {
        /** @private */
        let mapsTitleFont: IFontMapping;
        /** @private */
        let mapsSubTitleFont: IFontMapping;
        /** @private */
        let tooltipLabelFont: IFontMapping;
        /** @private */
        let legendTitleFont: IFontMapping;
        /** @private */
        let legendLabelFont: IFontMapping;
        /** @private */
        let dataLabelFont: IFontMapping;
    }
    export namespace BootstrapTheme {
        /** @private */
        let mapsTitleFont: IFontMapping;
        /** @private */
        let mapsSubTitleFont: IFontMapping;
        /** @private */
        let tooltipLabelFont: IFontMapping;
        /** @private */
        let legendTitleFont: IFontMapping;
        /** @private */
        let legendLabelFont: IFontMapping;
        /** @private */
        let dataLabelFont: IFontMapping;
    }
    /**
     * Internal use of Method to getting colors based on themes.
     * @private
     * @param theme
     */
    export function getShapeColor(theme: MapsTheme): string[];
    /**
     * HighContrast Theme configuration
     */
    export namespace HighContrastTheme {
        /** @private */
        let mapsTitleFont: IFontMapping;
        /** @private */
        let mapsSubTitleFont: IFontMapping;
        /** @private */
        let tooltipLabelFont: IFontMapping;
        /** @private */
        let legendTitleFont: IFontMapping;
        /** @private */
        let legendLabelFont: IFontMapping;
        /** @private */
        let dataLabelFont: IFontMapping;
    }
    
    /**
     * Represent the annotation rendering for map
     */
    export class Annotations {
        private map;
        constructor(map: Maps);
        renderAnnotationElements(): void;
        /**
         * To create annotation elements
         */
        createAnnotationTemplate(parentElement: HTMLElement, annotation: Annotation, annotationIndex: number): void;
        protected getModuleName(): string;
        /**
         * To destroy the annotation.
         * @return {void}
         * @private
         */
        destroy(map: Maps): void;
    }
    
    /**
     * Highlight module class
     */
    export class Highlight {
        private maps;
        private highlightSettings;
        constructor(maps: Maps);
        /**
         * To bind events for highlight module
         */
        private addEventListener();
        /**
         * To unbind events for highlight module
         */
        private removeEventListener();
        /**
         * Public method for highlight module
         */
        addHighlight(layerIndex: number, name: string, enable: boolean): void;
        private mouseMove(e);
        private mapHighlight(targetEle, shapeData, data);
        private highlightMap(targetEle, eventArgs);
        /**
         * Get module name.
         */
        protected getModuleName(): string;
        /**
         * To destroy the highlight.
         * @return {void}
         * @private
         */
        destroy(maps: Maps): void;
    }
    
    /**
     * Selection module class
     */
    export class Selection {
        private maps;
        private selectionsettings;
        private selectionType;
        constructor(maps: Maps);
        /**
         * For binding events to selection module
         */
        private addEventListener();
        /**
         * For removing events from selection modue
         */
        private removeEventListener();
        private mouseClick(targetEle);
        /**
         * Public method for selection
         */
        addSelection(layerIndex: number, name: string, enable: boolean): void;
        /**
         * Method for selection
         */
        private selectMap(targetEle, shapeData, data);
        /**
         * Remove legend selection
         */
        /**
         * Get module name.
         */
        protected getModuleName(): string;
        /**
         * To destroy the selection.
         * @return {void}
         * @private
         */
        destroy(maps: Maps): void;
    }
    
    /**
     * Tooltip module class
     */
    export class MapsTooltip {
        private maps;
        private tooltipEle;
        private element;
        private ejTooltip;
        private currentValue;
        private currentData;
        private border;
        private shapeColor;
        private textStyle;
        private options;
        private previousId;
        private isTouch;
        private position;
        private mouse;
        private size;
        private customTooltip;
        constructor(maps: Maps);
        /**
         * To bind events for tooltip module
         */
        private addEventListener();
        /**
         * To unbind events for tooltip module
         */
        private removeEventListener();
        private mouseMove(e);
        private setMouseXY(e);
        /**
         * Method to render the tooltip for maps.
         */
        renderTooltip(e: MouseEvent): void;
        private getTargetElement(element);
        private closeTooltip(delay, duration?, effect?);
        private manipulateTarget(currentTarget);
        /**
         * Method to append the target element for tooltip
         */
        private appendTargetElement(location, padding?);
        private formatter(format, data);
        /**
         * Method to perform the tooltip for maps.
         */
        private onBeforeRender(args);
        /**
         * To get content for the current toolitp
         */
        private setTooltipContent(options?);
        private joinElements(elements);
        /**
         * Method to customize the tooltip elements for maps.
         */
        private tooltipCustomization(args, options?);
        /**
         * Get module name.
         */
        protected getModuleName(): string;
        /**
         * To destroy the tooltip.
         * @return {void}
         * @private
         */
        destroy(maps: Maps): void;
    }
    
    /**
     * Zoom module class
     */
    export class Zoom {
        private maps;
        toolBarGroup: Element;
        private groupElements;
        private currentToolbarEle;
        private zoomingRect;
        private selectionColor;
        private fillColor;
        private zoomInElements;
        private zoomOutElements;
        private zoomElements;
        private panElements;
        isPanning: boolean;
        mouseEnter: boolean;
        baseTranslatePoint: Point;
        private wheelEvent;
        private cancelEvent;
        currentScale: number;
        isTouch: boolean;
        rectZoomingStart: boolean;
        touchStartList: ITouches[] | TouchList;
        touchMoveList: ITouches[] | TouchList;
        previousTouchMoveList: ITouches[] | TouchList;
        private pinchRect;
        mouseDownPoints: Point;
        mouseMovePoints: Point;
        pinchFactor: number;
        currentLayer: LayerSettings;
        private panColor;
        private zoomColor;
        browserName: string;
        isPointer: Boolean;
        private handled;
        constructor(maps: Maps);
        performZooming(position: Point, newZoomFactor: number, type: string): void;
        private getTileTranslatePosition(prevLevel, currentLevel, position);
        performRectZooming(): void;
        performPinchZooming(e: TouchEvent): void;
        drawZoomRectangle(): void;
        applyTransform(layerCollection: Element, scale: number, x: number, y: number): void;
        private dataLabelTranslate(element, factor, x, y, scale, type);
        private markerTranslate(element, factor, x, y, scale, type);
        panning(): void;
        toolBarZooming(zoomFactor: number, type: string): void;
        createZoomingToolbars(): void;
        performToolBarAction(e: PointerEvent): void;
        /**
         *
         * @private
         */
        performZoomingByToolBar(type: string): void;
        private panningStyle(toolbar);
        private applySelection(elements, color);
        showTooltip(e: PointerEvent): void;
        removeTooltip(): void;
        alignToolBar(): void;
        /**
         * To bind events.
         * @return {void}
         * @private
         */
        wireEvents(element: Element, process: Function): void;
        mapMouseWheel(e: WheelEvent): void;
        doubleClick(e: PointerEvent): void;
        mouseDownHandler(e: PointerEvent | TouchEvent): void;
        mouseMoveHandler(e: PointerEvent | TouchEvent): void;
        mouseUpHandler(e: PointerEvent): void;
        mouseCancelHandler(e: PointerEvent): void;
        click(e: PointerEvent): void;
        getMousePosition(pageX: number, pageY: number): Point;
        addEventListener(): void;
        removeEventListener(): void;
        /**
         * Get module name.
         */
        protected getModuleName(): string;
        /**
         * To destroy the zoom.
         * @return {void}
         * @private
         */
        destroy(maps: Maps): void;
    }
    
    /**
     * Maps enum doc
     */
    /**
     * Defines the Alignment. They are
     * * near - Align the element to the left.
     * * center - Align the element to the center.
     * * far - Align the element to the right.
     * *
     */
    export type Alignment = 'Near' | 'Center' | 'Far';
    /**
     * Defines Theme of the maps. They are
     * * Material - Render a maps with Material theme.
     * * Fabric - Render a maps with Fabric theme
     * * Bootstrap - Render a maps with Bootstrap theme
     */
    export type MapsTheme = 'Material' | 'Fabric' | 'Highcontrast' | 'Bootstrap';
    /**
     * Defines the position of the legend. They are
     * * top - Displays the legend on the top of maps.
     * * left - Displays the legend on the left of maps.
     * * bottom - Displays the legend on the bottom of maps.
     * * right - Displays the legend on the right of maps.
     * * float - Displays the legend  based on given x and y value.
     */
    export type LegendPosition = 'Top' | 'Left' | 'Bottom' | 'Right' | 'Float';
    /**
     * Defines the Legend types. They are
     * * Layers - Legend applicable to Layers.
     * * Bubbles - Legend applicable to Bubbles.
     * * Markers - Legend applicable to Markers.
     */
    export type LegendType = 'Layers' | 'Bubbles' | 'Markers';
    /**
     * Defines the smart label mode. They are
     * * Trim - Trims the datalabel which exceed the region
     * * None - Smart label mode is not applied
     * * hide - Hide the datalabel which exceeds the region
     */
    export type SmartLabelMode = 'Trim' | 'None' | 'Hide';
    /**
     * Defines the arrow position in navigation line. They are
     * * Start - Arrow is positioned at the starting position of navigation line
     * * End - Arrow is positioned at the ending position of navigation line
     */
    export type ArrowPosition = 'Start' | 'End';
    /**
     * Defines the label intersect action. They are
     * * Trim - Trims the intersected datalabel
     * * None - Intersection action is not applied
     * * Hide - Hides the intersected datalabel
     */
    export type IntersectAction = 'Trim' | 'None' | 'Hide';
    /**
     * Defines the Legend modes. They are
     * * Default - Specifies the Default mode.
     * * interactive - specifies the Interactive mode.
     */
    export type LegendMode = 'Default' | 'Interactive';
    /**
     * Defines the Layer types.
     * * Geometry - Specifies the geometry type.
     * * Bing - Specifies the Bing type.
     */
    export type ShapeLayerType = 'Geometry' | 'OSM' | 'Bing';
    /**
     * Defines the map layer types.
     * * Layer - Specifies the layer type.
     * * SubLayer - Specifies the sublayer type.
     */
    export type Type = 'Layer' | 'SubLayer';
    /**
     * Defines the marker types.
     * * Circle - Specifies the Circle type.
     * * Rectangle - Specifies the Rectangle type.
     * * Cross - Specifies the Cross type.
     * * Diamond - Specifies the Diamond type.
     * * Star - Specifies the Star type.
     * * Balloon - Specifies the Balloon type.
     * * Triangle - Specifies the Triangle type.
     * * HorizontalLine - Specifies the HorizontalLine type.
     * * VerticalLine - Specifies the VerticalLine type.
     */
    export type MarkerType = 'Circle' | 'Rectangle' | 'Cross' | 'Diamond' | 'Star' | 'Balloon' | 'Triangle' | 'HorizontalLine' | 'VerticalLine' | 'Image';
    /**
     * Defines the projection type of the maps.
     * * Mercator -Specifies the Mercator projection type.
     */
    export type ProjectionType = 'Mercator' | 'Winkel3' | 'Miller' | 'Eckert3' | 'Eckert5' | 'Eckert6' | 'AitOff' | 'Equirectangular';
    /**
     * Defines bing map types
     * * Aerial - specifies the Aerial type
     * * AerialWithLabel - specifies the AerialWithLabel type
     * * Road - specifies the Road type
     */
    export type BingMapType = 'Aerial' | 'AerialWithLabel' | 'Road';
    /**
     * Defines the tool bar orientation
     */
    export type Orientation = 'Horizontal' | 'Vertical';
    /**
     * Defines the shape of legend. They are
     * * circle - Renders a circle.
     * * rectangle - Renders a rectangle.
     * * triangle - Renders a triangle.
     * * diamond - Renders a diamond.
     * * cross - Renders a cross.
     * * Star - Renders a star.
     * * horizontalLine - Renders a horizontalLine.
     * * verticalLine - Renders a verticalLine.
     * * pentagon - Renders a pentagon.
     * * invertedTriangle - Renders a invertedTriangle.
     */
    export type LegendShape = 'Circle' | 'Rectangle' | 'Triangle' | 'Diamond' | 'Cross' | 'Star' | 'HorizontalLine' | 'VerticalLine' | 'Pentagon' | 'InvertedTriangle';
    /**
     * Defines the legend arrangement
     */
    export type LegendArrangement = 'None' | 'Horizontal' | 'Vertical';
    /**
     * Defines the Alignment. They are
     * * none - Default alignment as none
     * * near - Align the element to the left.
     * * center - Align the element to the center.
     * * far - Align the element to the right.
     * *
     */
    export type AnnotationAlignment = 'None' | 'Near' | 'Center' | 'Far';
    /**
     * Defines the geometry type. They are
     * * Geographic - Default value of geometry layer.
     * * Normal - Normal rendering of geometry layer.
     * *
     */
    export type GeometryType = 'Geographic' | 'Normal';
    /**
     * Defines the bubble type
     */
    export type BubbleType = 'Circle' | 'Square';
    /**
     * Defines the label placement type
     */
    export type LabelPosition = 'Before' | 'After';
    /**
     * Defines the label intersect action types
     */
    export type LabelIntersectAction = 'None' | 'Trim' | 'Hide';
    
    /**
     * Maps internal use of `Size` type
     * @private
     */
    export class Size {
        height: number;
        width: number;
        constructor(width: number, height: number);
    }
    /**
     * To find number from string
     * @private
     */
    export function stringToNumber(value: string, containerSize: number): number;
    /**
     * Method to calculate the width and height of the maps
     */
    export function calculateSize(maps: Maps): void;
    /**
     * Method to create svg for maps.
     */
    export function createSvg(maps: Maps): void;
    /**
     * Method to convert degrees to radians
     */
    export function degreesToRadians(deg: number): number;
    /**
     * Convert radians to degrees method
     */
    export function radiansToDegrees(radian: number): number;
    /**
     * Method for converting from latitude and longitude values to points
     */
    export function convertGeoToPoint(latitude: number, longitude: number, factor: number, layer: LayerSettings, mapModel: Maps): Point;
    /**
     * Converting tile latitude and longitude to point
     */
    export function convertTileLatLongToPoint(center: MapLocation, zoomLevel: number, tileTranslatePoint: MapLocation, isMapCoordinates: boolean): MapLocation;
    /**
     * Method for calculate x point
     */
    export function xToCoordinate(mapObject: Maps, val: number): number;
    /**
     * Method for calculate y point
     */
    export function yToCoordinate(mapObject: Maps, val: number): number;
    /**
     * Method for calculate aitoff projection
     */
    export function aitoff(x: number, y: number): Point;
    /**
     * Method to round the number
     */
    export function roundTo(a: number, b: number): number;
    export function sinci(x: number): number;
    export function acos(a: number): number;
    /**
     * Method to calculate bound
     */
    export function calculateBound(value: number, min: number, max: number): number;
    /**
     * Map internal class for point
     */
    export class Point {
        x: number;
        y: number;
        constructor(x: number, y: number);
    }
    /**
     * Map internal class for min and max
     *
     */
    export class MinMax {
        min: number;
        max: number;
        constructor(min: number, max: number);
    }
    /**
     * Map internal class locations
     */
    export class GeoLocation {
        latitude: MinMax;
        longitude: MinMax;
        constructor(latitude: MinMax, longitude: MinMax);
    }
    /**
     * Function to measure the height and width of the text.
     * @param  {string} text
     * @param  {FontModel} font
     * @param  {string} id
     * @returns no
     * @private
     */
    export function measureText(text: string, font: FontModel): Size;
    /**
     * Internal use of text options
     * @private
     */
    export class TextOption {
        id: string;
        anchor: string;
        text: string | string[];
        transform: string;
        x: number;
        y: number;
        baseLine: string;
        constructor(id?: string, x?: number, y?: number, anchor?: string, text?: string | string[], transform?: string, baseLine?: string);
    }
    /**
     * Internal use of path options
     * @private
     */
    export class PathOption {
        id: string;
        opacity: number;
        fill: string;
        stroke: string;
        ['stroke-width']: number;
        ['stroke-dasharray']: string;
        d: string;
        ['marker-start']: string;
        ['marker-end']: string;
        constructor(id: string, fill: string, width: number, color: string, opacity?: number, dashArray?: string, d?: string, markerStart?: string, markerEnd?: string);
    }
    /**
     * Internal use of rectangle options
     * @private
     */
    export class RectOption extends PathOption {
        x: number;
        y: number;
        height: number;
        width: number;
        rx: number;
        ry: number;
        transform: string;
        ['stroke-dasharray']: string;
        constructor(id: string, fill: string, border: BorderModel, opacity: number, rect: Rect, rx?: number, ry?: number, transform?: string, dashArray?: string);
    }
    /**
     * Internal use of circle options
     * @private
     */
    export class CircleOption extends PathOption {
        cy: number;
        cx: number;
        r: number;
        ['stroke-dasharray']: string;
        constructor(id: string, fill: string, border: BorderModel, opacity: number, cx: number, cy: number, r: number, dashArray: string);
    }
    /**
     * Internal use of polygon options
     * @private
     */
    export class PolygonOption extends PathOption {
        points: string;
        constructor(id: string, points: string, fill: string, width: number, color: string, opacity?: number, dashArray?: string);
    }
    /**
     * Internal use of polyline options
     * @private
     */
    export class PolylineOption extends PolygonOption {
        constructor(id: string, points: string, fill: string, width: number, color: string, opacity?: number, dashArray?: string);
    }
    /**
     * Internal use of line options
     * @private
     */
    export class LineOption extends PathOption {
        x1: number;
        y1: number;
        x2: number;
        y2: number;
        constructor(id: string, line: Line, fill: string, width: number, color: string, opacity?: number, dashArray?: string);
    }
    /**
     * Internal use of line
     * @property
     */
    export class Line {
        x1: number;
        y1: number;
        x2: number;
        y2: number;
        constructor(x1: number, y1: number, x2: number, y2: number);
    }
    /**
     * Internal use of map location type
     * @private
     */
    export class MapLocation {
        x: number;
        y: number;
        constructor(x: number, y: number);
    }
    /**
     * Internal use of type rect
     * @private
     */
    export class Rect {
        x: number;
        y: number;
        height: number;
        width: number;
        constructor(x: number, y: number, width: number, height: number);
    }
    /**
     * Internal use of pattern unit types enum.
     * @private
     */
    export type patternUnits = 'userSpaceOnUse' | 'objectBoundingBox';
    /**
     * Internal use for pattern creation.
     * @property
     */
    export class PatternOptions {
        id: string;
        patternUnits: patternUnits;
        patternContentUnits: patternUnits;
        patternTransform: string;
        x: number;
        y: number;
        width: number;
        height: number;
        href: string;
        constructor(id: string, x: number, y: number, width: number, height: number, patternUnits?: patternUnits, patternContentUnits?: patternUnits, patternTransform?: string, href?: string);
    }
    /**
     * Internal rendering of text
     * @private
     */
    export function renderTextElement(options: TextOption, font: FontModel, color: string, parent: HTMLElement | Element, isMinus?: boolean): Element;
    /**
     * @private
     */
    export function convertElement(element: Element, markerId: string, data: Object, index: number, mapObj: Maps): HTMLElement;
    export function convertElementFromLabel(element: Element, labelId: string, data: object, index: number, mapObj: Maps): HTMLElement;
    /**
     * Internal use of append shape element
     * @private
     */
    export function appendShape(shape: Element, element: Element): Element;
    /**
     * Internal rendering of Circle
     * @private
     */
    export function drawCircle(maps: Maps, options: CircleOption, element?: Element): Element;
    /**
     * Internal rendering of Rectangle
     * @private
     */
    export function drawRectangle(maps: Maps, options: RectOption, element?: Element): Element;
    /**
     * Internal rendering of Path
     * @private
     */
    export function drawPath(maps: Maps, options: PathOption, element?: Element): Element;
    /**
     * Internal rendering of Polygon
     * @private
     */
    export function drawPolygon(maps: Maps, options: PolygonOption, element?: Element): Element;
    /**
     * Internal rendering of Polyline
     * @private
     */
    export function drawPolyline(maps: Maps, options: PolylineOption, element?: Element): Element;
    /**
     * Internal rendering of Line
     * @private
     */
    export function drawLine(maps: Maps, options: LineOption, element?: Element): Element;
    /**
     * @private
     * Calculate marker shapes
     */
    export function calculateShapes(maps: Maps, shape: MarkerType, options: PathOption, size: Size, location: MapLocation, markerEle: Element): Element;
    /**
     * Internal rendering of Diamond
     * @private
     */
    export function drawDiamond(maps: Maps, options: PathOption, size: Size, location: MapLocation, element?: Element): Element;
    /**
     * Internal rendering of Triangle
     * @private
     */
    export function drawTriangle(maps: Maps, options: PathOption, size: Size, location: MapLocation, element?: Element): Element;
    /**
     * Internal rendering of Cross
     * @private
     */
    export function drawCross(maps: Maps, options: PathOption, size: Size, location: MapLocation, element?: Element): Element;
    /**
     * Internal rendering of HorizontalLine
     * @private
     */
    export function drawHorizontalLine(maps: Maps, options: PathOption, size: Size, location: MapLocation, element?: Element): Element;
    /**
     * Internal rendering of VerticalLine
     * @private
     */
    export function drawVerticalLine(maps: Maps, options: PathOption, size: Size, location: MapLocation, element?: Element): Element;
    /**
     * Internal rendering of Star
     * @private
     */
    export function drawStar(maps: Maps, options: PathOption, size: Size, location: MapLocation, element?: Element): Element;
    /**
     * Internal rendering of Balloon
     * @private
     */
    export function drawBalloon(maps: Maps, options: PathOption, size: Size, location: MapLocation, element?: Element): Element;
    /**
     * Internal rendering of Pattern
     * @private
     */
    export function drawPattern(maps: Maps, options: PatternOptions, elements: Element[], element?: Element): Element;
    /**
     * Method to get specific field and vaues from data.
     * @private
     */
    export function getFieldData(dataSource: object[], fields: string[]): object[];
    /**
     * To find the index of dataSource from shape properties
     */
    export function checkShapeDataFields(dataSource: object[], properties: object, dataPath: string, propertyPath: string): number;
    export function filter(points: MapLocation[], start: number, end: number): MapLocation[];
    /**
     * To find the midpoint of the polygon from points
     */
    export function findMidPointOfPolygon(points: MapLocation[]): object;
    /**
     * @private
     * Check custom path
     */
    export function isCustomPath(layerData: Object[]): boolean;
    /**
     * @private
     * Trim the title text
     */
    export function textTrim(maxWidth: number, text: string, font: FontModel): string;
    /**
     * Method to calculate x position of title
     */
    export function findPosition(location: Rect, alignment: Alignment, textSize: Size, type: string): Point;
    /**
     * To remove element by id
     */
    export function removeElement(id: string): void;
    /**
     * @private
     */
    export function getTranslate(mapObject: Maps, layer: LayerSettings): Object;
    /**
     * To get the html element by specified id
     */
    export function getElementByID(id: string): Element;
    /**
     * To apply internalization
     */
    export function Internalize(maps: Maps, value: number): string;
    /**
     * Function     to compile the template function for maps.
     * @returns Function
     * @private
     */
    export function getTemplateFunction(template: string): Function;
    /**
     * Function to get element from id.
     * @returns Element
     * @private
     */
    export function getElement(id: string): Element;
    /**
     * Function to get shape data using target id
     */
    export function getShapeData(targetId: string, map: Maps): {
        shapeData: object;
        data: object;
    };
    /**
     * Function to trigger shapeSelected event
     * @private
     */
    export function triggerShapeEvent(targetId: string, selection: SelectionSettingsModel | HighlightSettingsModel, maps: Maps, eventName: string): IShapeSelectedEventArgs;
    /**
     * Function to get elements using class name
     */
    export function getElementsByClassName(className: string): HTMLCollectionOf<Element>;
    /**
     * Function to get elements using querySelectorAll
     */
    /**
     * Function to get elements using querySelector
     */
    export function querySelector(args: string, elementSelector: string): Element;
    /**
     * Function to get the element for selection and highlight using public method
     */
    export function getTargetElement(layerIndex: number, name: string, enable: boolean, map: Maps): Element;
    /**
     * Function to create style element for highlight and selection
     */
    export function createStyle(id: string, className: string, eventArgs: IShapeSelectedEventArgs): Element;
    /**
     * Function to customize the style for highlight and selection
     */
    export function customizeStyle(id: string, className: string, eventArgs: IShapeSelectedEventArgs): void;
    /**
     * Function to remove class from element
     */
    export function removeClass(element: Element): void;
    /**
     * Animation Effect Calculation End
     * @private
     */
    export function elementAnimate(element: Element, delay: number, duration: number, point: MapLocation, maps: Maps, ele?: string, radius?: number): void;
    /**
     *
     * @param touchList
     * @param e
     * @param touches
     */
    export function addTouchPointer(touchList: ITouches[], e: PointerEvent, touches: TouchList): ITouches[];
    /** @private */
    export function createTooltip(id: string, text: string, top: number, left: number, fontSize: string): void;
    /** @private */
    export function drawSymbol(location: Point, shape: string, size: Size, url: string, options: PathOption): Element;
    /** @private */
    export function calculateLegendShapes(location: Point, size: Size, shape: string, options: PathOption, url: string): IShapes;
    /**
     * Animation Effect Calculation End
     * @private
     */
    /** @private */
    export function getElementOffset(childElement: HTMLElement, parentElement: HTMLElement): Size;
    /** @private */
    export function changeBorderWidth(element: Element, index: number, scale: number, maps: Maps): void;
    /** @private */
    export function changeNavaigationLineWidth(element: Element, index: number, scale: number, maps: Maps): void;
    
  }
  export namespace navigations {
    
    /**
     * Interface for a class AccordionActionSettings
     */
    export interface AccordionActionSettingsModel {
    
        /**
       * Specifies the type of animation.
       * @default : 'SlideDown'
       */
        effect?: 'None' | ej.base.Effect;
    
        /**
       * Specifies the duration to animate.
       * @default : 400
       */
        duration?: number;
    
        /**
       * Specifies the animation timing function.
       * @default : 'linear'
       */
        easing?: string;
    
    }
    
    /**
     * Interface for a class AccordionAnimationSettings
     */
    export interface AccordionAnimationSettingsModel {
    
        /**
       * Specifies the animation to appear while collapsing the Accordion item.
       * @default { effect: 'SlideDown', duration: 400, easing: 'linear' }
       */
        collapse?: AccordionActionSettingsModel;
    
        /**
       * Specifies the animation to appear while expanding the Accordion item.
       * @default { effect: 'SlideDown', duration: 400, easing: 'linear' }
       */
        expand?: AccordionActionSettingsModel;
    
    }
    
    /**
     * Interface for a class AccordionItem
     */
    export interface AccordionItemModel {
    
        /**
         * Sets the text content to be displayed for the Accordion item.
         * You can set the content of the Accordion item using `content` property.
         * It also supports to include the title as `HTML element`, `string`, or `query selector`.
         * ```typescript
         *   let accordionObj: Accordion = new Accordion( { 
         *        items : [ 
         *          { header: 'Accordion Header', content: 'Accordion Content' },
         *          { header: '<div>Accordion Header</div>', content: '<div>Accordion Content</div' },
         *          { header: '#headerContent', content: '#panelContent' }]
         *        });
         *   accordionObj.appendTo('#accordion');
         * ```
         * @default undefined
         */
        content?: string;
    
        /**
         * Sets the header text to be displayed for the Accordion item.
         * You can set the title of the Accordion item using `header` property.
         * It also supports to include the title as `HTML element`, `string`, or `query selector`.
         * ```typescript
         *   let accordionObj: Accordion = new Accordion( { 
         *        items : [ 
         *          { header: 'Accordion Header', content: 'Accordion Content' },
         *          { header: '<div>Accordion Header</div>', content: '<div>Accordion Content</div' },
         *          { header: '#headerContent', content: '#panelContent' }]
         *        });
         *   accordionObj.appendTo('#accordion');
         * ```
         * @default undefined
         */
        header?: string;
    
        /**
         * Defines single/multiple classes (separated by a space) are to be used for Accordion item customization.
         * @default undefined
         */
        cssClass?: string;
    
        /**
         * Defines an icon with the given custom CSS class that is to be rendered before the header text.
         * Add the css classes to the `iconCss` property and write the css styles to the defined class to set images/icons.
         * Adding icon is applicable only to the header.
         * ```typescript
         *   let accordionObj: Accordion = new Accordion( { 
         *        items : [ 
         *          { header: 'Accordion Header', iconCss: 'e-app-icon' }]
         *        });
         *   accordionObj.appendTo('#accordion');
         * ```
         * ```css
         * .e-app-icon::before {
         *   content: "\e710";
         * }
         * ```
         * @default undefined
         */
        iconCss?: string;
    
        /**
         * Sets the expand (true) or collapse (false) state of the Accordion item. By default, all the items are in a collapsed state.
         * @default 'false'
         */
        expanded?: Boolean;
    
    }
    
    /**
     * Interface for a class Accordion
     */
    export interface AccordionModel extends ej.base.ComponentModel{
    
        /**
         * An array of item that is used to specify Accordion items.
         * ```typescript
         *   let accordionObj: Accordion = new Accordion( { 
         *        items : [ 
         *          { header: 'Accordion Header', content: 'Accordion Content' }]
         *        });
         *   accordionObj.appendTo('#accordion');
         * ```
         * @default []
         */
        items?: AccordionItemModel[];
    
        /**
         * Specifies the width of the Accordion in pixels/number/percentage. Number value is considered as pixels.
         * @default '100%'
         */
        width?: string | number;
    
        /**
         * Specifies the height of the Accordion in pixels/number/percentage. Number value is considered as pixels.
         * @default 'auto'
         */
        height?: string | number;
    
        /**
         * Specifies the options to expand single or multiple panel at a time.
         * The possible values are:
         * - Single: Sets to expand only one Accordion item at a time.
         * - Multiple: Sets to expand more than one Accordion item at a time.
         * @default 'Multiple'
         */
        expandMode?: ExpandMode;
    
        /**
         * Specifies the animation configuration settings for expanding and collapsing the panel.
         * @default { expand: { effect: 'SlideDown', duration: 400, easing: 'linear' },
         * collapse: { effect: 'SlideUp', duration: 400, easing: 'linear' }}
         */
        animation?: AccordionAnimationSettingsModel;
    
        /**
         * The event will be fired while clicking on the Accordion headers.
         * @event
         */
        clicked?: ej.base.EmitType<AccordionClickArgs>;
    
        /**
         * The event will be fired before the item gets collapsed/expanded.
         * @event
         */
        expanding?: ej.base.EmitType<ExpandEventArgs>;
    
        /**
         * The event will be fired after the item gets collapsed/expanded.
         * @event
         */
        expanded?: ej.base.EmitType<ExpandEventArgs>;
    
        /**
         * The event will be fired once the control rendering is completed.
         * @event
         */
        created?: ej.base.EmitType<Event>;
    
        /**
         * The event will be fired when the control gets destroyed.
         * @event
         */
        destroyed?: ej.base.EmitType<Event>;
    
    }
    
    /**
     * Specifies the option to expand single or multiple panel at a time.
     */
    export type ExpandMode = 'Single' | 'Multiple';
    export interface AccordionClickArgs extends ej.base.BaseEventArgs {
        /** Defines the current Accordion Item Object. */
        item?: AccordionItemModel;
        /** Defines the current Event arguments. */
        originalEvent?: Event;
    }
    export interface ExpandEventArgs extends ej.base.BaseEventArgs {
        /** Defines the current Accordion Item Object. */
        item?: AccordionItemModel;
        /** Defines the current Accordion Item Element. */
        element?: HTMLElement;
        /** Defines the expand/collapse state. */
        isExpanded?: boolean;
        /** Defines the prevent action. */
        cancel?: boolean;
    }
    export class AccordionActionSettings extends ej.base.ChildProperty<AccordionActionSettings> {
        /**
         * Specifies the type of animation.
         * @default : 'SlideDown'
         */
        effect: 'None' | ej.base.Effect;
        /**
         * Specifies the duration to animate.
         * @default : 400
         */
        duration: number;
        /**
         * Specifies the animation timing function.
         * @default : 'linear'
         */
        easing: string;
    }
    export class AccordionAnimationSettings extends ej.base.ChildProperty<AccordionAnimationSettings> {
        /**
         * Specifies the animation to appear while collapsing the Accordion item.
         * @default { effect: 'SlideDown', duration: 400, easing: 'linear' }
         */
        collapse: AccordionActionSettingsModel;
        /**
         * Specifies the animation to appear while expanding the Accordion item.
         * @default { effect: 'SlideDown', duration: 400, easing: 'linear' }
         */
        expand: AccordionActionSettingsModel;
    }
    /**
     * An item object that is used to configure Accordion items.
     */
    export class AccordionItem extends ej.base.ChildProperty<AccordionItem> {
        /**
         * Sets the text content to be displayed for the Accordion item.
         * You can set the content of the Accordion item using `content` property.
         * It also supports to include the title as `HTML element`, `string`, or `query selector`.
         * ```typescript
         *   let accordionObj: Accordion = new Accordion( {
         *        items : [
         *          { header: 'Accordion Header', content: 'Accordion Content' },
         *          { header: '<div>Accordion Header</div>', content: '<div>Accordion Content</div' },
         *          { header: '#headerContent', content: '#panelContent' }]
         *        });
         *   accordionObj.appendTo('#accordion');
         * ```
         * @default undefined
         */
        content: string;
        /**
         * Sets the header text to be displayed for the Accordion item.
         * You can set the title of the Accordion item using `header` property.
         * It also supports to include the title as `HTML element`, `string`, or `query selector`.
         * ```typescript
         *   let accordionObj: Accordion = new Accordion( {
         *        items : [
         *          { header: 'Accordion Header', content: 'Accordion Content' },
         *          { header: '<div>Accordion Header</div>', content: '<div>Accordion Content</div' },
         *          { header: '#headerContent', content: '#panelContent' }]
         *        });
         *   accordionObj.appendTo('#accordion');
         * ```
         * @default undefined
         */
        header: string;
        /**
         * Defines single/multiple classes (separated by a space) are to be used for Accordion item customization.
         * @default undefined
         */
        cssClass: string;
        /**
         * Defines an icon with the given custom CSS class that is to be rendered before the header text.
         * Add the css classes to the `iconCss` property and write the css styles to the defined class to set images/icons.
         * Adding icon is applicable only to the header.
         * ```typescript
         *   let accordionObj: Accordion = new Accordion( {
         *        items : [
         *          { header: 'Accordion Header', iconCss: 'e-app-icon' }]
         *        });
         *   accordionObj.appendTo('#accordion');
         * ```
         * ```css
         * .e-app-icon::before {
         *   content: "\e710";
         * }
         * ```
         * @default undefined
         */
        iconCss: string;
        /**
         * Sets the expand (true) or collapse (false) state of the Accordion item. By default, all the items are in a collapsed state.
         * @default 'false'
         */
        expanded: Boolean;
    }
    /**
     * The Accordion is a vertically collapsible content panel that displays one or more panels at a time within the available space.
     * ```html
     * <div id='accordion'/>
     * <script>
     *   var accordionObj = new Accordion();
     *   accordionObj.appendTo('#accordion');
     * </script>
     * ```
     */
    export class Accordion extends ej.base.Component<HTMLElement> implements ej.base.INotifyPropertyChanged {
        private trgtEle;
        private ctrlTem;
        private keyModule;
        private expandedItems;
        private initExpand;
        private isNested;
        private isDestroy;
        private templateEle;
        /**
         * Contains the keyboard configuration of the Accordion.
         */
        private keyConfigs;
        /**
         * An array of item that is used to specify Accordion items.
         * ```typescript
         *   let accordionObj: Accordion = new Accordion( {
         *        items : [
         *          { header: 'Accordion Header', content: 'Accordion Content' }]
         *        });
         *   accordionObj.appendTo('#accordion');
         * ```
         * @default []
         */
        items: AccordionItemModel[];
        /**
         * Specifies the width of the Accordion in pixels/number/percentage. Number value is considered as pixels.
         * @default '100%'
         */
        width: string | number;
        /**
         * Specifies the height of the Accordion in pixels/number/percentage. Number value is considered as pixels.
         * @default 'auto'
         */
        height: string | number;
        /**
         * Specifies the options to expand single or multiple panel at a time.
         * The possible values are:
         * - Single: Sets to expand only one Accordion item at a time.
         * - Multiple: Sets to expand more than one Accordion item at a time.
         * @default 'Multiple'
         */
        expandMode: ExpandMode;
        /**
         * Specifies the animation configuration settings for expanding and collapsing the panel.
         * @default { expand: { effect: 'SlideDown', duration: 400, easing: 'linear' },
         * collapse: { effect: 'SlideUp', duration: 400, easing: 'linear' }}
         */
        animation: AccordionAnimationSettingsModel;
        /**
         * The event will be fired while clicking on the Accordion headers.
         * @event
         */
        clicked: ej.base.EmitType<AccordionClickArgs>;
        /**
         * The event will be fired before the item gets collapsed/expanded.
         * @event
         */
        expanding: ej.base.EmitType<ExpandEventArgs>;
        /**
         * The event will be fired after the item gets collapsed/expanded.
         * @event
         */
        expanded: ej.base.EmitType<ExpandEventArgs>;
        /**
         * The event will be fired once the control rendering is completed.
         * @event
         */
        created: ej.base.EmitType<Event>;
        /**
         * The event will be fired when the control gets destroyed.
         * @event
         */
        destroyed: ej.base.EmitType<Event>;
        /**
         * Initializes a new instance of the Accordion class.
         * @param options  - Specifies Accordion model properties as options.
         * @param element  - Specifies the element that is rendered as an Accordion.
         */
        constructor(options?: AccordionModel, element?: string | HTMLElement);
        /**
         * Removes the control from the DOM and also removes all its related events.
         * @returns void
         */
        destroy(): void;
        protected preRender(): void;
        private add(ele, val);
        private remove(ele, val);
        /**
         * To initialize the control rendering
         * @private
         */
        protected render(): void;
        private initialize();
        private renderControl();
        private unwireEvents();
        private wireEvents();
        private focusIn(e);
        private focusOut(e);
        private ctrlTemplate();
        private toggleIconGenerate();
        private initItemExpand();
        private renderItems();
        private clickHandler(e);
        private eleMoveFocus(action, root, trgt);
        private keyActionHandler(e);
        private headerEleGenerate();
        private renderInnerItem(item, index);
        private fetchElement(ele, value, index, isHeader);
        private ariaAttrUpdate(itemEle);
        private contentRendering(index);
        private expand(trgt);
        private expandAnimation(ef, icn, trgt, trgtItemEle, animate, args);
        private expandProgress(progress, icon, trgt, trgtItemEle, eventArgs);
        private expandedItemsPush(item);
        private getIndexByItem(item);
        private expandedItemsPop(item);
        private collapse(trgt);
        private collapseAnimation(ef, trgt, trgtItEl, icn, animate, args);
        private collapseProgress(progress, icon, trgt, trgtItemEle, eventArgs);
        /**
         * Returns the current module name.
         * @returns string
         * @private
         */
        protected getModuleName(): string;
        private itemAttribUpdate();
        /**
         * Adds new item to the Accordion with the specified index of the Accordion.
         * @param  {AccordionItemModel} item - Item array that is to be added to the Accordion.
         * @param  {number} index - Number value that determines where the item should be added.
         * By default, item is added at the last index if the index is not specified.
         * @returns void
         */
        addItem(item: AccordionItemModel, index?: number): void;
        private expandedItemRefresh(ele);
        /**
         * Dynamically removes item from Accordion.
         * @param  {number} index - Number value that determines which item should be removed.
         * @returns void.
         */
        removeItem(index: number): void;
        /**
         * Sets focus to the specified index item header in Accordion.
         * @param  {number} index - Number value that determines which item should be focused.
         * @returns void.
         */
        select(index: number): void;
        /**
         * Shows or hides the specified item from Accordion.
         * @param  {number} index - Number value that determines which item should be hidden/shown.
         * @param  {Boolean} isHidden - Boolean value that determines the action either hide (true) or show (false). Default value is false.
         *  If the `isHidden` value is false, the item is shown or else item it is hidden.
         * @returns void.
         */
        hideItem(index: number, isHidden?: Boolean): void;
        /**
         * Enables/Disables the specified Accordion item.
         * @param  {number} index - Number value that determines which item should be enabled/disabled.
         * @param  {boolean} isEnable - Boolean value that determines the action as enable (true) or disable (false).
         * If the `isEnable` value is true, the item is enabled or else it is disabled.
         * @returns void.
         */
        enableItem(index: number, isEnable: boolean): void;
        /**
         * Expands/Collapses the specified Accordion item.
         * @param  {boolean} isExpand - Boolean value that determines the action as expand or collapse.
         * @param  {number} index - Number value that determines which item should be expanded/collapsed.`index` is optional parameter.
         *  Without Specifying index, based on the `isExpand` value all Accordion item can be expanded or collapsed.
         * @returns void.
         */
        expandItem(isExpand: boolean, index?: number): void;
        private itemExpand(isExpand, ele, index);
        private destroyItems();
        private updateItem(item, index);
        protected getPersistData(): string;
        /**
         * Gets called when the model property changes.The data that describes the old and new values of the property that changed.
         * @param  {AccordionModel} newProp
         * @param  {AccordionModel} oldProp
         * @returns void
         * @private
         */
        onPropertyChanged(newProp: AccordionModel, oldProp: AccordionModel): void;
    }
    
    /**
     * Interface for a class HScroll
     */
    export interface HScrollModel extends ej.base.ComponentModel{
    
        /**
         * Specifies the left or right scrolling distance of the horizontal scrollbar moving.
         * @default '40'
         */
        scrollStep?: number;
    
    }
    
    /**
     * HScroll module is introduces horizontal scroller when content exceeds the current viewing area.
     * It can be useful for the components like Toolbar, Tab which needs horizontal scrolling alone.
     * Hidden content can be view by touch moving or icon click.
     * ```html
     * <div id="scroll"/>
     * <script>
     *   var scrollObj = new HScroll();
     *   scrollObj.appendTo("#scroll");
     * </script>
     * ```
     */
    export class HScroll extends ej.base.Component<HTMLElement> implements ej.base.INotifyPropertyChanged {
        private touchModule;
        private scrollEle;
        private scrollItems;
        private uniqueId;
        private timeout;
        private keyTimeout;
        private keyTimer;
        private browser;
        private browserCheck;
        private ieCheck;
        private isDevice;
        /**
         * Specifies the left or right scrolling distance of the horizontal scrollbar moving.
         * @default '40'
         */
        scrollStep: number;
        /**
         * Initialize the event handler
         * @private
         */
        protected preRender(): void;
        /**
         * To Initialize the control rendering
         * @private
         */
        protected render(): void;
        /**
         * Initializes a new instance of the HScroll class.
         * @param options  - Specifies HScroll model properties as options.
         * @param element  - Specifies the element for which horizontal scrolling applies.
         */
        constructor(options?: HScrollModel, element?: string | HTMLElement);
        private initialize();
        protected getPersistData(): string;
        /**
         * Returns the current module name.
         * @returns string
         * @private
         */
        protected getModuleName(): string;
        /**
         * Removes the control from the DOM and also removes all its related events.
         * @returns void
         */
        destroy(): void;
        private createNavIcon(element);
        private onKeyPress(e);
        private onKeyUp(e);
        private eventBinding(ele);
        private repeatScroll();
        private tabHoldHandler(e);
        private contains(ele, className);
        private eleScrolling(scrollDis, trgt);
        private clickEventHandler(e);
        private touchHandler(e);
        private arrowDisabling(addDisable, removeDisable);
        private scrollHandler(e);
        /**
         * Gets called when the model property changes.The data that describes the old and new values of property that changed.
         * @param  {HScrollModel} newProp
         * @param  {HScrollModel} oldProp
         * @returns void
         * @private
         */
        onPropertyChanged(newProp: HScrollModel, oldProp: HScrollModel): void;
    }
    
    /**
     * Interface for a class MenuItem
     */
    export interface MenuItemModel {
    
        /**
         * Defines class/multiple classes separated by a space for the menu Item that is used to include an icon.
         * Menu Item can include font icon and sprite image.
         * @default ''
         */
        iconCss?: string;
    
        /**
         * Specifies the id for menu item.
         * @default ''
         */
        id?: string;
    
        /**
         * Specifies separator between the menu items. Separator are horizontal lines used to group menu items.
         * @default false
         */
        separator?: boolean;
    
        /**
         * Specifies the sub menu items that is the array of MenuItem model.
         * @default []
         */
        items?: MenuItemModel[];
    
        /**
         * Specifies text for menu item.
         * @default ''
         */
        text?: string;
    
        /**
         * Specifies url for menu item that creates the anchor link to navigate to the url provided.
         * @default ''
         */
        url?: string;
    
    }
    
    /**
     * Interface for a class ContextMenu
     */
    export interface ContextMenuModel extends ej.base.ComponentModel{
    
        /**
         * Defines class/multiple classes separated by a space in the ContextMenu wrapper.
         * ContextMenu customization can be achieved by using this.
         * @default ''
         */
        cssClass?: string;
    
        /**
         * Specifies the filter selector for elements inside the target in that the context menu will be opened.
         * @default ''
         */
        filter?: string;
    
        /**
         * Specifies whether to show the sub menu or not on click.
         * When set to true, the sub menu will open only on mouse click.
         * @default false
         */
        showItemOnClick?: boolean;
    
        /**
         * Specifies menu items with its properties which will be rendered as Context Menu.
         * @default []
         */
        items?: MenuItemModel[];
    
        /**
         * Specifies target element selector in which the ContextMenu should be opened.
         * @default ''
         */
        target?: string;
    
        /**
         * Specifies the animation settings for the sub menu open.
         * @default { duration: 400, easing: 'ease', effect: 'SlideDown' }
         */
        animationSettings?: MenuAnimationSettings;
    
        /**
         * Triggers while rendering each menu item.
         * @event
         */
        beforeItemRender?: ej.base.EmitType<ej.navigations.MenuEventArgs>;
    
        /**
         * Triggers before opening the menu item.
         * @event
         */
        beforeOpen?: ej.base.EmitType<ej.navigations.BeforeOpenCloseMenuEventArgs>;
    
        /**
         * Triggers while opening the menu item.
         * @event
         */
        onOpen?: ej.base.EmitType<OpenCloseMenuEventArgs>;
    
        /**
         * Triggers before closing the menu.
         * @event
         */
        beforeClose?: ej.base.EmitType<ej.navigations.BeforeOpenCloseMenuEventArgs>;
    
        /**
         * Triggers while closing the menu.
         * @event
         */
        onClose?: ej.base.EmitType<OpenCloseMenuEventArgs>;
    
        /**
         * Triggers while selecting menu item.
         * @event
         */
        select?: ej.base.EmitType<ej.navigations.MenuEventArgs>;
    
    }
    
    /**
     * Menu animation effects
     */
    export type MenuEffect = 'None' | 'SlideDown' | 'ZoomIn';
    /**
     * Specifies context menu items.
     */
    export class MenuItem extends ej.base.ChildProperty<MenuItem> {
        /**
         * Defines class/multiple classes separated by a space for the menu Item that is used to include an icon.
         * Menu Item can include font icon and sprite image.
         * @default ''
         */
        iconCss: string;
        /**
         * Specifies the id for menu item.
         * @default ''
         */
        id: string;
        /**
         * Specifies separator between the menu items. Separator are horizontal lines used to group menu items.
         * @default false
         */
        separator: boolean;
        /**
         * Specifies the sub menu items that is the array of MenuItem model.
         * @default []
         */
        items: MenuItemModel[];
        /**
         * Specifies text for menu item.
         * @default ''
         */
        text: string;
        /**
         * Specifies url for menu item that creates the anchor link to navigate to the url provided.
         * @default ''
         */
        url: string;
    }
    /**
     * The ContextMenu is a graphical user interface that appears on the user right click/touch hold operation.
     * ```html
     * <div id = 'target'></div>
     * <ul id = 'contextmenu'></ul>
     * ```
     * ```typescript
     * <script>
     * var contextMenuObj = new ContextMenu({items: [{ text: 'Cut' }, { text: 'Copy' },{ text: 'Paste' }], target: '#target'});
     * </script>
     * ```
     */
    export class ContextMenu extends ej.base.Component<HTMLUListElement> implements ej.base.INotifyPropertyChanged {
        private animation;
        private ngElement;
        private navIdx;
        private isTapHold;
        private targetElement;
        /**
         * Defines class/multiple classes separated by a space in the ContextMenu wrapper.
         * ContextMenu customization can be achieved by using this.
         * @default ''
         */
        cssClass: string;
        /**
         * Specifies the filter selector for elements inside the target in that the context menu will be opened.
         * @default ''
         */
        filter: string;
        /**
         * Specifies whether to show the sub menu or not on click.
         * When set to true, the sub menu will open only on mouse click.
         * @default false
         */
        showItemOnClick: boolean;
        /**
         * Specifies menu items with its properties which will be rendered as Context Menu.
         * @default []
         */
        items: MenuItemModel[];
        /**
         * Specifies target element selector in which the ContextMenu should be opened.
         * @default ''
         */
        target: string;
        /**
         * Specifies the animation settings for the sub menu open.
         * @default { duration: 400, easing: 'ease', effect: 'SlideDown' }
         */
        animationSettings: MenuAnimationSettings;
        /**
         * Triggers while rendering each menu item.
         * @event
         */
        beforeItemRender: ej.base.EmitType<ej.navigations.MenuEventArgs>;
        /**
         * Triggers before opening the menu item.
         * @event
         */
        beforeOpen: ej.base.EmitType<ej.navigations.BeforeOpenCloseMenuEventArgs>;
        /**
         * Triggers while opening the menu item.
         * @event
         */
        onOpen: ej.base.EmitType<OpenCloseMenuEventArgs>;
        /**
         * Triggers before closing the menu.
         * @event
         */
        beforeClose: ej.base.EmitType<ej.navigations.BeforeOpenCloseMenuEventArgs>;
        /**
         * Triggers while closing the menu.
         * @event
         */
        onClose: ej.base.EmitType<OpenCloseMenuEventArgs>;
        /**
         * Triggers while selecting menu item.
         * @event
         */
        select: ej.base.EmitType<ej.navigations.MenuEventArgs>;
        /**
         * Constructor for creating the widget.
         * @private
         */
        constructor(options?: ContextMenuModel, element?: string | HTMLUListElement);
        /**
         * Initialized animation with parent menu animation settings.
         * @private
         */
        protected preRender(): void;
        /**
         * Initialize the control rendering
         * @private
         */
        protected render(): void;
        private initWrapper();
        private renderItems();
        private wireEvents();
        private mouseDownHandler(e);
        private keyBoardHandler(e);
        private upDownKeyHandler(e);
        private isValidLI(cli, index, action);
        private rightEnterKeyHandler(e);
        private leftEscKeyHandler(e);
        private scrollHandler(e);
        private touchHandler(e);
        private cmenuHandler(e);
        /**
         * Closes the ContextMenu if it is opened.
         */
        close(): void;
        private closeMenu(ulIndex?, e?);
        private isMenuVisible();
        private canOpen(target);
        /**
         * This method is used to open the ContextMenu in specified position.
         * @param top To specify ContextMenu vertical positioning.
         * @param left To specify ContextMenu horizontal positioning.
         * @returns void
         */
        open(top: number, left: number): void;
        private openMenu(li, item, top?, left?, e?);
        private setPosition(li, ul, top, left);
        private toggleVisiblity(ul, isVisible?);
        private createItems(items);
        private toRawObject(items);
        private moverHandler(e);
        private hasField(items, field);
        private getWrapper();
        private clickHandler(e);
        private setLISelected(li);
        private getLIByClass(ul, classname);
        private getItem(navIdx);
        private getItems(navIdx);
        private getIdx(ul, li, skipHdr?);
        private getLI(elem);
        /**
         * Called internally if any of the property value changed
         * @private
         * @param {ContextMenuModel} newProp
         * @param {ContextMenuModel} oldProp
         * @returns void
         */
        onPropertyChanged(newProp: ContextMenuModel, oldProp: ContextMenuModel): void;
        private getChangedItemIndex(newProp, index, idx);
        private removeItem(item, navIdx, idx);
        /**
         * Used to unwire the bind events.
         * @private
         */
        protected unWireEvents(): void;
        private toggleAnimation(ul, isMenuOpen?);
        private end(ul, isMenuOpen);
        /**
         * Get the properties to be maintained in the persisted state.
         * @returns string
         */
        protected getPersistData(): string;
        /**
         * Get component name.
         * @returns string
         * @private
         */
        protected getModuleName(): string;
        private getIndex(data, items?, navIdx?, isCallBack?);
        /**
         * This method is used to enable or disable the menu items in the ContextMenu based on the items and enable argument.
         * @param items Text items that needs to be enabled/disabled.
         * @param enable Set `true`/`false` to enable/disable the list items.
         * @returns void
         */
        enableItems(items: string[], enable?: boolean): void;
        /**
         * This method is used to show the menu items in the ContextMenu based on the items text.
         * @param items Text items that needs to be shown.
         * @returns void
         */
        showItems(items: string[]): void;
        /**
         * This method is used to hide the menu items in the ContextMenu based on the items text.
         * @param items Text items that needs to be hidden.
         * @returns void
         */
        hideItems(items: string[]): void;
        private showHideItems(items, ishide);
        /**
         * It is used to remove the menu items from the ContextMenu based on the items text.
         * @param items Text items that needs to be removed.
         * @returns void
         */
        removeItems(items: string[]): void;
        /**
         * It is used to insert the menu items after the specified menu item text.
         * @param items Items that needs to be inserted.
         * @param text Text item after that the element to be inserted.
         * @returns void
         */
        insertAfter(items: MenuItemModel[], text: string): void;
        /**
         * It is used to insert the menu items before the specified menu item text.
         * @param items Items that needs to be inserted.
         * @param text Text item before that the element to be inserted.
         * @returns void
         */
        insertBefore(items: MenuItemModel[], text: string): void;
        private insertItems(items, text, isAfter?);
        private getZIndex();
        /**
         * Destroys the widget.
         * @returns void
         */
        destroy(): void;
    }
    /**
     * Interface for before item render / select event.
     * @private
     */
    export interface MenuEventArgs extends ej.base.BaseEventArgs {
        element: HTMLElement;
        item: MenuItemModel;
    }
    /**
     * Interface for before open / close event.
     * @private
     */
    export interface BeforeOpenCloseMenuEventArgs extends ej.base.BaseEventArgs {
        element: HTMLElement;
        items: MenuItemModel[];
        parentItem: MenuItemModel;
        event: Event;
        cancel: boolean;
    }
    /**
     * Interface for open/close event.
     */
    export interface OpenCloseMenuEventArgs extends ej.base.BaseEventArgs {
        element: HTMLElement;
        items: MenuItemModel[];
        parentItem: MenuItemModel;
    }
    /**
     * Animation configuration settings.
     */
    export interface MenuAnimationSettings {
        /**
         * Specifies the effect that shown in the sub menu transform.
         * The possible effects are:
         * * None: Specifies the sub menu transform with no animation effect.
         * * SlideDown: Specifies the sub menu transform with slide down effect.
         * * ZoomIn: Specifies the sub menu transform with zoom in effect.
         */
        effect?: MenuEffect;
        /**
         * Specifies the time duration to transform object.
         */
        duration?: number;
        /**
         * Specifies the easing effect applied while transform.
         */
        easing?: string;
    }
    export interface ListBaseMenuModel extends ej.navigations.MenuItemModel {
        htmlAttributes: {
            [key: string]: string;
        };
    }
    
    /**
     * Interface for a class Sidebar
     */
    export interface SidebarModel extends ej.base.ComponentModel{
    
        /**
         * Specifies the size of the Sidebar in dock state.
         * @default 'auto'
         */
        dockSize?: string | number;
    
        /**
         * Specifies the media query whether the sidebar need to be opened when the resolution meets
         * @default null
         */
        mediaQuery?: MediaQueryList;
    
        /**
         * Specifies the docking state of the component.
         * @default false
         */
        enableDock?: boolean;
    
        /**
         * Enables the expand or collapse while swiping in touch devices.
         * @default true
         */
        enableGestures?: boolean;
    
        /**
         * Specifies the Sidebar in RTL state.
         * @default false
         */
        enableRtl?: boolean;
    
        /**
         * Specifies the Sidebar animation to be enabled or not.
         * @default true
         */
        animate?: boolean;
    
        /**
         * Specifies the height of the Sidebar.
         * @default 'auto'
         */
        height?: string | number;
    
        /**
         * Specifies whether the Sidebar need to be closed or not when document area is clicked.
         * @default false
         */
        closeOnDocumentClick?: boolean;
    
        /**
         * Specifies the position of the Sidebar (Left/Right) corresponding to the primary content.
         * @default 'Left'
         */
        position?: SidebarPosition;
    
        /**
         * Specifies the element position of the Sidebar inside any element.
         * @default null
         */
        target?: HTMLElement | string;
    
        /**
         * Specifies the whether to apply overlay options to primary content when the Sidebar is in an open state.
         * @default false
         */
        showBackdrop?: boolean;
    
        /**
         * Specifies the expanding types of the Sidebar.
         * @default 'Auto'
         */
        type?: SidebarType;
    
        /**
         * Specifies the width of the Sidebar.
         * @default 'auto'
         */
        width?: string | number;
    
        /**
         * Specifies the z-index of the Sidebar.
         * @default 1000
         */
        zIndex?: string | number;
    
        /**
         * Triggers the event when component is created.
         * @event 
         */
        created?: ej.base.EmitType<Event>;
    
        /**
         * Triggers when component is closed.
         *  @event 
         */
        close?: ej.base.EmitType<Event>;
    
        /**
         * Triggers when component is opened.
         *  @event 
         */
        open?: ej.base.EmitType<Event>;
    
        /**
         * Triggers when component is show or hide.
         *  @event 
         */
        change?: ej.base.EmitType<Event>;
    
        /**
         * Triggers when component gets destroyed.
         *  @event 
         */
        destroyed?: ej.base.EmitType<Event>;
    
    }
    
    /**
     * Specifies the Sidebar types.
     */
    export type SidebarType = 'Slide' | 'Over' | 'Push' | 'Auto';
    /**
     * Specifies the Sidebar positions.
     */
    export type SidebarPosition = 'Left' | 'Right';
    /**
     * Sidebar is an expandable and collapsible
     * component that typically act as a side container to place the primary or secondary content alongside of the main content.
     * ```html
     * <aside id="sidebar">
     * </aside>
     * ````
     * ````typescript
     * <script>
     *   let sidebarObject = new Sidebar({ });
     *   sidebarObject.appendTo("#sidebar");
     * </script>
     * ```
     */
    export class Sidebar extends ej.base.Component<HTMLElement> implements ej.base.INotifyPropertyChanged {
        private eventArguments;
        private modal;
        private mainContentEle;
        private sidebarEle;
        /**
         * Specifies the size of the Sidebar in dock state.
         * @default 'auto'
         */
        dockSize: string | number;
        /**
         * Specifies the media query whether the sidebar need to be opened when the resolution meets
         * @default null
         */
        mediaQuery: MediaQueryList;
        /**
         * Specifies the docking state of the component.
         * @default false
         */
        enableDock: boolean;
        /**
         * Enables the expand or collapse while swiping in touch devices.
         * @default true
         */
        enableGestures: boolean;
        /**
         * Specifies the Sidebar in RTL state.
         * @default false
         */
        enableRtl: boolean;
        /**
         * Specifies the Sidebar animation to be enabled or not.
         * @default true
         */
        animate: boolean;
        /**
         * Specifies the height of the Sidebar.
         * @default 'auto'
         */
        height: string | number;
        /**
         * Specifies whether the Sidebar need to be closed or not when document area is clicked.
         * @default false
         */
        closeOnDocumentClick: boolean;
        /**
         * Specifies the position of the Sidebar (Left/Right) corresponding to the primary content.
         * @default 'Left'
         */
        position: SidebarPosition;
        /**
         * Specifies the element position of the Sidebar inside any element.
         * @default null
         */
        target: HTMLElement | string;
        /**
         * Specifies the whether to apply overlay options to primary content when the Sidebar is in an open state.
         * @default false
         */
        showBackdrop: boolean;
        /**
         * Specifies the expanding types of the Sidebar.
         * @default 'Auto'
         */
        type: SidebarType;
        /**
         * Specifies the width of the Sidebar.
         * @default 'auto'
         */
        width: string | number;
        /**
         * Specifies the z-index of the Sidebar.
         * @default 1000
         */
        zIndex: string | number;
        /**
         * Triggers the event when component is created.
         * @event
         */
        created: ej.base.EmitType<Event>;
        /**
         * Triggers when component is closed.
         *  @event
         */
        close: ej.base.EmitType<Event>;
        /**
         * Triggers when component is opened.
         *  @event
         */
        open: ej.base.EmitType<Event>;
        /**
         * Triggers when component is show or hide.
         *  @event
         */
        change: ej.base.EmitType<Event>;
        /**
         * Triggers when component gets destroyed.
         *  @event
         */
        destroyed: ej.base.EmitType<Event>;
        constructor(options?: SidebarModel, element?: string | HTMLElement);
        protected preRender(): void;
        protected render(): void;
        protected initialize(): void;
        private setContext();
        private setCloseOnDocumentClick();
        private setWidth();
        private setZindex();
        private addClass();
        private destroyBackDrop();
        /**
         * Hide the Sidebar component.
         * @returns void
         */
        hide(): void;
        /**
         * Shows the Sidebar component.
         * @returns void
         */
        show(): void;
        private setAnimation();
        private setDock();
        private createBackDrop();
        protected getPersistData(): string;
        /**
         * Returns the current module name.
         * @returns string
         * @private
         */
        protected getModuleName(): string;
        /**
         * Shows or hides the Sidebar based on the current state.
         * @returns void
         */
        toggle(e?: Event): void;
        /**
         * Specifies the current state of the Sidebar component.
         * @returns boolean
         */
        isOpen(): boolean;
        private setMediaQuery();
        protected resize(e: Event): void;
        private documentclickHandler(e);
        private enableGestureHandler(args);
        private setEnableGestures();
        private wireEvents();
        private unWireEvents();
        onPropertyChanged(newProp: SidebarModel, oldProp: SidebarModel): void;
        protected setType(type?: string): void;
        /**
         * Removes the control from the DOM and removes all its related events
         * @returns void
         */
        destroy(): void;
    }
    /**
     * Defines the event arguments for the event.
     * @returns void
     */
    export interface EventArgs {
        name: string;
        element: HTMLElement;
    }
    
    /**
     * Interface for a class TabActionSettings
     */
    export interface TabActionSettingsModel {
    
        /**
         * Specifies the animation effect for displaying Tab content.
         * @default : 'SlideLeftIn'
         */
        effect?: 'None' | ej.base.Effect;
    
        /**
         * Specifies the time duration to transform content.
         * @default : 600
         */
        duration?: number;
    
        /**
         * Specifies easing effect applied while transforming content.
         * @default : 'ease'
         */
        easing?: string;
    
    }
    
    /**
     * Interface for a class TabAnimationSettings
     */
    export interface TabAnimationSettingsModel {
    
        /**
         * Specifies the animation to appear while moving to previous Tab content.
         * @default { effect: 'SlideLeftIn', duration: 600, easing: 'ease' }
         */
        previous?: TabActionSettingsModel;
    
        /**
         * Specifies the animation to appear while moving to next Tab content.
         * @default { effect: 'SlideRightIn', duration: 600, easing: 'ease' }
         */
        next?: TabActionSettingsModel;
    
    }
    
    /**
     * Interface for a class Header
     */
    export interface HeaderModel {
    
        /**
         * Specifies the display text of the Tab item header.
         * @default ''
         */
        text?: string | HTMLElement;
    
        /**
         * Specifies the icon class that is used to render an icon in the Tab header.
         * @default ''
         */
        iconCss?: string;
    
        /**
         * Options for positioning the icon in the Tab item header. This property depends on `iconCss` property.
         * The possible values are:
         * - Left: Places the icon to the `left` of the item.
         * - Top: Places the icon on the `top` of the item.
         * - Right: Places the icon to the `right` end of the item.
         * - Bottom: Places the icon at the `bottom` of the item.
         * @default 'left'
         */
        iconPosition?: string;
    
    }
    
    /**
     * Interface for a class TabItem
     */
    export interface TabItemModel {
    
        /**
         * The object used for configuring the Tab item header properties.
         * @default {}
         */
        header?: HeaderModel;
    
        /**
         * Specifies the content of Tab item, that is displayed when concern item header is selected.
         * @default ''
         */
        content?: string | HTMLElement;
    
        /**
         * Sets the CSS classes to the Tab item to customize its styles.
         * @default ''
         */
        cssClass?: string;
    
        /**
         * Sets true to disable user interactions of the Tab item.
         * @default false
         */
        disabled?: boolean;
    
    }
    
    /**
     * Interface for a class Tab
     */
    export interface TabModel extends ej.base.ComponentModel{
    
        /**
         * An array of object that is used to configure the Tab component.
         * ```typescript
         *   let tabObj: Tab = new Tab( {
         *     items: [
         *       { header: { text: 'TabItem1' }, content: 'Tab Item1 Content' },
         *       { header: { text: 'TabItem2' }, content: 'Tab Item2 Content' }
         *     ]
         *   });
         *   tabObj.appendTo('#tab');
         * ```
         * @default []
         */
        items?: TabItemModel[];
    
        /**
         * Specifies the width of the Tab component. Default, Tab width sets based on the width of its parent.
         * @default '100%'
         */
        width?: string | number;
    
        /**
         * Specifies the height of the Tab component. By default, Tab height is set based on the height of its parent.
         * To use height property, heightAdjustMode must be set to 'None'.
         * @default 'auto'
         */
        height?: string | number;
    
        /**
         * Sets the CSS classes to root element of the Tab that helps to customize component styles.
         * @default ''
         */
        cssClass?: string;
    
        /**
         * Specifies the index for activating the current Tab item.
         * ```typescript
         *   let tabObj: Tab = new Tab( {
         *     selectedItem: 1,
         *     items: [
         *       { header: { text: 'TabItem1' }, content: 'Tab Item1 Content' },
         *       { header: { text: 'TabItem2' }, content: 'Tab Item2 Content' }
         *     ]
         *   });
         *   tabObj.appendTo('#tab');
         * ```
         * @default 0
         */
        selectedItem?: number;
    
        /**
         * Specifies the orientation of Tab header.
         * The possible values are:
         * - Top: Places the Tab header on the top.
         * - Bottom: Places the Tab header at the bottom.
         * @default 'Top'
         */
        headerPlacement?: HeaderPosition;
    
        /**
         * Specifies the height style for Tab content.
         * The possible values are:
         * - None: Based on the given height property, the content panel height is set.
         * - Auto: Tallest panel height of a given Tab content is set to all the other panels.
         * - Content: Based on the corresponding content height, the content panel height is set.
         * - Fill: Based on the parent height, the content panel hight is set.
         * @default 'Content'
         */
        heightAdjustMode?: HeightStyles;
    
        /**
         * Specifies the Tab display mode when Tab content exceeds the viewing area.
         * The possible modes are:
         * - Scrollable: All the elements are displayed in a single line with horizontal scrolling enabled.
         * - Popup: Tab container holds the items that can be placed within the available space and rest of the items are moved to the popup.
         * If the popup content overflows the height of the page, the rest of the elements can be viewed by scrolling the popup.
         * @default 'Scrollable'
         */
        overflowMode?: OverflowMode;
    
        /**
         * Specifies the direction of the Tab. For the culture like Arabic, direction can be switched as right-to-left.
         * @default false
         */
        enableRtl?: boolean;
    
        /**
         * Enable or disable persisting component's state between page reloads. 
         * If enabled, following list of states will be persisted.
         * 1. selectedItem
         * @default false.
         */
        enablePersistence?: boolean;
    
        /**
         * Specifies whether to show the close button for header items to remove the item from the Tab.
         * @default false
         */
        showCloseButton?: boolean;
    
        /**
         * Specifies the animation configuration settings while showing the content of the Tab.
         * @default 
         * { previous: { effect: 'SlideLeftIn', duration: 600, easing: 'ease' },
         *   next: { effect: 'SlideRightIn', duration: 600, easing: 'ease' } }
         */
        animation?: TabAnimationSettingsModel;
    
        /**
         * The event will be fired once the component rendering is completed.
         * @event
         */
        created?: ej.base.EmitType<Event>;
    
        /**
         * The event will be fired before adding the item to the Tab.
         * @event
         */
        adding?: ej.base.EmitType<Event>;
    
        /**
         * The event will be fired after adding the item to the Tab.
         * @event
         */
        added?: ej.base.EmitType<Event>;
    
        /**
         * The event will be fired before the item gets selected.
         * @event
         */
        selecting?: ej.base.EmitType<SelectEventArgs>;
    
        /**
         * The event will be fired after the item gets selected.
         * @event
         */
        selected?: ej.base.EmitType<SelectEventArgs>;
    
        /**
         * The event will be fired before removing the item from the Tab.
         * @event
         */
        removing?: ej.base.EmitType<RemoveEventArgs>;
    
        /**
         * The event will be fired after removing the item from the Tab.
         * @event
         */
        removed?: ej.base.EmitType<RemoveEventArgs>;
    
        /**
         * The event will be fired when the component gets destroyed.
         * @event
         */
        destroyed?: ej.base.EmitType<Event>;
    
    }
    
    /**
     * Options to set the orientation of Tab header.
     */
    export type HeaderPosition = 'Top' | 'Bottom';
    /**
     * Options to set the content element height adjust modes.
     */
    export type HeightStyles = 'None' | 'Auto' | 'Content' | 'Fill';
    export interface SelectEventArgs extends ej.base.BaseEventArgs {
        /** Defines the previous Tab item element. */
        previousItem: HTMLElement;
        /** Defines the previous Tab item index. */
        previousIndex: number;
        /** Defines the selected Tab item element. */
        selectedItem: HTMLElement;
        /** Defines the selected Tab item index. */
        selectedIndex: number;
        /** Defines the content selection done through swiping. */
        isSwiped: boolean;
        /** Defines the prevent action. */
        cancel?: boolean;
    }
    export interface RemoveEventArgs extends ej.base.BaseEventArgs {
        /** Defines the removed Tab item element. */
        removedItem: HTMLElement;
        /** Defines the removed Tab item index. */
        removedIndex: number;
    }
    export class TabActionSettings extends ej.base.ChildProperty<TabActionSettings> {
        /**
         * Specifies the animation effect for displaying Tab content.
         * @default : 'SlideLeftIn'
         */
        effect: 'None' | ej.base.Effect;
        /**
         * Specifies the time duration to transform content.
         * @default : 600
         */
        duration: number;
        /**
         * Specifies easing effect applied while transforming content.
         * @default : 'ease'
         */
        easing: string;
    }
    export class TabAnimationSettings extends ej.base.ChildProperty<TabAnimationSettings> {
        /**
         * Specifies the animation to appear while moving to previous Tab content.
         * @default { effect: 'SlideLeftIn', duration: 600, easing: 'ease' }
         */
        previous: TabActionSettingsModel;
        /**
         * Specifies the animation to appear while moving to next Tab content.
         * @default { effect: 'SlideRightIn', duration: 600, easing: 'ease' }
         */
        next: TabActionSettingsModel;
    }
    /**
     * Objects used for configuring the Tab item header properties.
     */
    export class Header extends ej.base.ChildProperty<Header> {
        /**
         * Specifies the display text of the Tab item header.
         * @default ''
         */
        text: string | HTMLElement;
        /**
         * Specifies the icon class that is used to render an icon in the Tab header.
         * @default ''
         */
        iconCss: string;
        /**
         * Options for positioning the icon in the Tab item header. This property depends on `iconCss` property.
         * The possible values are:
         * - Left: Places the icon to the `left` of the item.
         * - Top: Places the icon on the `top` of the item.
         * - Right: Places the icon to the `right` end of the item.
         * - Bottom: Places the icon at the `bottom` of the item.
         * @default 'left'
         */
        iconPosition: string;
    }
    /**
     * An array of object that is used to configure the Tab.
     */
    export class TabItem extends ej.base.ChildProperty<TabItem> {
        /**
         * The object used for configuring the Tab item header properties.
         * @default {}
         */
        header: HeaderModel;
        /**
         * Specifies the content of Tab item, that is displayed when concern item header is selected.
         * @default ''
         */
        content: string | HTMLElement;
        /**
         * Sets the CSS classes to the Tab item to customize its styles.
         * @default ''
         */
        cssClass: string;
        /**
         * Sets true to disable user interactions of the Tab item.
         * @default false
         */
        disabled: boolean;
    }
    /**
     * Tab is a content panel to show multiple contents in a single space, one at a time.
     * Each Tab item has an associated content, that will be displayed based on the active Tab header item.
     * ```html
     * <div id="tab"></div>
     * <script>
     *   var tabObj = new Tab();
     *   tab.appendTo("#tab");
     * </script>
     * ```
     */
    export class Tab extends ej.base.Component<HTMLElement> implements ej.base.INotifyPropertyChanged {
        private hdrEle;
        private cntEle;
        private tbObj;
        private tbItems;
        private tbItem;
        private tbPop;
        private isTemplate;
        private isPopup;
        private isReplace;
        private prevIndex;
        private prevItem;
        private popEle;
        private actEleId;
        private bdrLine;
        private popObj;
        private btnCls;
        private cnt;
        private show;
        private hide;
        private enableAnimation;
        private keyModule;
        private tabKeyModule;
        private touchModule;
        private animateOptions;
        private animObj;
        private maxHeight;
        private title;
        private initRender;
        private prevActiveEle;
        private isSwipeed;
        private isNested;
        private templateEle;
        /**
         * Contains the keyboard configuration of the Tab.
         */
        private keyConfigs;
        /**
         * An array of object that is used to configure the Tab component.
         * ```typescript
         *   let tabObj: Tab = new Tab( {
         *     items: [
         *       { header: { text: 'TabItem1' }, content: 'Tab Item1 Content' },
         *       { header: { text: 'TabItem2' }, content: 'Tab Item2 Content' }
         *     ]
         *   });
         *   tabObj.appendTo('#tab');
         * ```
         * @default []
         */
        items: TabItemModel[];
        /**
         * Specifies the width of the Tab component. Default, Tab width sets based on the width of its parent.
         * @default '100%'
         */
        width: string | number;
        /**
         * Specifies the height of the Tab component. By default, Tab height is set based on the height of its parent.
         * To use height property, heightAdjustMode must be set to 'None'.
         * @default 'auto'
         */
        height: string | number;
        /**
         * Sets the CSS classes to root element of the Tab that helps to customize component styles.
         * @default ''
         */
        cssClass: string;
        /**
         * Specifies the index for activating the current Tab item.
         * ```typescript
         *   let tabObj: Tab = new Tab( {
         *     selectedItem: 1,
         *     items: [
         *       { header: { text: 'TabItem1' }, content: 'Tab Item1 Content' },
         *       { header: { text: 'TabItem2' }, content: 'Tab Item2 Content' }
         *     ]
         *   });
         *   tabObj.appendTo('#tab');
         * ```
         * @default 0
         */
        selectedItem: number;
        /**
         * Specifies the orientation of Tab header.
         * The possible values are:
         * - Top: Places the Tab header on the top.
         * - Bottom: Places the Tab header at the bottom.
         * @default 'Top'
         */
        headerPlacement: HeaderPosition;
        /**
         * Specifies the height style for Tab content.
         * The possible values are:
         * - None: Based on the given height property, the content panel height is set.
         * - Auto: Tallest panel height of a given Tab content is set to all the other panels.
         * - Content: Based on the corresponding content height, the content panel height is set.
         * - Fill: Based on the parent height, the content panel hight is set.
         * @default 'Content'
         */
        heightAdjustMode: HeightStyles;
        /**
         * Specifies the Tab display mode when Tab content exceeds the viewing area.
         * The possible modes are:
         * - Scrollable: All the elements are displayed in a single line with horizontal scrolling enabled.
         * - Popup: Tab container holds the items that can be placed within the available space and rest of the items are moved to the popup.
         * If the popup content overflows the height of the page, the rest of the elements can be viewed by scrolling the popup.
         * @default 'Scrollable'
         */
        overflowMode: OverflowMode;
        /**
         * Specifies the direction of the Tab. For the culture like Arabic, direction can be switched as right-to-left.
         * @default false
         */
        enableRtl: boolean;
        /**
         * Enable or disable persisting component's state between page reloads.
         * If enabled, following list of states will be persisted.
         * 1. selectedItem
         * @default false.
         */
        enablePersistence: boolean;
        /**
         * Specifies whether to show the close button for header items to remove the item from the Tab.
         * @default false
         */
        showCloseButton: boolean;
        /**
         * Specifies the animation configuration settings while showing the content of the Tab.
         * @default
         * { previous: { effect: 'SlideLeftIn', duration: 600, easing: 'ease' },
         *   next: { effect: 'SlideRightIn', duration: 600, easing: 'ease' } }
         */
        animation: TabAnimationSettingsModel;
        /**
         * The event will be fired once the component rendering is completed.
         * @event
         */
        created: ej.base.EmitType<Event>;
        /**
         * The event will be fired before adding the item to the Tab.
         * @event
         */
        adding: ej.base.EmitType<Event>;
        /**
         * The event will be fired after adding the item to the Tab.
         * @event
         */
        added: ej.base.EmitType<Event>;
        /**
         * The event will be fired before the item gets selected.
         * @event
         */
        selecting: ej.base.EmitType<SelectEventArgs>;
        /**
         * The event will be fired after the item gets selected.
         * @event
         */
        selected: ej.base.EmitType<SelectEventArgs>;
        /**
         * The event will be fired before removing the item from the Tab.
         * @event
         */
        removing: ej.base.EmitType<RemoveEventArgs>;
        /**
         * The event will be fired after removing the item from the Tab.
         * @event
         */
        removed: ej.base.EmitType<RemoveEventArgs>;
        /**
         * The event will be fired when the component gets destroyed.
         * @event
         */
        destroyed: ej.base.EmitType<Event>;
        /**
         * Removes the component from the DOM and detaches all its related event handlers, attributes and classes.
         * @returns void
         */
        destroy(): void;
        /**
         * Initialize component
         * @private
         */
        protected preRender(): void;
        /**
         * Initializes a new instance of the Tab class.
         * @param options  - Specifies Tab model properties as options.
         * @param element  - Specifies the element that is rendered as a Tab.
         */
        constructor(options?: TabModel, element?: string | HTMLElement);
        /**
         * Initialize the component rendering
         * @private
         */
        protected render(): void;
        private renderContainer();
        private renderHeader();
        private renderContent();
        private parseObject(items, index);
        private removeActiveClass(id);
        private checkPopupOverflow(ele);
        private popupHandler(target);
        private setCloseButton(val);
        private prevCtnAnimation(prev, current);
        private triggerPrevAnimation(oldCnt, prevIndex);
        private triggerAnimation(id, value);
        private keyPressed(trg);
        private getEleIndex(item);
        private extIndex(id);
        private expTemplateContent();
        private templateCompile(ele, cnt);
        private getContent(ele, index, callType);
        private getTrgContent(cntEle, no);
        private findEle(items, key);
        private setOrientation(place, ele);
        private setCssClass(ele, cls, val);
        private setContentHeight(val);
        private getHeight(ele);
        private setActiveBorder();
        private setActive(value);
        private setItems(items);
        private setRTL(value);
        private refreshActiveBorder();
        private wireEvents();
        private unWireEvents();
        private clickHandler(args);
        private swipeHandler(e);
        private spaceKeyDown(e);
        private keyHandler(e);
        private refreshActElePosition();
        private refreshItemVisibility(target);
        private hoverHandler(e);
        /**
         * Enables or disables the specified Tab item. On passing value as `false`, the item will be disabled.
         * @param  {number} index - Index value of target Tab item.
         * @param  {boolean} value - Boolean value that determines whether the command should be enabled or disabled.
         * By default, isEnable is true.
         * @returns void.
         */
        enableTab(index: number, value: boolean): void;
        /**
         * Adds new items to the Tab that accepts an array as Tab items.
         * @param  {TabItemsModel[]} items - An array of item that is added to the Tab.
         * @param  {number} index - Number value that determines where the items to be added. By default, index is 0.
         * @returns void.
         */
        addTab(items: TabItemModel[], index?: number): void;
        /**
         * Removes the items in the Tab from the specified index.
         * @param  {number} index - Index of target item that is going to be removed.
         * @returns void.
         */
        removeTab(index: number): void;
        /**
         * Shows or hides the Tab that is in the specified index.
         * @param  {number} index - Index value of target item.
         * @param  {boolean} value - Based on this Boolean value, item will be hide (false) or show (true). By default, value is true.
         * @returns void.
         */
        hideTab(index: number, value?: boolean): void;
        /**
         * Specifies the index or HTMLElement to select an item from the Tab.
         * @param  {number | HTMLElement} args - Index or DOM element is used for selecting an item from the Tab.
         * @returns void.
         */
        select(args: number | HTMLElement): void;
        /**
         * Specifies the value to disable/enable the Tab component.
         * When set to `true`, the component will be disabled.
         * @param  {boolean} value - Based on this Boolean value, Tab will be enabled (false) or disabled (true).
         * @returns void.
         */
        disable(value: boolean): void;
        /**
         * Get the properties to be maintained in the persisted state.
         * @returns string
         */
        protected getPersistData(): string;
        /**
         * Returns the current module name.
         * @returns string
         * @private
         */
        protected getModuleName(): string;
        /**
         * Gets called when the model property changes.The data that describes the old and new values of the property that changed.
         * @param  {TabModel} newProp
         * @param  {TabModel} oldProp
         * @returns void
         * @private
         */
        onPropertyChanged(newProp: TabModel, oldProp: TabModel): void;
    }
    
    /**
     * Interface for a class Item
     */
    export interface ItemModel {
    
        /**
         * Specifies the unique ID to be used with button or input element of Toolbar items.
         * @default ""
         */
        id?: string;
    
        /**
         * Specifies the text to be displayed on the Toolbar button.
         * @default ""
         */
        text?: string;
    
        /**
         * Specifies the width of the Toolbar button commands.
         * @default 'auto'
         */
        width?: number | string;
    
        /**
         * Defines single/multiple classes (separated by space) to be used for customization of commands.
         * @default ""
         */
        cssClass?: string;
    
        /**
         * Defines the priority of items to display it in popup always.
         * It allows to maintain toolbar item on popup always but it does not work for toolbar priority items.
         * @default false
         */
        showAlwaysInPopup?: boolean;
    
        /**
         * Defines single/multiple classes separated by space used to specify an icon for the button.
         * The icon will be positioned before the text content if text is available, otherwise the icon alone will be rendered.
         * @default ""
         */
        prefixIcon?: string;
    
        /**
         * Defines single/multiple classes separated by space used to specify an icon for the button.
         * The icon will be positioned after the text content if text is available.
         * @default ""
         */
        suffixIcon?: string;
    
        /**
         * Specifies the Toolbar command display area when an element's content is too large to fit available space.
         * This is applicable only to `popup` mode. Possible values are:
         * - show:  Always shows the item as the primary priority on the *Toolbar*.
         * - hide: Always shows the item as the secondary priority on the *popup*.
         * - none: No priority for display, and as per normal order moves to popup when content exceeds.
         * @default 'None'
         */
        overflow?: OverflowOption;
    
        /**
         * Specifies the HTML element/element ID as a string that can be added as a Toolbar command.
         * ```
         * E.g - items: [{ template: '<input placeholder="Search"/>' },{ template: '#checkbox1' }]
         * ```
         * @default ""
         */
        template?: string | Object;
    
        /**
         * Specifies the types of command to be rendered in the Toolbar.
         * Supported types are:
         * - Button: Creates the Button control with its given properties like text, prefixIcon, etc.
         * - Separator: Adds a horizontal line that separates the Toolbar commands.
         * - Input: Creates an input element that is applicable to template rendering with Syncfusion controls like DropDownList,
         * AutoComplete, etc.
         * @default 'Button'
         */
        type?: ItemType;
    
        /**
         * Specifies where the button text will be displayed on *popup mode* of the Toolbar.
         * Possible values are:
         * - Toolbar:  Text will be displayed on *Toolbar* only.
         * - Overflow: Text will be displayed only when content overflows to *popup*.
         * - Both: Text will be displayed on *popup* and *Toolbar*.
         * @default 'Both'
         */
        showTextOn?: DisplayMode;
    
        /**
         * Defines htmlAttributes used to add custom attributes to Toolbar command.
         * Supports HTML attributes such as style, class, etc.
         * @default 'null'
         */
        htmlAttributes?: { [key: string]: string; };
    
        /**
         * Specifies the text to be displayed on the Toolbar button.
         * @default ""
         */
        tooltipText?: string;
    
        /**
         * Specifies the location for aligning Toolbar items on the Toolbar. Each command will be aligned according to the `align` property.
         * Possible values are:
         * - Left: To align commands to the left side of the Toolbar.
         * - Center: To align commands at the center of the Toolbar.
         * - Right: To align commands to the right side of the Toolbar.
         * ```html
         * <div id="element"> </div>
         * ```
         * ```typescript
         * let toolbar: Toolbar = new Toolbar({
         *     items: [
         *         { text: "Home" },
         *         { text: "My Home Page" , align: 'Center' },
         *         { text: "Search", align: 'Right' }
         *         { text: "Settings", align: 'Right' }
         *     ]
         * });
         * toolbar.appendTo('#element');
         * ```
         * @default "Left"
         */
        align?: ItemAlign;
    
    }
    
    /**
     * Interface for a class Toolbar
     */
    export interface ToolbarModel extends ej.base.ComponentModel{
    
        /**
         * An array of items that is used to configure Toolbar commands.
         * @default []
         */
        items?: ej.navigations.ItemModel[];
    
        /**
         * Specifies the width of the Toolbar in pixels/numbers/percentage. Number value is considered as pixels.
         * @default 'auto'
         */
        width?: string | number;
    
        /**
         * Specifies the height of the Toolbar in pixels/number/percentage. Number value is considered as pixels.
         * @default 'auto'
         */
        height?: string | number;
    
        /**
         * Specifies the Toolbar display mode when Toolbar content exceeds the viewing area.
         * Possible modes are:
         * - Scrollable: All the elements are displayed in a single line with horizontal scrolling enabled.
         * - Popup: Prioritized elements are displayed on the Toolbar and the rest of elements are moved to the *popup*.
         * If the popup content overflows the height of the page, the rest of the elements will be hidden.
         * @default 'Scrollable'
         */
        overflowMode?: OverflowMode;
    
        /**
         * Specifies the direction of the Toolbar commands. For cultures like Arabic, Hebrew, etc. direction can be switched to right to left.
         * @default 'false'
         */
        enableRtl?: boolean;
    
        /**
         * The event will be fired on clicking the Toolbar elements.
         * @event
         */
        clicked?: ej.base.EmitType<ClickEventArgs>;
    
        /**
         * The event will be fired when the control is rendered.
         * @event
         */
        created?: ej.base.EmitType<Event>;
    
        /**
         * The event will be fired when the control gets destroyed.
         * @event
         */
        destroyed?: ej.base.EmitType<Event>;
    
        /**
         * The event will be fired before the control is rendered on a page.
         * @event
         */
        beforeCreate?: ej.base.EmitType<Event>;
    
    }
    
    /**
     * Specifies the options for supporting element types of Toolbar command.
     */
    export type ItemType = 'Button' | 'Separator' | 'Input';
    /**
     * Specifies the options of where the text will be displayed in popup mode of the Toolbar.
     */
    export type DisplayMode = 'Both' | 'Overflow' | 'Toolbar';
    /**
     * Specifies the options of the Toolbar item display area when the Toolbar content overflows to available space.Applicable to `popup` mode.
     */
    export type OverflowOption = 'None' | 'Show' | 'Hide';
    /**
     * Specifies the options of Toolbar display mode. Display option is considered when Toolbar content exceeds the available space.
     */
    export type OverflowMode = 'Scrollable' | 'Popup';
    export type ItemAlign = 'Left' | 'Center' | 'Right';
    export interface ClickEventArgs extends ej.base.BaseEventArgs {
        /** Defines the current Toolbar Item Object. */
        item: ItemModel;
        /** Defines the current Event arguments. */
        originalEvent: Event;
        /** Defines the prevent action. */
        cancel?: boolean;
    }
    /**
     * An item object that is used to configure Toolbar commands.
     */
    export class Item extends ej.base.ChildProperty<Item> {
        /**
         * Specifies the unique ID to be used with button or input element of Toolbar items.
         * @default ""
         */
        id: string;
        /**
         * Specifies the text to be displayed on the Toolbar button.
         * @default ""
         */
        text: string;
        /**
         * Specifies the width of the Toolbar button commands.
         * @default 'auto'
         */
        width: number | string;
        /**
         * Defines single/multiple classes (separated by space) to be used for customization of commands.
         * @default ""
         */
        cssClass: string;
        /**
         * Defines the priority of items to display it in popup always.
         * It allows to maintain toolbar item on popup always but it does not work for toolbar priority items.
         * @default false
         */
        showAlwaysInPopup: boolean;
        /**
         * Defines single/multiple classes separated by space used to specify an icon for the button.
         * The icon will be positioned before the text content if text is available, otherwise the icon alone will be rendered.
         * @default ""
         */
        prefixIcon: string;
        /**
         * Defines single/multiple classes separated by space used to specify an icon for the button.
         * The icon will be positioned after the text content if text is available.
         * @default ""
         */
        suffixIcon: string;
        /**
         * Specifies the Toolbar command display area when an element's content is too large to fit available space.
         * This is applicable only to `popup` mode. Possible values are:
         * - show:  Always shows the item as the primary priority on the *Toolbar*.
         * - hide: Always shows the item as the secondary priority on the *popup*.
         * - none: No priority for display, and as per normal order moves to popup when content exceeds.
         * @default 'None'
         */
        overflow: OverflowOption;
        /**
         * Specifies the HTML element/element ID as a string that can be added as a Toolbar command.
         * ```
         * E.g - items: [{ template: '<input placeholder="Search"/>' },{ template: '#checkbox1' }]
         * ```
         * @default ""
         */
        template: string | Object;
        /**
         * Specifies the types of command to be rendered in the Toolbar.
         * Supported types are:
         * - Button: Creates the Button control with its given properties like text, prefixIcon, etc.
         * - Separator: Adds a horizontal line that separates the Toolbar commands.
         * - Input: Creates an input element that is applicable to template rendering with Syncfusion controls like DropDownList,
         * AutoComplete, etc.
         * @default 'Button'
         */
        type: ItemType;
        /**
         * Specifies where the button text will be displayed on *popup mode* of the Toolbar.
         * Possible values are:
         * - Toolbar:  Text will be displayed on *Toolbar* only.
         * - Overflow: Text will be displayed only when content overflows to *popup*.
         * - Both: Text will be displayed on *popup* and *Toolbar*.
         * @default 'Both'
         */
        showTextOn: DisplayMode;
        /**
         * Defines htmlAttributes used to add custom attributes to Toolbar command.
         * Supports HTML attributes such as style, class, etc.
         * @default 'null'
         */
        htmlAttributes: {
            [key: string]: string;
        };
        /**
         * Specifies the text to be displayed on the Toolbar button.
         * @default ""
         */
        tooltipText: string;
        /**
         * Specifies the location for aligning Toolbar items on the Toolbar. Each command will be aligned according to the `align` property.
         * Possible values are:
         * - Left: To align commands to the left side of the Toolbar.
         * - Center: To align commands at the center of the Toolbar.
         * - Right: To align commands to the right side of the Toolbar.
         * ```html
         * <div id="element"> </div>
         * ```
         * ```typescript
         * let toolbar: Toolbar = new Toolbar({
         *     items: [
         *         { text: "Home" },
         *         { text: "My Home Page" , align: 'Center' },
         *         { text: "Search", align: 'Right' }
         *         { text: "Settings", align: 'Right' }
         *     ]
         * });
         * toolbar.appendTo('#element');
         * ```
         * @default "Left"
         */
        align: ItemAlign;
    }
    /**
     * The Toolbar control contains a group of commands that are aligned horizontally.
     * ```html
     * <div id="toolbar"/>
     * <script>
     *   var toolbarObj = new Toolbar();
     *   toolbarObj.appendTo("#toolbar");
     * </script>
     * ```
     */
    export class Toolbar extends ej.base.Component<HTMLElement> implements ej.base.INotifyPropertyChanged {
        private trgtEle;
        private ctrlTem;
        /** @hidden */
        private popObj;
        /** @hidden */
        private tbarEle;
        /** @hidden */
        private tbarAlgEle;
        /** @hidden */
        private tbarAlign;
        /** @hidden */
        private tbarEleMrgn;
        /** @hidden */
        private tbResize;
        private offsetWid;
        private keyModule;
        private scrollModule;
        private activeEle;
        private popupPriCount;
        private tbarItemsCol;
        /**
         * Contains the keyboard configuration of the Toolbar.
         */
        private keyConfigs;
        /**
         * An array of items that is used to configure Toolbar commands.
         * @default []
         */
        items: ej.navigations.ItemModel[];
        /**
         * Specifies the width of the Toolbar in pixels/numbers/percentage. Number value is considered as pixels.
         * @default 'auto'
         */
        width: string | number;
        /**
         * Specifies the height of the Toolbar in pixels/number/percentage. Number value is considered as pixels.
         * @default 'auto'
         */
        height: string | number;
        /**
         * Specifies the Toolbar display mode when Toolbar content exceeds the viewing area.
         * Possible modes are:
         * - Scrollable: All the elements are displayed in a single line with horizontal scrolling enabled.
         * - Popup: Prioritized elements are displayed on the Toolbar and the rest of elements are moved to the *popup*.
         * If the popup content overflows the height of the page, the rest of the elements will be hidden.
         * @default 'Scrollable'
         */
        overflowMode: OverflowMode;
        /**
         * Specifies the direction of the Toolbar commands. For cultures like Arabic, Hebrew, etc. direction can be switched to right to left.
         * @default 'false'
         */
        enableRtl: boolean;
        /**
         * The event will be fired on clicking the Toolbar elements.
         * @event
         */
        clicked: ej.base.EmitType<ClickEventArgs>;
        /**
         * The event will be fired when the control is rendered.
         * @event
         */
        created: ej.base.EmitType<Event>;
        /**
         * The event will be fired when the control gets destroyed.
         * @event
         */
        destroyed: ej.base.EmitType<Event>;
        /**
         * The event will be fired before the control is rendered on a page.
         * @event
         */
        beforeCreate: ej.base.EmitType<Event>;
        /**
         * Removes the control from the DOM and also removes all its related events.
         * @returns void.
         */
        destroy(): void;
        /**
         * Initialize the event handler
         * @private
         */
        protected preRender(): void;
        /**
         * Initializes a new instance of the Toolbar class.
         * @param options  - Specifies Toolbar model properties as options.
         * @param element  - Specifies the element that is rendered as a Toolbar.
         */
        constructor(options?: ToolbarModel, element?: string | HTMLElement);
        private wireEvents();
        private docKeyDown(e);
        private unwireEvents();
        private clearProperty();
        private docEvent(e);
        private destroyHScroll();
        private destroyItems();
        private destroyMode();
        private add(ele, val);
        private remove(ele, val);
        private elementFocus(ele);
        private clstElement(tbrNavChk, trgt);
        private keyHandling(clst, e, trgt, navChk, scrollChk);
        private keyActionHandler(e);
        private eleFocus(closest, pos);
        private clickHandler(e);
        private popupClickHandler(ele, popupNav, CLS_RTL);
        /**
         * To Initialize the control rendering
         * @private
         */
        protected render(): void;
        private initialize();
        private renderControl();
        private initHScroll(element, innerItems);
        private itemWidthCal(items);
        private checkOverflow(element, innerItem);
        /** @hidden */
        refreshOverflow(): void;
        private renderOverflowMode();
        private createPopupEle(ele, innerEle);
        private pushingPoppedEle(tbarObj, popupPri, ele, eleHeight);
        private createPopup();
        private popupInit(element, ele);
        private popupOpen(e);
        private popupClose(e);
        private checkPriority(ele, inEle, eleWidth, pre);
        private createPopupIcon(element);
        private tbarPriRef(inEle, indx, sepPri, el, des, elWid, wid, ig);
        private popupRefresh(popupEle, destroy);
        private ignoreEleFetch(index, innerEle);
        private checkPopupRefresh(root, popEle);
        private popupEleWidth(el);
        private popupEleRefresh(width, popupEle, destroy);
        private removePositioning();
        private refreshPositioning();
        private itemPositioning();
        private tbarItemAlign(item, itemEle, pos);
        private ctrlTemplate();
        private renderItems();
        private setAttr(attr, element);
        /**
         * Enables or disables the specified Toolbar item.
         * @param  {HTMLElement|NodeList} items - DOM element or an array of items to be enabled or disabled.
         * @param  {boolean} isEnable  - Boolean value that determines whether the command should be enabled or disabled.
         * By default, `isEnable` is set to true.
         * @returns void.
         */
        enableItems(items: HTMLElement | NodeList, isEnable?: boolean): void;
        /**
         * Adds new items to the Toolbar that accepts an array as Toolbar items.
         * @param  {ItemsModel[]} items - DOM element or an array of items to be added to the Toolbar.
         * @param  {number} index - Number value that determines where the command is to be added. By default, index is 0.
         * @returns void.
         */
        addItems(items: ej.navigations.ItemModel[], index?: number): void;
        /**
         * Removes the items from the Toolbar. Acceptable arguments are index of item/HTMLElement/node list.
         * @param  {number|HTMLElement|NodeList|HTMLElement[]} args
         * Index or DOM element or an Array of item which is to be removed from the Toolbar.
         * @returns void.
         */
        removeItems(args: number | HTMLElement | NodeList | Element | HTMLElement[]): void;
        private removeItemByIndex(index, innerItems);
        private templateRender(templateProp, innerEle, item);
        private buttonRendering(item, innerEle);
        private renderSubComponent(item);
        private itemClick(e);
        private activeEleSwitch(ele);
        private activeEleRemove(curEle);
        protected getPersistData(): string;
        /**
         * Returns the current module name.
         * @returns string
         * @private
         */
        protected getModuleName(): string;
        private itemsRerender(newProp);
        private resize();
        /**
         * Gets called when the model property changes.The data that describes the old and new values of the property that changed.
         * @param  {ToolbarModel} newProp
         * @param  {ToolbarModel} oldProp
         * @returns void
         * @private
         */
        onPropertyChanged(newProp: ToolbarModel, oldProp: ToolbarModel): void;
        /**
         * Shows or hides the Toolbar item that is in the specified index.
         * @param  {number} index - Index value of target item.
         * @param  {boolean} value - Based on this Boolean value, item will be hide (true) or show (false). By default, value is false.
         * @returns void.
         */
        hideItem(index: number, value?: boolean): void;
    }
    
    /**
     * Interface for a class FieldsSettings
     */
    export interface FieldsSettingsModel {
    
        /**
         * Binds the field settings for child nodes or mapping field for nested nodes objects that contain array of JSON objects.
         */
        child?: string | FieldsSettingsModel;
    
        /**
         * Specifies the array of JavaScript objects or instance of DataManager to populate the nodes.
         * @default []
         */
        dataSource?: ej.data.DataManager | { [key: string]: Object }[];
    
        /**
         * Specifies the mapping field for expand state of the TreeView node.
         */
        expanded?: string;
    
        /**
         * Specifies the mapping field for hasChildren to check whether a node has child nodes or not.
         */
        hasChildren?: string;
    
        /**
         * Specifies the mapping field for htmlAttributes to be added to the TreeView node.
         */
        htmlAttributes?: string;
    
        /**
         * Specifies the mapping field for icon class of each TreeView node that will be added before the text.
         */
        iconCss?: string;
    
        /**
         * Specifies the ID field mapped in dataSource.
         */
        id?: string;
    
        /**
         * Specifies the mapping field for image URL of each TreeView node where image will be added before the text.
         */
        imageUrl?: string;
    
        /**
         * Specifies the field for checked state of the TreeView node.
         */
        isChecked?: string;
    
        /**
         * Specifies the parent ID field mapped in dataSource.
         */
        parentID?: string;
    
        /**
         * Defines the external [`Query`](http://ej2.syncfusion.com/documentation/data/api-query.html) 
         * that will execute along with data processing.    
         * @default null    
         */
        query?: ej.data.Query;
    
        /**
         * Specifies the mapping field for selected state of the TreeView node.
         */
        selected?: string;
    
        /**
         * Specifies the table name used to fetch data from a specific table in the server.
         */
        tableName?: string;
    
        /**
         * Specifies the mapping field for text displayed as TreeView node's display text.
         */
        text?: string;
    
        /**
         * Specifies the mapping field for tooltip that will be displayed as hovering text of the TreeView node.
         */
        tooltip?: string;
    
        /**
         * Specifies the mapping field for navigateUrl to be added as hyper-link of the TreeView node.
         */
        navigateUrl?: string;
    
    }
    
    /**
     * Interface for a class ActionSettings
     */
    export interface ActionSettingsModel {
    
        /**
         * Specifies the type of animation.
         * @default : 'SlideDown';
         */
        effect?: ej.base.Effect;
    
        /**
         * Specifies the duration to animate.
         * @default : 400;
         */
        duration?: number;
    
        /**
         * Specifies the animation timing function.
         * @default : 'linear';
         */
        easing?: string;
    
    }
    
    /**
     * Interface for a class NodeAnimationSettings
     */
    export interface NodeAnimationSettingsModel {
    
        /**
         * Specifies the animation that applies on collapsing the nodes.
         * @default { effect: 'SlideUp', duration: 400, easing: 'linear' }
         */
        collapse?: ActionSettingsModel;
    
        /**
         * Specifies the animation that applies on expanding the nodes.
         * @default { effect: 'SlideDown', duration: 400, easing: 'linear' }
         */
        expand?: ActionSettingsModel;
    
    }
    
    /**
     * Interface for a class TreeView
     */
    export interface TreeViewModel extends ej.base.ComponentModel{
    
        /**
         * Indicates whether the TreeView allows drag and drop of nodes. To drag and drop a node in
         * desktop, hold the mouse on the node, drag it to the target node and drop the node by releasing
         * the mouse. For touch devices, drag and drop operation is performed by touch, touch move
         * and touch end. For more information on drag and drop nodes concept, refer to 
         * [Drag and Drop](http://ej2.syncfusion.com/documentation/treeview/drag-and-drop.html).
         * @default false
         */
        allowDragAndDrop?: boolean;
    
        /**
         * Enables or disables editing of the text in the TreeView node. When `allowEditing` property is set 
         * to true, the TreeView allows you to edit the node by double clicking the node or by navigating to
         * the node and pressing **F2** key. For more information on node editing, refer
         * to [Node Editing](http://ej2.syncfusion.com/documentation/treeview/node-editing.html).
         * @default false
         */
        allowEditing?: boolean;
    
        /**
         * Enables or disables multi-selection of nodes. To select multiple nodes:
         * * Select the nodes by holding down the CTRL key while clicking on the nodes.
         * * Select consecutive nodes by clicking the first node to select and hold down the **SHIFT** key
         * and click the last node to select.
         * 
         * For more information on multi-selection, refer to 
         * [Multi-Selection](http://ej2.syncfusion.com/documentation/treeview/multi-selection.html).
         * @default false
         */
        allowMultiSelection?: boolean;
    
        /**
         * Specifies the type of animation applied on expanding and collapsing the nodes along with duration.
         * @default {expand: { effect: 'SlideDown', duration: 400, easing: 'linear' },
         * collapse: { effect: 'SlideUp', duration: 400, easing: 'linear' }}
         */
        animation?: NodeAnimationSettingsModel;
    
        /**
         * The `checkedNodes` property is used to determine the nodes to be checked or the nodes already checked in the TreeView component.
         * The `checkedNodes` property depends upon the value of `showCheckBox` property.
         * @default []
         */
        checkedNodes?: string[];
    
        /**
         * Specifies the CSS classes to be added with root element of the TreeView to help customize the appearance of the component.
         * @default ''
         */
        cssClass?: string;
    
        /**
         * Enables or disables persisting TreeView state between page reloads. If enabled, following states will persist.
         * 1. Selected Nodes
         * 2. Checked Nodes
         * @default false
         */
        enablePersistence?: boolean;
    
        /**
         * Enables or disables RTL mode on the component that displays the content in the right to left direction.
         * @default false
         */
        enableRtl?: boolean;
    
        /**
         * Specifies an action that determines whether the node can expand or collapse. The available actions are,
         * * `Auto` - The expand/collapse operation happens when you double-click the node in desktop, and when you single-click
         * the node in mobile devices.
         * * `Click` - The expand/collapse operation happens when you single-click the node in both desktop and mobile devices.
         * * `DblClick` - The expand/collapse operation happens when you double-click the node in both desktop and mobile devices.
         * @default 'Auto'
         */
        expandOn?: ExpandOnSettings;
    
        /**
         * Specifies the data source and mapping fields to render TreeView nodes.
         * @default {id: 'id', text: 'text', dataSource: [], child: 'child', parentID: 'parentID', hasChildren: 'hasChildren',
         *  expanded: 'expanded', htmlAttributes: 'htmlAttributes', iconCss: 'iconCss', imageUrl: 'imageUrl', isChecked: 'isChecked',
         *  query: null, selected: 'selected', tableName: null, tooltip: 'tooltip', navigateUrl: 'navigateUrl'}
         */
        fields?: FieldsSettingsModel;
    
        /**
         * Enables or disables the full node selection. If the `fullRowSelect` property is enabled, all the 
         * nodes will be selected by clicking its text.
         * @default true
         */
        fullRowSelect?: boolean;
    
        /**
         * Specifies a template to render customized content for all the nodes. If the `nodeTemplate` property 
         * is set, the template content overrides the displayed node text. The property accepts template string
         * [template string](http://ej2.syncfusion.com/documentation/base/template-engine.html) 
         * or HTML element ID holding the content. For more information on template concept, refer to
         * [Template](http://ej2.syncfusion.com/documentation/treeview/template.html).
         * @default null
         */
        nodeTemplate?: string;
    
        /**
         * Represents the selected nodes in the TreeView component. Nodes can be selected by clicking 
         * the text in the node. The `selectedNodes` property is used to determine the nodes to be selected or 
         * nodes already selected. The `selectedNodes` property depends upon the value of the 
         * `allowMultiSelection` property.
         * @default []
         */
        selectedNodes?: string[];
    
        /**
         * Specifies a value that indicates whether the nodes are sorted in the ascending or descending order,
         * or are not sorted at all. The available types of sort order are,
         * * `None` - The nodes are not sorted.
         * * `Ascending` - The nodes are sorted in the ascending order.
         * * `Descending` - The nodes are sorted in the ascending order.
         * @default 'None'
         */
        sortOrder?: SortOrder;
    
        /**
         * Indicates that the nodes will display CheckBoxes in the TreeView.
         * The CheckBox will be displayed next to the expand/collapse icon of the node. For more information on CheckBoxes, refer to
         * [CheckBox](http://ej2.syncfusion.com/documentation/treeview/checkbox.html).
         * @default false
         */
        showCheckBox?: boolean;
    
        /**
         * Triggers when the TreeView control is created successfully.
         * @event
         */
        created?: ej.base.EmitType<Object>;
    
        /**
         * Triggers when data source is populated in the TreeView.
         * @event 
         */
        dataBound?: ej.base.EmitType<DataBoundEventArgs>;
    
        /**
         * Triggers before the TreeView node is appended to the TreeView element. It helps to customize specific nodes.
         * @event
         */
        drawNode?: ej.base.EmitType<DrawNodeEventArgs>;
    
        /**
         * Triggers when the TreeView control is destroyed successfully.
         * @event
         */
        destroyed?: ej.base.EmitType<Object>;
    
        /**
         * Triggers when key press is successful. It helps to customize the operations at key press.
         * @event
         */
        keyPress?: ej.base.EmitType<NodeKeyPressEventArgs>;
    
        /**
         * Triggers when the TreeView node is checked/unchecked successfully.
         * @event 
         */
        nodeChecked?: ej.base.EmitType<NodeCheckEventArgs>;
    
        /**
         * Triggers before the TreeView node is to be checked/unchecked.
         * @event 
         */
        nodeChecking?: ej.base.EmitType<NodeCheckEventArgs>;
    
        /**
         * Triggers when the TreeView node is clicked successfully.
         * @event
         */
        nodeClicked?: ej.base.EmitType<NodeClickEventArgs>;
    
        /**
         * Triggers when the TreeView node collapses successfully.
         * @event 
         */
        nodeCollapsed?: ej.base.EmitType<NodeExpandEventArgs>;
    
        /**
         * Triggers before the TreeView node collapses.
         * @event 
         */
        nodeCollapsing?: ej.base.EmitType<NodeExpandEventArgs>;
    
        /**
         * Triggers when the TreeView node is dragged (moved) continuously.
         * @event 
         */
        nodeDragging?: ej.base.EmitType<DragAndDropEventArgs>;
    
        /**
         * Triggers when the TreeView node drag (move) starts.
         * @event 
         */
        nodeDragStart?: ej.base.EmitType<DragAndDropEventArgs>;
    
        /**
         * Triggers when the TreeView node drag (move) is stopped.
         * @event 
         */
        nodeDragStop?: ej.base.EmitType<DragAndDropEventArgs>;
    
        /**
         * Triggers when the TreeView node is dropped on target element successfully.
         * @event 
         */
        nodeDropped?: ej.base.EmitType<DragAndDropEventArgs>;
    
        /**
         * Triggers when the TreeView node is renamed successfully.
         * @event 
         */
        nodeEdited?: ej.base.EmitType<NodeEditEventArgs>;
    
        /**
         * Triggers before the TreeView node is renamed.
         * @event 
         */
        nodeEditing?: ej.base.EmitType<NodeEditEventArgs>;
    
        /**
         * Triggers when the TreeView node expands successfully.
         * @event 
         */
        nodeExpanded?: ej.base.EmitType<NodeExpandEventArgs>;
    
        /**
         * Triggers before the TreeView node is to be expanded.
         * @event 
         */
        nodeExpanding?: ej.base.EmitType<NodeExpandEventArgs>;
    
        /**
         * Triggers when the TreeView node is selected/unselected successfully.
         * @event 
         */
        nodeSelected?: ej.base.EmitType<NodeSelectEventArgs>;
    
        /**
         * Triggers before the TreeView node is selected/unselected.
         * @event 
         */
        nodeSelecting?: ej.base.EmitType<NodeSelectEventArgs>;
    
    }
    
    export interface EJ2Instance extends HTMLElement {
        ej2_instances: Object[];
    }
    export interface NodeExpandEventArgs {
        /**
         * If you want to cancel this event then, set cancel as true. Otherwise, false.
         */
        cancel: boolean;
        /**
         * If the event is triggered by interaction, it returns true. Otherwise, it returns false.
         */
        isInteracted: boolean;
        /**
         * Return the expanded/collapsed TreeView node.
         */
        node: HTMLLIElement;
        /**
         * Return the expanded/collapsed node as JSON object from data source.
         */
        nodeData: {
            [key: string]: Object;
        };
    }
    export interface NodeSelectEventArgs {
        /**
         * Return the name of action like select or un-select.
         */
        action: string;
        /**
         * If you want to cancel this event then, set cancel as true. Otherwise, false.
         */
        cancel: boolean;
        /**
         * If the event is triggered by interaction, it returns true. Otherwise, it returns false.
         */
        isInteracted: boolean;
        /**
         * Return the currently selected TreeView node.
         */
        node: HTMLLIElement;
        /**
         * Return the currently selected node as JSON object from data source.
         */
        nodeData: {
            [key: string]: Object;
        };
    }
    export interface NodeCheckEventArgs {
        /**
         * Return the name of action like check or un-check.
         */
        action: string;
        /**
         * If you want to cancel this event then, set cancel as true. Otherwise, false.
         */
        cancel: boolean;
        /**
         * If the event is triggered by interaction, it returns true. Otherwise, it returns false.
         */
        isInteracted: boolean;
        /**
         * Return the currently checked TreeView node.
         */
        node: HTMLLIElement;
        /**
         * Return the currently checked node as JSON object from data source.
         */
        data: {
            [key: string]: Object;
        }[];
    }
    export interface NodeEditEventArgs {
        /**
         * If you want to cancel this event then, set cancel as true. Otherwise, false.
         */
        cancel: boolean;
        /**
         * Return the current TreeView node new text.
         */
        newText: string;
        /**
         * Return the current TreeView node.
         */
        node: HTMLLIElement;
        /**
         * Return the current node as JSON object from data source.
         */
        nodeData: {
            [key: string]: Object;
        };
        /**
         * Return the current TreeView node old text.
         */
        oldText: string;
        /**
         * Gets or sets the inner HTML of TreeView node while editing.
         */
        innerHtml: string;
    }
    export interface DragAndDropEventArgs {
        /**
         * If you want to cancel this event then, set cancel as true. Otherwise, false.
         */
        cancel: boolean;
        /**
         * Return the actual event.
         */
        event: MouseEvent & TouchEvent;
        /**
         * Return the currently dragged TreeView node.
         */
        draggedNode: HTMLLIElement;
        /**
         * Return the currently dragged node as array of JSON object from data source.
         */
        draggedNodeData: {
            [key: string]: Object;
        };
        /**
         * Return the dropped TreeView node.
         */
        droppedNode: HTMLLIElement;
        /**
         * Return the dropped node as array of JSON object from data source.
         */
        droppedNodeData: {
            [key: string]: Object;
        };
        /**
         * Return the target element from which drag starts/end.
         */
        target: HTMLElement;
    }
    export interface DrawNodeEventArgs {
        /**
         * Return the current rendering node.
         */
        node: HTMLLIElement;
        /**
         * Return the current rendering node as JSON object.
         */
        nodeData: {
            [key: string]: Object;
        };
        /**
         * Return the current rendering node text.
         */
        text: string;
    }
    export interface NodeClickEventArgs {
        /**
         * Return the actual event.
         */
        event: MouseEvent;
        /**
         * Return the current clicked TreeView node.
         */
        node: HTMLLIElement;
    }
    export interface NodeKeyPressEventArgs {
        /**
         * If you want to cancel this event then, set cancel as true. Otherwise, false.
         */
        cancel: boolean;
        /**
         * Return the actual event.
         */
        event: ej.base.KeyboardEventArgs;
        /**
         * Return the current active TreeView node.
         */
        node: HTMLLIElement;
    }
    export interface DataBoundEventArgs {
        /**
         * Return the TreeView data.
         */
        data: {
            [key: string]: Object;
        }[];
    }
    export interface ItemCreatedArgs {
        curData: {
            [key: string]: Object;
        };
        item: HTMLElement;
        options: ej.lists.ListBaseOptions;
        text: string;
        fields: ej.lists.FieldsMapping;
    }
    /**
     * Configures the fields to bind to the properties of node in the TreeView component.
     */
    export class FieldsSettings extends ej.base.ChildProperty<FieldsSettings> {
        /**
         * Binds the field settings for child nodes or mapping field for nested nodes objects that contain array of JSON objects.
         */
        child: string | FieldsSettingsModel;
        /**
         * Specifies the array of JavaScript objects or instance of DataManager to populate the nodes.
         * @default []
         */
        dataSource: ej.data.DataManager | {
            [key: string]: Object;
        }[];
        /**
         * Specifies the mapping field for expand state of the TreeView node.
         */
        expanded: string;
        /**
         * Specifies the mapping field for hasChildren to check whether a node has child nodes or not.
         */
        hasChildren: string;
        /**
         * Specifies the mapping field for htmlAttributes to be added to the TreeView node.
         */
        htmlAttributes: string;
        /**
         * Specifies the mapping field for icon class of each TreeView node that will be added before the text.
         */
        iconCss: string;
        /**
         * Specifies the ID field mapped in dataSource.
         */
        id: string;
        /**
         * Specifies the mapping field for image URL of each TreeView node where image will be added before the text.
         */
        imageUrl: string;
        /**
         * Specifies the field for checked state of the TreeView node.
         */
        isChecked: string;
        /**
         * Specifies the parent ID field mapped in dataSource.
         */
        parentID: string;
        /**
         * Defines the external [`Query`](http://ej2.syncfusion.com/documentation/data/api-query.html)
         * that will execute along with data processing.
         * @default null
         */
        query: ej.data.Query;
        /**
         * Specifies the mapping field for selected state of the TreeView node.
         */
        selected: string;
        /**
         * Specifies the table name used to fetch data from a specific table in the server.
         */
        tableName: string;
        /**
         * Specifies the mapping field for text displayed as TreeView node's display text.
         */
        text: string;
        /**
         * Specifies the mapping field for tooltip that will be displayed as hovering text of the TreeView node.
         */
        tooltip: string;
        /**
         * Specifies the mapping field for navigateUrl to be added as hyper-link of the TreeView node.
         */
        navigateUrl: string;
    }
    export type ExpandOnSettings = 'Auto' | 'Click' | 'DblClick';
    export type SortOrder = 'None' | 'Ascending' | 'Descending';
    /**
     * Configures animation settings for the TreeView component.
     */
    export class ActionSettings extends ej.base.ChildProperty<ActionSettings> {
        /**
         * Specifies the type of animation.
         * @default : 'SlideDown';
         */
        effect: ej.base.Effect;
        /**
         * Specifies the duration to animate.
         * @default : 400;
         */
        duration: number;
        /**
         * Specifies the animation timing function.
         * @default : 'linear';
         */
        easing: string;
    }
    /**
     * Configures the animation settings for expanding and collapsing nodes in TreeView.
     */
    export class NodeAnimationSettings extends ej.base.ChildProperty<NodeAnimationSettings> {
        /**
         * Specifies the animation that applies on collapsing the nodes.
         * @default { effect: 'SlideUp', duration: 400, easing: 'linear' }
         */
        collapse: ActionSettingsModel;
        /**
         * Specifies the animation that applies on expanding the nodes.
         * @default { effect: 'SlideDown', duration: 400, easing: 'linear' }
         */
        expand: ActionSettingsModel;
    }
    /**
     * The TreeView component is used to represent hierarchical data in a tree like structure with advanced
     * functions to perform edit, drag and drop, selection with check-box, and more.
     * ```html
     *  <div id="tree"></div>
     * ```
     * ```typescript
     *  let treeObj: TreeView = new TreeView();
     *  treeObj.appendTo('#tree');
     * ```
     */
    export class TreeView extends ej.base.Component<HTMLElement> implements ej.base.INotifyPropertyChanged {
        private cloneElement;
        private treeData;
        private rootData;
        private groupedData;
        private ulElement;
        private listBaseOption;
        private dataType;
        private rippleFn;
        private rippleIconFn;
        private isNumberTypeId;
        private expandOnType;
        private keyboardModule;
        private liList;
        private aniObj;
        private treeList;
        private isLoaded;
        private expandArgs;
        private oldText;
        private dragObj;
        private dropObj;
        private dragTarget;
        private dragLi;
        private dragData;
        private startNode;
        private nodeTemplateFn;
        private currentLoadData;
        private checkActionNodes;
        private touchEditObj;
        private touchClickObj;
        private dragStartAction;
        private touchExpandObj;
        private inputObj;
        private isAnimate;
        private spinnerElement;
        private touchClass;
        private editData;
        private editFields;
        private keyConfigs;
        /**
         * Indicates whether the TreeView allows drag and drop of nodes. To drag and drop a node in
         * desktop, hold the mouse on the node, drag it to the target node and drop the node by releasing
         * the mouse. For touch devices, drag and drop operation is performed by touch, touch move
         * and touch end. For more information on drag and drop nodes concept, refer to
         * [Drag and Drop](http://ej2.syncfusion.com/documentation/treeview/drag-and-drop.html).
         * @default false
         */
        allowDragAndDrop: boolean;
        /**
         * Enables or disables editing of the text in the TreeView node. When `allowEditing` property is set
         * to true, the TreeView allows you to edit the node by double clicking the node or by navigating to
         * the node and pressing **F2** key. For more information on node editing, refer
         * to [Node Editing](http://ej2.syncfusion.com/documentation/treeview/node-editing.html).
         * @default false
         */
        allowEditing: boolean;
        /**
         * Enables or disables multi-selection of nodes. To select multiple nodes:
         * * Select the nodes by holding down the CTRL key while clicking on the nodes.
         * * Select consecutive nodes by clicking the first node to select and hold down the **SHIFT** key
         * and click the last node to select.
         *
         * For more information on multi-selection, refer to
         * [Multi-Selection](http://ej2.syncfusion.com/documentation/treeview/multi-selection.html).
         * @default false
         */
        allowMultiSelection: boolean;
        /**
         * Specifies the type of animation applied on expanding and collapsing the nodes along with duration.
         * @default {expand: { effect: 'SlideDown', duration: 400, easing: 'linear' },
         * collapse: { effect: 'SlideUp', duration: 400, easing: 'linear' }}
         */
        animation: NodeAnimationSettingsModel;
        /**
         * The `checkedNodes` property is used to determine the nodes to be checked or the nodes already checked in the TreeView component.
         * The `checkedNodes` property depends upon the value of `showCheckBox` property.
         * @default []
         */
        checkedNodes: string[];
        /**
         * Specifies the CSS classes to be added with root element of the TreeView to help customize the appearance of the component.
         * @default ''
         */
        cssClass: string;
        /**
         * Enables or disables persisting TreeView state between page reloads. If enabled, following states will persist.
         * 1. Selected Nodes
         * 2. Checked Nodes
         * @default false
         */
        enablePersistence: boolean;
        /**
         * Enables or disables RTL mode on the component that displays the content in the right to left direction.
         * @default false
         */
        enableRtl: boolean;
        /**
         * Specifies an action that determines whether the node can expand or collapse. The available actions are,
         * * `Auto` - The expand/collapse operation happens when you double-click the node in desktop, and when you single-click
         * the node in mobile devices.
         * * `Click` - The expand/collapse operation happens when you single-click the node in both desktop and mobile devices.
         * * `DblClick` - The expand/collapse operation happens when you double-click the node in both desktop and mobile devices.
         * @default 'Auto'
         */
        expandOn: ExpandOnSettings;
        /**
         * Specifies the data source and mapping fields to render TreeView nodes.
         * @default {id: 'id', text: 'text', dataSource: [], child: 'child', parentID: 'parentID', hasChildren: 'hasChildren',
         *  expanded: 'expanded', htmlAttributes: 'htmlAttributes', iconCss: 'iconCss', imageUrl: 'imageUrl', isChecked: 'isChecked',
         *  query: null, selected: 'selected', tableName: null, tooltip: 'tooltip', navigateUrl: 'navigateUrl'}
         */
        fields: FieldsSettingsModel;
        /**
         * Enables or disables the full node selection. If the `fullRowSelect` property is enabled, all the
         * nodes will be selected by clicking its text.
         * @default true
         */
        fullRowSelect: boolean;
        /**
         * Specifies a template to render customized content for all the nodes. If the `nodeTemplate` property
         * is set, the template content overrides the displayed node text. The property accepts template string
         * [template string](http://ej2.syncfusion.com/documentation/base/template-engine.html)
         * or HTML element ID holding the content. For more information on template concept, refer to
         * [Template](http://ej2.syncfusion.com/documentation/treeview/template.html).
         * @default null
         */
        nodeTemplate: string;
        /**
         * Represents the selected nodes in the TreeView component. Nodes can be selected by clicking
         * the text in the node. The `selectedNodes` property is used to determine the nodes to be selected or
         * nodes already selected. The `selectedNodes` property depends upon the value of the
         * `allowMultiSelection` property.
         * @default []
         */
        selectedNodes: string[];
        /**
         * Specifies a value that indicates whether the nodes are sorted in the ascending or descending order,
         * or are not sorted at all. The available types of sort order are,
         * * `None` - The nodes are not sorted.
         * * `Ascending` - The nodes are sorted in the ascending order.
         * * `Descending` - The nodes are sorted in the ascending order.
         * @default 'None'
         */
        sortOrder: SortOrder;
        /**
         * Indicates that the nodes will display CheckBoxes in the TreeView.
         * The CheckBox will be displayed next to the expand/collapse icon of the node. For more information on CheckBoxes, refer to
         * [CheckBox](http://ej2.syncfusion.com/documentation/treeview/checkbox.html).
         * @default false
         */
        showCheckBox: boolean;
        /**
         * Triggers when the TreeView control is created successfully.
         * @event
         */
        created: ej.base.EmitType<Object>;
        /**
         * Triggers when data source is populated in the TreeView.
         * @event
         */
        dataBound: ej.base.EmitType<DataBoundEventArgs>;
        /**
         * Triggers before the TreeView node is appended to the TreeView element. It helps to customize specific nodes.
         * @event
         */
        drawNode: ej.base.EmitType<DrawNodeEventArgs>;
        /**
         * Triggers when the TreeView control is destroyed successfully.
         * @event
         */
        destroyed: ej.base.EmitType<Object>;
        /**
         * Triggers when key press is successful. It helps to customize the operations at key press.
         * @event
         */
        keyPress: ej.base.EmitType<NodeKeyPressEventArgs>;
        /**
         * Triggers when the TreeView node is checked/unchecked successfully.
         * @event
         */
        nodeChecked: ej.base.EmitType<NodeCheckEventArgs>;
        /**
         * Triggers before the TreeView node is to be checked/unchecked.
         * @event
         */
        nodeChecking: ej.base.EmitType<NodeCheckEventArgs>;
        /**
         * Triggers when the TreeView node is clicked successfully.
         * @event
         */
        nodeClicked: ej.base.EmitType<NodeClickEventArgs>;
        /**
         * Triggers when the TreeView node collapses successfully.
         * @event
         */
        nodeCollapsed: ej.base.EmitType<NodeExpandEventArgs>;
        /**
         * Triggers before the TreeView node collapses.
         * @event
         */
        nodeCollapsing: ej.base.EmitType<NodeExpandEventArgs>;
        /**
         * Triggers when the TreeView node is dragged (moved) continuously.
         * @event
         */
        nodeDragging: ej.base.EmitType<DragAndDropEventArgs>;
        /**
         * Triggers when the TreeView node drag (move) starts.
         * @event
         */
        nodeDragStart: ej.base.EmitType<DragAndDropEventArgs>;
        /**
         * Triggers when the TreeView node drag (move) is stopped.
         * @event
         */
        nodeDragStop: ej.base.EmitType<DragAndDropEventArgs>;
        /**
         * Triggers when the TreeView node is dropped on target element successfully.
         * @event
         */
        nodeDropped: ej.base.EmitType<DragAndDropEventArgs>;
        /**
         * Triggers when the TreeView node is renamed successfully.
         * @event
         */
        nodeEdited: ej.base.EmitType<NodeEditEventArgs>;
        /**
         * Triggers before the TreeView node is renamed.
         * @event
         */
        nodeEditing: ej.base.EmitType<NodeEditEventArgs>;
        /**
         * Triggers when the TreeView node expands successfully.
         * @event
         */
        nodeExpanded: ej.base.EmitType<NodeExpandEventArgs>;
        /**
         * Triggers before the TreeView node is to be expanded.
         * @event
         */
        nodeExpanding: ej.base.EmitType<NodeExpandEventArgs>;
        /**
         * Triggers when the TreeView node is selected/unselected successfully.
         * @event
         */
        nodeSelected: ej.base.EmitType<NodeSelectEventArgs>;
        /**
         * Triggers before the TreeView node is selected/unselected.
         * @event
         */
        nodeSelecting: ej.base.EmitType<NodeSelectEventArgs>;
        constructor(options?: TreeViewModel, element?: string | HTMLElement);
        /**
         * Get component name.
         * @returns string
         * @private
         */
        getModuleName(): string;
        /**
         * Initialize the event handler
         */
        protected preRender(): void;
        /**
         * Get the properties to be maintained in the persisted state.
         * @returns string
         * @hidden
         */
        getPersistData(): string;
        /**
         * To Initialize the control rendering
         * @private
         */
        protected render(): void;
        private initialize();
        private setEnableRtl();
        private setRipple();
        private setFullRow(isEnabled);
        private setMultiSelect(isEnabled);
        private templateComplier(template);
        private setDataBinding();
        private getQuery(mapper, value?);
        private getType();
        private setRootData();
        private renderItems(isSorted);
        private beforeNodeCreate(e);
        private frameMouseHandler(e);
        private addActionClass(e, action, cssClass);
        private getDataType(ds, mapper);
        private getGroupedData(dataSource, groupBy);
        private getSortedData(list);
        private finalizeNode(element);
        private updateCheckedProp();
        private ensureParentCheckState(element);
        private ensureChildCheckState(element, e?);
        private doCheckBoxAction(nodes, doCheck);
        private changeState(wrapper, state, e?, isPrevent?, isAdd?);
        private addCheck(liEle);
        private removeCheck(liEle);
        private getCheckEvent(currLi, action, e);
        private finalize();
        private doSelectionAction();
        private selectGivenNodes(sNodes);
        private clickHandler(e);
        private nodeCheckingEvent(wrapper, isCheck, e);
        private nodeCheckedEvent(wrapper, isCheck, e);
        private triggerClickEvent(e, li);
        private expandNode(currLi, icon);
        private expandedNode(currLi, ul, icon);
        private collapseNode(currLi, icon, e);
        private setHeight(currLi, ul);
        private animateHeight(args, start, end);
        private renderChildNodes(parentLi, expandChild?);
        private ensureCheckNode(element);
        private getFields(mapper, nodeLevel, dataLevel);
        private getChildFields(mapper, nodeLevel, dataLevel);
        private getChildMapper(mapper);
        private getChildNodes(obj, parentId, isRoot?);
        private getChildGroup(data, parentId, isRoot);
        private renderSubChild(element, expandChild?);
        private toggleSelect(li, e, multiSelect?);
        private isActive(li);
        private selectNode(li, e, multiSelect?);
        private unselectNode(li, e);
        private setFocusElement(li);
        private addSelect(liEle);
        private removeSelect(liEle);
        private removeSelectAll();
        private getSelectEvent(currLi, action, e);
        private setExpandOnType();
        private expandHandler(e);
        private expandCollapseAction(currLi, e);
        private expandAction(currLi, icon, e, expandChild?);
        private keyActionHandler(e);
        private navigateToFocus(isUp);
        private isVisibleInViewport(txtWrap);
        private getScrollParent(node);
        private shiftKeySelect(isTowards, e);
        private checkNode(e);
        private validateCheckNode(checkWrap, isCheck, li, e);
        private openNode(toBeOpened, e);
        private navigateNode(isTowards);
        private navigateRootNode(isBackwards);
        private getFocusedNode();
        private focusNextNode(li, isTowards);
        private getNextNode(li);
        private getPrevNode(li);
        private getRootNode();
        private getEndNode();
        private setFocus(preNode, nextNode);
        private updateIdAttr(preNode, nextNode);
        private focusIn();
        private focusOut();
        private onMouseOver(e);
        private setHover(li);
        private onMouseLeave(e);
        private removeHover();
        private getNodeData(currLi, fromDS?);
        private getText(currLi, fromDS?);
        private getExpandEvent(currLi, e);
        private reRenderNodes();
        private setCssClass(oldClass, newClass);
        private editingHandler(e);
        private createTextbox(liEle, e);
        private updateOldText(liEle);
        private inputFocusOut(e);
        private appendNewText(liEle, txtEle, newText, isInput);
        private getElement(ele);
        private getEditEvent(liEle, newText, inpEle);
        private getNodeObject(id);
        private getChildNodeObject(obj, mapper, id);
        private setDragAndDrop(toBind);
        private initializeDrag();
        private dragAction(e, virtualEle);
        private dropAction(e);
        private appendNode(dropTarget, dragLi, dropLi, e, dragObj, offsetY);
        private dropAsSiblingNode(dragLi, dropLi, e, dragObj);
        private dropAsChildNode(dragLi, dropLi, dragObj, index?, e?, pos?);
        private expandParent(dropLi);
        private updateElement(dragParentUl, dragParentLi);
        private updateAriaLevel(dragLi);
        private updateChildAriaLevel(element, level);
        private renderVirtualEle(e);
        private removeVirtualEle();
        private destroyDrag();
        private getDragEvent(event, obj, dropTarget, target);
        private addFullRow(toAdd);
        private createFullRow(item);
        private addMultiSelect(toAdd);
        private collapseByLevel(element, level, excludeHiddenNodes);
        private collapseAllNodes(excludeHiddenNodes);
        private expandByLevel(element, level, excludeHiddenNodes);
        private expandAllNodes(excludeHiddenNodes);
        private getVisibleNodes(excludeHiddenNodes, nodes);
        private removeNode(node);
        private updateInstance();
        private updateList();
        private updateSelectedNodes();
        private doGivenAction(nodes, selector, toExpand);
        private addGivenNodes(nodes, dropLi, index, isRemote?);
        private updateMapper(level);
        private doDisableAction(nodes);
        private doEnableAction(nodes);
        private setTouchClass();
        private wireInputEvents(inpEle);
        private wireEditingEvents(toBind);
        private wireClickEvent(toBind);
        private wireExpandOnEvent(toBind);
        private mouseDownStatus;
        private mouseDownHandler(e);
        private preventContextMenu(e);
        private wireEvents();
        private unWireEvents();
        private parents(element, selector);
        private isDescendant(parent, child);
        protected showSpinner(element: HTMLElement): void;
        protected hideSpinner(element: HTMLElement): void;
        private setCheckedNodes(nodes);
        /**
         * Called internally if any of the property value changed.
         * @param  {TreeView} newProp
         * @param  {TreeView} oldProp
         * @returns void
         * @private
         */
        onPropertyChanged(newProp: TreeViewModel, oldProp: TreeViewModel): void;
        /**
         * Removes the component from the DOM and detaches all its related event handlers. It also removes the attributes and classes.
         */
        destroy(): void;
        /**
         * Adds the collection of TreeView nodes based on target and index position. If target node is not specified,
         * then the nodes are added as children of the given parentID or in the root level of TreeView.
         * @param  { Object[] } nodes - Specifies the array of JSON data that has to be added.
         * @param  { string | Element } target - Specifies ID of TreeView node/TreeView node as target element.
         * @param  { number } index - Specifies the index to place the newly added nodes in the target element.
         */
        addNodes(nodes: {
            [key: string]: Object;
        }[], target: string | Element, index: number): void;
        /**
         * Initiates the editing of the TreeView node
         * @param  {string | Element} node - Specifies ID of TreeView node/TreeView node.
         */
        beginEdit(node: string | Element): void;
        /**
         * Checks all the unchecked nodes. You can also check specific nodes by passing array of unchecked nodes
         * as argument to this method.
         * @param  {string[] | Element[]} nodes - Specifies the array of TreeView nodes ID/array of TreeView node.
         */
        checkAll(nodes?: string[] | Element[]): void;
        /**
         * Collapses all the expanded TreeView nodes. You can collapse specific nodes by passing array of nodes as argument to this method.
         * You can also collapse all the nodes excluding the hidden nodes by setting **excludeHiddenNodes** to true. If you want to collapse
         * a specific level of nodes, set **level** as argument to collapseAll method.
         * @param  {string[] | Element[]} nodes - Specifies the array of TreeView nodes ID/ array of TreeView node.
         * @param  {number} level - TreeView nodes will collapse up to the given level.
         * @param  {boolean} excludeHiddenNodes - Whether or not to exclude hidden nodes of TreeView when collapsing all nodes.
         */
        collapseAll(nodes?: string[] | Element[], level?: number, excludeHiddenNodes?: boolean): void;
        /**
         * Disables the collection of nodes by passing the ID of nodes or node elements in the array.
         * @param  {string[] | Element[]} nodes - Specifies the array of TreeView nodes ID/array of TreeView nodes.
         */
        disableNodes(nodes: string[] | Element[]): void;
        /**
         * Enables the collection of disabled nodes by passing the ID of nodes or node elements in the array.
         * @param  {string[] | Element[]} nodes - Specifies the array of TreeView nodes ID/array of TreeView nodes.
         */
        enableNodes(nodes: string[] | Element[]): void;
        /**
         * Ensures the node visibility and brings into view if the node is invisible by specifying the node's ID or node element.
         * The TreeView will expand and scroll to the specific node to bring it to visibility.
         * @param  {string | Element} node - Specifies ID of TreeView node/TreeView nodes.
         */
        ensureVisible(node: string | Element): void;
        /**
         * Expands all the collapsed TreeView nodes. You can expand the specific nodes by passing the array of collapsed nodes
         * as argument to this method. You can also expand all the collapsed nodes by excluding the hidden nodes by setting
         * **excludeHiddenNodes** to true to this method. To expand a specific level of nodes, set **level** as argument to expandAll method.
         * @param  {string[] | Element[]} nodes - Specifies the array of TreeView nodes ID/array of TreeView nodes.
         * @param  {number} level - TreeView nodes will expand up to the given level.
         * @param  {boolean} excludeHiddenNodes - Whether or not to exclude hidden nodes when expanding all nodes.
         */
        expandAll(nodes?: string[] | Element[], level?: number, excludeHiddenNodes?: boolean): void;
        /**
         * Get the node's data such as id, text, parentID, selected, isChecked, and expanded by passing the node element or it's ID.
         * @param  {string | Element} node - Specifies ID of TreeView node/TreeView node.
         */
        getNode(node: string | Element): {
            [key: string]: Object;
        };
        /**
         * Moves the collection of nodes within the same TreeView based on target or its index position.
         * @param  {string[] | Element[]} sourceNodes - Specifies the array of TreeView nodes ID/array of TreeView node.
         * @param  {string | Element} target - Specifies ID of TreeView node/TreeView node as target element.
         * @param  {number} index - Specifies the index to place the moved nodes in the target element.
         */
        moveNodes(sourceNodes: string[] | Element[], target: string | Element, index: number): void;
        /**
         * Removes the collection of TreeView nodes by passing the array of node details as argument to this method.
         * @param  {string[] | Element[]} nodes - Specifies the array of TreeView nodes ID/array of TreeView node.
         */
        removeNodes(nodes: string[] | Element[]): void;
        /**
         * Replaces the text of the TreeView node with the given text.
         * @param  {string | Element} target - Specifies ID of TreeView node/TreeView node as target element.
         * @param  {string} newText - Specifies the new text of TreeView node.
         */
        updateNode(target: string | Element, newText: string): void;
        /**
         * Unchecks all the checked nodes. You can also uncheck the specific nodes by passing array of checked nodes
         * as argument to this method.
         * @param  {string[] | Element[]} nodes - Specifies the array of TreeView nodes ID/array of TreeView node.
         */
        uncheckAll(nodes?: string[] | Element[]): void;
    }
    
  }
  export namespace pdfexport {
    
    /**
     * `PdfAction` class represents base class for all action types.
     * @private
     */
    export abstract class PdfAction implements IPdfWrapper {
        /**
         * Specifies the Next `action` to perform.
         * @private
         */
        private action;
        /**
         * Specifies the Internal variable to store `dictionary`.
         * @private
         */
        private pdfDictionary;
        /**
         * Specifies the Internal variable to store `dictionary properties`.
         * @private
         */
        protected dictionaryProperties: DictionaryProperties;
        /**
         * Initialize instance for `Action` class.
         * @private
         */
        protected constructor();
        /**
         * Gets and Sets the `Next` action to perform.
         * @private
         */
        next: PdfAction;
        /**
         * Gets and Sets the instance of PdfDictionary class for `Dictionary`.
         * @private
         */
        readonly dictionary: PdfDictionary;
        /**
         * `Initialize` the action type.
         * @private
         */
        protected initialize(): void;
        /**
         * Gets the `Element` as IPdfPrimitive class.
         * @private
         */
        readonly element: IPdfPrimitive;
    }
    
    /**
     * `PdfUriAction` class for initialize the uri related internals.
     * @private
     */
    export class PdfUriAction extends PdfAction {
        /**
         * Specifies the `uri` string.
         * @default ''.
         * @private
         */
        private uniformResourceIdentifier;
        /**
         * Initialize instance of `PdfUriAction` class.
         * @private
         */
        constructor();
        /**
         * Initialize instance of `PdfUriAction` class.
         * @private
         */
        constructor(uri: string);
        /**
         * Gets and Sets the value of `Uri`.
         * @private
         */
        uri: string;
        /**
         * `Initialize` the internals.
         * @private
         */
        protected initialize(): void;
    }
    
    /**
     * Represents base class for `link annotations` with associated action.
     * @private
     */
    export abstract class PdfActionLinkAnnotation extends PdfLinkAnnotation {
        /**
         * Internal variable to store annotation's `action`.
         * @default null
         * @private
         */
        private pdfAction;
        /**
         * Internal variable to store annotation's `Action`.
         * @private
         */
        abstract action: PdfAction;
        /**
         * Specifies the constructor for `ActionLinkAnnotation`.
         * @private
         */
        constructor(rectangle: RectangleF);
        /**
         * get and set the `action`.
         * @hidden
         */
        getSetAction(value?: PdfAction): PdfAction | void;
    }
    
    /**
     * `PdfAnnotationCollection` class represents the collection of 'PdfAnnotation' objects.
     * @private
     */
    export class PdfAnnotationCollection implements IPdfWrapper {
        /**
         * `Error` constant message.
         * @private
         */
        private alreadyExistsAnnotationError;
        /**
         * `Error` constant message.
         * @private
         */
        private missingAnnotationException;
        /**
         * Specifies the Internal variable to store fields of `PdfDictionaryProperties`.
         * @private
         */
        protected dictionaryProperties: DictionaryProperties;
        /**
         * Parent `page` of the collection.
         * @private
         */
        private page;
        /**
         * Array of the `annotations`.
         * @private
         */
        private internalAnnotations;
        /**
         * privte `list` for the annotations.
         * @private
         */
        lists: PdfAnnotation[];
        /**
         * Gets the `PdfAnnotation` object at the specified index. Read-Only.
         * @private
         */
        annotations: PdfArray;
        /**
         * Initializes a new instance of the `PdfAnnotationCollection` class.
         * @private
         */
        constructor();
        /**
         * Initializes a new instance of the `PdfAnnotationCollection` class with the specified page.
         * @private
         */
        constructor(page: PdfPage);
        /**
         * `Adds` a new annotation to the collection.
         * @private
         */
        add(annotation: PdfAnnotation): void | number;
        /**
         * `Adds` a Annotation to collection.
         * @private
         */
        protected doAdd(annotation: PdfAnnotation): void | number;
        /**
         * `Set a color of an annotation`.
         * @private
         */
        private setColor(annotation);
        /**
         * Gets the `Element` representing this object.
         * @private
         */
        readonly element: IPdfPrimitive;
    }
    
    /**
     * `PdfAnnotation` class represents the base class for annotation objects.
     * @private
     */
    export abstract class PdfAnnotation implements IPdfWrapper {
        /**
         * Specifies the Internal variable to store fields of `PdfDictionaryProperties`.
         * @private
         */
        protected dictionaryProperties: DictionaryProperties;
        /**
         * `Color` of the annotation
         * @private
         */
        private pdfColor;
        /**
         * `Bounds` of the annotation.
         * @private
         */
        private rectangle;
        /**
         * Parent `page` of the annotation.
         * @private
         */
        private pdfPage;
        /**
         * `Brush of the text` of the annotation.
         * @default new PdfSolidBrush(new PdfColor(0, 0, 0))
         * @private
         */
        private textBrush;
        /**
         * `Font of the text` of the annotation.
         * @default new PdfStandardFont(PdfFontFamily.TimesRoman, 10)
         * @private
         */
        private textFont;
        /**
         * `StringFormat of the text` of the annotation.
         * @default new PdfStringFormat(PdfTextAlignment.Left)
         * @private
         */
        private format;
        /**
         * `Text` of the annotation.
         * @private
         */
        private content;
        /**
         * Internal variable to store `dictionary`.
         * @private
         */
        private pdfDictionary;
        /**
         * To specifying the `Inner color` with which to fill the annotation
         * @private
         */
        private internalColor;
        /**
         * `opacity or darkness` of the annotation.
         * @private
         * @default 1.0
         */
        private darkness;
        /**
         * `Color` of the annotation
         * @private
         */
        color: PdfColor;
        /**
         * To specifying the `Inner color` with which to fill the annotation
         * @private
         */
        innerColor: PdfColor;
        /**
         * `bounds` of the annotation.
         * @private
         */
        bounds: RectangleF;
        /**
         * Parent `page` of the annotation.
         * @private
         */
        readonly page: PdfPage;
        /**
         * To specifying the `Font of the text` in the annotation.
         * @private
         */
        font: PdfFont;
        /**
         * To specifying the `StringFormat of the text` in the annotation.
         * @private
         */
        stringFormat: PdfStringFormat;
        /**
         * To specifying the `Brush of the text` in the annotation.
         * @private
         */
        brush: PdfBrush;
        /**
         * `Text` of the annotation.
         * @private
         */
        text: string;
        /**
         * Internal variable to store `dictionary`.
         * @hidden
         */
        dictionary: PdfDictionary;
        /**
         * Object initialization for `Annotation` class
         * @private
         */
        constructor();
        constructor(bounds: RectangleF);
        /**
         * `Initialize` the annotation event handler and specifies the type of the annotation.
         * @private
         */
        protected initialize(): void;
        /**
         * Sets related `page` of the annotation.
         * @private
         */
        setPage(page: PdfPageBase): void;
        /**
         * Handles the `BeginSave` event of the Dictionary.
         * @private
         */
        beginSave(): void;
        /**
         * `Saves` an annotation.
         * @private
         */
        protected save(): void;
        /**
         * Gets the `element`.
         * @private
         */
        readonly element: IPdfPrimitive;
    }
    
    /**
     * `PdfDocumentLinkAnnotation` class represents an annotation object with holds link on another location within a document.
     * ```typescript
     * // create a new PDF document
     * let document : PdfDocument = new PdfDocument();
     * // create new pages
     * let page1 : PdfPage = document.pages.add();
     * let page2 : PdfPage = document.pages.add();
     * // create a new rectangle
     * let bounds : RectangleF = new RectangleF({x : 10, y : 200}, {width : 300, height : 25});
     * //
     * // create a new document link annotation
     * let documentLinkAnnotation : PdfDocumentLinkAnnotation = new PdfDocumentLinkAnnotation(bounds);
     * // set the annotation text
     * documentLinkAnnotation.text = 'Document link annotation';
     * // set the destination
     * documentLinkAnnotation.destination = new PdfDestination(page2);
     * // set the documentlink annotation location
     * documentLinkAnnotation.destination.location = new PointF(10, 0);
     * // add this annotation to a new page
     * page1.annotations.add(documentLinkAnnotation);
     * //
     * // save the document to disk
     * document.save('output.pdf');
     * // destroy the document
     * document.destroy();
     * ```
     */
    export class PdfDocumentLinkAnnotation extends PdfLinkAnnotation {
        /**
         * `Destination` of the annotation.
         * @default null
         * @private
         */
        private pdfDestination;
        /**
         * Gets or sets the `destination` of the annotation.
         * ```typescript
         * // create a new PDF document
         * let document : PdfDocument = new PdfDocument();
         * // create new pages
         * let page1 : PdfPage = document.pages.add();
         * let page2 : PdfPage = document.pages.add();
         * // create a new rectangle
         * let bounds : RectangleF = new RectangleF({x : 10, y : 200}, {width : 300, height : 25});
         * //
         * // create a new document link annotation
         * let documentLinkAnnotation : PdfDocumentLinkAnnotation = new PdfDocumentLinkAnnotation(bounds);
         * // set the annotation text
         * documentLinkAnnotation.text = 'Document link annotation';
         * // set the destination
         * documentLinkAnnotation.destination = new PdfDestination(page2);
         * // set the documentlink annotation location
         * documentLinkAnnotation.destination.location = new PointF(10, 0);
         * // add this annotation to a new page
         * page1.annotations.add(documentLinkAnnotation);
         * //
         * // save the document to disk
         * document.save('output.pdf');
         * // destroy the document
         * document.destroy();
         * ```
         * @default null
         */
        destination: PdfDestination;
        /**
         * Initializes new `PdfDocumentLinkAnnotation` instance with specified bounds.
         * @private
         */
        constructor(rectangle: RectangleF);
        /**
         * Initializes new `PdfDocumentLinkAnnotation` instance with specified bounds and destination.
         * @private
         */
        constructor(rectangle: RectangleF, destination: PdfDestination);
        /**
         * `Saves` annotation object.
         * @private
         */
        save(): void;
        /**
         * `Clone` the document link annotation.
         * @private
         */
        clone(): PdfDocumentLinkAnnotation;
    }
    
    /**
     * `PdfLinkAnnotation` class represents the ink annotation class.
     * @private
     */
    export abstract class PdfLinkAnnotation extends PdfAnnotation {
        /**
         * Initializes new instance of `PdfLineAnnotation` class with specified points.
         * @private
         */
        constructor();
        /**
         * Initializes new instance of `PdfLineAnnotation` class with set of points and annotation text.
         * @private
         */
        constructor(rectangle: RectangleF);
        /**
         * `Initializes` annotation object.
         * @private
         */
        protected initialize(): void;
    }
    
    /**
     * `PdfTextWebLink` class represents the class for text web link annotation.
     * ```typescript
     * // create a new PDF document.
     * let document : PdfDocument = new PdfDocument();
     * // add a page to the document.
     * let page1 : PdfPage = document.pages.add();
     * // create the font
     * let font : PdfFont = new PdfStandardFont(PdfFontFamily.Helvetica, 12);
     * //
     * // create the Text Web Link
     * let textLink : PdfTextWebLink = new PdfTextWebLink();
     * // set the hyperlink
     * textLink.url = 'http://www.google.com';
     * // set the link text
     * textLink.text = 'Google';
     * // set the font
     * textLink.font = font;
     * // draw the hyperlink in PDF page
     * textLink.draw(page1, new PointF(10, 40));
     * //
     * // save the document.
     * document.save('output.pdf');
     * // destroy the document
     * document.destroy();
     * ```
     */
    export class PdfTextWebLink extends PdfTextElement {
        /**
         * Internal variable to store `Url`.
         * @default ''
         * @private
         */
        private uniformResourceLocator;
        /**
         * Internal variable to store `Uri Annotation` object.
         * @default null
         * @private
         */
        private uriAnnotation;
        /**
         * Checks whether the drawTextWebLink method with `PointF` overload is called or not.
         * If it set as true, then the start position of each lines excluding firest line is changed as (0, Y).
         * @private
         * @hidden
         */
        private recalculateBounds;
        private defaultBorder;
        /**
         * Gets or sets the `Uri address`.
         * ```typescript
         * // create a new PDF document.
         * let document : PdfDocument = new PdfDocument();
         * // add a page to the document.
         * let page1 : PdfPage = document.pages.add();
         * // create the font
         * let font : PdfFont = new PdfStandardFont(PdfFontFamily.Helvetica, 12);
         * // create the Text Web Link
         * let textLink : PdfTextWebLink = new PdfTextWebLink();
         * //
         * // set the hyperlink
         * textLink.url = 'http://www.google.com';
         * //
         * // set the link text
         * textLink.text = 'Google';
         * // set the font
         * textLink.font = font;
         * // draw the hyperlink in PDF page
         * textLink.draw(page1, new PointF(10, 40));
         * // save the document.
         * document.save('output.pdf');
         * // destroy the document
         * document.destroy();
         * ```
         */
        url: string;
        /**
         * Initializes a new instance of the `PdfTextWebLink` class.
         * @private
         */
        constructor();
        /**
         * `Draws` a Text Web Link on the Page with the specified location.
         * @private
         */
        draw(page: PdfPage, location: PointF): PdfLayoutResult;
        /**
         * `Draws` a Text Web Link on the Page with the specified bounds.
         * @private
         */
        draw(page: PdfPage, bounds: RectangleF): PdfLayoutResult;
        /**
         * `Draw` a Text Web Link on the Graphics with the specified location.
         * @private
         */
        draw(graphics: PdfGraphics, location: PointF): PdfLayoutResult;
        /**
         * `Draw` a Text Web Link on the Graphics with the specified bounds.
         * @private
         */
        draw(graphics: PdfGraphics, bounds: RectangleF): PdfLayoutResult;
        /**
         * Helper method `Draw` a Multiple Line Text Web Link on the Graphics with the specified location.
         * @private
         */
        private drawMultipleLineWithPoint(result, page, location);
        /**
         * Helper method `Draw` a Multiple Line Text Web Link on the Graphics with the specified bounds.
         * @private
         */
        private drawMultipleLineWithBounds(result, page, bounds);
        private calculateBounds(currentBounds, lineWidth, maximumWidth, startPosition);
    }
    
    /**
     * PdfUriAnnotation.ts class for EJ2-PDF
     */
    
    /**
     * `PdfUriAnnotation` class represents the Uri annotation.
     * @private
     */
    export class PdfUriAnnotation extends PdfActionLinkAnnotation {
        /**
         * Internal variable to store `acton` for the annotation.
         * @private
         */
        private pdfUriAction;
        /**
         * Get `action` of the annotation.
         * @private
         */
        readonly uriAction: PdfUriAction;
        /**
         * Gets or sets the `Uri` address.
         * @private
         */
        uri: string;
        /**
         * Gets or sets the `action`.
         * @private
         */
        action: PdfAction;
        /**
         * Initializes a new instance of the `PdfUriAnnotation` class with specified bounds.
         * @private
         */
        constructor(rectangle: RectangleF);
        /**
         * Initializes a new instance of the `PdfUriAnnotation` class with specified bounds and URI.
         * @private
         */
        constructor(rectangle: RectangleF, uri: string);
        /**
         * `Initializes` annotation object.
         * @private
         */
        protected initialize(): void;
    }
    
    /**
     * @private
     * @hidden
     */
    export interface IDictionaryPair<K, V> {
        key: K;
        value: V;
    }
    /**
     * @private
     * @hidden
     */
    export class Dictionary<K, V> {
        /**
         * @private
         * @hidden
         */
        protected table: {
            [key: string]: IDictionaryPair<K, V>;
        };
        /**
         * @private
         * @hidden
         */
        protected nElements: number;
        /**
         * @private
         * @hidden
         */
        protected toStr: (key: K) => string;
        /**
         * @private
         * @hidden
         */
        constructor(toStringFunction?: (key: K) => string);
        /**
         * @private
         * @hidden
         */
        getValue(key: K): V;
        /**
         * @private
         * @hidden
         */
        setValue(key: K, value: V): V;
        /**
         * @private
         * @hidden
         */
        remove(key: K): V;
        /**
         * @private
         * @hidden
         */
        keys(): K[];
        /**
         * @private
         * @hidden
         */
        values(): V[];
        /**
         * @private
         * @hidden
         */
        containsKey(key: K): boolean;
        /**
         * @private
         * @hidden
         */
        clear(): void;
        /**
         * @private
         * @hidden
         */
        size(): number;
    }
    
    /**
     * Utils.ts class for EJ2-PDF
     * @private
     * @hidden
     */
    export interface ICompareFunction<T> {
        (a: T, b: T): number;
    }
    /**
     * @private
     * @hidden
     */
    export interface IEqualsFunction<T> {
        (a: T, b: T): boolean;
    }
    /**
     * @private
     * @hidden
     */
    export interface ILoopFunction<T> {
        (a: T): boolean | void;
    }
    /**
     * @private
     * @hidden
     */
    export function defaultToString(item: string | number | string[] | number[] | Object | Object[] | boolean): string;
    
    /**
     * Dictionary class
     * @private
     * @hidden
     */
    export class TemporaryDictionary<K, V> {
        /**
         * @hidden
         * @private
         */
        private mKeys;
        /**
         * @hidden
         * @private
         */
        private mValues;
        /**
         * @hidden
         * @private
         */
        size(): number;
        /**
         * @hidden
         * @private
         */
        add(key: K, value: V): number;
        /**
         * @hidden
         * @private
         */
        keys(): K[];
        /**
         * @hidden
         * @private
         */
        values(): V[];
        /**
         * @hidden
         * @private
         */
        getValue(key: K): V;
        /**
         * @hidden
         * @private
         */
        setValue(key: K, value: V): void;
        /**
         * @hidden
         * @private
         */
        remove(key: K): boolean;
        /**
         * @hidden
         * @private
         */
        containsKey(key: K): boolean;
        /**
         * @hidden
         * @private
         */
        clear(): void;
    }
    
    /**
     * PdfCatalog.ts class for EJ2-PDF
     */
    
    /**
     * `PdfCatalog` class represents internal catalog of the Pdf document.
     * @private
     */
    export class PdfCatalog extends PdfDictionary {
        /**
         * Internal variable to store collection of `sections`.
         * @default null
         * @private
         */
        private sections;
        /**
         * Internal variable for accessing fields from `DictionryProperties` class.
         * @private
         */
        private tempDictionaryProperties;
        /**
         * Initializes a new instance of the `PdfCatalog` class.
         * @private
         */
        constructor();
        /**
         * Gets or sets the sections, which contain `pages`.
         * @private
         */
        pages: PdfSectionCollection;
    }
    
    /**
     * PdfDocumentBase.ts class for EJ2-PDF
     */
    
    /**
     * `PdfDocumentBase` class represent common properties of PdfDocument classes.
     * @private
     */
    export class PdfDocumentBase {
        /**
         * Collection of the main `objects`.
         * @private
         */
        private objects;
        /**
         * The `cross table`.
         * @private
         */
        private pdfCrossTable;
        /**
         * `Object` that is saving currently.
         * @private
         */
        private currentSavingObject;
        /**
         * Document `catlog`.
         * @private
         */
        private pdfCatalog;
        /**
         * If the stream is copied,  then it specifies true.
         * @private
         */
        isStreamCopied: boolean;
        /**
         * Instance of parent `document`.
         * @private
         */
        private document;
        /**
         * Initializes a new instance of the `PdfDocumentBase` class.
         * @private
         */
        constructor();
        /**
         * Initializes a new instance of the `PdfDocumentBase` class with instance of PdfDocument as argument.
         * @private
         */
        constructor(document: PdfDocument);
        /**
         * Gets the `PDF objects` collection, which stores all objects and references to it..
         * @private
         */
        readonly pdfObjects: PdfMainObjectCollection;
        /**
         * Gets the `cross-reference` table.
         * @private
         */
        readonly crossTable: PdfCrossTable;
        /**
         * Gets or sets the current saving `object number`.
         * @private
         */
        currentSavingObj: PdfReference;
        /**
         * Gets the PDF document `catalog`.
         * @private
         */
        catalog: PdfCatalog;
        /**
         * Sets the `main object collection`.
         * @private
         */
        setMainObjectCollection(mainObjectCollection: PdfMainObjectCollection): void;
        /**
         * Sets the `cross table`.
         * @private
         */
        setCrossTable(cTable: PdfCrossTable): void;
        /**
         * Sets the `catalog`.
         * @private
         */
        setCatalog(catalog: PdfCatalog): void;
        /**
         * `Saves` the document to the specified filename.
         * @private
         */
        save(): Promise<{
            blobData: Blob;
        }>;
        /**
         * `Saves` the document to the specified filename.
         * @public
         * ```typescript
         * // create a new PDF document
         * let document : PdfDocument = new PdfDocument();
         * // add a pages to the document
         * let page1 : PdfPage = document.pages.add();
         * //
         * // save the document
         * document.save('output.pdf');
         * //
         * // destroy the document
         * document.destroy();
         * ```
         * @param filename Specifies the file name to save the output pdf document.
         */
        save(filename: string): void;
        /**
         * `Clone` of parent object - PdfDocument.
         * @private
         */
        clone(): PdfDocument;
    }
    
    /**
     * PdfDocumentTemplate.ts class for EJ2-PDF
     */
    
    /**
     * `PdfDocumentTemplate` class encapsulates a page template for all the pages in the document.
     * @private
     */
    export class PdfDocumentTemplate {
        /**
         * `Left` page template object.
         * @private
         */
        private leftTemplate;
        /**
         * `Top` page template object.
         * @private
         */
        private topTemplate;
        /**
         * `Right` page template object.
         * @private
         */
        private rightTemplate;
        /**
         * `Bottom` page template object.
         * @private
         */
        private bottomTemplate;
        /**
         * `EvenLeft` page template object.
         * @private
         */
        private evenLeft;
        /**
         * `EvenTop` page template object.
         * @private
         */
        private evenTop;
        /**
         * `EvenRight` page template object.
         * @private
         */
        private evenRight;
        /**
         * `EventBottom` page template object.
         * @private
         */
        private evenBottom;
        /**
         * `OddLeft` page template object.
         * @private
         */
        private oddLeft;
        /**
         * `OddTop` page template object.
         * @private
         */
        private oddTop;
        /**
         * `OddRight` page template object.
         * @private
         */
        private oddRight;
        /**
         * `OddBottom` page template object.
         * @private
         */
        private oddBottom;
        /**
         * `Left` page template object.
         * @public
         */
        left: PdfPageTemplateElement;
        /**
         * `Top` page template object.
         * @public
         */
        top: PdfPageTemplateElement;
        /**
         * `Right` page template object.
         * @public
         */
        right: PdfPageTemplateElement;
        /**
         * `Bottom` page template object.
         * @public
         */
        bottom: PdfPageTemplateElement;
        /**
         * `EvenLeft` page template object.
         * @public
         */
        EvenLeft: PdfPageTemplateElement;
        /**
         * `EvenTop` page template object.
         * @public
         */
        EvenTop: PdfPageTemplateElement;
        /**
         * `EvenRight` page template object.
         * @public
         */
        EvenRight: PdfPageTemplateElement;
        /**
         * `EvenBottom` page template object.
         * @public
         */
        EvenBottom: PdfPageTemplateElement;
        /**
         * `OddLeft` page template object.
         * @public
         */
        OddLeft: PdfPageTemplateElement;
        /**
         * `OddTop` page template object.
         * @public
         */
        OddTop: PdfPageTemplateElement;
        /**
         * `OddRight` page template object.
         * @public
         */
        OddRight: PdfPageTemplateElement;
        /**
         * `OddBottom` page template object.
         * @public
         */
        OddBottom: PdfPageTemplateElement;
        /**
         * Initializes a new instance of the `PdfDocumentTemplate` class.
         * @public
         */
        constructor();
        /**
         * Returns `left` template.
         * @public
         */
        getLeft(page: PdfPage): PdfPageTemplateElement;
        /**
         * Returns `top` template.
         * @public
         */
        getTop(page: PdfPage): PdfPageTemplateElement;
        /**
         * Returns `right` template.
         * @public
         */
        getRight(page: PdfPage): PdfPageTemplateElement;
        /**
         * Returns `bottom` template.
         * @public
         */
        getBottom(page: PdfPage): PdfPageTemplateElement;
        /**
         * Checks whether the page `is even`.
         * @private
         */
        private isEven(page);
        /**
         * Checks a `template element`.
         * @private
         */
        private checkElement(templateElement, type);
    }
    
    /**
     * Represents a PDF document and can be used to create a new PDF document from the scratch.
     * ```typescript
     * // create a new PDF document
     * let document : PdfDocument = new PdfDocument();
     * // add a new page to the document
     * let page1 : PdfPage = document.pages.add();
     * // set the font
     * let font : PdfStandardFont = new PdfStandardFont(PdfFontFamily.Helvetica, 20);
     * // create black brush
     * let blackBrush : PdfSolidBrush = new PdfSolidBrush(new PdfColor(0, 0, 0));
     * // draw the text
     * page1.graphics.drawString('Hello World', font, blackBrush, new PointF(0, 0));
     * // save the document
     * document.save('output.pdf');
     * // destroy the document
     * document.destroy();
     * ```
     */
    export class PdfDocument extends PdfDocumentBase {
        /**
         * `Cache` of the objects.
         * @private
         */
        private static cacheCollection;
        /**
         * Default `margin` value.
         * @default 40.0
         * @private
         */
        readonly defaultMargin: number;
        /**
         * Default page `settings`.
         * @private
         */
        private settings;
        /**
         * Internal variable to store document`s collection of `sections`.
         * @private
         */
        private sectionCollection;
        /**
         * Internal variable to store document`s collection of `pages`.
         * @private
         */
        private documentPageCollection;
        /**
         * Internal variable to store instance of `StreamWriter` classes..
         * @default null
         * @private
         */
        streamWriter: ej.fileutils.StreamWriter;
        /**
         * Defines the `color space` of the document
         * @private
         */
        private pdfColorSpace;
        /**
         * Internal variable to store `template` which is applied to each page of the document.
         * @private
         */
        private pageTemplate;
        /**
         * `Font` used in complex objects to draw strings and text when it is not defined explicitly.
         * @default null
         * @private
         */
        private static defaultStandardFont;
        /**
         * Initializes a new instance of the `PdfDocument` class.
         * @public
         */
        constructor();
        /**
         * Initializes a new instance of the `PdfDocument` class.
         * @private
         */
        constructor(isMerging: boolean);
        /**
         * Gets the `default font`. It is used for complex objects when font is not explicitly defined.
         * @private
         */
        static readonly defaultFont: PdfFont;
        /**
         * Gets the collection of the `sections` in the document.
         * @private
         */
        readonly sections: PdfSectionCollection;
        /**
         * Gets the document's page setting.
         * @public
         */
        /**
         * Sets the document's page setting.
         * ```typescript
         * // create a new PDF document
         * let document : PdfDocument = new PdfDocument();
         *
         * // sets the right margin of the page
         * document.pageSettings.margins.right = 0;
         * // set the page size.
         * document.pageSettings.size = new SizeF(500, 500);
         * // change the page orientation to landscape
         * document.pageSettings.orientation = PdfPageOrientation.Landscape;
         * // apply 90 degree rotation on the page
         * document.pageSettings.rotate = PdfPageRotateAngle.RotateAngle90;
         *
         * // add a pages to the document
         * let page1 : PdfPage = document.pages.add();
         * // set font
         * let font : PdfStandardFont = new PdfStandardFont(PdfFontFamily.Helvetica, 20);
         * // set brush
         * let blackBrush : PdfSolidBrush = new PdfSolidBrush(new PdfColor(0, 0, 0));
         * // set the specified Point
         * let point : PointF = new PointF(page1.getClientSize().width - 200, page1.getClientSize().height - 200);
         * // draw the text
         * page1.graphics.drawString('Hello World', font, blackBrush, point);
         * // save the document
         * document.save('output.pdf');
         * // destroy the document
         * document.destroy();
         * ```
         */
        pageSettings: PdfPageSettings;
        /**
         * Represents the collection of pages in the PDF document.
         * ```typescript
         * // create a new PDF document
         * let document : PdfDocument = new PdfDocument();
         * //
         * // get the collection of pages in the document
         * let pageCollection : PdfDocumentPageCollection  = document.pages;
         * //
         * // add pages
         * let page1 : PdfPage = pageCollection.add();
         * // save the document
         * document.save('output.pdf');
         * // destroy the document
         * document.destroy();
         * ```
         */
        readonly pages: PdfDocumentPageCollection;
        /**
         * Gets collection of the `cached objects`.
         * @private
         */
        /**
         * Sets collection of the `cached objects`.
         * @private
         */
        static cache: PdfCacheCollection;
        /**
         * Gets or sets the `color space` of the document. This property can be used to create PDF document in RGB, Gray scale or CMYK color spaces.
         * @private
         */
        colorSpace: PdfColorSpace;
        /**
         * Gets or sets a `template` to all pages in the document.
         * @private
         */
        template: PdfDocumentTemplate;
        /**
         * Saves the document to the specified output stream and return the stream as Blob.
         * @private
         */
        docSave(stream: ej.fileutils.StreamWriter, isBase: boolean): Blob;
        /**
         * Saves the document to the specified output stream.
         * @private
         */
        docSave(stream: ej.fileutils.StreamWriter, filename: string, isBase: boolean): void;
        /**
         * Checks the pages `presence`.
         * @private
         */
        private checkPagesPresence();
        /**
         * disposes the current instance of `PdfDocument` class.
         * ```typescript
         * // create a new PDF document
         * let document : PdfDocument = new PdfDocument();
         * // add a new page to the document
         * let page1 : PdfPage = document.pages.add();
         * // set the font
         * let font : PdfStandardFont = new PdfStandardFont(PdfFontFamily.Helvetica, 20);
         * // create black brush
         * let blackBrush : PdfSolidBrush = new PdfSolidBrush(new PdfColor(0, 0, 0));
         * // draw the text
         * page1.graphics.drawString('Hello World', font, blackBrush, new PointF(0, 0));
         * // save the document
         * document.save('output.pdf');
         * // destroy the document
         * document.destroy();
         * ```
         */
        destroy(): void;
    }
    
    /**
     * PdfAutomaticFieldInfoCollection.ts class for EJ2-PDF
     * @private
     */
    
    /**
     * Represent a `collection of automatic fields information`.
     * @private
     */
    export class PdfAutomaticFieldInfoCollection {
        /**
         * Internal variable to store instance of `pageNumberFields` class.
         * @private
         */
        private automaticFieldsInformation;
        /**
         * Gets the `page number fields collection`.
         * @private
         */
        readonly automaticFields: PdfAutomaticFieldInfo[];
        /**
         * Initializes a new instance of the 'PdfPageNumberFieldInfoCollection' class.
         * @private
         */
        constructor();
        /**
         * Add page number field into collection.
         * @private
         */
        add(fieldInfo: PdfAutomaticFieldInfo): number;
    }
    
    /**
     * PdfAutomaticFieldInfo.ts class for EJ2-PDF
     * @private
     */
    
    /**
     * Represents information about the automatic field.
     * @private
     */
    export class PdfAutomaticFieldInfo {
        /**
         * Internal variable to store location of the field.
         * @private
         */
        private pageNumberFieldLocation;
        /**
         * Internal variable to store field.
         * @private
         */
        private pageNumberField;
        /**
         * Internal variable to store x scaling factor.
         * @private
         */
        private scaleX;
        /**
         * Internal variable to store y scaling factor.
         * @private
         */
        private scaleY;
        /**
         * Initializes a new instance of the 'PdfAutomaticFieldInfo' class.
         * @private
         */
        constructor(field: PdfAutomaticFieldInfo);
        /**
         * Initializes a new instance of the 'PdfAutomaticFieldInfo' class.
         * @private
         */
        constructor(field: PdfAutomaticField, location: PointF);
        /**
         * Initializes a new instance of the 'PdfAutomaticFieldInfo' class.
         * @private
         */
        constructor(field: PdfAutomaticField, location: PointF, scaleX: number, scaleY: number);
        /**
         * Gets or sets the location.
         * @private
         */
        location: PointF;
        /**
         * Gets or sets the field.
         * @private
         */
        field: PdfAutomaticField;
        /**
         * Gets or sets the scaling X factor.
         * @private
         */
        scalingX: number;
        /**
         * Gets or sets the scaling Y factor.
         * @private
         */
        scalingY: number;
    }
    
    /**
     * PdfAutomaticField.ts class for EJ2-PDF
     */
    
    /**
     * Represents a fields which is calculated before the document saves.
     */
    export abstract class PdfAutomaticField extends PdfGraphicsElement {
        private internalBounds;
        private internalFont;
        private internalBrush;
        private internalPen;
        private internalStringFormat;
        private internalTemplateSize;
        protected constructor();
        bounds: RectangleF;
        size: SizeF;
        location: PointF;
        font: PdfFont;
        brush: PdfBrush;
        pen: PdfPen;
        stringFormat: PdfStringFormat;
        abstract getValue(graphics: PdfGraphics): string;
        abstract performDraw(graphics: PdfGraphics, location: PointF, scalingX: number, scalingY: number): void;
        performDrawHelper(graphics: PdfGraphics, location: PointF, scalingX: number, scalingY: number): void;
        draw(graphics: PdfGraphics): void;
        draw(graphics: PdfGraphics, location: PointF): void;
        draw(graphics: PdfGraphics, x: number, y: number): void;
        protected getSize(): SizeF;
        protected drawInternal(graphics: PdfGraphics): void;
        protected getBrush(): PdfBrush;
        protected getFont(): PdfFont;
        getPageFromGraphics(graphics: PdfGraphics): PdfPage;
    }
    
    /**
     * PdfCompositeField.ts class for EJ2-PDF
     */
    
    /**
     * Represents class which can concatenate multiple automatic fields into single string.
     */
    export class PdfCompositeField extends PdfMultipleValueField {
        /**
         * Stores the array of automatic fields.
         * @private
         */
        private internalAutomaticFields;
        /**
         * Stores the text value of the field.
         * @private
         */
        private internalText;
        /**
         * Initialize a new instance of `PdfCompositeField` class.
         * @param font Font of the field.
         * @param brush Color of the field.
         * @param text Content of the field.
         * @param list List of the automatic fields in specific order based on the text content.
         */
        constructor(font: PdfFont, brush: PdfBrush, text: string, ...list: PdfAutomaticField[]);
        /**
         * Gets and sets the content of the field.
         * @public
         */
        text: string;
        /**
         * Gets and sets the list of the field to drawn.
         * @public
         */
        automaticFields: PdfAutomaticField[];
        /**
         * Return the actual value generated from the list of automatic fields.
         * @public
         */
        getValue(graphics: PdfGraphics): string;
    }
    
    /**
     * PdfAutomaticField.ts class for EJ2-PDF
     */
    
    /**
     * Represents automatic field which has the same value within the `PdfGraphics`.
     */
    export abstract class PdfMultipleValueField extends PdfAutomaticField {
        /**
         * Stores the instance of dictionary values of `graphics and template value pair`.
         * @private
         */
        private list;
        constructor();
        performDraw(graphics: PdfGraphics, location: PointF, scalingX: number, scalingY: number): void;
    }
    
    /**
     * PdfPageCountField.ts class for EJ2-PDF
     */
    
    /**
     * Represents total PDF document page count automatic field.
     */
    export class PdfPageCountField extends PdfSingleValueField {
        /**
         * Stores the number style of the field.
         * @private
         */
        private internalNumberStyle;
        /**
         * Initialize a new instance for page number field.
         * @public
         */
        constructor(font: PdfFont);
        /**
         * Initialize a new instance for page number field.
         * @public
         */
        constructor(font: PdfFont, bounds: RectangleF);
        /**
         * Initialize a new instance for page number field.
         * @public
         */
        constructor(font: PdfFont, brush: PdfBrush);
        /**
         * Gets and sets the number style of the field.
         * @public
         */
        numberStyle: PdfNumberStyle;
        /**
         * Return the actual value of the content to drawn.
         * @public
         */
        getValue(graphics: PdfGraphics): string;
    }
    
    /**
     * PdfNumbersConvertor.ts class for EJ2-PDF
     * @private
     */
    
    /**
     * `PdfNumbersConvertor` for convert page number into numbers, roman letters, etc.,
     * @private
     */
    export class PdfNumbersConvertor {
        /**
         * numbers of letters in english [readonly].
         * @default = 26.0
         * @private
         */
        private static readonly letterLimit;
        /**
         * Resturns `acsii start index` value.
         * @default 64
         * @private
         */
        private static readonly acsiiStartIndex;
        /**
         * Convert string value from page number with correct format.
         * @private
         */
        static convert(intArabic: number, numberStyle: PdfNumberStyle): string;
        /**
         * Converts `arabic to roman` letters.
         * @private
         */
        private static arabicToRoman(intArabic);
        /**
         * Converts `arabic to normal letters`.
         * @private
         */
        private static arabicToLetter(arabic);
        /**
         * Generate a string value of an input number.
         * @private
         */
        private static generateNumber(value, magnitude, letter);
        /**
         * Convert a input number into letters.
         * @private
         */
        private static convertToLetter(arabic);
        /**
         * Convert number to actual string value.
         * @private
         */
        private static appendChar(builder, value);
    }
    
    /**
     * PdfPageNumberField.ts class for EJ2-PDF
     */
    
    /**
     * Represents PDF document `page number field`.
     * @public
     */
    export class PdfPageNumberField extends PdfMultipleValueField {
        /**
         * Initialize a new instance for page number field.
         * @public
         */
        constructor(font: PdfFont);
        /**
         * Initialize a new instance for page number field.
         * @public
         */
        constructor(font: PdfFont, bounds: RectangleF);
        /**
         * Initialize a new instance for page number field.
         * @public
         */
        constructor(font: PdfFont, brush: PdfBrush);
        /**
         * Stores the number style of the page number field.
         * @private
         */
        private internalNumberStyle;
        /**
         * Gets and sets the number style of the page number field.
         * @private
         */
        numberStyle: PdfNumberStyle;
        /**
         * Return the `string` value of page number field.
         * @public
         */
        getValue(graphics: PdfGraphics): string;
        /**
         * Internal method to `get actual value of page number`.
         * @private
         */
        protected internalGetValue(page: PdfPage): string;
    }
    
    /**
     * PdfTemplateValuePair.ts class for EJ2-PDF
     * @private
     */
    
    /**
     * Represent class to store information about `template and value pairs`.
     * @private
     */
    export class PdfTemplateValuePair {
        /**
         * Internal variable to store template.
         * @default null
         * @private
         */
        private pdfTemplate;
        /**
         * Intenal variable to store value.
         * @private
         */
        private content;
        /**
         * Initializes a new instance of the 'PdfTemplateValuePair' class.
         * @private
         */
        constructor();
        constructor(template: PdfTemplate, value: string);
        /**
         * Gets or sets the template.
         * @private
         */
        template: PdfTemplate;
        /**
         * Gets or sets the value.
         * @private
         */
        value: string;
    }
    
    /**
     * PdfSingleValueField.ts class for EJ2-PDF
     */
    
    /**
     * Represents automatic field which has the same value in the whole document.
     */
    export abstract class PdfSingleValueField extends PdfAutomaticField {
        private list;
        private painterGraphics;
        constructor();
        performDraw(graphics: PdfGraphics, location: PointF, scalingX: number, scalingY: number): void;
    }
    
    /**
     * Coordinates of Position for `PointF`.
     * @private
     */
    export class PointF {
        /**
         * Value of `X`.
         * @private
         */
        x: number;
        /**
         * Value of `Y`.
         * @private
         */
        y: number;
        /**
         * Instance of `PointF` class.
         * @private
         */
        constructor();
        /**
         * Instance of `PointF` class with X, Y co-ordinates.
         * @private
         */
        constructor(x: number, y: number);
    }
    /**
     * Width and Height as `Size`.
     * @private
     */
    export class SizeF {
        /**
         * Value of ``Height``.
         * @private
         */
        height: number;
        /**
         * Value of `Width`.
         * @private
         */
        width: number;
        /**
         * Instance of `SizeF` class.
         * @private
         */
        constructor();
        /**
         * Instance of `SizeF` class with Width and Height.
         * @private
         */
        constructor(width: number, height: number);
    }
    /**
     * `RectangleF` with Position and size.
     * @private
     */
    export class RectangleF {
        /**
         * Value of `X`.
         * @private
         */
        x: number;
        /**
         * Value of `Y`.
         * @private
         */
        y: number;
        /**
         * Value of `Height`.
         * @private
         */
        height: number;
        /**
         * Value of `Width`.
         * @private
         */
        width: number;
        /**
         * Instance of `RectangleF` class.
         * @private
         */
        constructor();
        /**
         * Instance of `RectangleF` class with X, Y, Width and Height.
         * @private
         */
        constructor(x: number, y: number, height: number, width: number);
        /**
         * Instance of `RectangleF` class with PointF, SizeF.
         * @private
         */
        constructor(pointF: PointF, sizeF: SizeF);
    }
    
    /**
     * public Enum for `PdfDestinationMode`.
     * @private
     */
    export enum PdfDestinationMode {
        /**
         * Specifies the type of `Location`.
         * @private
         */
        Location = 0,
        /**
         * Specifies the type of `FitToPage`.
         * @private
         */
        FitToPage = 1,
        /**
         * Specifies the type of `FitR`.
         * @private
         */
        FitR = 2,
    }
    
    /**
     * `Collection of the cached objects`.
     * @private
     */
    export class PdfCacheCollection {
        /**
         * Stores the similar `objects`.
         * @private
         */
        private referenceObjects;
        /**
         * Stores the references of font with GUID `objects`.
         * @private
         */
        private pdfFontCollection;
        /**
         * Initializes a new instance of the `PdfCacheCollection` class.
         * @private
         */
        constructor();
        /**
         * `Searches` for the similar cached object. If is not found - adds the object to the cache.
         * @private
         */
        search(obj: IPdfCache): IPdfCache;
        /**
         * `Creates` a new group.
         * @private
         */
        private createNewGroup();
        destroy(): void;
    }
    
    /**
     * PdfCollection.ts class for EJ2-PDF
     * The class used to handle the collection of PdF objects.
     */
    export class PdfCollection {
        /**
         * Stores the `objects` as array.
         * @private
         */
        private collection;
        /**
         * Initializes a new instance of the `Collection` class.
         * @private
         */
        constructor();
        /**
         * Gets the `Count` of stored objects.
         * @private
         */
        readonly count: number;
        /**
         * Gets the `list` of stored objects.
         * @private
         */
        readonly list: Object[];
    }
    
    /**
     * PdfDestination.ts class for EJ2-PDF
     */
    
    /**
     * `PdfDestination` class represents an anchor in the document
     * where bookmarks or annotations can direct when clicked.
     */
    export class PdfDestination implements IPdfWrapper {
        /**
         * Internal variable for accessing fields from `DictionryProperties` class.
         * @private
         */
        protected dictionaryProperties: DictionaryProperties;
        /**
         * Type of the `destination`.
         * @private
         */
        private destinationMode;
        /**
         * `Zoom` factor.
         * @private
         * @default 0
         */
        private zoomFactor;
        /**
         * `Location` of the destination.
         * @default new PointF() with 0 ,0 as co-ordinates
         * @private
         */
        private destinationLocation;
        /**
         * `Bounds` of the destination as RectangleF.
         * @default RectangleF.Empty
         * @private
         */
        private bounds;
        /**
         * Parent `page` reference.
         * @private
         */
        private pdfPage;
        /**
         * Pdf primitive representing `this` object.
         * @private
         */
        private array;
        /**
         * Initializes a new instance of the `PdfDestination` class with page object.
         * @private
         */
        constructor(page: PdfPageBase);
        /**
         * Initializes a new instance of the `PdfDestination` class with page object and location.
         * @private
         */
        constructor(page: PdfPageBase, location: PointF);
        /**
         * Initializes a new instance of the `PdfDestination` class with page object and bounds.
         * @private
         */
        constructor(page: PdfPageBase, rectangle: RectangleF);
        /**
         * Gets and Sets the `zoom` factor.
         * @private
         */
        zoom: number;
        /**
         * Gets and Sets the `page` object.
         * @private
         */
        page: PdfPageBase;
        /**
         * Gets and Sets the destination `mode`.
         * @private
         */
        mode: PdfDestinationMode;
        /**
         * Gets and Sets the `location`.
         * @private
         */
        location: PointF;
        /**
         * `Translates` co-ordinates to PDF co-ordinate system (lower/left).
         * @private
         */
        private pointToNativePdf(page, point);
        /**
         * `In fills` array by correct values.
         * @private
         */
        private initializePrimitive();
        /**
         * Gets the `element` representing this object.
         * @private
         */
        readonly element: IPdfPrimitive;
    }
    
    /**
     * `constants.ts` class for EJ2-PDF
     * @private
     */
    export class ProcedureSets {
        /**
         * Specifies the `PDF` procedure set.
         * @private
         */
        readonly pdf: string;
        /**
         * Specifies the `Text` procedure set.
         * @private
         */
        readonly text: string;
        /**
         * Specifies the `ImageB` procedure set.
         * @private
         */
        readonly imageB: string;
        /**
         * Specifies the `ImageC` procedure set.
         * @private
         */
        readonly imageC: string;
        /**
         * Specifies the `ImageI` procedure set.
         * @private
         */
        readonly imageI: string;
    }
    
    /**
     * public Enum for `PdfHorizontalAlignment`.
     * @private
     */
    export enum PdfHorizontalAlignment {
        /**
         * Specifies the type of `Left`.
         * @private
         */
        Left = 0,
        /**
         * Specifies the type of `Center`.
         * @private
         */
        Center = 1,
        /**
         * Specifies the type of `Right`.
         * @private
         */
        Right = 2,
    }
    /**
     * public Enum for `PdfVerticalAlignment`.
     * @private
     */
    export enum PdfVerticalAlignment {
        /**
         * Specifies the type of `Top`.
         * @private
         */
        Top = 0,
        /**
         * Specifies the type of `Middle`.
         * @private
         */
        Middle = 1,
        /**
         * Specifies the type of `Bottom`.
         * @private
         */
        Bottom = 2,
    }
    /**
     * public Enum for `public`.
     * @private
     */
    export enum PdfTextAlignment {
        /**
         * Specifies the type of `Left`.
         * @private
         */
        Left = 0,
        /**
         * Specifies the type of `Center`.
         * @private
         */
        Center = 1,
        /**
         * Specifies the type of `Right`.
         * @private
         */
        Right = 2,
        /**
         * Specifies the type of `Justify`.
         * @private
         */
        Justify = 3,
    }
    /**
     * public Enum for `TextRenderingMode`.
     * @private
     */
    export enum TextRenderingMode {
        /**
         * Specifies the type of `Fill`.
         * @private
         */
        Fill = 0,
        /**
         * Specifies the type of `Stroke`.
         * @private
         */
        Stroke = 1,
        /**
         * Specifies the type of `FillStroke`.
         * @private
         */
        FillStroke = 2,
        /**
         * Specifies the type of `None`.
         * @private
         */
        None = 3,
        /**
         * Specifies the type of `ClipFlag`.
         * @private
         */
        ClipFlag = 4,
        /**
         * Specifies the type of `ClipFill`.
         * @private
         */
        ClipFill = 4,
        /**
         * Specifies the type of `ClipStroke`.
         * @private
         */
        ClipStroke = 5,
        /**
         * Specifies the type of `ClipFillStroke`.
         * @private
         */
        ClipFillStroke = 6,
        /**
         * Specifies the type of `Clip`.
         * @private
         */
        Clip = 7,
    }
    /**
     * public Enum for `PdfLineJoin`.
     * @private
     */
    export enum PdfLineJoin {
        /**
         * Specifies the type of `Miter`.
         * @private
         */
        Miter = 0,
        /**
         * Specifies the type of `Round`.
         * @private
         */
        Round = 1,
        /**
         * Specifies the type of `Bevel`.
         * @private
         */
        Bevel = 2,
    }
    /**
     * public Enum for `PdfLineCap`.
     * @private
     */
    export enum PdfLineCap {
        /**
         * Specifies the type of `Flat`.
         * @private
         */
        Flat = 0,
        /**
         * Specifies the type of `Round`.
         * @private
         */
        Round = 1,
        /**
         * Specifies the type of `Square`.
         * @private
         */
        Square = 2,
    }
    /**
     * public Enum for `PdfDashStyle`.
     * @private
     */
    export enum PdfDashStyle {
        /**
         * Specifies the type of `Solid`.
         * @private
         */
        Solid = 0,
        /**
         * Specifies the type of `Dash`.
         * @private
         */
        Dash = 1,
        /**
         * Specifies the type of `Dot`.
         * @private
         */
        Dot = 2,
        /**
         * Specifies the type of `DashDot`.
         * @private
         */
        DashDot = 3,
        /**
         * Specifies the type of `DashDotDot`.
         * @private
         */
        DashDotDot = 4,
        /**
         * Specifies the type of `Custom`.
         * @private
         */
        Custom = 5,
    }
    /**
     * public Enum for `PdfFillMode`.
     * @private
     */
    export enum PdfFillMode {
        /**
         * Specifies the type of `Winding`.
         * @private
         */
        Winding = 0,
        /**
         * Specifies the type of `Alternate`.
         * @private
         */
        Alternate = 1,
    }
    /**
     * public Enum for `PdfColorSpace`.
     * @private
     */
    export enum PdfColorSpace {
        /**
         * Specifies the type of `Rgb`.
         * @private
         */
        Rgb = 0,
        /**
         * Specifies the type of `Cmyk`.
         * @private
         */
        Cmyk = 1,
        /**
         * Specifies the type of `GrayScale`.
         * @private
         */
        GrayScale = 2,
        /**
         * Specifies the type of `Indexed`.
         * @private
         */
        Indexed = 3,
    }
    /**
     * public Enum for `PdfBlendMode`.
     * @private
     */
    export enum PdfBlendMode {
        /**
         * Specifies the type of `Normal`.
         * @private
         */
        Normal = 0,
        /**
         * Specifies the type of `Multiply`.
         * @private
         */
        Multiply = 1,
        /**
         * Specifies the type of `Screen`.
         * @private
         */
        Screen = 2,
        /**
         * Specifies the type of `Overlay`.
         * @private
         */
        Overlay = 3,
        /**
         * Specifies the type of `Darken`.
         * @private
         */
        Darken = 4,
        /**
         * Specifies the type of `Lighten`.
         * @private
         */
        Lighten = 5,
        /**
         * Specifies the type of `ColorDodge`.
         * @private
         */
        ColorDodge = 6,
        /**
         * Specifies the type of `ColorBurn`.
         * @private
         */
        ColorBurn = 7,
        /**
         * Specifies the type of `HardLight`.
         * @private
         */
        HardLight = 8,
        /**
         * Specifies the type of `SoftLight`.
         * @private
         */
        SoftLight = 9,
        /**
         * Specifies the type of `Difference`.
         * @private
         */
        Difference = 10,
        /**
         * Specifies the type of `Exclusion`.
         * @private
         */
        Exclusion = 11,
        /**
         * Specifies the type of `Hue`.
         * @private
         */
        Hue = 12,
        /**
         * Specifies the type of `Saturation`.
         * @private
         */
        Saturation = 13,
        /**
         * Specifies the type of `Color`.
         * @private
         */
        Color = 14,
        /**
         * Specifies the type of `Luminosity`.
         * @private
         */
        Luminosity = 15,
    }
    /**
     * public Enum for `PdfGraphicsUnit`.
     * @private
     */
    export enum PdfGraphicsUnit {
        /**
         * Specifies the type of `Centimeter`.
         * @private
         */
        Centimeter = 0,
        /**
         * Specifies the type of `Pica`.
         * @private
         */
        Pica = 1,
        /**
         * Specifies the type of `Pixel`.
         * @private
         */
        Pixel = 2,
        /**
         * Specifies the type of `Point`.
         * @private
         */
        Point = 3,
        /**
         * Specifies the type of `Inch`.
         * @private
         */
        Inch = 4,
        /**
         * Specifies the type of `Document`.
         * @private
         */
        Document = 5,
        /**
         * Specifies the type of `Millimeter`.
         * @private
         */
        Millimeter = 6,
    }
    /**
     * public Enum for `PdfGridImagePosition`.
     * @private
     */
    export enum PdfGridImagePosition {
        /**
         * Specifies the type of `Fit`.
         * @private
         */
        Fit = 0,
        /**
         * Specifies the type of `Center`.
         * @private
         */
        Center = 1,
        /**
         * Specifies the type of `Stretch`.
         * @private
         */
        Stretch = 2,
        /**
         * Specifies the type of `Tile`.
         * @private
         */
        Tile = 3,
    }
    
    /**
     * Implements structures and routines working with `color`.
     * ```typescript
     * // create a new PDF document
     * let document : PdfDocument = new PdfDocument();
     * // add a new page to the document
     * let page1 : PdfPage = document.pages.add();
     * // set the font
     * let font : PdfStandardFont = new PdfStandardFont(PdfFontFamily.Helvetica, 20);
     * //
     * // set color
     * let brushColor : PdfColor = new PdfColor(0, 0, 0);
     * //
     * // create black brush
     * let blackBrush : PdfSolidBrush = new PdfSolidBrush(brushColor);
     * // draw the text
     * page1.graphics.drawString('Hello World', font, blackBrush, new PointF(0, 0));
     * // save the document
     * document.save('output.pdf');
     * // destroy the document
     * document.destroy();
     * ```
     * @default black color
     */
    export class PdfColor {
        /**
         * Holds `RGB colors` converted into strings.
         * @private
         */
        private static rgbStrings;
        /**
         * Holds Gray scale colors converted into strings for `stroking`.
         * @private
         */
        private static grayStringsSroke;
        /**
         * Holds Gray scale colors converted into strings for `filling`.
         * @private
         */
        private static grayStringsFill;
        /**
         * Value of `Red` channel.
         * @private
         */
        private redColor;
        /**
         * Value of `Cyan` channel.
         * @private
         */
        private cyanColor;
        /**
         * Value of `Green` channel.
         * @private
         */
        private greenColor;
        /**
         * Value of `Magenta` channel.
         * @private
         */
        private magentaColor;
        /**
         * Value of `Blue` channel.
         * @private
         */
        private blueColor;
        /**
         * Value of `Yellow` channel.
         * @private
         */
        private yellowColor;
        /**
         * Value of `Black` channel.
         * @private
         */
        private blackColor;
        /**
         * Value of `Gray` channel.
         * @private
         */
        private grayColor;
        /**
         * `Alpha` channel.
         * @private
         */
        private alpha;
        /**
         * Shows if the color `is empty`.
         * @private
         */
        private filled;
        /**
         * `Max value` of color channel.
         * @private
         */
        static readonly maxColourChannelValue: number;
        /**
         * Initialize a new instance for `PdfColor` class.
         */
        constructor();
        constructor(color1: PdfColor);
        constructor(color1: number, color2: number, color3: number);
        constructor(color1: number, color2: number, color3: number, color4: number);
        /**
         * `Calculate and assign` cyan, megenta, yellow colors from rgb values..
         * @private
         */
        private assignCMYK(r, g, b);
        /**
         * Gets or sets `Red` channel value.
         * @private
         */
        r: number;
        /**
         * Gets the `Red` color
         * @private
         */
        readonly red: number;
        /**
         * Gets or sets `Blue` channel value.
         * @private
         */
        b: number;
        /**
         * Gets the `blue` color.
         * @private
         */
        readonly blue: number;
        /**
         *  Gets or sets `Green` channel value.
         * @private
         */
        g: number;
        /**
         * Gets the `Green` color.
         * @private
         */
        readonly green: number;
        /**
         * Gets or sets `Gray` channel value.
         * @private
         */
        gray: number;
        /**
         * Gets whether the PDFColor `is Empty` or not.
         * @private
         */
        readonly isEmpty: boolean;
        /**
         * Gets or sets `Alpha` channel value.
         * @private
         */
        a: number;
        /**
         * Converts `PDFColor to PDF string` representation.
         * @private
         */
        toString(colorSpace: PdfColorSpace, stroke: boolean): string;
        /**
         * Sets `RGB` color.
         * @private
         */
        private rgbToString(ifStroking);
        /**
         * Converts `colour to a PDF array`.
         * @private
         */
        toArray(colorSpace: PdfColorSpace): PdfArray;
    }
    
    /**
     * PdfGraphics.ts class for EJ2-PDF
     */
    
    /**
     * `PdfGraphics` class represents a graphics context of the objects.
     * It's used for performing all the graphics operations.
     * ```typescript
     * // create a new PDF document
     * let document : PdfDocument = new PdfDocument();
     * // add a new page to the document
     * let page1 : PdfPage = document.pages.add();
     * // set the font
     * let font : PdfStandardFont = new PdfStandardFont(PdfFontFamily.Helvetica, 20);
     * // create black brush
     * let blackBrush : PdfSolidBrush = new PdfSolidBrush(new PdfColor(0, 0, 0));
     * //
     * //graphics of the page
     * let page1Graphics : PdfGraphics = page1.graphics;
     * // draw the text on the page1 graphics
     * page1Graphics.drawString('Hello World', font, blackBrush, new PointF(0, 0));
     * //
     * // save the document
     * document.save('output.pdf');
     * // destroy the document
     * document.destroy();
     * ```
     */
    export class PdfGraphics {
        /**
         * Specifies the mask of `path type values`.
         * @private
         */
        private static readonly pathTypesValuesMask;
        /**
         * Represents the `Stream writer` object.
         * @private
         */
        private pdfStreamWriter;
        /**
         * Represents the state, whether it `is saved or not`.
         * @private
         */
        private bStateSaved;
        /**
         * Represents the `Current pen`.
         * @private
         */
        private currentPen;
        /**
         * Represents the `Current brush`.
         * @private
         */
        private currentBrush;
        /**
         * Represents the `Current font`.
         * @private
         */
        private currentFont;
        /**
         * Represents the `Current font`.
         * @private
         */
        currentPage: PdfPage;
        /**
         * Represents the `Current color space`.
         * @private
         */
        private currentColorSpace;
        /**
         * The `transformation matrix` monitoring all changes with CTM.
         * @private
         */
        private transformationMatrix;
        /**
         * Stores `previous rendering mode`.
         * @private
         */
        private previousTextRenderingMode;
        /**
         * Previous `character spacing` value or 0.
         * @private
         */
        private previousCharacterSpacing;
        /**
         * Previous `word spacing` value or 0.
         * @private
         */
        private previousWordSpacing;
        /**
         * The `previously used text scaling` value.
         * @private
         */
        private previousTextScaling;
        /**
         * Event handler object to store instance of `PdfResources` class.
         * @private
         */
        private getResources;
        /**
         * Indicates whether `color space was initialized`.
         * @private
         */
        private bCSInitialized;
        /**
         * Represents the `Size of the canvas`.
         * @private
         */
        private canvasSize;
        /**
         * Represents the size of the canvas reduced by `margins and templates`.
         * @private
         */
        clipBounds: RectangleF;
        /**
         * Current `string format`.
         * @private
         */
        private currentStringFormat;
        /**
         * Instance of `ProcedureSets` class.
         * @private
         */
        private procedureSets;
        /**
         * To check wihether it is a `direct text rendering`.
         * @default true
         * @private
         */
        private isNormalRender;
        /**
         * check whether to `use font size` to calculate the shift.
         * @default false
         * @private
         */
        private isUseFontSize;
        /**
         * check whether the font is in `italic type`.
         * @default false
         * @private
         */
        private isItalic;
        /**
         * Check whether it is an `emf Text Matrix`.
         * @default false
         * @private
         */
        isEmfTextScaled: boolean;
        /**
         * Check whether it is an `emf` call.
         * @default false
         * @private
         */
        isEmf: boolean;
        /**
         * Check whether it is an `emf plus` call.
         * @default false
         * @private
         */
        isEmfPlus: boolean;
        /**
         * Check whether it is in `base line format`.
         * @default true
         * @private
         */
        isBaselineFormat: boolean;
        /**
         * Emf Text `Scaling Factor`.
         * @private
         */
        emfScalingFactor: SizeF;
        /**
         * Internal variable to store `layout result` after drawing string.
         * @private
         */
        private pdfStringLayoutResult;
        /**
         * Internal variable to store `layer` on which this graphics lays.
         * @private
         */
        private pageLayer;
        /**
         * To check whether the `last color space` of document and garphics is saved.
         * @private
         */
        private colorSpaceChanged;
        /**
         * Media box upper right `bound`.
         * @hidden
         * @private
         */
        private internalMediaBoxUpperRightBound;
        /**
         * Holds instance of PdfArray as `cropBox`.
         * @private
         */
        cropBox: PdfArray;
        /**
         * Checks whether the object is `transparencyObject`.
         * @hidden
         * @private
         */
        private static transparencyObject;
        /**
         * Stores an instance of `DictionaryProperties`.
         * @private
         */
        private dictionaryProperties;
        /**
         * `last document colorspace`.
         * @hidden
         * @private
         */
        private lastDocumentCS;
        /**
         * `last graphics's colorspace`.
         * @hidden
         * @private
         */
        private lastGraphicsCS;
        /**
         * Checks whether the x co-ordinate is need to set as client size or not.
         * @hidden
         * @private
         */
        private isOverloadWithPosition;
        /**
         * Checks whether the x co-ordinate is need to set as client size or not.
         * @hidden
         * @private
         */
        private isPointOverload;
        /**
         * Current colorspaces.
         * @hidden
         * @private
         */
        private currentColorSpaces;
        /**
         * Checks the current image `is optimized` or not.
         * @default false.
         * @private
         */
        isImageOptimized: boolean;
        /**
         * Returns the `current graphics state`.
         * @private
         */
        private gState;
        /**
         * Stores the `graphics states`.
         * @private
         */
        private graphicsState;
        /**
         * Stores the `trasparencies`.
         * @private
         */
        private trasparencies;
        /**
         * Indicates whether the object `had trasparency`.
         * @default false
         * @private
         */
        private istransparencySet;
        /**
         * Stores the instance of `PdfAutomaticFieldInfoCollection` class .
         * @default null
         * @private
         */
        private internalAutomaticFields;
        /**
         * Stores shift value for draw string with `PointF` overload.
         * @private
         * @hidden
         */
        private shift;
        /**
         * Stores the index of the start line that should draw with in the next page.
         * @private
         */
        private startCutIndex;
        /**
         * Returns the `result` after drawing string.
         * @private
         */
        readonly stringLayoutResult: PdfStringLayoutResult;
        /**
         * Gets the `size` of the canvas.
         * @private
         */
        readonly size: SizeF;
        /**
         * Gets and Sets the value of `MediaBox upper right bound`.
         * @private
         */
        mediaBoxUpperRightBound: number;
        /**
         * Gets the `size` of the canvas reduced by margins and page templates.
         * @private
         */
        readonly clientSize: SizeF;
        /**
         * Gets or sets the current `color space` of the document
         * @private
         */
        colorSpace: PdfColorSpace;
        /**
         * Gets the `stream writer`.
         * @private
         */
        readonly streamWriter: PdfStreamWriter;
        /**
         * Gets the `transformation matrix` reflecting current transformation.
         * @private
         */
        readonly matrix: PdfTransformationMatrix;
        /**
         * Gets the `layer` for the graphics, if exists.
         * @private
         */
        readonly layer: PdfPageLayer;
        /**
         * Gets the `page` for this graphics, if exists.
         * @private
         */
        readonly page: PdfPageBase;
        readonly automaticFields: PdfAutomaticFieldInfoCollection;
        /**
         * Initializes a new instance of the `PdfGraphics` class.
         * @private
         */
        constructor(size: SizeF, resources: GetResourceEventHandler, writer: PdfStreamWriter);
        /**
         * Initializes a new instance of the `PdfGraphics` class.
         * @private
         */
        constructor(size: SizeF, resources: GetResourceEventHandler, stream: PdfStream);
        /**
         * `Initializes` this instance.
         * @private
         */
        initialize(): void;
        /**
         * `Draw the template`.
         * @private
         */
        drawPdfTemplate(template: PdfTemplate, location: PointF): void;
        drawPdfTemplate(template: PdfTemplate, location: PointF, size: SizeF): void;
        /**
         * `Draws the specified text` at the specified location and size with string format.
         * ```typescript
         * // create a new PDF document
         * let document : PdfDocument = new PdfDocument();
         * // add a pages to the document
         * let page1 : PdfPage = document.pages.add();
         * // set font
         * let font : PdfStandardFont = new PdfStandardFont(PdfFontFamily.Helvetica, 20);
         * // set pen
         * let pen : PdfPen = new PdfPen(new PdfColor(255, 0, 0));
         * // set brush
         * let brush : PdfSolidBrush = new PdfSolidBrush(new PdfColor(0, 0, 0));
         * // set rectangle bounds
         * let rectangle : RectangleF = new RectangleF({x : 10, y : 10}, {width : 200, height : 200});
         * // set the format for string
         * let stringFormat : PdfStringFormat = new PdfStringFormat();
         * // set the text alignment
         * stringFormat.alignment = PdfTextAlignment.Center;
         * // set the vertical alignment
         * stringFormat.lineAlignment = PdfVerticalAlignment.Middle;
         * //
         * // draw the text
         * page1.graphics.drawString('Hello World', font, pen, brush, rectangle, stringFormat);
         * //
         * // save the document
         * document.save('output.pdf');
         * // destroy the document
         * document.destroy();
         * ```
         * @param s Input text.
         * @param font Font of the text.
         * @param pen Color of the text.
         * @param brush Color of the text.
         * @param layoutRectangle RectangleF structure that specifies the bounds of the drawn text.
         * @param format String formatting information.
         */
        drawString(s: string, font: PdfFont, pen: PdfPen, brush: PdfBrush, x: number, y: number, format: PdfStringFormat): void;
        drawString(s: string, font: PdfFont, pen: PdfPen, brush: PdfBrush, x: number, y: number, width: number, height: number, format: PdfStringFormat): void;
        /**
         * `Draws a line` connecting the two points specified by the coordinate pairs.
         * ```typescript
         * // create a new PDF document
         * let document : PdfDocument = new PdfDocument();
         * // create a new page
         * let page1 : PdfPage = document.pages.add();
         * //
         * // draw the line
         * page1.graphics.drawLine(new PdfPen(new PdfColor(0, 0, 255)), new PointF(10, 20), new PointF(100, 200));
         * //
         * // save the document.
         * document.save('output.pdf');
         * // destroy the document
         * document.destroy();
         * ```
         * @param pen Color of the line.
         * @param point1 PointF structure that represents the first point to connect.
         * @param point2 PointF structure that represents the second point to connect.
         */
        drawLine(pen: PdfPen, point1: PointF, point2: PointF): void;
        /**
         * `Draws a line` connecting the two points specified by the coordinate pairs.
         * ```typescript
         * // create a new PDF document
         * let document : PdfDocument = new PdfDocument();
         * // create a new page
         * let page1 : PdfPage = document.pages.add();
         * //
         * // draw the line
         * page1.graphics.drawLine(new PdfPen(new PdfColor(0, 0, 255)), 10, 20, 100, 200);
         * //
         * // save the document.
         * document.save('output.pdf');
         * // destroy the document
         * document.destroy();
         * ```
         * @param pen Color of the line.
         * @param x1 The x-coordinate of the first point.
         * @param y1 The y-coordinate of the first point.
         * @param x2 The x-coordinate of the second point.
         * @param y2 The y-coordinate of the second point.
         */
        drawLine(pen: PdfPen, x1: number, y1: number, x2: number, y2: number): void;
        /**
         * `Draws a rectangle` specified by a pen, a coordinate pair, a width, and a height.
         * ```typescript
         * // create a new PDF document.
         * let document : PdfDocument = new PdfDocument();
         * // create a new page
         * let page1 : PdfPage = document.pages.add();
         * // create pen for draw rectangle
         * let pen : PdfPen = new PdfPen(new PdfColor(238, 130, 238));
         * //
         * // draw rectangle
         * page1.graphics.drawRectangle(pen, 10, 10, 50, 100);
         * //
         * // save the document
         * document.save('output.pdf');
         * // destroy the document
         * document.destroy();
         * ```
         * @param pen Color of the rectangle.
         * @param x The x-coordinate of the upper-left corner of the rectangle to draw.
         * @param y The y-coordinate of the upper-left corner of the rectangle to draw.
         * @param width Width of the rectangle to draw.
         * @param height Height of the rectangle to draw.
         */
        drawRectangle(pen: PdfPen, x: number, y: number, width: number, height: number): void;
        /**
         * `Draws a rectangle` specified by a brush, coordinate pair, a width, and a height.
         * ```typescript
         * // create a new PDF document.
         * let document : PdfDocument = new PdfDocument();
         * // create a new page
         * let page1 : PdfPage = document.pages.add();
         * // create brush for draw rectangle
         * let brush : PdfSolidBrush = new PdfSolidBrush(new PdfColor(238, 130, 238));
         * //
         * // draw rectangle
         * page1.graphics.drawRectangle(brush, 10, 10, 50, 100);
         * //
         * // save the document
         * document.save('output.pdf');
         * // destroy the document
         * document.destroy();
         * ```
         * @param brush Color of the rectangle.
         * @param x The x-coordinate of the upper-left corner of the rectangle to draw.
         * @param y The y-coordinate of the upper-left corner of the rectangle to draw.
         * @param width Width of the rectangle to draw.
         * @param height Height of the rectangle to draw.
         */
        drawRectangle(brush: PdfBrush, x: number, y: number, width: number, height: number): void;
        /**
         * `Draws a rectangle` specified by a pen, a coordinate pair, a width, and a height.
         * ```typescript
         * // create a new PDF document.
         * let document : PdfDocument = new PdfDocument();
         * // create a new page
         * let page1 : PdfPage = document.pages.add();
         * // create brush for draw rectangle
         * let brush : PdfSolidBrush = new PdfSolidBrush(new PdfColor(238, 130, 238));
         * // set pen
         * let pen : PdfPen = new PdfPen(new PdfColor(0, 0, 0));
         * //
         * // draw rectangle
         * page1.graphics.drawRectangle(pen, brush, 10, 10, 50, 100);
         * //
         * // save the document
         * document.save('output.pdf');
         * // destroy the document
         * document.destroy();
         * ```
         * @param pen A Pen that determines the color, width, and style of the rectangle.
         * @param brush Color of the rectangle.
         * @param x The x-coordinate of the upper-left corner of the rectangle to draw.
         * @param y The y-coordinate of the upper-left corner of the rectangle to draw.
         * @param width Width of the rectangle to draw.
         * @param height Height of the rectangle to draw.
         */
        drawRectangle(pen: PdfPen, brush: PdfBrush, x: number, y: number, width: number, height: number): void;
        /**
         * `Draws the path`.
         * @private
         */
        private drawPath(pen, brush, needClosing);
        /**
         * `Draws the path`.
         * @private
         */
        private drawPath(pen, brush, fillMode, needClosing);
        /**
         * `Draws the specified image`, using its original physical size, at the location specified by a coordinate pair.
         * ```typescript
         * // create a new PDF document.
         * let document : PdfDocument = new PdfDocument();
         * // add a page to the document.
         * let page1 : PdfPage = document.pages.add();
         * // base64 string of an image
         * let imageString : string = '/9j/3+2w7em7HzY/KiijFw … 1OEYRUYrQ45yc5OUtz/9k=';
         * // load the image from the base64 string of original image.
         * let image : PdfBitmap = new PdfBitmap(imageString);
         * //
         * // draw the image
         * page1.graphics.drawImage(image, 10, 10);
         * //
         * // save the document.
         * document.save('output.pdf');
         * // destroy the document
         * document.destroy();
         * ```
         * @param image PdfImage to draw.
         * @param x The x-coordinate of the upper-left corner of the drawn image.
         * @param y The y-coordinate of the upper-left corner of the drawn image.
         */
        drawImage(image: PdfImage, x: number, y: number): void;
        /**
         * `Draws the specified image`, using its original physical size, at the location specified by a coordinate pair.
         * ```typescript
         * // create a new PDF document.
         * let document : PdfDocument = new PdfDocument();
         * // add a page to the document.
         * let page1 : PdfPage = document.pages.add();
         * // base64 string of an image
         * let imageString : string = '/9j/3+2w7em7HzY/KiijFw … 1OEYRUYrQ45yc5OUtz/9k=';
         * // load the image from the base64 string of original image.
         * let image : PdfBitmap = new PdfBitmap(imageString);
         * //
         * // draw the image
         * page1.graphics.drawImage(image, 0, 0, 100, 100);
         * //
         * // save the document.
         * document.save('output.pdf');
         * // destroy the document
         * document.destroy();
         * ```
         * @param image PdfImage to draw.
         * @param x The x-coordinate of the upper-left corner of the drawn image.
         * @param y The y-coordinate of the upper-left corner of the drawn image.
         * @param width Width of the drawn image.
         * @param height Height of the drawn image.
         */
        drawImage(image: PdfImage, x: number, y: number, width: number, height: number): void;
        /**
         * Returns `bounds` of the line info.
         * @private
         */
        getLineBounds(lineIndex: number, result: PdfStringLayoutResult, font: PdfFont, layoutRectangle: RectangleF, format: PdfStringFormat): RectangleF;
        /**
         * Creates `lay outed rectangle` depending on the text settings.
         * @private
         */
        checkCorrectLayoutRectangle(textSize: SizeF, x: number, y: number, format: PdfStringFormat): RectangleF;
        /**
         * Sets the `layer` for the graphics.
         * @private
         */
        setLayer(layer: PdfPageLayer): void;
        /**
         * Adding page number field before page saving.
         * @private
         */
        pageSave(page: PdfPage): void;
        /**
         * `Draws a layout result`.
         * @private
         */
        drawStringLayoutResult(result: PdfStringLayoutResult, font: PdfFont, pen: PdfPen, brush: PdfBrush, layoutRectangle: RectangleF, format: PdfStringFormat): void;
        /**
         * Gets the `next page`.
         * @private
         */
        getNextPage(): PdfPage;
        /**
         * `Sets the clipping` region of this Graphics to the rectangle specified by a RectangleF structure.
         * ```typescript
         * // create a new PDF document
         * let document : PdfDocument = new PdfDocument();
         * // create a new page
         * let page1 : PdfPage = document.pages.add();
         * // create PDF graphics for the page
         * let graphics : PdfGraphics = page1.graphics;
         * // set the font
         * let font : PdfFont = new PdfStandardFont(PdfFontFamily.TimesRoman, 20);
         * // create black brush
         * let blackBrush : PdfSolidBrush = new PdfSolidBrush(new PdfColor(0, 0, 0));
         * //
         * // set clipping with rectangle bounds
         * graphics.setClip(new RectangleF({x : 10, y : 80}, {width : 150 , height : 15}));
         * //
         * // draw the text after clipping
         * graphics.drawString('Text after clipping', font, blackBrush, new PointF(10, 80));
         * // save the document.
         * document.save('output.pdf');
         * // destroy the document
         * document.destroy();
         * ```
         * @param rectangle RectangleF structure that represents the new clip region.
         */
        setClip(rectangle: RectangleF): void;
        /**
         * `Sets the clipping` region of this Graphics to the result of the specified operation combining the current clip region and the rectangle specified by a RectangleF structure.
         * @private
         */
        setClip(rectangle: RectangleF, mode: PdfFillMode): void;
        /**
         * Applies all the `text settings`.
         * @private
         */
        private applyStringSettings(font, pen, brush, format, bounds);
        /**
         * Calculates `shift value` if the text is vertically aligned.
         * @private
         */
        getTextVerticalAlignShift(textHeight: number, boundsHeight: number, format: PdfStringFormat): number;
        /**
         * `Draws layout result`.
         * @private
         */
        private drawLayoutResult(result, font, format, layoutRectangle);
        /**
         * `Draws Ascii line`.
         * @private
         */
        private drawAsciiLine(lineInfo, layoutRectangle, font, format);
        /**
         * `Justifies` the line if needed.
         * @private
         */
        private justifyLine(lineInfo, boundsWidth, format);
        /**
         * `Reset` or reinitialize the current graphic value.
         * @private
         */
        reset(size: SizeF): void;
        /**
         * Checks whether the line should be `justified`.
         * @private
         */
        private shouldJustify(lineInfo, boundsWidth, format);
        /**
         * Emulates `Underline, Strikeout` of the text if needed.
         * @private
         */
        private underlineStrikeoutText(pen, brush, result, font, layoutRectangle, format);
        /**
         * `Creates a pen` for drawing lines in the text.
         * @private
         */
        private createUnderlineStikeoutPen(pen, brush, font, format);
        /**
         * Return `text rendering mode`.
         * @private
         */
        private getTextRenderingMode(pen, brush, format);
        /**
         * Returns `line indent` for the line.
         * @private
         */
        private getLineIndent(lineInfo, format, layoutBounds, firstLine);
        /**
         * Calculates shift value if the line is `horizontaly aligned`.
         * @private
         */
        private getHorizontalAlignShift(lineWidth, boundsWidth, format);
        /**
         * Gets or sets the value that indicates `text direction` mode.
         * @private
         */
        private rightToLeft(format);
        /**
         * Controls all `state modifications` and react repectively.
         * @private
         */
        private stateControl(pen, brush, font);
        /**
         * Controls all `state modifications` and react respectively.
         * @private
         */
        private stateControl(pen, brush, font, format);
        /**
         * Initializes the `current color space`.
         * @private
         */
        private initCurrentColorSpace(colorspace);
        /**
         * Controls the `pen state`.
         * @private
         */
        private penControl(pen, saveState);
        /**
         * Controls the `brush state`.
         * @private
         */
        private brushControl(brush, saveState);
        /**
         * Saves the font and other `font settings`.
         * @private
         */
        private fontControl(font, format, saveState);
        /**
         * `Sets the transparency` of this Graphics with the specified value for pen.
         * ```typescript
         * // create a new PDF document
         * let document : PdfDocument = new PdfDocument();
         * // create a new page
         * let page1 : PdfPage = document.pages.add();
         * // create pen
         * let pen : PdfPen = new PdfPen(new PdfColor(0, 0, 0));
         * //
         * // set transparency
         * page1.graphics.setTransparency(0.5);
         * //
         * // draw the rectangle after applying transparency
         * page1.graphics.drawRectangle(pen, new RectangleF({x : 0, y : 0}, {width : 100, height : 50}));
         * // save the document.
         * document.save('output.pdf');
         * // destroy the document
         * document.destroy();
         * ```
         * @param alpha The alpha value for both pen and brush.
         */
        setTransparency(alpha: number): void;
        /**
         * `Sets the transparency` of this Graphics with the specified value for pen and brush.
         * ```typescript
         * // create a new PDF document
         * let document : PdfDocument = new PdfDocument();
         * // create a new page
         * let page1 : PdfPage = document.pages.add();
         * // create pen
         * let pen : PdfPen = new PdfPen(new PdfColor(0, 0, 0));
         * // set brush
         * let brush : PdfSolidBrush = new PdfSolidBrush(new PdfColor(0, 0, 0));
         * //
         * // set transparency
         * page1.graphics.setTransparency(0.8, 0.2);
         * //
         * // draw the rectangle after applying transparency
         * page1.graphics.drawRectangle(pen, brush, new RectangleF({x : 0, y : 0}, {width : 100, height : 50}));
         * // save the document.
         * document.save('output.pdf');
         * // destroy the document
         * document.destroy();
         * ```
         * @param alphaPen The alpha value for pen.
         * @param alphaBrush The alpha value for brush.
         */
        setTransparency(alphaPen: number, alphaBrush: number): void;
        /**
         * `Sets the transparency` of this Graphics with the specified PdfBlendMode.
         * @private
         */
        setTransparency(alphaPen: number, alphaBrush: number, blendMode: PdfBlendMode): void;
        /**
         * Sets the `drawing area and translates origin`.
         * @private
         */
        clipTranslateMargins(clipBounds: RectangleF): void;
        clipTranslateMargins(x: number, y: number, left: number, top: number, right: number, bottom: number): void;
        /**
         * `Updates y` co-ordinate.
         * @private
         */
        updateY(y: number): number;
        /**
         * Used to `translate the transformation`.
         * ```typescript
         * // create a new PDF document
         * let document : PdfDocument = new PdfDocument();
         * // create a new page
         * let page1 : PdfPage = document.pages.add();
         * // set pen
         * let pen : PdfPen = new PdfPen(new PdfColor(0, 0, 0));
         * //
         * // set translate transform
         * page1.graphics.translateTransform(100, 100);
         * //
         * // draw the rectangle after applying translate transform
         * page1.graphics.drawRectangle(pen, new RectangleF({x : 0, y : 0}, {width : 100, height : 50}));
         * // save the document.
         * document.save('output.pdf');
         * // destroy the document
         * document.destroy();
         * ```
         * @param offsetX The x-coordinate of the translation.
         * @param offsetY The y-coordinate of the translation.
         */
        translateTransform(offsetX: number, offsetY: number): void;
        /**
         * `Translates` coordinates of the input matrix.
         * @private
         */
        private getTranslateTransform(x, y, input);
        /**
         * Applies the specified `scaling operation` to the transformation matrix of this Graphics by prepending it to the object's transformation matrix.
         * ```typescript
         * // create a new PDF document
         * let document : PdfDocument = new PdfDocument();
         * // create a new page
         * let page1 : PdfPage = document.pages.add();
         * // create pen
         * let pen : PdfPen = new PdfPen(new PdfColor(0, 0, 0));
         * //
         * // apply scaling trasformation
         * page1.graphics.scaleTransform(1.5, 2);
         * //
         * // draw the rectangle after applying scaling transform
         * page1.graphics.drawRectangle(pen, new RectangleF({x : 100, y : 100}, {width : 100, height : 50}));
         * // save the document.
         * document.save('output.pdf');
         * // destroy the document
         * document.destroy();
         * ```
         * @param scaleX Scale factor in the x direction.
         * @param scaleY Scale factor in the y direction.
         */
        scaleTransform(scaleX: number, scaleY: number): void;
        /**
         * `Scales` coordinates of the input matrix.
         * @private
         */
        private getScaleTransform(x, y, input);
        /**
         * Applies the specified `rotation` to the transformation matrix of this Graphics.
         * ```typescript
         * // create a new PDF document
         * let document : PdfDocument = new PdfDocument();
         * // create a new page
         * let page1 : PdfPage = document.pages.add();
         * // create pen
         * let pen : PdfPen = new PdfPen(new PdfColor(0, 0, 0));
         * //
         * // set RotateTransform with 25 degree of angle
         * page1.graphics.rotateTransform(25);
         * //
         * // draw the rectangle after RotateTransformation
         * page1.graphics.drawRectangle(pen, new RectangleF({x : 100, y : 100}, {width : 100, height : 50}));
         * // save the document.
         * document.save('output.pdf');
         * // destroy the document
         * document.destroy();
         * ```
         * @param angle Angle of rotation in degrees.
         */
        rotateTransform(angle: number): void;
        /**
         * `Initializes coordinate system`.
         * @private
         */
        initializeCoordinates(): void;
        /**
         * `Rotates` coordinates of the input matrix.
         * @private
         */
        private getRotateTransform(angle, input);
        /**
         * `Saves` the current state of this Graphics and identifies the saved state with a GraphicsState.
         * ```typescript
         * // create a new PDF document
         * let document : PdfDocument = new PdfDocument();
         * // create a new page
         * let page1 : PdfPage = document.pages.add();
         * // create pen
         * let pen : PdfPen = new PdfPen(new PdfColor(0, 0, 0));
         * //
         * // save the graphics state
         * let state1 : PdfGraphicsState = page1.graphics.save();
         * //
         * page1.graphics.scaleTransform(1.5, 2);
         * // draw the rectangle
         * page1.graphics.drawRectangle(pen, new RectangleF({x : 100, y : 100}, {width : 100, height : 50}));
         * // restore the graphics state
         * page1.graphics.restore(state1);
         * // save the document.
         * document.save('output.pdf');
         * // destroy the document
         * document.destroy();
         * ```
         */
        save(): PdfGraphicsState;
        /**
         * `Restores the state` of this Graphics to the state represented by a GraphicsState.
         * @private
         */
        restore(): void;
        /**
         * `Restores the state` of this Graphics to the state represented by a GraphicsState.
         * @private
         */
        restore(state: PdfGraphicsState): void;
        /**
         * `Restores graphics state`.
         * @private
         */
        private doRestoreState();
    }
    /**
     * `GetResourceEventHandler` class is alternate for event handlers and delegates.
     * @private
     * @hidden
     */
    export class GetResourceEventHandler {
        /**
         * Return the instance of `PdfResources` class.
         * @private
         */
        getResources(): PdfResources;
        /**
         * Variable to store instance of `PdfPageBase as sender`.
         * @hidden
         * @private
         */
        sender: PdfPageBase | PdfTemplate;
        /**
         * Initialize instance of `GetResourceEventHandler` class.
         * Alternate for event handlers and delegates.
         * @private
         */
        constructor(sender: PdfPageBase | PdfTemplate);
    }
    export class PdfGraphicsState {
        /**
         * `Parent graphics` object.
         * @private
         */
        private pdfGraphics;
        /**
         * The current `transformation matrix`.
         * @private
         */
        private transformationMatrix;
        /**
         * Stores `previous rendering mode`.
         * @default TextRenderingMode.Fill
         * @private
         */
        private internalTextRenderingMode;
        /**
         * `Previous character spacing` value or 0.
         * @default 0.0
         * @private
         */
        private internalCharacterSpacing;
        /**
         * `Previous word spacing` value or 0.
         * @default 0.0
         * @private
         */
        private internalWordSpacing;
        /**
         * The previously used `text scaling value`.
         * @default 100.0
         * @private
         */
        private internalTextScaling;
        /**
         * `Current pen`.
         * @private
         */
        private pdfPen;
        /**
         * `Current brush`.
         * @private
         */
        private pdfBrush;
        /**
         * `Current font`.
         * @private
         */
        private pdfFont;
        /**
         * `Current color space`.
         * @default PdfColorSpace.Rgb
         * @private
         */
        private pdfColorSpace;
        /**
         * Gets the parent `graphics object`.
         * @private
         */
        readonly graphics: PdfGraphics;
        /**
         * Gets the `current matrix`.
         * @private
         */
        readonly matrix: PdfTransformationMatrix;
        /**
         * Gets or sets the `current character spacing`.
         * @private
         */
        characterSpacing: number;
        /**
         * Gets or sets the `word spacing` value.
         * @private
         */
        wordSpacing: number;
        /**
         * Gets or sets the `text scaling` value.
         * @private
         */
        textScaling: number;
        /**
         * Gets or sets the `current pen` object.
         * @private
         */
        pen: PdfPen;
        /**
         * Gets or sets the `brush`.
         * @private
         */
        brush: PdfBrush;
        /**
         * Gets or sets the `current font` object.
         * @private
         */
        font: PdfFont;
        /**
         * Gets or sets the `current color space` value.
         * @private
         */
        colorSpace: PdfColorSpace;
        /**
         * Gets or sets the `text rendering mode`.
         * @private
         */
        textRenderingMode: TextRenderingMode;
        /**
         * `default constructor`.
         * @private
         */
        constructor();
        /**
         * Creates new object for `PdfGraphicsState`.
         * @private
         */
        constructor(graphics: PdfGraphics, matrix: PdfTransformationMatrix);
    }
    
    /**
     * PdfMargins.ts class for EJ2-PDF
     * A class representing PDF page margins.
     */
    export class PdfMargins {
        /**
         * Represents the `Left margin` value.
         * @private
         */
        private leftMargin;
        /**
         * Represents the `Top margin` value.
         * @private
         */
        private topMargin;
        /**
         * Represents the `Right margin` value.
         * @private
         */
        private rightMargin;
        /**
         * Represents the `Bottom margin` value.
         * @private
         */
        private bottomMargin;
        /**
         * Represents the `Default Page Margin` value.
         * @default 0.0
         * @private
         */
        private readonly pdfMargin;
        /**
         * Initializes a new instance of the `PdfMargins` class.
         * @private
         */
        constructor();
        /**
         * Gets or sets the `left margin` size.
         * @private
         */
        left: number;
        /**
         * Gets or sets the `top margin` size.
         * @private
         */
        top: number;
        /**
         * Gets or sets the `right margin` size.
         * @private
         */
        right: number;
        /**
         * Gets or sets the `bottom margin` size.
         * @private
         */
        bottom: number;
        /**
         * Sets the `margins`.
         * @private
         */
        all: number;
        /**
         * Sets the `margins`.
         * @private
         */
        setMargins(margin1: number): void;
        /**
         * Sets the `margins`.
         * @private
         */
        setMargins(margin1: number, margin2: number): void;
        /**
         * Sets the `margins`.
         * @private
         */
        setMargins(margin1: number, margin2: number, margin3: number, margin4: number): void;
        /**
         * `Clones` the object.
         * @private
         */
        clone(): PdfMargins;
    }
    
    /**
     * PdfPen.ts class for EJ2-PDF
     */
    
    /**
     * `PdfPen` class defining settings for drawing operations, that determines the color,
     * width, and style of the drawing elements.
     * ```typescript
     * // create a new PDF document
     * let document : PdfDocument = new PdfDocument();
     * // create a new page
     * let page1 : PdfPage = document.pages.add();
     * // set pen
     * let pen : PdfPen = new PdfPen(new PdfColor(0, 0, 0));
     * // draw rectangle
     * page1.graphics.drawRectangle(pen, new RectangleF({x : 0, y : 0}, {width : 100, height : 50}));
     * // save the document.
     * document.save('output.pdf');
     * // destroy the document
     * document.destroy();
     * ```
     */
    export class PdfPen {
        /**
         * Specifies the `color of the pen`.
         * @default new PdfColor()
         * @private
         */
        private pdfColor;
        /**
         * Specifies the `dash offset of the pen`.
         * @default 0
         * @private
         */
        private dashOffsetValue;
        /**
         * Specifies the `dash pattern of the pen`.
         * @default [0]
         * @private
         */
        private penDashPattern;
        /**
         * Specifies the `dash style of the pen`.
         * @default Solid
         * @private
         */
        private pdfDashStyle;
        /**
         * Specifies the `line cap of the pen`.
         * @default 0
         * @private
         */
        private pdfLineCap;
        /**
         * Specifies the `line join of the pen`.
         * @default 0
         * @private
         */
        private pdfLineJoin;
        /**
         * Specifies the `width of the pen`.
         * @default 1.0
         * @private
         */
        private penWidth;
        /**
         * Specifies the `brush of the pen`.
         * @private
         */
        private pdfBrush;
        /**
         * Specifies the `mitter limit of the pen`.
         * @default 0.0
         * @private
         */
        private internalMiterLimit;
        /**
         * Stores the `colorspace` value.
         * @default Rgb
         * @private
         */
        private colorSpace;
        /**
         * Initializes a new instance of the `PdfPen` class with color.
         * ```typescript
         * // create a new PDF document
         * let document : PdfDocument = new PdfDocument();
         * // create a new page
         * let page1 : PdfPage = document.pages.add();
         * //
         * // set pen
         * let pen : PdfPen = new PdfPen(new PdfColor(0, 0, 0));
         * //
         * // draw rectangle
         * page1.graphics.drawRectangle(pen, new RectangleF({x : 0, y : 0}, {width : 100, height : 50}));
         * // save the document.
         * document.save('output.pdf');
         * // destroy the document
         * document.destroy();
         * ```
         * @param color Color of the pen.
         */
        constructor(color: PdfColor);
        /**
         * Initializes a new instance of the `PdfPen` class with 'PdfBrush' class and width of the pen.
         * @private
         */
        constructor(brush: PdfBrush, width: number);
        /**
         * Initializes a new instance of the `PdfPen` class with color and width of the pen.
         * ```typescript
         * // create a new PDF document
         * let document : PdfDocument = new PdfDocument();
         * // create a new page
         * let page1 : PdfPage = document.pages.add();
         * //
         * // set pen
         * let pen : PdfPen = new PdfPen(new PdfColor(0, 0, 0), 2);
         * //
         * // draw rectangle
         * page1.graphics.drawRectangle(pen, new RectangleF({x : 0, y : 0}, {width : 100, height : 50}));
         * // save the document.
         * document.save('output.pdf');
         * // destroy the document
         * document.destroy();
         * ```
         * @param color Color of the pen.
         * @param width Width of the pen's line.
         */
        constructor(color: PdfColor, width: number);
        /**
         * Gets or sets the `color of the pen`.
         * @private
         */
        color: PdfColor;
        /**
         * Gets or sets the `dash offset of the pen`.
         * @private
         */
        dashOffset: number;
        /**
         * Gets or sets the `dash pattern of the pen`.
         * @private
         */
        dashPattern: number[];
        /**
         * Gets or sets the `dash style of the pen`.
         * ```typescript
         * // create a new PDF document
         * let document : PdfDocument = new PdfDocument();
         * // create a new page
         * let page1 : PdfPage = document.pages.add();
         * // set pen
         * let pen : PdfPen = new PdfPen(new PdfColor(0, 0, 0));
         * //
         * // set pen style
         * pen.dashStyle = PdfDashStyle.DashDot;
         * // get pen style
         * let style : PdfDashStyle = pen.dashStyle;
         * //
         * // draw rectangle
         * page1.graphics.drawRectangle(pen, new RectangleF({x : 0, y : 0}, {width : 100, height : 50}));
         * // save the document.
         * document.save('output.pdf');
         * // destroy the document
         * document.destroy();
         * ```
         */
        dashStyle: PdfDashStyle;
        /**
         * Gets or sets the `line cap of the pen`.
         * @private
         */
        lineCap: PdfLineCap;
        /**
         * Gets or sets the `line join style of the pen`.
         * @private
         */
        lineJoin: PdfLineJoin;
        /**
         * Gets or sets the `miter limit`.
         * @private
         */
        miterLimit: number;
        /**
         * Gets or sets the `width of the pen`.
         * ```typescript
         * // create a new PDF document
         * let document : PdfDocument = new PdfDocument();
         * // create a new page
         * let page1 : PdfPage = document.pages.add();
         * // set pen
         * let pen : PdfPen = new PdfPen(new PdfColor(0, 0, 0));
         * //
         * // set pen width
         * pen.width = 2;
         * //
         * // draw rectangle
         * page1.graphics.drawRectangle(pen, new RectangleF({x : 0, y : 0}, {width : 100, height : 50}));
         * // save the document.
         * document.save('output.pdf');
         * // destroy the document
         * document.destroy();
         * ```
         */
        width: number;
        /**
         * `Clones` this instance of PdfPen class.
         * @private
         */
        clone(): PdfPen;
        /**
         * `Sets the brush`.
         * @private
         */
        private setBrush(brush);
        /**
         * `Monitors the changes`.
         * @private
         */
        monitorChanges(currentPen: PdfPen, streamWriter: PdfStreamWriter, getResources: GetResourceEventHandler, saveState: boolean, currentColorSpace: PdfColorSpace, matrix: PdfTransformationMatrix): boolean;
        /**
         * `Controls the dash style` and behaviour of each line.
         * @private
         */
        private dashControl(pen, saveState, streamWriter);
        /**
         * `Gets the pattern` of PdfPen.
         * @private
         */
        getPattern(): number[];
    }
    
    /**
     * PdfResources.ts class for EJ2-PDF
     */
    
    /**
     * `PdfResources` class used to set resource contents like font, image.
     * @private
     */
    export class PdfResources extends PdfDictionary {
        /**
         * Dictionary for the `objects names`.
         * @private
         */
        private pdfNames;
        /**
         * Dictionary for the `properties names`.
         * @private
         */
        private properties;
        /**
         * `Font name`.
         * @private
         */
        private fontName;
        /**
         * Stores instance of `parent document`.
         * @private
         */
        private pdfDocument;
        /**
         * Initializes a new instance of the `PdfResources` class.
         * @private
         */
        constructor();
        /**
         * Initializes a new instance of the `PdfResources` class.
         * @private
         */
        constructor(baseDictionary: PdfDictionary);
        /**
         * Gets the `font names`.
         * @private
         */
        private readonly names;
        /**
         * Get or set the `page document`.
         * @private
         */
        document: PdfDocument;
        /**
         * `Generates name` for the object and adds to the resource if the object is new.
         * @private
         */
        getName(obj: IPdfWrapper): PdfName;
        /**
         * Gets `resource names` to font dictionaries.
         * @private
         */
        getNames(): TemporaryDictionary<IPdfPrimitive, PdfName>;
        /**
         * Add `RequireProcedureSet` into procset array.
         * @private
         */
        requireProcedureSet(procedureSetName: string): void;
        /**
         * `Remove font` from array.
         * @private
         */
        removeFont(name: string): void;
        /**
         * Generates `Unique string name`.
         * @private
         */
        private generateName();
        /**
         * `Adds object` to the resources.
         * @private
         */
        add(font: PdfFont, name: PdfName): void;
        /**
         * `Adds object` to the resources.
         * @private
         */
        add(template: PdfTemplate, name: PdfName): void;
        /**
         * `Adds object` to the resources.
         * @private
         */
        add(brush: PdfBrush, name: PdfName): void;
        /**
         * `Adds object` to the resources.
         * @private
         */
        add(transparency: PdfTransparency, name: PdfName): void;
        /**
         * `Adds object` to the resources.
         * @private
         */
        add(image: PdfImage | PdfBitmap, name: PdfName): void;
    }
    /**
     * Used to create new guid for resources.
     * @private
     */
    export class Guid {
        /**
         * `String value of GUID`.
         * @private
         */
        private stringValue;
        /**
         * static field to store `endding value of current GUID`.
         * @private
         */
        private static guid;
        /**
         * Generate `Random number` for GUID.
         * @private
         */
        private static readonly randomNumber;
        /**
         * Initialize an `instance of GUID` class.
         * @private
         */
        constructor(stringValue?: string);
        /**
         * Return the value of `GUID as string`.
         * @private
         */
        toString(): string;
        /**
         * Generate `new GUID`.
         * @private
         */
        static getNewGuidString(): string;
    }
    
    /**
     * PdfTransformationMatrix.ts class for EJ2-PDF
     */
    
    /**
     * Class for representing Root `transformation matrix`.
     */
    export class PdfTransformationMatrix {
        /**
         * Value for `angle converting`.
         * @default Math.PI / 180.0
         * @private
         */
        private static readonly degRadFactor;
        /**
         * Value for `angle converting`.
         * @default 180.0 / Math.PI
         * @private
         */
        private readonly radDegFactor;
        /**
         * `Transformation matrix`.
         * @private
         */
        private transformationMatrix;
        /**
         * Gets or sets the `internal matrix object`.
         * @private
         */
        matrix: Matrix;
        /**
         * Initializes object of `PdfTransformationMatrix` class.
         * @private
         */
        constructor();
        /**
         * Initializes object of `PdfTransformationMatrix` class.
         * @private
         */
        constructor(value: boolean);
        /**
         * `Translates` coordinates by specified coordinates.
         * @private
         */
        translate(offsetX: number, offsetY: number): void;
        /**
         * `Scales` coordinates by specified coordinates.
         * @private
         */
        scale(scaleX: number, scaleY: number): void;
        /**
         * `Rotates` coordinate system in counterclockwise direction.
         * @private
         */
        rotate(angle: number): void;
        /**
         * Gets `PDF representation`.
         * @private
         */
        toString(): string;
        /**
         * `Multiplies` matrices (changes coordinate system.)
         * @private
         */
        multiply(matrix: PdfTransformationMatrix): void;
        /**
         * Converts `degrees to radians`.
         * @private
         */
        static degreesToRadians(degreesX: number): number;
        /**
         * Converts `radians to degrees`.
         * @private
         */
        radiansToDegrees(radians: number): number;
        /**
         * `Clones` this instance of PdfTransformationMatrix.
         * @private
         */
        clone(): PdfTransformationMatrix;
    }
    export class Matrix {
        /**
         * `elements` in the matrix.
         * @private
         */
        private metrixElements;
        /**
         * Initializes a new instance of the `Matrix` class.
         * @private
         */
        constructor();
        /**
         * Initializes a new instance of the `Matrix` class with number array.
         * @private
         */
        constructor(elements: number[]);
        /**
         * Initializes a new instance of the `Matrix` class.
         * @private
         */
        constructor(m11: number, m12: number, m21: number, m22: number, dx: number, dy: number);
        /**
         * Gets the `elements`.
         * @private
         */
        readonly elements: number[];
        /**
         * Gets the off set `X`.
         * @private
         */
        readonly offsetX: number;
        /**
         * Gets the off set `Y`.
         * @private
         */
        readonly offsetY: number;
        /**
         * `Translates` coordinates by specified coordinates.
         * @private
         */
        translate(offsetX: number, offsetY: number): void;
        /**
         * `Translates` the specified offset X.
         * @private
         */
        transform(point: PointF): PointF;
        /**
         * `Multiplies matrices` (changes coordinate system.)
         * @private
         */
        multiply(matrix: Matrix): void;
        /**
         * `Dispose` this instance of PdfTransformationMatrix class.
         * @private
         */
        dispose(): void;
        /**
         * `Clones` this instance of PdfTransformationMatrix class.
         * @private
         */
        clone(): Object;
    }
    
    /**
     * PdfTransparency.ts class for EJ2-PDF
     */
    
    /**
     * Represents a simple `transparency`.
     * @private
     */
    export class PdfTransparency implements IPdfWrapper {
        /**
         * Internal variable to store `dictionary`.
         * @default new PdfDictionary()
         * @private
         */
        private dictionary;
        /**
         * Internal variable for accessing fields from `DictionryProperties` class.
         * @default new DictionaryProperties()
         * @private
         */
        private dictionaryProperties;
        /**
         * Initializes a new instance of the `Transparency` class.
         * @private
         */
        constructor(stroke: number, fill: number, mode: PdfBlendMode);
        /**
         * Gets the `element`.
         * @private
         */
        readonly element: IPdfPrimitive;
    }
    
    /**
     * PdfUnitConverter.ts class for EJ2-PDF
     */
    
    /**
     * Used to perform `convertion between pixels and points`.
     * @private
     */
    export class PdfUnitConverter {
        /**
         * Indicates default `horizontal resolution`.
         * @default 96
         * @private
         */
        static readonly horizontalResolution: number;
        /**
         * Indicates default `vertical resolution`.
         * @default 96
         * @private
         */
        static readonly verticalResolution: number;
        /**
         * `Width, in millimeters`, of the physical screen.
         * @private
         */
        static readonly horizontalSize: number;
        /**
         * `Height, in millimeters`, of the physical screen.
         * @private
         */
        static readonly verticalSize: number;
        /**
         * `Width, in pixels`, of the screen.
         * @private
         */
        static readonly pxHorizontalResolution: number;
        /**
         * `Height, in pixels`, of the screen.
         * @private
         */
        static readonly pxVerticalResolution: number;
        /**
         * `Matrix` for conversations between different numeric systems.
         * @private
         */
        private proportions;
        /**
         * Initializes a new instance of the `UnitConvertor` class with DPI value.
         * @private
         */
        constructor(dpi: number);
        /**
         * `Converts` the value, from one graphics unit to another graphics unit.
         * @private
         */
        convertUnits(value: number, from: PdfGraphicsUnit, to: PdfGraphicsUnit): number;
        /**
         * Converts the value `to pixel` from specified graphics unit.
         * @private
         */
        convertToPixels(value: number, from: PdfGraphicsUnit): number;
        /**
         * Converts value, to specified graphics unit `from Pixel`.
         * @private
         */
        convertFromPixels(value: number, to: PdfGraphicsUnit): number;
        /**
         * `Update proportions` matrix according to Graphics settings.
         * @private
         */
        private updateProportionsHelper(pixelPerInch);
    }
    
    /**
     * PdfBrush.ts class for EJ2-PDF
     */
    
    /**
     * `PdfBrush` class provides objects used to fill the interiors of graphical shapes such as rectangles,
     * ellipses, pies, polygons, and paths.
     * @private
     */
    export abstract class PdfBrush {
        /**
         * Creates instanceof `PdfBrush` class.
         * @hidden
         * @private
         */
        constructor();
        /**
         * Stores the instance of `PdfColor` class.
         * @private
         */
        color: PdfColor;
        /**
         * `MonitorChanges` abstract method overload.
         * @hidden
         * @private
         */
        abstract monitorChanges(brush: PdfBrush, streamWriter: PdfStreamWriter, getResources: GetResourceEventHandler, saveChanges: boolean, currentColorSpace: PdfColorSpace): boolean;
        /**
         * `MonitorChanges` abstract method overload.
         * @hidden
         * @private
         */
        abstract monitorChanges(brush: PdfBrush, streamWriter: PdfStreamWriter, getResources: GetResourceEventHandler, saveChanges: boolean, currentColorSpace: PdfColorSpace, check: boolean): boolean;
        /**
         * `MonitorChanges` abstract method overload.
         * @hidden
         * @private
         */
        abstract monitorChanges(brush: PdfBrush, streamWriter: PdfStreamWriter, getResources: GetResourceEventHandler, saveChanges: boolean, currentColorSpace: PdfColorSpace, check: boolean, iccBased: boolean): boolean;
        /**
         * `MonitorChanges` abstract method overload.
         * @hidden
         * @private
         */
        abstract monitorChanges(brush: PdfBrush, streamWriter: PdfStreamWriter, getResources: GetResourceEventHandler, saveChanges: boolean, currentColorSpace: PdfColorSpace, check: boolean, iccBased: boolean, indexed: boolean): boolean;
        /**
         * `MonitorChanges` abstract method overload.
         * @hidden
         * @private
         */
        abstract resetChanges(streamWriter: PdfStreamWriter): void;
    }
    
    /**
     * Represents a brush that fills any object with a solid color.
     * ```typescript
     * // create a new PDF document
     * let document : PdfDocument = new PdfDocument();
     * // add a pages to the document
     * let page1 : PdfPage = document.pages.add();
     * // set font
     * let font : PdfStandardFont = new PdfStandardFont(PdfFontFamily.Helvetica, 20);
     * // set brush
     * let blackBrush : PdfSolidBrush = new PdfSolidBrush(new PdfColor(0, 0, 0));
     * // draw the text
     * page1.graphics.drawString('Hello World', font, blackBrush, new PointF(10, 10));
     * // save the document
     * document.save('output.pdf');
     * // destroy the document
     * document.destroy();
     * ```
     */
    export class PdfSolidBrush extends PdfBrush {
        /**
         * The `colour` of the brush.
         * @private
         */
        pdfColor: PdfColor;
        /**
         * Indicates if the brush is `immutable`.
         * @private
         */
        private bImmutable;
        /**
         * The `color space` of the brush.
         * @private
         */
        private colorSpace;
        /**
         * Initializes a new instance of the `PdfSolidBrush` class.
         * ```typescript
         * // create a new PDF document
         * let document : PdfDocument = new PdfDocument();
         * // add a pages to the document
         * let page1 : PdfPage = document.pages.add();
         * // set font
         * let font : PdfStandardFont = new PdfStandardFont(PdfFontFamily.Helvetica, 20);
         * // set brush
         * let blackBrush : PdfSolidBrush = new PdfSolidBrush(new PdfColor(0, 0, 0));
         * // draw the text
         * page1.graphics.drawString('Hello World', font, blackBrush, new PointF(10, 10));
         * // save the document
         * document.save('output.pdf');
         * // destroy the document
         * document.destroy();
         * ```
         * @param color color of the brush
         */
        constructor(color: PdfColor);
        /**
         * Gets or sets the `color` of the brush.
         * @private
         */
        color: PdfColor;
        /**
         * `Monitors` the changes of the brush and modify PDF state respectively.
         * @private
         */
        monitorChanges(brush: PdfBrush, streamWriter: PdfStreamWriter, getResources: GetResourceEventHandler, saveChanges: boolean, currentColorSpace: PdfColorSpace): boolean;
        /**
         * `Resets` the changes, which were made by the brush.
         * @private
         */
        resetChanges(streamWriter: PdfStreamWriter): void;
    }
    
    /**
     * public Enum for `PdfLayoutType`.
     * @private
     */
    export enum PdfLayoutType {
        /**
         * Specifies the type of `Paginate`.
         * @private
         */
        Paginate = 0,
        /**
         * Specifies the type of `OnePage`.
         * @private
         */
        OnePage = 1,
    }
    /**
     * public Enum for `PdfLayoutBreakType`.
     * @private
     */
    export enum PdfLayoutBreakType {
        /**
         * Specifies the type of `FitPage`.
         * @private
         */
        FitPage = 0,
        /**
         * Specifies the type of `FitElement`.
         * @private
         */
        FitElement = 1,
        /**
         * Specifies the type of `FitColumnsToPage`.
         * @private
         */
        FitColumnsToPage = 2,
    }
    
    /**
     * PdfLayoutElement.ts class for EJ2-PDF
     */
    
    /**
     * `PdfLayoutElement` class represents the base class for all elements that can be layout on the pages.
     * @private
     */
    export abstract class PdfLayoutElement {
        /**
         * Indicating whether [`embed fonts`]
         * @private
         */
        private bEmbedFonts;
        /**
         * `Draws` the element on the page with the specified page and "PointF" class
         * @private
         */
        drawHelper(page: PdfPage, location: PointF): PdfLayoutResult;
        /**
         * `Draws` the element on the page with the specified page and pair of coordinates
         * @private
         */
        drawHelper(page: PdfPage, x: number, y: number): PdfLayoutResult;
        /**
         * `Draws` the element on the page with the specified page and "RectangleF" class
         * @private
         */
        drawHelper(page: PdfPage, layoutRectangle: RectangleF): PdfLayoutResult;
        /**
         * `Draws` the element on the page with the specified page, "PointF" class and layout format
         * @private
         */
        drawHelper(page: PdfPage, location: PointF, format: PdfLayoutFormat): PdfLayoutResult;
        /**
         * `Draws` the element on the page with the specified page, pair of coordinates and layout format
         * @private
         */
        drawHelper(page: PdfPage, x: number, y: number, format: PdfLayoutFormat): PdfLayoutResult;
        /**
         * `Draws` the element on the page.
         * @private
         */
        drawHelper(page: PdfPage, layoutRectangle: RectangleF, embedFonts: boolean): PdfLayoutResult;
        /**
         * `Draws` the element on the page with the specified page, "RectangleF" class and layout format
         * @private
         */
        drawHelper(page: PdfPage, layoutRectangle: RectangleF, format: PdfLayoutFormat): PdfLayoutResult;
        /**
         * `Layouts` the specified param.
         * @private
         */
        protected abstract layout(param: PdfLayoutParams): PdfLayoutResult;
    }
    
    /**
     * PdfTemplate.ts class for EJ2-PDF
     */
    
    /**
     * Represents `Pdf Template` object.
     * @private
     */
    export class PdfTemplate implements IPdfWrapper {
        /**
         * Stores the value of current `graphics`.
         * @private
         */
        private pdfGraphics;
        /**
         * Stores the instance of `PdfResources` class.
         * @private
         */
        private resources;
        /**
         * Stores the `size` of the 'PdfTemplate'.
         * @private
         */
        private templateSize;
        /**
         * Initialize an instance for `DictionaryProperties` class.
         * @private
         * @hidden
         */
        private dictionaryProperties;
        /**
         * Stores the `content` of the 'PdfTemplate'.
         * @private
         */
        content: PdfStream;
        /**
         * Checks whether the transformation 'is performed'.
         * @default true
         * @private
         */
        writeTransformation: boolean;
        /**
         * Gets the size of the 'PdfTemplate'.
         */
        readonly size: SizeF;
        /**
         * Gets the width of the 'PdfTemplate'.
         */
        readonly width: number;
        /**
         * Gets the height of the 'PdfTemplate'.
         */
        readonly height: number;
        /**
         * Gets the `graphics` of the 'PdfTemplate'.
         */
        readonly graphics: PdfGraphics;
        /**
         * Gets the resources and modifies the template dictionary.
         * @private
         */
        getResources(): PdfResources;
        /**
         * Create the new instance for `PdfTemplate` class.
         * @private
         */
        constructor();
        /**
         * Create the new instance for `PdfTemplate` class with Size.
         * @private
         */
        constructor(arg1: SizeF);
        /**
         * Create the new instance for `PdfTemplate` class with width and height.
         * @private
         */
        constructor(arg1: number, arg2: number);
        /**
         * `Initialize` the type and subtype of the template.
         * @private
         */
        private initialize();
        /**
         * `Adds type key`.
         * @private
         */
        private addType();
        /**
         * `Adds SubType key`.
         * @private
         */
        private addSubType();
        /**
         * `Reset` the size of the 'PdfTemplate'.
         */
        reset(): void;
        reset(size: SizeF): void;
        /**
         * `Set the size` of the 'PdfTemplate'.
         * @private
         */
        private setSize(size);
        /**
         * Gets the `content stream` of 'PdfTemplate' class.
         * @private
         */
        readonly element: IPdfPrimitive;
    }
    
    /**
     * PdfTextElement.ts class for EJ2-PDF
     */
    
    /**
     * `PdfTextElement` class represents the text area with the ability to span several pages
     * and inherited from the 'PdfLayoutElement' class.
     * @private
     */
    export class PdfTextElement extends PdfLayoutElement {
        /**
         * `Text` data.
         * @private
         */
        private content;
        /**
         * `Value` of text data.
         * @private
         */
        private elementValue;
        /**
         * `Pen` for text drawing.
         * @private
         */
        private pdfPen;
        /**
         * `Brush` for text drawing.
         * @private
         */
        private pdfBrush;
        /**
         * `Font` for text drawing.
         * @private
         */
        private pdfFont;
        /**
         * Text `format`.
         * @private
         */
        private format;
        /**
         * indicate whether the drawText with PointF overload is called or not.
         * @default false
         * @private
         */
        private hasPointOverload;
        /**
         * indicate whether the PdfGridCell value is `PdfTextElement`
         * @default false
         * @private
         */
        isPdfTextElement: boolean;
        /**
         * Initializes a new instance of the `PdfTextElement` class.
         * @private
         */
        constructor();
        /**
         * Initializes a new instance of the `PdfTextElement` class with text to draw into the PDF.
         * @private
         */
        constructor(text: string);
        /**
         * Initializes a new instance of the `PdfTextElement` class with the text and `PdfFont`.
         * @private
         */
        constructor(text: string, font: PdfFont);
        /**
         * Initializes a new instance of the `PdfTextElement` class with text,`PdfFont` and `PdfPen`.
         * @private
         */
        constructor(text: string, font: PdfFont, pen: PdfPen);
        /**
         * Initializes a new instance of the `PdfTextElement` class with text,`PdfFont` and `PdfBrush`.
         * @private
         */
        constructor(text: string, font: PdfFont, brush: PdfBrush);
        /**
         * Initializes a new instance of the `PdfTextElement` class with text,`PdfFont`,`PdfPen`,`PdfBrush` and `PdfStringFormat`.
         * @private
         */
        constructor(text: string, font: PdfFont, pen: PdfPen, brush: PdfBrush, format: PdfStringFormat);
        /**
         * Gets or sets a value indicating the `text` that should be printed.
         * ```typescript
         * // create a new PDF document.
         * let document : PdfDocument = new PdfDocument();
         * // add a page to the document.
         * let page1 : PdfPage = document.pages.add();
         * // create the font
         * let font : PdfFont = new PdfStandardFont(PdfFontFamily.Helvetica, 12);
         * // create the Text Web Link
         * let textLink : PdfTextWebLink = new PdfTextWebLink();
         * // set the hyperlink
         * textLink.url = 'http://www.google.com';
         * //
         * // set the link text
         * textLink.text = 'Google';
         * //
         * // set the font
         * textLink.font = font;
         * // draw the hyperlink in PDF page
         * textLink.draw(page1, new PointF(10, 40));
         * // save the document.
         * document.save('output.pdf');
         * // destroy the document
         * document.destroy();
         * ```
         */
        text: string;
        /**
         * Gets or sets a `value` indicating the text that should be printed.
         * @private
         */
        readonly value: string;
        /**
         * Gets or sets a `PdfPen` that determines the color, width, and style of the text
         * @private
         */
        pen: PdfPen;
        /**
         * Gets or sets the `PdfBrush` that will be used to draw the text with color and texture.
         * @private
         */
        brush: PdfBrush;
        /**
         * Gets or sets a `PdfFont` that defines the text format.
         * ```typescript
         * // create a new PDF document.
         * let document : PdfDocument = new PdfDocument();
         * // add a page to the document.
         * let page1 : PdfPage = document.pages.add();
         * // create the font
         * let font : PdfFont = new PdfStandardFont(PdfFontFamily.Helvetica, 12);
         * // create the Text Web Link
         * let textLink : PdfTextWebLink = new PdfTextWebLink();
         * // set the hyperlink
         * textLink.url = 'http://www.google.com';
         * // set the link text
         * textLink.text = 'Google';
         * //
         * // set the font
         * textLink.font = font;
         * //
         * // draw the hyperlink in PDF page
         * textLink.draw(page1, new PointF(10, 40));
         * // save the document.
         * document.save('output.pdf');
         * // destroy the document
         * document.destroy();
         * ```
         */
        font: PdfFont;
        /**
         * Gets or sets the `PdfStringFormat` that will be used to set the string format
         * @private
         */
        stringFormat: PdfStringFormat;
        /**
         * Gets a `brush` for drawing.
         * @private
         */
        getBrush(): PdfBrush;
        /**
         * `Layouts` the element.
         * @private
         */
        protected layout(param: PdfLayoutParams): PdfLayoutResult;
        /**
         * `Draws` the element on the page with the specified page and "PointF" class
         * @private
         */
        drawText(page: PdfPage, location: PointF): PdfLayoutResult;
        /**
         * `Draws` the element on the page with the specified page and pair of coordinates
         * @private
         */
        drawText(page: PdfPage, x: number, y: number): PdfLayoutResult;
        /**
         * `Draws` the element on the page with the specified page and "RectangleF" class
         * @private
         */
        drawText(page: PdfPage, layoutRectangle: RectangleF): PdfLayoutResult;
        /**
         * `Draws` the element on the page with the specified page, "PointF" class and layout format
         * @private
         */
        drawText(page: PdfPage, location: PointF, format: PdfLayoutFormat): PdfLayoutResult;
        /**
         * `Draws` the element on the page with the specified page, pair of coordinates and layout format
         * @private
         */
        drawText(page: PdfPage, x: number, y: number, format: PdfLayoutFormat): PdfLayoutResult;
        /**
         * `Draws` the element on the page.
         * @private
         */
        drawText(page: PdfPage, layoutRectangle: RectangleF, embedFonts: boolean): PdfLayoutResult;
        /**
         * `Draws` the element on the page with the specified page, "RectangleF" class and layout format
         * @private
         */
        drawText(page: PdfPage, layoutRectangle: RectangleF, format: PdfLayoutFormat): PdfLayoutResult;
        private calculateResultBounds(result, lineWidth, maximumWidth, startPosition);
    }
    
    /**
     * ElementLayouter.ts class for EJ2-PDF
     */
    
    /**
     * Base class for `elements lay outing`.
     * @private
     */
    export abstract class ElementLayouter {
        /**
         * Layout the `element`.
         * @private
         */
        private layoutElement;
        /**
         * Initializes a new instance of the `ElementLayouter` class.
         * @private
         */
        constructor(element: PdfLayoutElement);
        /**
         * Gets the `element`.
         * @private
         */
        readonly elements: PdfLayoutElement;
        /**
         * Gets the `element`.
         * @private
         */
        getElement(): PdfLayoutElement;
        /**
         * `Layouts` the element.
         * @private
         */
        layout(param: PdfLayoutParams): PdfLayoutResult;
        layout(param: PdfLayoutParams, isBoundsChanged: boolean): PdfLayoutResult;
        /**
         * Returns the `next page`.
         * @private
         */
        getNextPage(currentPage: PdfPage): PdfPage;
        /**
         * `Layouts` the element.
         * @private
         */
        protected abstract layoutInternal(param: PdfLayoutParams, isBoundsChanged?: boolean): PdfLayoutResult;
    }
    export class PdfLayoutFormat {
        /**
         * Indicates whether `PaginateBounds` were set and should be used or not.
         * @private
         */
        private boundsSet;
        /**
         * `Bounds` for the paginating.
         * @private
         */
        private layoutPaginateBounds;
        /**
         * `Layout` type of the element.
         * @private
         */
        private layoutType;
        /**
         * `Break` type of the element.
         * @private
         */
        private breakType;
        /**
         * Gets or sets `layout` type of the element.
         * @private
         */
        layout: PdfLayoutType;
        /**
         * Gets or sets `break` type of the element.
         * @private
         */
        break: PdfLayoutBreakType;
        /**
         * Gets or sets the `bounds` on the next page.
         * @private
         */
        paginateBounds: RectangleF;
        /**
         * Gets a value indicating whether [`use paginate bounds`].
         * @private
         */
        readonly usePaginateBounds: boolean;
        /**
         * Initializes a new instance of the `PdfLayoutFormat` class.
         * @private
         */
        constructor();
        /**
         * Initializes a new instance of the `PdfLayoutFormat` class.
         * @private
         */
        constructor(baseFormat: PdfLayoutFormat);
    }
    export class PdfLayoutParams {
        /**
         * The last `page` where the element was drawn.
         * @private
         */
        private pdfPage;
        /**
         * The `bounds` of the element on the last page where it was drawn.
         * @private
         */
        private layoutBounds;
        /**
         * Layout settings as `format`.
         * @private
         */
        private layoutFormat;
        /**
         * Gets or sets the layout `page` for the element.
         * @private
         */
        page: PdfPage;
        /**
         * Gets or sets layout `bounds` for the element.
         * @private
         */
        bounds: RectangleF;
        /**
         * Gets or sets `layout settings` for the element.
         * @private
         */
        format: PdfLayoutFormat;
    }
    export class PdfLayoutResult {
        /**
         * The last `page` where the element was drawn.
         * @private
         */
        private pdfPage;
        /**
         * The `bounds` of the element on the last page where it was drawn.
         * @private
         */
        private layoutBounds;
        /**
         * Gets the last `page` where the element was drawn.
         * @private
         */
        readonly page: PdfPage;
        /**
         * Gets the `bounds` of the element on the last page where it was drawn.
         * @private
         */
        readonly bounds: RectangleF;
        /**
         * Initializes the new instance of `PdfLayoutResult` class.
         * @private
         */
        constructor(page: PdfPage, bounds: RectangleF);
    }
    
    /**
     * PdfGraphicsElement.ts class for EJ2-PDF
     */
    
    /**
     * Represents a base class for all page graphics elements.
     */
    export abstract class PdfGraphicsElement {
        protected constructor();
        /**
         * `Draws` the page number field.
         * @public
         */
        drawHelper(graphics: PdfGraphics, x: number, y: number): void;
        protected abstract drawInternal(graphics: PdfGraphics): void;
    }
    
    /**
     * PdfShapeElement.ts class for EJ2-PDF
     * @private
     */
    
    /**
     * Base class for the main shapes.
     * @private
     */
    export abstract class PdfShapeElement extends PdfLayoutElement {
        /**
         * Gets the bounds.
         * @private
         */
        getBounds(): RectangleF;
        /**
         * Returns a rectangle that bounds this element.
         * @private
         */
        protected abstract getBoundsInternal(): RectangleF;
        /**
         * Layouts the element.
         * @private
         */
        protected layout(param: PdfLayoutParams): PdfLayoutResult;
    }
    
    /**
     * ShapeLayouter.ts class for EJ2-PDF
     * @private
     */
    
    /**
     * ShapeLayouter class.
     * @private
     */
    export class ShapeLayouter extends ElementLayouter {
        /**
         * Initializes the object to store `older form elements` of previous page.
         * @default 0
         * @private
         */
        olderPdfForm: number;
        /**
         * Initializes the offset `index`.
         * * @default 0
         * @private
         */
        private static index;
        /**
         * Initializes the `difference in page height`.
         * * @default 0
         * @private
         */
        private static splitDiff;
        /**
         * Determines the `end of Vertical offset` values.
         * * @default false
         * @private
         */
        private static last;
        /**
         * Determines the document link annotation `border width`.
         * * @default 0
         * @private
         */
        private static readonly borderWidth;
        /**
         * Checks weather `is pdf grid` or not.
         * @private
         */
        isPdfGrid: boolean;
        /**
         * The `bounds` of the shape element.
         * * @default new RectangleF()
         * @private
         */
        shapeBounds: RectangleF;
        /**
         * The `bottom cell padding`.
         * @private
         */
        bottomCellPadding: number;
        /**
         * Total Page size of the web page.
         * * @default 0
         * @private
         */
        private totalPageSize;
        /**
         * Initializes a new instance of the `ShapeLayouter` class.
         * @private
         */
        constructor(element: PdfShapeElement);
        /**
         * Gets shape element.
         * @private
         */
        readonly element: PdfShapeElement;
        /**
         * Layouts the element.
         * @private
         */
        protected layoutInternal(param: PdfLayoutParams): PdfLayoutResult;
    }
    
    /**
     * TextLayouter.ts class for EJ2-PDF
     */
    
    /**
     * Class that `layouts the text`.
     * @private
     */
    export class TextLayouter extends ElementLayouter {
        /**
         * String `format`.
         * @private
         */
        private format;
        /**
         * Gets the layout `element`.
         * @private
         */
        readonly element: PdfTextElement;
        /**
         * Initializes a new instance of the `TextLayouter` class.
         * @private
         */
        constructor(element: PdfTextElement);
        /**
         * `Layouts` the element.
         * @private
         */
        protected layoutInternal(param: PdfLayoutParams): PdfLayoutResult;
        /**
         * Raises `PageLayout` event if needed.
         * @private
         */
        private getLayoutResult(pageResult);
        /**
         * `Layouts` the text on the page.
         * @private
         */
        private layoutOnPage(text, currentPage, currentBounds, param);
        /**
         * `Corrects current bounds` on the page.
         * @private
         */
        private checkCorrectBounds(currentPage, currentBounds);
        /**
         * Returns a `rectangle` where the text was printed on the page.
         * @private
         */
        private getTextPageBounds(currentPage, currentBounds, stringResult);
    }
    export class TextPageLayoutResult {
        /**
         * The last `page` where the text was drawn.
         * @private
         */
        page: PdfPage;
        /**
         * The `bounds` of the element on the last page where it was drawn.
         * @private
         */
        bounds: RectangleF;
        /**
         * Indicates whether the lay outing has been finished [`end`].
         * @private
         */
        end: boolean;
        /**
         * The `text` that was not printed.
         * @private
         */
        remainder: string;
        /**
         * Gets or sets a `bounds` of the last text line that was printed.
         * @private
         */
        lastLineBounds: RectangleF;
    }
    export class PdfTextLayoutResult extends PdfLayoutResult {
        /**
         * The `text` that was not printed.
         * @private
         */
        private remainderText;
        /**
         * The `bounds` of the last line that was printed.
         * @private
         */
        private lastLineTextBounds;
        /**
         * Gets a value that contains the `text` that was not printed.
         * @private
         */
        readonly remainder: string;
        /**
         * Gets a value that indicates the `bounds` of the last line that was printed on the page.
         * @private
         */
        readonly lastLineBounds: RectangleF;
        /**
         * Initializes the new instance of `PdfTextLayoutResult` class.
         * @private
         */
        constructor(page: PdfPage, bounds: RectangleF, remainder: string, lastLineBounds: RectangleF);
    }
    
    /**
     * public Enum for `PdfFontStyle`.
     * @private
     */
    export enum PdfFontStyle {
        /**
         * Specifies the type of `Regular`.
         * @private
         */
        Regular = 0,
        /**
         * Specifies the type of `Bold`.
         * @private
         */
        Bold = 1,
        /**
         * Specifies the type of `Italic`.
         * @private
         */
        Italic = 2,
        /**
         * Specifies the type of `Underline`.
         * @private
         */
        Underline = 4,
        /**
         * Specifies the type of `Strikeout`.
         * @private
         */
        Strikeout = 8,
    }
    /**
     * Specifies the font family from the standard font.
     * ```typescript
     * // create a new PDF document
     * let document : PdfDocument = new PdfDocument();
     * // add a new page to the document
     * let page1 : PdfPage = document.pages.add();
     * // create new standard font
     * let font : PdfStandardFont = new PdfStandardFont(PdfFontFamily.Helvetica, 20);
     * // create black brush
     * let blackBrush : PdfSolidBrush = new PdfSolidBrush(new PdfColor(0, 0, 0));
     * // draw the text
     * page1.graphics.drawString('Hello World', font, blackBrush, new PointF(0, 0));
     * // save the document
     * document.save('output.pdf');
     * ```
     */
    export enum PdfFontFamily {
        /**
         * Specifies the `Helvetica` font.
         */
        Helvetica = 0,
        /**
         * Specifies the `Courier` font.
         */
        Courier = 1,
        /**
         * Specifies the `TimesRoman` font.
         */
        TimesRoman = 2,
        /**
         * Specifies the `Symbol` font.
         */
        Symbol = 3,
        /**
         * Specifies the `ZapfDingbats` font.
         */
        ZapfDingbats = 4,
    }
    /**
     * public Enum for `PdfFontType`.
     * @private
     */
    export enum PdfFontType {
        /**
         * Specifies the type of `Standard`.
         * @private
         */
        Standard = 0,
        /**
         * Specifies the type of `TrueType`.
         * @private
         */
        TrueType = 1,
        /**
         * Specifies the type of `TrueTypeEmbedded`.
         * @private
         */
        TrueTypeEmbedded = 2,
    }
    /**
     * public Enum for `PdfWordWrapType`.
     * @private
     */
    export enum PdfWordWrapType {
        /**
         * Specifies the type of `None`.
         * @private
         */
        None = 0,
        /**
         * Specifies the type of `Word`.
         * @private
         */
        Word = 1,
        /**
         * Specifies the type of `WordOnly`.
         * @private
         */
        WordOnly = 2,
        /**
         * Specifies the type of `Character`.
         * @private
         */
        Character = 3,
    }
    /**
     * public Enum for `PdfSubSuperScript`.
     * @private
     */
    export enum PdfSubSuperScript {
        /**
         * Specifies the type of `None`.
         * @private
         */
        None = 0,
        /**
         * Specifies the type of `SuperScript`.
         * @private
         */
        SuperScript = 1,
        /**
         * Specifies the type of `SubScript`.
         * @private
         */
        SubScript = 2,
    }
    /**
     * public Enum for `FontEncoding`.
     * @private
     */
    export enum FontEncoding {
        /**
         * Specifies the type of `Unknown`.
         * @private
         */
        Unknown = 0,
        /**
         * Specifies the type of `StandardEncoding`.
         * @private
         */
        StandardEncoding = 1,
        /**
         * Specifies the type of `MacRomanEncoding`.
         * @private
         */
        MacRomanEncoding = 2,
        /**
         * Specifies the type of `MacExpertEncoding`.
         * @private
         */
        MacExpertEncoding = 3,
        /**
         * Specifies the type of `WinAnsiEncoding`.
         * @private
         */
        WinAnsiEncoding = 4,
        /**
         * Specifies the type of `PdfDocEncoding`.
         * @private
         */
        PdfDocEncoding = 5,
        /**
         * Specifies the type of `IdentityH`.
         * @private
         */
        IdentityH = 6,
    }
    
    /**
     * PdfFontMetrics.ts class for EJ2-PDF
     */
    
    /**
     * `Metrics` of the font.
     * @private
     */
    export class PdfFontMetrics {
        /**
         * Gets `ascent` of the font.
         * @private
         */
        ascent: number;
        /**
         * Gets `descent` of the font.
         * @private
         */
        descent: number;
        /**
         * `Name` of the font.
         * @private
         */
        name: string;
        /**
         * Gets `PostScript` Name of the  font.
         * @private
         */
        postScriptName: string;
        /**
         * Gets `size` of the font.
         * @private
         */
        size: number;
        /**
         * Gets `height` of the font.
         * @private
         */
        height: number;
        /**
         * `First char` of the font.
         * @private
         */
        firstChar: number;
        /**
         * `Last char` of the font.
         * @private
         */
        lastChar: number;
        /**
         * `Line gap`.
         * @private
         */
        lineGap: number;
        /**
         * `Subscript` size factor.
         * @private
         */
        subScriptSizeFactor: number;
        /**
         * `Superscript` size factor.
         * @private
         */
        superscriptSizeFactor: number;
        /**
         * Gets `table` of glyphs` width.
         * @private
         */
        internalWidthTable: WidthTable;
        /**
         * Checks whether is it `unicode font` or not.
         * @private
         */
        isUnicodeFont: boolean;
        /**
         * Returns `ascent` taking into consideration font`s size.
         * @private
         */
        getAscent(format: PdfStringFormat): number;
        /**
         * Returns `descent` taking into consideration font`s size.
         * @private
         */
        getDescent(format: PdfStringFormat): number;
        /**
         * Returns `Line gap` taking into consideration font`s size.
         * @private
         */
        getLineGap(format: PdfStringFormat): number;
        /**
         * Returns `height` taking into consideration font`s size.
         * @private
         */
        getHeight(format: PdfStringFormat): number;
        /**
         * Calculates `size` of the font depending on the subscript/superscript value.
         * @private
         */
        getSize(format: PdfStringFormat): number;
        /**
         * `Clones` the metrics.
         * @private
         */
        clone(): PdfFontMetrics;
        /**
         * Gets or sets the `width table`.
         * @private
         */
        widthTable: WidthTable;
    }
    export abstract class WidthTable {
        /**
         * Returns the `width` of the specific index.
         * @private
         */
        abstract items(index: number): number;
        /**
         * `Clones` this instance of the WidthTable class.
         * @private
         */
        abstract clone(): WidthTable;
        /**
         * Static `clones` this instance of the WidthTable class.
         * @private
         */
        static clone(): WidthTable;
    }
    export class StandardWidthTable extends WidthTable {
        /**
         * The `widths` of the supported characters.
         * @private
         */
        private widths;
        /**
         * Gets the `32 bit number` at the specified index.
         * @private
         */
        items(index: number): number;
        /**
         * Gets the `length` of the internal array.
         * @private
         */
        readonly length: number;
        /**
         * Initializes a new instance of the `StandardWidthTable` class.
         * @private
         */
        constructor(widths: number[]);
        /**
         * `Clones` this instance of the WidthTable class.
         * @private
         */
        clone(): WidthTable;
        /**
         * Converts width table to a `PDF array`.
         * @private
         */
        toArray(): PdfArray;
    }
    
    /**
     * PdfFont.ts class for EJ2-PDF
     */
    
    /**
     * Defines a particular format for text, including font face, size, and style attributes.
     * @private
     */
    export abstract class PdfFont implements IPdfWrapper, IPdfCache {
        /**
         * `Multiplier` of the symbol width.
         * @default 0.001
         * @private
         */
        static readonly charSizeMultiplier: number;
        /**
         * `Synchronization` object.
         * @private
         */
        protected static syncObject: Object;
        /**
         * `Size` of the font.
         * @private
         */
        private fontSize;
        /**
         * `Style` of the font.
         * @private
         */
        private fontStyle;
        /**
         * `Metrics` of the font.
         * @private
         */
        private fontMetrics;
        /**
         * PDf `primitive` of the font.
         * @private
         */
        private pdfFontInternals;
        /**
         * Initializes a new instance of the `PdfFont` class.
         * @private
         */
        protected constructor(size: number);
        /**
         * Initializes a new instance of the `PdfFont` class.
         * @private
         */
        protected constructor(size: number, style: PdfFontStyle);
        /**
         * Gets the face name of this Font.
         * @private
         */
        readonly name: string;
        /**
         * Gets the size of this font.
         * @private
         */
        readonly size: number;
        /**
         * Gets the height of the font in points.
         * @private
         */
        readonly height: number;
        /**
         * Gets the style information for this font.
         * @private
         */
        style: PdfFontStyle;
        /**
         * Gets a value indicating whether this `PdfFont` is `bold`.
         * @private
         */
        readonly bold: boolean;
        /**
         * Gets a value indicating whether this `PdfFont` has the `italic` style applied.
         * @private
         */
        readonly italic: boolean;
        /**
         * Gets a value indicating whether this `PdfFont` is `strikeout`.
         * @private
         */
        readonly strikeout: boolean;
        /**
         * Gets a value indicating whether this `PdfFont` is `underline`.
         * @private
         */
        readonly underline: boolean;
        /**
         * Gets or sets the `metrics` for this font.
         * @private
         */
        metrics: PdfFontMetrics;
        /**
         * Gets the `element` representing the font.
         * @private
         */
        readonly element: IPdfPrimitive;
        /**
         * `Measures` a string by using this font.
         * @private
         */
        measureString(text: string): SizeF;
        /**
         * `Measures` a string by using this font.
         * @private
         */
        measureString(text: string, format: PdfStringFormat): SizeF;
        /**
         * `Measures` a string by using this font.
         * @private
         */
        measureString(text: string, format: PdfStringFormat, charactersFitted: number, linesFilled: number): SizeF;
        /**
         * `Measures` a string by using this font.
         * @private
         */
        measureString(text: string, width: number): SizeF;
        /**
         * `Measures` a string by using this font.
         * @private
         */
        measureString(text: string, width: number, format: PdfStringFormat): SizeF;
        /**
         * `Measures` a string by using this font.
         * @private
         */
        measureString(text: string, width: number, format: PdfStringFormat, charactersFitted: number, linesFilled: number): SizeF;
        /**
         * `Measures` a string by using this font.
         * @private
         */
        measureString(text: string, layoutArea: SizeF): SizeF;
        /**
         * `Measures` a string by using this font.
         * @private
         */
        measureString(text: string, layoutArea: SizeF, format: PdfStringFormat): SizeF;
        /**
         * `Measures` a string by using this font.
         * @private
         */
        measureString(text: string, layoutArea: SizeF, format: PdfStringFormat, charactersFitted: number, linesFilled: number): SizeF;
        /**
         * `Checks` whether the object is similar to another object.
         * @private
         */
        equalsTo(obj: IPdfCache): boolean;
        /**
         * Returns `internals` of the object.
         * @private
         */
        getInternals(): IPdfPrimitive;
        /**
         * Sets `internals` to the object.
         * @private
         */
        setInternals(internals: IPdfPrimitive): void;
        /**
         * `Checks` whether fonts are equals.
         * @private
         */
        protected abstract equalsToFont(font: PdfFont): boolean;
        /**
         * Returns `width` of the line.
         * @private
         */
        abstract getLineWidth(line: string, format: PdfStringFormat): number;
        /**
         * Sets the `style` of the font.
         * @private
         */
        protected setStyle(style: PdfFontStyle): void;
        /**
         * Applies `settings` to the default line width.
         * @private
         */
        protected applyFormatSettings(line: string, format: PdfStringFormat, width: number): number;
    }
    
    /**
     * PdfStandardFontMetricsFactory.ts class for EJ2-PDF
     */
    
    /**
     * @private
     * `Factory of the standard fonts metrics`.
     */
    export class PdfStandardFontMetricsFactory {
        /**
         * `Multiplier` os subscript superscript.
         * @private
         */
        private static readonly subSuperScriptFactor;
        /**
         * `Ascender` value for the font.
         * @private
         */
        private static readonly helveticaAscent;
        /**
         * `Ascender` value for the font.
         * @private
         */
        private static readonly helveticaDescent;
        /**
         * `Font type`.
         * @private
         */
        private static readonly helveticaName;
        /**
         * `Ascender` value for the font.
         * @private
         */
        private static readonly helveticaBoldAscent;
        /**
         * `Ascender` value for the font.
         * @private
         */
        private static readonly helveticaBoldDescent;
        /**
         * `Font type`.
         * @private
         */
        private static readonly helveticaBoldName;
        /**
         * `Ascender` value for the font.
         * @private
         */
        private static readonly helveticaItalicAscent;
        /**
         * `Ascender` value for the font.
         * @private
         */
        private static readonly helveticaItalicDescent;
        /**
         * `Font type`.
         * @private
         */
        private static readonly helveticaItalicName;
        /**
         * `Ascender` value for the font.
         * @private
         */
        private static readonly helveticaBoldItalicAscent;
        /**
         * `Ascender` value for the font.
         * @private
         */
        private static readonly helveticaBoldItalicDescent;
        /**
         * `Font type`.
         * @private
         */
        private static readonly helveticaBoldItalicName;
        /**
         * `Ascender` value for the font.
         * @private
         */
        private static readonly courierAscent;
        /**
         * `Ascender` value for the font.
         * @private
         */
        private static readonly courierDescent;
        /**
         * `Font type`.
         * @private
         */
        private static readonly courierName;
        /**
         * `Ascender` value for the font.
         * @private
         */
        private static readonly courierBoldAscent;
        /**
         * `Ascender` value for the font.
         * @private
         */
        private static readonly courierBoldDescent;
        /**
         * `Font type`.
         * @private
         */
        private static readonly courierBoldName;
        /**
         * `Ascender` value for the font.
         * @private
         */
        private static readonly courierItalicAscent;
        /**
         * `Ascender` value for the font.
         * @private
         */
        private static readonly courierItalicDescent;
        /**
         * `Font type`.
         * @private
         */
        private static readonly courierItalicName;
        /**
         * `Ascender` value for the font.
         * @private
         */
        private static readonly courierBoldItalicAscent;
        /**
         * `Ascender` value for the font.
         * @private
         */
        private static readonly courierBoldItalicDescent;
        /**
         * `Font type`.
         * @private
         */
        private static readonly courierBoldItalicName;
        /**
         * `Ascender` value for the font.
         * @private
         */
        private static readonly timesAscent;
        /**
         * `Ascender` value for the font.
         * @private
         */
        private static readonly timesDescent;
        /**
         * `Font type`.
         * @private
         */
        private static readonly timesName;
        /**
         * `Ascender` value for the font.
         * @private
         */
        private static readonly timesBoldAscent;
        /**
         * `Ascender` value for the font.
         * @private
         */
        private static readonly timesBoldDescent;
        /**
         * `Font type`.
         * @private
         */
        private static readonly timesBoldName;
        /**
         * `Ascender` value for the font.
         * @private
         */
        private static readonly timesItalicAscent;
        /**
         * `Ascender` value for the font.
         * @private
         */
        private static readonly timesItalicDescent;
        /**
         * `Font type`.
         * @private
         */
        private static readonly timesItalicName;
        /**
         * `Ascender` value for the font.
         * @private
         */
        private static readonly timesBoldItalicAscent;
        /**
         * `Ascender` value for the font.
         * @private
         */
        private static readonly timesBoldItalicDescent;
        /**
         * `Font type`.
         * @private
         */
        private static readonly timesBoldItalicName;
        /**
         * `Ascender` value for the font.
         * @private
         */
        private static readonly symbolAscent;
        /**
         * `Ascender` value for the font.
         * @private
         */
        private static readonly symbolDescent;
        /**
         * `Font type`.
         * @private
         */
        private static readonly symbolName;
        /**
         * `Ascender` value for the font.
         * @private
         */
        private static readonly zapfDingbatsAscent;
        /**
         * `Ascender` value for the font.
         * @private
         */
        private static readonly zapfDingbatsDescent;
        /**
         * `Font type`.
         * @private
         */
        private static readonly zapfDingbatsName;
        /**
         * `Arial` widths table.
         * @private
         */
        private static arialWidth;
        /**
         * `Arial bold` widths table.
         * @private
         */
        private static arialBoldWidth;
        /**
         * `Fixed` widths table.
         * @private
         */
        private static fixedWidth;
        /**
         * `Times` widths table.
         * @private
         */
        private static timesRomanWidth;
        /**
         * `Times bold` widths table.
         * @private
         */
        private static timesRomanBoldWidth;
        /**
         * `Times italic` widths table.
         * @private
         */
        private static timesRomanItalicWidth;
        /**
         * `Times bold italic` widths table.
         * @private
         */
        static timesRomanBoldItalicWidths: number[];
        /**
         * `Symbol` widths table.
         * @private
         */
        private static symbolWidth;
        /**
         * `Zip dingbats` widths table.
         * @private
         */
        private static zapfDingbatsWidth;
        /**
         * Returns `metrics` of the font.
         * @private
         */
        static getMetrics(fontFamily: PdfFontFamily, fontStyle: PdfFontStyle, size: number): PdfFontMetrics;
        /**
         * Creates `Helvetica font metrics`.
         * @private
         */
        private static getHelveticaMetrics(fontFamily, fontStyle, size);
        /**
         * Creates `Courier font metrics`.
         * @private
         */
        private static getCourierMetrics(fontFamily, fontStyle, size);
        /**
         * Creates `Times font metrics`.
         * @private
         */
        private static getTimesMetrics(fontFamily, fontStyle, size);
        /**
         * Creates `Symbol font metrics`.
         * @private
         */
        private static getSymbolMetrics(fontFamily, fontStyle, size);
        /**
         * Creates `ZapfDingbats font metrics`.
         * @private
         */
        private static getZapfDingbatsMetrics(fontFamily, fontStyle, size);
    }
    
    /**
     * Represents one of the 14 standard fonts.
     * It's used to create a standard PDF font to draw the text in to the PDF.
     * ```typescript
     * // create a new PDF document
     * let document : PdfDocument = new PdfDocument();
     * // add a new page to the document
     * let page1 : PdfPage = document.pages.add();
     * //
     * // create new standard font
     * let font : PdfStandardFont = new PdfStandardFont(PdfFontFamily.Helvetica, 20);
     * //
     * // create black brush
     * let blackBrush : PdfSolidBrush = new PdfSolidBrush(new PdfColor(0, 0, 0));
     * // draw the text
     * page1.graphics.drawString('Hello World', font, blackBrush, new PointF(0, 0));
     * // save the document
     * document.save('output.pdf');
     * // destroy the document
     * document.destroy();
     * ```
     */
    export class PdfStandardFont extends PdfFont {
        /**
         * First character `position`.
         * @private
         */
        private static readonly charOffset;
        /**
         * `FontFamily` of the font.
         * @private
         */
        private pdfFontFamily;
        /**
         * Gets `ascent` of the font.
         * @private
         */
        private dictionaryProperties;
        /**
         * Gets `encodings` for internal class use.
         * @hidden
         * @private
         */
        private encodings;
        /**
         * Initializes a new instance of the `PdfStandardFont` class with font family and it`s size.
         * ```typescript
         * // create a new PDF document
         * let document : PdfDocument = new PdfDocument();
         * // add a new page to the document
         * let page1 : PdfPage = document.pages.add();
         * // create black brush
         * let blackBrush : PdfSolidBrush = new PdfSolidBrush(new PdfColor(0, 0, 0));
         * // set the font with the font family and font size
         * let font : PdfStandardFont = new PdfStandardFont(PdfFontFamily.Helvetica, 20);
         * // draw the text
         * page1.graphics.drawString('Hello World', font, blackBrush, new PointF(0, 0));
         * // save the document
         * document.save('output.pdf');
         * // destroy the document
         * document.destroy();
         * ```
         * @param fontFamily Represents the font family to be used.
         * @param size Represents the size of the font.
         */
        constructor(fontFamily: PdfFontFamily, size: number);
        /**
         * Initializes a new instance of the `PdfStandardFont` class with font family, size and font style.
         * ```typescript
         * // create a new PDF document
         * let document : PdfDocument = new PdfDocument();
         * // add a pages to the document
         * let page1 : PdfPage = document.pages.add();
         * // set font
         * let font : PdfStandardFont = new PdfStandardFont(PdfFontFamily.Helvetica, 20, PdfFontStyle.Bold);
         * // set brush
         * let blackBrush : PdfSolidBrush = new PdfSolidBrush(new PdfColor(0, 0, 0));
         * // draw the text
         * page1.graphics.drawString('Hello World', font, blackBrush, new PointF(10, 10));
         * // save the document
         * document.save('output.pdf');
         * // destroy the document
         * document.destroy();
         * ```
         * @param fontFamily Represents the font family to be used.
         * @param size Represents the size of the font.
         * @param style Represents the font style.
         */
        constructor(fontFamily: PdfFontFamily, size: number, style: PdfFontStyle);
        /**
         * Initializes a new instance of the `PdfStandardFont` class with `PdfStandardFont` as prototype and font size.
         * @private
         */
        constructor(prototype: PdfStandardFont, size: number);
        /**
         * Initializes a new instance of the `PdfStandardFont` class with `PdfStandardFont` as prototype,font size and font style.
         * @private
         */
        constructor(prototype: PdfStandardFont, size: number, style: PdfFontStyle);
        /**
         * Gets the `FontFamily`.
         * @private
         */
        readonly fontFamily: PdfFontFamily;
        /**
         * Checks font `style` of the font.
         * @private
         */
        private checkStyle();
        /**
         * Returns `width` of the line.
         * @public
         */
        getLineWidth(line: string, format: PdfStringFormat): number;
        /**
         * Checks whether fonts are `equals`.
         * @private
         */
        protected equalsToFont(font: PdfFont): boolean;
        /**
         * `Initializes` font internals..
         * @private
         */
        private initializeInternals();
        /**
         * `Creates` font`s dictionary.
         * @private
         */
        private createInternals();
        /**
         * Returns `width` of the char. This methods doesn`t takes into consideration font`s size.
         * @private
         */
        private getCharWidthInternal(charCode, format);
        /**
         * `Converts` the specified text.
         * @private
         */
        static convert(text: string): string;
    }
    
    /**
     * PdfStringFormat.ts class for EJ2-PDF
     */
    
    /**
     * `PdfStringFormat` class represents the text layout information on PDF.
     * ```typescript
     * // create a new PDF document
     * let document : PdfDocument = new PdfDocument();
     * // add a pages to the document
     * let page1 : PdfPage = document.pages.add();
     * // set font
     * let font : PdfStandardFont = new PdfStandardFont(PdfFontFamily.Helvetica, 20);
     * // set brush
     * let blackBrush : PdfSolidBrush = new PdfSolidBrush(new PdfColor(0, 0, 0));
     * //
     * // set the format for string
     * let stringFormat : PdfStringFormat = new PdfStringFormat();
     * // set the text alignment
     * stringFormat.alignment = PdfTextAlignment.Center;
     * // set the vertical alignment
     * stringFormat.lineAlignment = PdfVerticalAlignment.Middle;
     * //
     * // draw the text
     * page1.graphics.drawString('Hello World', font, blackBrush, new PointF(10, 10), stringFormat);
     * // save the document
     * document.save('output.pdf');
     * // destroy the document
     * document.destroy();
     * ```
     */
    export class PdfStringFormat {
        /**
         * `Horizontal text alignment`.
         * @private
         */
        private textAlignment;
        /**
         * `Vertical text alignment`.
         * @private
         */
        private verticalAlignment;
        /**
         * Indicates whether `RTL` should be checked.
         * @private
         */
        private isRightToLeft;
        /**
         * `Character spacing` value.
         * @private
         */
        private internalCharacterSpacing;
        /**
         * `Word spacing` value.
         * @private
         */
        private internalWordSpacing;
        /**
         * Text `leading`.
         * @private
         */
        private leading;
        /**
         * Shows if the text should be a part of the current `clipping` path.
         * @private
         */
        private clip;
        /**
         * Indicates whether the text is in `subscript or superscript` mode.
         * @private
         */
        private pdfSubSuperScript;
        /**
         * The `scaling factor` of the text being drawn.
         * @private
         */
        private scalingFactor;
        /**
         * Indent of the `first line` in the text.
         * @private
         */
        private initialLineIndent;
        /**
         * Indent of the `first line` in the paragraph.
         * @private
         */
        private internalParagraphIndent;
        /**
         * Indicates whether entire lines are laid out in the formatting rectangle only or not[`line limit`].
         * @private
         */
        private internalLineLimit;
        /**
         * Indicates whether spaces at the end of the line should be left or removed[`measure trailing spaces`].
         * @private
         */
        private trailingSpaces;
        /**
         * Indicates whether the text region should be `clipped` or not.
         * @private
         */
        private isNoClip;
        /**
         * Indicates text `wrapping` type.
         * @private
         */
        private wordWrapType;
        /**
         * Initializes a new instance of the `PdfStringFormat` class.
         * @private
         */
        constructor();
        /**
         * Initializes a new instance of the `PdfStringFormat` class with horizontal alignment of a text.
         * @private
         */
        constructor(alignment: PdfTextAlignment);
        /**
         * Initializes a new instance of the `PdfStringFormat` class with column format.
         * @private
         */
        constructor(columnFormat: string);
        /**
         * Initializes a new instance of the `PdfStringFormat` class with horizontal and vertical alignment.
         * @private
         */
        constructor(alignment: PdfTextAlignment, lineAlignment: PdfVerticalAlignment);
        /**
         * Gets or sets the `horizontal` text alignment
         * ```typescript
         * // create a new PDF document
         * let document : PdfDocument = new PdfDocument();
         * // add a pages to the document
         * let page1 : PdfPage = document.pages.add();
         * // set font
         * let font : PdfStandardFont = new PdfStandardFont(PdfFontFamily.Helvetica, 20);
         * // set brush
         * let blackBrush : PdfSolidBrush = new PdfSolidBrush(new PdfColor(0, 0, 0));
         * //
         * // set the format for string
         * let stringFormat : PdfStringFormat = new PdfStringFormat();
         * // set the text alignment
         * stringFormat.alignment = PdfTextAlignment.Center;
         * //
         * // draw the text
         * page1.graphics.drawString('Hello World', font, blackBrush, new PointF(10, 10), stringFormat);
         * // save the document
         * document.save('output.pdf');
         * // destroy the document
         * document.destroy();
         * ```
         */
        alignment: PdfTextAlignment;
        /**
         * Gets or sets the `vertical` text alignment.
         * ```typescript
         * // create a new PDF document
         * let document : PdfDocument = new PdfDocument();
         * // add a pages to the document
         * let page1 : PdfPage = document.pages.add();
         * // set font
         * let font : PdfStandardFont = new PdfStandardFont(PdfFontFamily.Helvetica, 20);
         * // set brush
         * let blackBrush : PdfSolidBrush = new PdfSolidBrush(new PdfColor(0, 0, 0));
         * //
         * // set the format for string
         * let stringFormat : PdfStringFormat = new PdfStringFormat();
         * // set the vertical alignment
         * stringFormat.lineAlignment = PdfVerticalAlignment.Middle;
         * //
         * // draw the text
         * page1.graphics.drawString('Hello World', font, blackBrush, new PointF(10, 10), stringFormat);
         * // save the document
         * document.save('output.pdf');
         * // destroy the document
         * document.destroy();
         * ```
         */
        lineAlignment: PdfVerticalAlignment;
        /**
         * Gets or sets the value that indicates text `direction` mode.
         * @private
         */
        rightToLeft: boolean;
        /**
         * Gets or sets value that indicates a `size` among the characters in the text.
         * ```typescript
         * // create a new PDF document
         * let document : PdfDocument = new PdfDocument();
         * // add a pages to the document
         * let page1 : PdfPage = document.pages.add();
         * // set font
         * let font : PdfStandardFont = new PdfStandardFont(PdfFontFamily.Helvetica, 20);
         * // set brush
         * let blackBrush : PdfSolidBrush = new PdfSolidBrush(new PdfColor(0, 0, 0));
         * //
         * // set the format for string
         * let stringFormat : PdfStringFormat = new PdfStringFormat();
         * // set character spacing
         * stringFormat.characterSpacing = 10;
         * //
         * // draw the text
         * page1.graphics.drawString('Hello World', font, blackBrush, new PointF(10, 10), stringFormat);
         * // save the document
         * document.save('output.pdf');
         * // destroy the document
         * document.destroy();
         * ```
         */
        characterSpacing: number;
        /**
         * Gets or sets value that indicates a `size` among the words in the text.
         * ```typescript
         * // create a new PDF document
         * let document : PdfDocument = new PdfDocument();
         * // add a pages to the document
         * let page1 : PdfPage = document.pages.add();
         * // set font
         * let font : PdfStandardFont = new PdfStandardFont(PdfFontFamily.Helvetica, 20);
         * // set brush
         * let blackBrush : PdfSolidBrush = new PdfSolidBrush(new PdfColor(0, 0, 0));
         * //
         * // set the format for string
         * let stringFormat : PdfStringFormat = new PdfStringFormat();
         * // set word spacing
         * stringFormat.wordSpacing = 10;
         * //
         * // draw the text
         * page1.graphics.drawString('Hello World', font, blackBrush, new PointF(10, 10), stringFormat);
         * // save the document
         * document.save('output.pdf');
         * // destroy the document
         * document.destroy();
         * ```
         */
        wordSpacing: number;
        /**
         * Gets or sets value that indicates the `vertical distance` between the baselines of adjacent lines of text.
         * ```typescript
         * // create a new PDF document
         * let document : PdfDocument = new PdfDocument();
         * // add a pages to the document
         * let page1 : PdfPage = document.pages.add();
         * // set font
         * let font : PdfStandardFont = new PdfStandardFont(PdfFontFamily.Helvetica, 20);
         * // set brush
         * let blackBrush : PdfSolidBrush = new PdfSolidBrush(new PdfColor(0, 0, 0));
         * // set string
         * let text : string = 'Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor
         * incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitati';
         * // set rectangle bounds
         * let rectangle : RectangleF = new RectangleF({x : 0, y : 0}, {width : 300, height : 100})
         * //
         * // set the format for string
         * let stringFormat : PdfStringFormat = new PdfStringFormat();
         * // set line spacing
         * stringFormat.lineSpacing = 10;
         * //
         * // draw the text
         * page1.graphics.drawString(text, font, blackBrush, rectangle, stringFormat);
         * // save the document
         * document.save('output.pdf');
         * // destroy the document
         * document.destroy();
         * ```
         */
        lineSpacing: number;
        /**
         * Gets or sets a value indicating whether the text is `clipped` or not.
         * @private
         */
        clipPath: boolean;
        /**
         * Gets or sets value indicating whether the text is in `subscript or superscript` mode.
         * @private
         */
        subSuperScript: PdfSubSuperScript;
        /**
         * Gets or sets the `indent` of the first line in the paragraph.
         * @private
         */
        paragraphIndent: number;
        /**
         * Gets or sets a value indicating whether [`line limit`].
         * @private
         */
        lineLimit: boolean;
        /**
         * Gets or sets a value indicating whether [`measure trailing spaces`].
         * @private
         */
        measureTrailingSpaces: boolean;
        /**
         * Gets or sets a value indicating whether [`no clip`].
         * @private
         */
        noClip: boolean;
        /**
         * Gets or sets value indicating type of the text `wrapping`.
         * @private
         */
        wordWrap: PdfWordWrapType;
        /**
         * Gets or sets the `scaling factor`.
         * @private
         */
        horizontalScalingFactor: number;
        /**
         * Gets or sets the `indent` of the first line in the text.
         * @private
         */
        firstLineIndent: number;
        /**
         * `Clones` the object.
         * @private
         */
        clone(): Object;
    }
    
    /**
     * PdfStringLayouter.ts class for EJ2-PDF
     */
    
    /**
     * Class `lay outing the text`.
     */
    export class PdfStringLayouter {
        /**
         * `Text` data.
         * @private
         */
        private text;
        /**
         * Pdf `font`.
         * @private
         */
        private font;
        /**
         * String `format`.
         * @private
         */
        private format;
        /**
         * `Size` of the text.
         * @private
         */
        private size;
        /**
         * `Bounds` of the text.
         * @private
         */
        private rectangle;
        /**
         * Pdf page `height`.
         * @private
         */
        private pageHeight;
        /**
         * String `tokenizer`.
         * @private
         */
        private reader;
        /**
         * Specifies if [`isTabReplaced`].
         * @private
         */
        private isTabReplaced;
        /**
         * Count of tab `occurance`.
         * @private
         */
        private tabOccuranceCount;
        /**
         * Checks whether the x co-ordinate is need to set as client size or not.
         * @hidden
         * @private
         */
        private isOverloadWithPosition;
        /**
         * Stores client size of the page if the layout method invoked with `PointF` overload.
         * @hidden
         * @private
         */
        private clientSize;
        /**
         * Initializes a new instance of the `StringLayouter` class.
         * @private
         */
        constructor();
        /**
         * `Layouts` the text.
         * @private
         */
        layout(text: string, font: PdfFont, format: PdfStringFormat, rectangle: RectangleF, pageHeight: number, recalculateBounds: boolean, clientSize: SizeF): PdfStringLayoutResult;
        layout(text: string, font: PdfFont, format: PdfStringFormat, size: SizeF, recalculateBounds: boolean, clientSize: SizeF): PdfStringLayoutResult;
        /**
         * `Initializes` internal data.
         * @private
         */
        private initialize(text, font, format, rectangle, pageHeight);
        private initialize(text, font, format, size);
        /**
         * `Clear` all resources.
         * @private
         */
        private clear();
        /**
         * `Layouts` the text.
         * @private
         */
        private doLayout();
        /**
         * Returns `line indent` for the line.
         * @private
         */
        private getLineIndent(firstLine);
        /**
         * Calculates `height` of the line.
         * @private
         */
        private getLineHeight();
        /**
         * Calculates `width` of the line.
         * @private
         */
        private getLineWidth(line);
        /**
         * `Layouts` line.
         * @private
         */
        private layoutLine(line, lineIndent);
        /**
         * `Adds` line to line result.
         * @private
         */
        private addToLineResult(lineResult, lines, line, lineWidth, breakType);
        /**
         * `Copies` layout result from line result to entire result. Checks whether we can proceed lay outing or not.
         * @private
         */
        private copyToResult(result, lineResult, lines, numInserted);
        /**
         * `Finalizes` final result.
         * @private
         */
        private finalizeResult(result, lines);
        /**
         * `Trims` whitespaces at the line.
         * @private
         */
        private trimLine(info, firstLine);
        /**
         * Returns `wrap` type.
         * @private
         */
        private getWrapType();
    }
    export class PdfStringLayoutResult {
        /**
         * Layout `lines`.
         * @private
         */
        layoutLines: LineInfo[];
        /**
         * The `text` wasn`t lay outed.
         * @private
         */
        textRemainder: string;
        /**
         * Actual layout text `bounds`.
         * @private
         */
        size: SizeF;
        /**
         * `Height` of the line.
         * @private
         */
        layoutLineHeight: number;
        /**
         * Gets the `text` which is not lay outed.
         * @private
         */
        readonly remainder: string;
        /**
         * Gets the actual layout text `bounds`.
         * @private
         */
        readonly actualSize: SizeF;
        /**
         * Gets layout `lines` information.
         * @private
         */
        readonly lines: LineInfo[];
        /**
         * Gets the `height` of the line.
         * @private
         */
        readonly lineHeight: number;
        /**
         * Gets value that indicates whether any layout text [`empty`].
         * @private
         */
        readonly empty: boolean;
        /**
         * Gets `number of` the layout lines.
         * @private
         */
        readonly lineCount: number;
    }
    export class LineInfo {
        /**
         * Line `text`.
         * @private
         */
        content: string;
        /**
         * `Width` of the text.
         * @private
         */
        lineWidth: number;
        /**
         * `Breaking type` of the line.
         * @private
         */
        type: LineType;
        /**
         * Gets the `type` of the line text.
         * @private
         */
        lineType: LineType;
        /**
         * Gets the line `text`.
         * @private
         */
        text: string;
        /**
         * Gets `width` of the line text.
         * @private
         */
        width: number;
    }
    /**
    * Break type of the `line`.
    * @private
    */
    export enum LineType {
        /**
         * Specifies the type of `None`.
         * @private
         */
        None = 0,
        /**
         * Specifies the type of `NewLineBreak`.
         * @private
         */
        NewLineBreak = 1,
        /**
         * Specifies the type of `LayoutBreak`.
         * @private
         */
        LayoutBreak = 2,
        /**
         * Specifies the type of `FirstParagraphLine`.
         * @private
         */
        FirstParagraphLine = 4,
        /**
         * Specifies the type of `LastParagraphLine`.
         * @private
         */
        LastParagraphLine = 8,
    }
    
    /**
     * StringTokenizer.ts class for EJ2-PDF
     * Utility class for working with strings.
     * @private
     */
    export class StringTokenizer {
        /**
         * `Whitespace` symbol.
         * @private
         */
        static readonly whiteSpace: string;
        /**
         * `tab` symbol.
         * @private
         */
        static readonly tab: string;
        /**
         * Array of `spaces`.
         * @private
         */
        static readonly spaces: string[];
        /**
         * `Pattern` for WhiteSpace.
         * @private
         */
        private static readonly whiteSpacePattern;
        /**
         * `Text` data.
         * @private
         */
        private text;
        /**
         * Current `position`.
         * @private
         */
        private currentPosition;
        /**
         * Initializes a new instance of the `StringTokenizer` class.
         * @private
         */
        constructor(textValue: string);
        /**
         * Gets text `length`.
         * @private
         */
        readonly length: number;
        /**
         * Gets or sets the position.
         * @private
         */
        position: number;
        /**
         * Returns number of symbols occurred in the text.
         * @private
         */
        static getCharsCount(text: string, symbols: string): number;
        /**
         * Returns number of symbols occurred in the text.
         * @private
         */
        static getCharsCount(text: string, symbols: string[]): number;
        /**
         * Reads line of the text.
         * @private
         */
        readLine(): string;
        /**
         * Reads line of the text.
         * @private
         */
        peekLine(): string;
        /**
         * Reads a word from the text.
         * @private
         */
        readWord(): string;
        /**
         * Peeks a word from the text.
         * @private
         */
        peekWord(): string;
        /**
         * Reads char form the data.
         * @private
         */
        read(): string;
        /**
         * Reads count of the symbols.
         * @private
         */
        read(count: number): string;
        /**
         * Peeks char form the data.
         * @private
         */
        peek(): string;
        /**
         * Closes a reader.
         * @private
         */
        close(): void;
        /**
         * Checks whether array contains a symbol.
         * @private
         */
        private static contains(array, symbol);
    }
    
    /**
     * ByteArray class
     * Used to keep information about image stream as byte array.
     * @private
     */
    export class ByteArray {
        /**
         * Current stream `position`.
         * @default 0
         * @private
         */
        private mPosition;
        /**
         * Uint8Array for returing `buffer`.
         * @hidden
         * @private
         */
        private buffer;
        /**
         * Specifies the `data view`.
         * @hidden
         * @private
         */
        private dataView;
        /**
         * Initialize the new instance for `byte-array` class
         * @hidden
         * @private
         */
        constructor(length: number);
        /**
         * Gets and Sets a current `position` of byte array.
         * @hidden
         * @private
         */
        position: number;
        /**
         * `Read` from current stream position.
         * @default 0
         * @hidden
         * @private
         */
        read(buffer: ByteArray, offset: number, count: number): void;
        /**
         * @hidden
         */
        getBuffer(index: number): number;
        /**
         * @hidden
         */
        writeFromBase64String(base64: string): void;
        /**
         * @hidden
         */
        encodedString(input: string): Uint8Array;
        /**
         * @hidden
         */
        readByte(offset: number): number;
        /**
         * @hidden
         */
        readonly internalBuffer: Uint8Array;
        /**
         * @hidden
         */
        readonly count: number;
    }
    
    /**
     * ImageDecoder class
     */
    
    /**
     * Specifies the image `format`.
     * @private
     */
    export enum ImageFormat {
        /**
         * Specifies the type of `Unknown`.
         * @hidden
         * @private
         */
        Unknown = 0,
        /**
         * Specifies the type of `Bmp`.
         * @hidden
         * @private
         */
        Bmp = 1,
        /**
         * Specifies the type of `Emf`.
         * @hidden
         * @private
         */
        Emf = 2,
        /**
         * Specifies the type of `Gif`.
         * @hidden
         * @private
         */
        Gif = 3,
        /**
         * Specifies the type of `Jpeg`.
         * @hidden
         * @private
         */
        Jpeg = 4,
        /**
         * Specifies the type of `Png`.
         * @hidden
         * @private
         */
        Png = 5,
        /**
         * Specifies the type of `Wmf`.
         * @hidden
         * @private
         */
        Wmf = 6,
        /**
         * Specifies the type of `Icon`.
         * @hidden
         * @private
         */
        Icon = 7,
    }
    /**
     * `Decode the image stream`.
     * @private
     */
    export class ImageDecoder {
        /**
         * Number array for `png header`.
         * @hidden
         * @private
         */
        private static mPngHeader;
        /**
         * Number Array for `jpeg header`.
         * @hidden
         * @private
         */
        private static mJpegHeader;
        /**
         * Number array for `gif header`.
         * @hidden
         * @private
         */
        private static GIF_HEADER;
        /**
         * Number array for `bmp header.`
         * @hidden
         * @private
         */
        private static BMP_HEADER;
        /**
         * `memory stream` to store image data.
         * @hidden
         * @private
         */
        private mStream;
        /**
         * Specifies `format` of image.
         * @hidden
         * @private
         */
        private mFormat;
        /**
         * `Height` of image.
         * @hidden
         * @private
         */
        private mHeight;
        /**
         * `Width` of image.
         * @hidden
         * @private
         */
        private mWidth;
        /**
         * `Bits per component`.
         * @default 8
         * @hidden
         * @private
         */
        private mbitsPerComponent;
        /**
         * ByteArray to store `image data`.
         * @hidden
         * @private
         */
        private mImageData;
        /**
         * Store an instance of `PdfStream` for an image.
         * @hidden
         * @private
         */
        private imageStream;
        /**
         * Internal variable for accessing fields from `DictionryProperties` class.
         * @hidden
         * @private
         */
        private dictionaryProperties;
        /**
         * Initialize the new instance for `image-decoder` class.
         * @private
         */
        constructor(stream: ByteArray);
        /**
         * Gets the `height` of image.
         * @hidden
         * @private
         */
        readonly height: number;
        /**
         * Gets the `width` of image.
         * @hidden
         * @private
         */
        readonly width: number;
        /**
         * Gets `bits per component`.
         * @hidden
         * @private
         */
        readonly bitsPerComponent: number;
        /**
         * Gets the `size` of an image data.
         * @hidden
         * @private
         */
        readonly size: number;
        /**
         * Gets the value of an `image data`.
         * @hidden
         * @private
         */
        readonly imageData: ByteArray;
        /**
         * Gets the value of an `image data as number array`.
         * @hidden
         * @private
         */
        readonly imageDataAsNumberArray: ArrayBuffer;
        /**
         * `Initialize` image data and image stream.
         * @hidden
         * @private
         */
        private initialize();
        /**
         * `Reset` stream position into 0.
         * @hidden
         * @private
         */
        private reset();
        /**
         * `Parse` Jpeg image.
         * @hidden
         * @private
         */
        private parseJpegImage();
        /**
         * Gets the image `format`.
         * @private
         * @hidden
         */
        readonly format: ImageFormat;
        /**
         * `Checks if JPG`.
         * @private
         * @hidden
         */
        private checkIfJpeg();
        /**
         * Return image `dictionary`.
         * @hidden
         * @private
         */
        getImageDictionary(): PdfStream;
        /**
         * Return `colorSpace` of an image.
         * @hidden
         * @private
         */
        private getColorSpace();
        /**
         * Return `decode parameters` of an image.
         * @hidden
         * @private
         */
        private getDecodeParams();
    }
    
    /**
     * PdfBitmap.ts class for EJ2-PDF
     */
    
    /**
     * The 'PdfBitmap' contains methods and properties to handle the Bitmap images.
     * ```typescript
     * // create a new PDF document.
     * let document : PdfDocument = new PdfDocument();
     * // add a page to the document.
     * let page1 : PdfPage = document.pages.add();
     * // base64 string of an image
     * let imageString : string = '/9j/3+2w7em7HzY/KiijFw … 1OEYRUYrQ45yc5OUtz/9k=';
     * // load the image from the base64 string of original image.
     * let image : PdfBitmap = new PdfBitmap(imageString);
     * // draw the image
     * page1.graphics.drawImage(image, new RectangleF({x : 10, y : 10}, {width : 200, height : 200}));
     * // save the document.
     * document.save('output.pdf');
     * // destroy the document
     * document.destroy();
     * ```
     */
    export class PdfBitmap extends PdfImage {
        /**
         * Specifies the `status` of an image.
         * @default true.
         * @hidden
         * @private
         */
        private imageStatus;
        /**
         * Internal variable for accessing fields from `DictionryProperties` class.
         * @hidden
         * @private
         */
        private dictionaryProperties;
        /**
         * `Type` of an image.
         * @hidden
         * @private
         */
        checkImageType: number;
        /**
         * Object to store `decoder` of an image.
         * @hidden
         * @private
         */
        decoder: ImageDecoder;
        /**
         * `Load image`.
         * @hidden
         * @private
         */
        private loadImage(encodedString);
        /**
         * Create an instance for `PdfBitmap` class.
         * @param encodedString Base64 string of an image.
         * ```typescript
         * // create a new PDF document.
         * let document : PdfDocument = new PdfDocument();
         * // add a page to the document.
         * let page1 : PdfPage = document.pages.add();
         * // base64 string of an image
         * let imageString : string = '/9j/3+2w7em7HzY/KiijFw … 1OEYRUYrQ45yc5OUtz/9k=';
         * //
         * // load the image from the base64 string of original image.
         * let image : PdfBitmap = new PdfBitmap(imageString);
         * //
         * // draw the image
         * page1.graphics.drawImage(image, new RectangleF({x : 10, y : 10}, {width : 200, height : 200}));
         * // save the document.
         * document.save('output.pdf');
         * // destroy the document
         * document.destroy();
         * ```
         */
        constructor(encodedString: string);
        /**
         * `Initialize` image parameters.
         * @private
         */
        initializeAsync(encodedString: string): void;
        /**
         * `Saves` the image into stream.
         * @private
         */
        save(): void;
    }
    
    /**
     * PdfImage.ts class for EJ2-PDF
     */
    
    /**
     * `PdfImage` class represents the base class for images and provides functionality for the 'PdfBitmap' class.
     * @private
     */
    export abstract class PdfImage implements IPdfWrapper {
        /**
         * `Width` of an image.
         * @private
         */
        private imageWidth;
        /**
         * `Height` of an image.
         * @private
         */
        private imageHeight;
        /**
         * `Bits per component` of an image.
         * @hidden
         * @private
         */
        bitsPerComponent: number;
        /**
         * `horizontal resolution` of an image.
         * @hidden
         * @private
         */
        horizontalResolution: number;
        /**
         * `Vertical resolution` of an image.
         * @hidden
         * @private
         */
        verticalResolution: number;
        /**
         * `physical dimension` of an image.
         * @hidden
         * @private
         */
        private imagePhysicalDimension;
        /**
         * Gets and Sets the `width` of an image.
         * @private
         */
        width: number;
        /**
         * Gets and Sets the `height` of an image.
         * @private
         */
        height: number;
        /**
         * Gets or sets the size of the image.
         * @private
         */
        size: SizeF;
        /**
         * Gets the `physical dimension` of an image.
         * @private
         */
        readonly physicalDimension: SizeF;
        /**
         * return the stored `stream of an image`.
         * @private
         */
        imageStream: PdfStream;
        /**
         * Gets the `element` image stream.
         * @private
         */
        readonly element: IPdfPrimitive;
        /**
         * `Save` the image stream.
         * @private
         */
        abstract save(): void;
        /**
         * Return the value of `width and height of an image` in points.
         * @private
         */
        getPointSize(width: number, height: number): SizeF;
        getPointSize(width: number, height: number, horizontalResolution: number, verticalResolution: number): SizeF;
    }
    
    /**
     * public Enum for `ObjectType`.
     * @private
     */
    export enum ObjectType {
        /**
         * Specifies the type of `Free`.
         * @private
         */
        Free = 0,
        /**
         * Specifies the type of `Normal`.
         * @private
         */
        Normal = 1,
        /**
         * Specifies the type of `Packed`.
         * @private
         */
        Packed = 2,
    }
    
    /**
     * public Enum for `CompositeFontType`.
     * @private
     */
    export enum ObjectStatus {
        /**
         * Specifies the type of `None`.
         * @private
         */
        None = 0,
        /**
         * Specifies the type of `Registered`.
         * @private
         */
        Registered = 1,
    }
    
    /**
     * `PdfCrossTable` is responsible for intermediate level parsing
     * and savingof a PDF document.
     * @private
     */
    export class PdfCrossTable {
        /**
         * Parent `Document`.
         * @private
         */
        private pdfDocument;
        /**
         * Internal variable to store primtive objects of `main object collection`.
         * @private
         */
        private items;
        /**
         * The `mapped references`.
         * @private
         */
        private mappedReferences;
        /**
         * The modified `objects` that should be saved.
         * @private
         */
        private objects;
        /**
         * The `trailer` for a new document.
         * @private
         */
        private internalTrailer;
        /**
         * Internal variable to store if document `is being merged`.
         * @private
         */
        private merging;
        /**
         * `Flag` that forces an object to be 'a new'.
         * @private
         */
        private bForceNew;
        /**
         * Holds `maximal generation number` or offset to object.
         * @default 0
         * @private
         */
        private maxGenNumIndex;
        /**
         * The `number of the objects`.
         * @default 0
         * @private
         */
        private objectCount;
        /**
         * Internal variable for accessing fields from `DictionryProperties` class.
         * @default new PdfDictionaryProperties()
         * @private
         */
        private dictionaryProperties;
        /**
         * Gets or sets if the document `is merged`.
         * @private
         */
        isMerging: boolean;
        /**
         * Gets the `trailer`.
         * @private
         */
        readonly trailer: PdfDictionary;
        /**
         * Gets or sets the main `PdfDocument` class instance.
         * @private
         */
        document: PdfDocumentBase;
        /**
         * Gets the catched `PDF object` main collection.
         * @private
         */
        readonly pdfObjects: PdfMainObjectCollection;
        /**
         * Gets the `object collection`.
         * @private
         */
        private readonly objectCollection;
        /**
         * Gets or sets the `number of the objects` within the document.
         * @private
         */
        count: number;
        /**
         * Returns `next available object number`.
         * @private
         */
        readonly nextObjNumber: number;
        /**
         * `Saves` the cross-reference table into the stream and return it as Blob.
         * @private
         */
        save(writer: PdfWriter): Blob;
        /**
         * `Saves` the cross-reference table into the stream.
         * @private
         */
        save(writer: PdfWriter, filename: string): void;
        /**
         * `Saves the endess` of the file.
         * @private
         */
        private saveTheEndess(writer, xrefPos);
        /**
         * `Saves the new trailer` dictionary.
         * @private
         */
        private saveTrailer(writer, count, prevXRef);
        /**
         * `Saves the xref section`.
         * @private
         */
        private saveSections(writer);
        /**
         * `Saves a subsection`.
         * @private
         */
        private saveSubsection(writer, objectNum, count);
        /**
         * Generates string for `xref table item`.
         * @private
         */
        getItem(offset: number, genNumber: number, isFree: boolean): string;
        /**
         * `Prepares a subsection` of the current section within the cross-reference table.
         * @private
         */
        private prepareSubsection(objectNum);
        /**
         * `Marks the trailer references` being saved.
         * @private
         */
        private markTrailerReferences();
        /**
         * `Saves the head`.
         * @private
         */
        private saveHead(writer);
        /**
         * Generates the `version` of the file.
         * @private
         */
        private generateFileVersion(document);
        /**
         * Retrieves the `reference` of the object given.
         * @private
         */
        getReference(obj: IPdfPrimitive): PdfReference;
        /**
         * Retrieves the `reference` of the object given.
         * @private
         */
        getReference(obj: IPdfPrimitive, bNew: boolean): PdfReference;
        /**
         * Retrieves the `reference` of the object given.
         * @private
         */
        private getSubReference(obj, bNew);
        /**
         * `Saves all objects` in the collection.
         * @private
         */
        private saveObjects(writer);
        /**
         * `Saves indirect object`.
         * @private
         */
        saveIndirectObject(obj: IPdfPrimitive, writer: PdfWriter): void;
        /**
         * Performs `real saving` of the save object.
         * @private
         */
        private doSaveObject(obj, reference, writer);
        /**
         * `Registers` an archived object.
         * @private
         */
        registerObject(offset: number, reference: PdfReference): void;
        /**
         * `Registers` the object in the cross reference table.
         * @private
         */
        registerObject(offset: number, reference: PdfReference, free: boolean): void;
        /**
         * `Dereferences` the specified primitive object.
         * @private
         */
        static dereference(obj: IPdfPrimitive): IPdfPrimitive;
    }
    export class RegisteredObject {
        /**
         * The `object number` of the indirect object.
         * @private
         */
        private object;
        /**
         * The `generation number` of the indirect object.
         * @private
         */
        generation: number;
        /**
         * The `offset` of the indirect object within the file.
         * @private
         */
        private offsetNumber;
        /**
         * Shows if the object `is free`.
         * @private
         */
        type: ObjectType;
        /**
         * Holds the current `cross-reference` table.
         * @private
         */
        private xrefTable;
        /**
         * Gets the `object number`.
         * @private
         */
        readonly objectNumber: number;
        /**
         * Gets the `offset`.
         * @private
         */
        readonly offset: number;
        /**
         * Initialize the `structure` with the proper values.
         * @private
         */
        constructor(offset: number, reference: PdfReference);
        /**
         * Initialize the `structure` with the proper values.
         * @private
         */
        constructor(offset: number, reference: PdfReference, free: boolean);
    }
    
    /**
     * dictionaryProperties.ts class for EJ2-PDF
     * PDF dictionary properties.
     * @private
     */
    export class DictionaryProperties {
        /**
         * Specifies the value of `Pages`.
         * @private
         */
        readonly pages: string;
        /**
         * Specifies the value of `Kids`.
         * @private
         */
        readonly kids: string;
        /**
         * Specifies the value of `Count`.
         * @private
         */
        readonly count: string;
        /**
         * Specifies the value of `Resources`.
         * @private
         */
        readonly resources: string;
        /**
         * Specifies the value of `Type`.
         * @private
         */
        readonly type: string;
        /**
         * Specifies the value of `Size`.
         * @private
         */
        readonly size: string;
        /**
         * Specifies the value of `MediaBox`.
         * @private
         */
        readonly mediaBox: string;
        /**
         * Specifies the value of `Parent`.
         * @private
         */
        readonly parent: string;
        /**
         * Specifies the value of `Root`.
         * @private
         */
        readonly root: string;
        /**
         * Specifies the value of `DecodeParms`.
         * @private
         */
        readonly decodeParms: string;
        /**
         * Specifies the value of `Filter`.
         * @private
         */
        readonly filter: string;
        /**
         * Specifies the value of `Font`.
         * @private
         */
        readonly font: string;
        /**
         * Specifies the value of `Type1`.
         * @private
         */
        readonly type1: string;
        /**
         * Specifies the value of `BaseFont`.
         * @private
         */
        readonly baseFont: string;
        /**
         * Specifies the value of `Encoding`.
         * @private
         */
        readonly encoding: string;
        /**
         * Specifies the value of `Subtype`.
         * @private
         */
        readonly subtype: string;
        /**
         * Specifies the value of `Contents`.
         * @private
         */
        readonly contents: string;
        /**
         * Specifies the value of `ProcSet`.
         * @private
         */
        readonly procset: string;
        /**
         * Specifies the value of `ColorSpace`.
         * @private
         */
        readonly colorSpace: string;
        /**
         * Specifies the value of `ExtGState`.
         * @private
         */
        readonly extGState: string;
        /**
         * Specifies the value of `Pattern`.
         * @private
         */
        readonly pattern: string;
        /**
         * Specifies the value of `XObject`.
         * @private
         */
        readonly xObject: string;
        /**
         * Specifies the value of `Length`.
         * @private
         */
        readonly length: string;
        /**
         * Specifies the value of `Width`.
         * @private
         */
        readonly width: string;
        /**
         * Specifies the value of `Height`.
         * @private
         */
        readonly height: string;
        /**
         * Specifies the value of `BitsPerComponent`.
         * @private
         */
        readonly bitsPerComponent: string;
        /**
         * Specifies the value of `Image`.
         * @private
         */
        readonly image: string;
        /**
         * Specifies the value of `dctdecode`.
         * @private
         */
        readonly dctdecode: string;
        /**
         * Specifies the value of `Columns`.
         * @private
         */
        readonly columns: string;
        /**
         * Specifies the value of `BlackIs1`.
         * @private
         */
        readonly blackIs1: string;
        /**
         * Specifies the value of `K`.
         * @private
         */
        readonly k: string;
        /**
         * Specifies the value of `S`.
         * @private
         */
        readonly s: string;
        /**
         * Specifies the value of `Predictor`.
         * @private
         */
        readonly predictor: string;
        /**
         * Specifies the value of `DeviceRGB`.
         * @private
         */
        readonly deviceRgb: string;
        /**
         * Specifies the value of `Next`.
         * @private
         */
        readonly next: string;
        /**
         * Specifies the value of `Action`.
         * @private
         */
        readonly action: string;
        /**
         * Specifies the value of `Link`.
         * @private
         */
        readonly link: string;
        /**
         *
         * Specifies the value of `A`.
         * @private
         */
        readonly a: string;
        /**
         * Specifies the value of `Annot`.
         * @private
         */
        readonly annot: string;
        /**
         * Specifies the value of `P`.
         * @private
         */
        readonly p: string;
        /**
         * Specifies the value of `C`.
         * @private
         */
        readonly c: string;
        /**
         * Specifies the value of `Rect`.
         * @private
         */
        readonly rect: string;
        /**
         * Specifies the value of `URI`.
         * @private
         */
        readonly uri: string;
        /**
         * Specifies the value of `Annots`.
         * @private
         */
        readonly annots: string;
        /**
         * Specifies the value of `ca`.
         * @private
         */
        readonly ca: string;
        /**
         * Specifies the value of `CA`.
         * @private
         */
        readonly CA: string;
        /**
         * Specifies the value of `XYZ`.
         * @private
         */
        readonly xyz: string;
        /**
         * Specifies the value of `Fit`.
         * @private
         */
        readonly fit: string;
        /**
         * Specifies the value of `Dest`.
         * @private
         */
        readonly dest: string;
        /**
         * Specifies the value of `BM`.
         * @private
         */
        readonly BM: string;
        /**
         * Specifies the value of `flatedecode`.
         * @private
         */
        readonly flatedecode: string;
        /**
         * Specifies the value of `Rotate`.
         * @private
         */
        readonly rotate: string;
        /**
         * Specifies the value of 'bBox'.
         * @private
         */
        readonly bBox: string;
        /**
         * Specifies the value of 'form'.
         * @private
         */
        readonly form: string;
        /**
         * Initialize an instance for `PdfDictionaryProperties` class.
         * @private
         */
        constructor();
    }
    
    /**
     * PdfMainObjectCollection.ts class for EJ2-PDF
     */
    
    /**
     * The collection of all `objects` within a PDF document.
     * @private
     */
    export class PdfMainObjectCollection {
        /**
         * The collection of the `indirect objects`.
         * @default []
         * @private
         */
        objectCollections: ObjectInfo[];
        /**
         * The collection of the `Indirect objects`.
         * @default new Dictionary<number, ObjectInfo>()
         * @private
         */
        mainObjectCollection: Dictionary<number, ObjectInfo>;
        /**
         * The collection of `primitive objects`.
         * @private
         */
        primitiveObjectCollection: Dictionary<IPdfPrimitive, number>;
        /**
         * Holds the `index of the object`.
         * @private
         */
        private index;
        /**
         * Stores the value of `IsNew`.
         * @private
         */
        private isNew;
        /**
         * Gets the `count`.
         * @private
         */
        readonly count: number;
        /**
         * Gets the value of `ObjectInfo` from object collection.
         * @private
         */
        items(index: number): ObjectInfo;
        /**
         * Specifies the value of `IsNew`.
         * @private
         */
        readonly outIsNew: boolean;
        /**
         * `Adds` the specified element.
         * @private
         */
        add(element: IPdfPrimitive): void;
        /**
         * `Looks` through the collection for the object specified.
         * @private
         */
        private lookFor(obj);
        /**
         * Gets the `reference of the object`.
         * @private
         */
        getReference(index: IPdfPrimitive, isNew: boolean): {
            reference: PdfReference;
            wasNew: boolean;
        };
        /**
         * Tries to set the `reference to the object`.
         * @private
         */
        trySetReference(obj: IPdfPrimitive, reference: PdfReference, found: boolean): boolean;
        destroy(): void;
    }
    export class ObjectInfo {
        /**
         * The `PDF object`.
         * @private
         */
        pdfObject: IPdfPrimitive;
        /**
         * `Object number and generation number` of the object.
         * @private
         */
        private pdfReference;
        /**
         * Initializes a new instance of the `ObjectInfo` class.
         * @private
         */
        constructor();
        /**
         * Initializes a new instance of the `ObjectInfo` class.
         * @private
         */
        constructor(obj: IPdfPrimitive);
        /**
         * Initializes a new instance of the `ObjectInfo` class.
         * @private
         */
        constructor(obj: IPdfPrimitive, reference: PdfReference);
        /**
         * Gets the `object`.
         * @private
         */
        object: IPdfPrimitive;
        /**
         * Gets the `reference`.
         * @private
         */
        readonly reference: PdfReference;
        /**
         * Sets the `reference`.
         * @private
         */
        setReference(reference: PdfReference): void;
    }
    
    /**
     * PdfOperators.ts class for EJ2-PDF
     * Class of string PDF common operators.
     * @private
     */
    export class Operators {
        /**
         * Specifies the value of `obj`.
         * @private
         */
        static readonly obj: string;
        /**
         * Specifies the value of `endObj`.
         * @private
         */
        static readonly endObj: string;
        /**
         * Specifies the value of `R`.
         * @private
         */
        static readonly r: string;
        /**
         * Specifies the value of ` `.
         * @private
         */
        static readonly whiteSpace: string;
        /**
         * Specifies the value of `/`.
         * @private
         */
        static readonly slash: string;
        /**
         * Specifies the value of `\r\n`.
         * @private
         */
        static readonly newLine: string;
        /**
         * Specifies the value of `stream`.
         * @private
         */
        static readonly stream: string;
        /**
         * Specifies the value of `endStream`.
         * @private
         */
        static readonly endStream: string;
        /**
         * Specifies the value of `xref`.
         * @private
         */
        static readonly xref: string;
        /**
         * Specifies the value of `f`.
         * @private
         */
        static readonly f: string;
        /**
         * Specifies the value of `n`.
         * @private
         */
        static readonly n: string;
        /**
         * Specifies the value of `trailer`.
         * @private
         */
        static readonly trailer: string;
        /**
         * Specifies the value of `startxref`.
         * @private
         */
        static readonly startxref: string;
        /**
         * Specifies the value of `eof`.
         * @private
         */
        static readonly eof: string;
        /**
         * Specifies the value of `header`.
         * @private
         */
        static readonly header: string;
        /**
         * Specifies the value of `beginText`.
         * @private
         */
        static readonly beginText: string;
        /**
         * Specifies the value of `endText`.
         * @private
         */
        static readonly endText: string;
        /**
         * Specifies the value of `m`.
         * @private
         */
        static readonly beginPath: string;
        /**
         * Specifies the value of `l`.
         * @private
         */
        static readonly appendLineSegment: string;
        /**
         * Specifies the value of `S`.
         * @private
         */
        static readonly stroke: string;
        /**
         * Specifies the value of `f`.
         * @private
         */
        static readonly fill: string;
        /**
         * Specifies the value of `f*`.
         * @private
         */
        static readonly fillEvenOdd: string;
        /**
         * Specifies the value of `B`.
         * @private
         */
        static readonly fillStroke: string;
        /**
         * Specifies the value of `B*`.
         * @private
         */
        static readonly fillStrokeEvenOdd: string;
        /**
         * Specifies the value of `c`.
         * @private
         */
        static readonly appendbeziercurve: string;
        /**
         * Specifies the value of `re`.
         * @private
         */
        static readonly appendRectangle: string;
        /**
         * Specifies the value of `q`.
         * @private
         */
        static readonly saveState: string;
        /**
         * Specifies the value of `Q`.
         * @private
         */
        static readonly restoreState: string;
        /**
         * Specifies the value of `Do`.
         * @private
         */
        static readonly paintXObject: string;
        /**
         * Specifies the value of `cm`.
         * @private
         */
        static readonly modifyCtm: string;
        /**
         * Specifies the value of `Tm`.
         * @private
         */
        static readonly modifyTM: string;
        /**
         * Specifies the value of `w`.
         * @private
         */
        static readonly setLineWidth: string;
        /**
         * Specifies the value of `J`.
         * @private
         */
        static readonly setLineCapStyle: string;
        /**
         * Specifies the value of `j`.
         * @private
         */
        static readonly setLineJoinStyle: string;
        /**
         * Specifies the value of `d`.
         * @private
         */
        static readonly setDashPattern: string;
        /**
         * Specifies the value of `i`.
         * @private
         */
        static readonly setFlatnessTolerance: string;
        /**
         * Specifies the value of `h`.
         * @private
         */
        static readonly closePath: string;
        /**
         * Specifies the value of `s`.
         * @private
         */
        static readonly closeStrokePath: string;
        /**
         * Specifies the value of `b`.
         * @private
         */
        static readonly closeFillStrokePath: string;
        /**
         * Specifies the value of `setCharacterSpace`.
         * @private
         */
        static readonly setCharacterSpace: string;
        /**
         * Specifies the value of `setWordSpace`.
         * @private
         */
        static readonly setWordSpace: string;
        /**
         * Specifies the value of `setHorizontalScaling`.
         * @private
         */
        static readonly setHorizontalScaling: string;
        /**
         * Specifies the value of `setTextLeading`.
         * @private
         */
        static readonly setTextLeading: string;
        /**
         * Specifies the value of `setFont`.
         * @private
         */
        static readonly setFont: string;
        /**
         * Specifies the value of `setRenderingMode`.
         * @private
         */
        static readonly setRenderingMode: string;
        /**
         * Specifies the value of `setTextRise`.
         * @private
         */
        static readonly setTextRise: string;
        /**
         * Specifies the value of `setTextScaling`.
         * @private
         */
        static readonly setTextScaling: string;
        /**
         * Specifies the value of `setCoords`.
         * @private
         */
        static readonly setCoords: string;
        /**
         * Specifies the value of `goToNextLine`.
         * @private
         */
        static readonly goToNextLine: string;
        /**
         * Specifies the value of `setText`.
         * @private
         */
        static readonly setText: string;
        /**
         * Specifies the value of `setTextWithFormatting`.
         * @private
         */
        static readonly setTextWithFormatting: string;
        /**
         * Specifies the value of `setTextOnNewLine`.
         * @private
         */
        static readonly setTextOnNewLine: string;
        /**
         * Specifies the value of `selectcolorspaceforstroking`.
         * @private
         */
        static readonly selectcolorspaceforstroking: string;
        /**
         * Specifies the value of `selectcolorspacefornonstroking`.
         * @private
         */
        static readonly selectcolorspacefornonstroking: string;
        /**
         * Specifies the value of `setrbgcolorforstroking`.
         * @private
         */
        static readonly setrbgcolorforstroking: string;
        /**
         * Specifies the value of `setrbgcolorfornonstroking`.
         * @private
         */
        static readonly setrbgcolorfornonstroking: string;
        /**
         * Specifies the value of `K`.
         * @private
         */
        static readonly setcmykcolorforstroking: string;
        /**
         * Specifies the value of `k`.
         * @private
         */
        static readonly setcmykcolorfornonstroking: string;
        /**
         * Specifies the value of `G`.
         * @private
         */
        static readonly setgraycolorforstroking: string;
        /**
         * Specifies the value of `g`.
         * @private
         */
        static readonly setgraycolorfornonstroking: string;
        /**
         * Specifies the value of `W`.
         * @private
         */
        static readonly clipPath: string;
        /**
         * Specifies the value of `clipPathEvenOdd`.
         * @private
         */
        static readonly clipPathEvenOdd: string;
        /**
         * Specifies the value of `n`.
         * @private
         */
        static readonly endPath: string;
        /**
         * Specifies the value of `setGraphicsState`.
         * @private
         */
        static readonly setGraphicsState: string;
        /**
         * Specifies the value of `%`.
         * @private
         */
        static readonly comment: string;
        /**
         * Specifies the value of `*`.
         * @private
         */
        static readonly evenOdd: string;
        /**
         * Specifies the value of `M`.
         * @private
         */
        static readonly setMiterLimit: string;
        /**
         * Specifies the value of `test`.
         * @private
         */
        private forTest;
        /**
         * Create an instance of `PdfOperator` class.
         * @private
         */
        constructor();
    }
    
    /**
     * PdfStreamWriter.ts class for EJ2-PDF
     */
    
    /**
     * Helper class to `write PDF graphic streams` easily.
     * @private
     */
    export class PdfStreamWriter implements IPdfWriter {
        /**
         * The PDF `stream` where the data should be write into.
         * @private
         */
        private stream;
        /**
         * Initialize an instance of `PdfStreamWriter` class.
         * @private
         */
        constructor(stream: PdfStream);
        /**
         * `Clear` the stream.
         * @public
         */
        clear(): void;
        /**
         * Sets the `graphics state`.
         * @private
         */
        setGraphicsState(dictionaryName: PdfName): void;
        /**
         * Sets the `graphics state`.
         * @private
         */
        setGraphicsState(dictionaryName: string): void;
        /**
         * `Executes the XObject`.
         * @private
         */
        executeObject(name: PdfName): void;
        /**
         * `Closes path object`.
         * @private
         */
        closePath(): void;
        /**
         * `Clips the path`.
         * @private
         */
        clipPath(useEvenOddRule: boolean): void;
        /**
         * `Closes, then fills and strokes the path`.
         * @private
         */
        closeFillStrokePath(useEvenOddRule: boolean): void;
        /**
         * `Fills and strokes path`.
         * @private
         */
        fillStrokePath(useEvenOddRule: boolean): void;
        /**
         * `Fills path`.
         * @private
         */
        fillPath(useEvenOddRule: boolean): void;
        /**
         * `Ends the path`.
         * @private
         */
        endPath(): void;
        /**
         * `Closes and fills the path`.
         * @private
         */
        closeFillPath(useEvenOddRule: boolean): void;
        /**
         * `Closes and strokes the path`.
         * @private
         */
        closeStrokePath(): void;
        /**
         * `Sets the text scaling`.
         * @private
         */
        setTextScaling(textScaling: number): void;
        /**
         * `Strokes path`.
         * @private
         */
        strokePath(): void;
        /**
         * `Restores` the graphics state.
         * @private
         */
        restoreGraphicsState(): void;
        /**
         * `Saves` the graphics state.
         * @private
         */
        saveGraphicsState(): void;
        /**
         * `Shifts the text to the point`.
         * @private
         */
        startNextLine(): void;
        /**
         * `Shifts the text to the point`.
         * @private
         */
        startNextLine(point: PointF): void;
        /**
         * `Shifts the text to the point`.
         * @private
         */
        startNextLine(x: number, y: number): void;
        /**
         * Sets `text leading`.
         * @private
         */
        setLeading(leading: number): void;
        /**
         * `Begins the path`.
         * @private
         */
        beginPath(x: number, y: number): void;
        /**
         * `Begins text`.
         * @private
         */
        beginText(): void;
        /**
         * `Ends text`.
         * @private
         */
        endText(): void;
        /**
         * `Appends the rectangle`.
         * @private
         */
        appendRectangle(rectangle: RectangleF): void;
        /**
         * `Appends the rectangle`.
         * @private
         */
        appendRectangle(x: number, y: number, width: number, height: number): void;
        /**
         * `Appends a line segment`.
         * @private
         */
        appendLineSegment(point: PointF): void;
        /**
         * `Appends a line segment`.
         * @private
         */
        appendLineSegment(x: number, y: number): void;
        /**
         * Sets the `text rendering mode`.
         * @private
         */
        setTextRenderingMode(renderingMode: TextRenderingMode): void;
        /**
         * Sets the `character spacing`.
         * @private
         */
        setCharacterSpacing(charSpacing: number): void;
        /**
         * Sets the `word spacing`.
         * @private
         */
        setWordSpacing(wordSpacing: number): void;
        /**
         * Shows the `next line text`.
         * @private
         */
        showNextLineText(text: string, hex: boolean): void;
        /**
         * Shows the `next line text`.
         * @private
         */
        showNextLineText(text: PdfString): void;
        /**
         * Set the `color space`.
         * @private
         */
        setColorSpace(name: string, forStroking: boolean): void;
        /**
         * Set the `color space`.
         * @private
         */
        setColorSpace(name: PdfName, forStroking: boolean): void;
        /**
         * Modifies current `transformation matrix`.
         * @private
         */
        modifyCtm(matrix: PdfTransformationMatrix): void;
        /**
         * Sets `font`.
         * @private
         */
        setFont(font: PdfFont, name: string, size: number): void;
        /**
         * Sets `font`.
         * @private
         */
        setFont(font: PdfFont, name: PdfName, size: number): void;
        /**
         * `Writes the operator`.
         * @private
         */
        private writeOperator(opcode);
        /**
         * Checks the `text param`.
         * @private
         */
        private checkTextParam(text);
        /**
         * Checks the `text param`.
         * @private
         */
        private checkTextParam(text);
        /**
         * `Writes the text`.
         * @private
         */
        private writeText(text, hex);
        /**
         * `Writes the text`.
         * @private
         */
        private writeText(text);
        /**
         * `Writes the point`.
         * @private
         */
        private writePoint(point);
        /**
         * `Writes the point`.
         * @private
         */
        private writePoint(x, y);
        /**
         * `Updates y` co-ordinate.
         * @private
         */
        updateY(arg: number): number;
        /**
         * `Writes string` to the file.
         * @private
         */
        write(string: string): void;
        /**
         * `Writes comment` to the file.
         * @private
         */
        writeComment(comment: string): void;
        /**
         * Sets the `color and space`.
         * @private
         */
        setColorAndSpace(color: PdfColor, colorSpace: PdfColorSpace, forStroking: boolean): void;
        /**
         * Sets the `line dash pattern`.
         * @private
         */
        setLineDashPattern(pattern: number[], patternOffset: number): void;
        /**
         * Sets the `line dash pattern`.
         * @private
         */
        private setLineDashPatternHelper(pattern, patternOffset);
        /**
         * Sets the `miter limit`.
         * @private
         */
        setMiterLimit(miterLimit: number): void;
        /**
         * Sets the `width of the line`.
         * @private
         */
        setLineWidth(width: number): void;
        /**
         * Sets the `line cap`.
         * @private
         */
        setLineCap(lineCapStyle: PdfLineCap): void;
        /**
         * Sets the `line join`.
         * @private
         */
        setLineJoin(lineJoinStyle: PdfLineJoin): void;
        /**
         * Gets or sets the current `position` within the stream.
         * @private
         */
        readonly position: number;
        /**
         * Gets `stream length`.
         * @private
         */
        readonly length: number;
        /**
         * Gets and Sets the `current document`.
         * @private
         */
        readonly document: PdfDocument;
    }
    
    /**
     * PdfWriter.ts class for EJ2-PDF
     */
    
    /**
     * Used to `write a string` into output file.
     * @private
     */
    export class PdfWriter implements IPdfWriter {
        /**
         * Specifies the current `position`.
         * @private
         */
        private currentPosition;
        /**
         * Specifies the `length` of the stream.
         * @private
         */
        private streamLength;
        /**
         * Check wheather the stream `can seek` or not.
         * @private
         */
        private cannotSeek;
        /**
         * Specifies the parent `document`.
         * @private
         */
        private pdfDocument;
        /**
         * Specifies the `stream`.
         * @private
         */
        private streamWriter;
        /**
         * Initialize an instance of `PdfWriter` class.
         * @private
         */
        constructor(stream: ej.fileutils.StreamWriter);
        /**
         * Gets and Sets the `document`.
         * @private
         */
        document: PdfDocumentBase;
        /**
         * Gets the `position`.
         * @private
         */
        readonly position: number;
        /**
         * Gets  the `length` of the stream'.
         * @private
         */
        readonly length: number;
        /**
         * Gets the `stream`.
         * @private
         */
        readonly stream: ej.fileutils.StreamWriter;
        /**
         * `Writes the specified data`.
         * @private
         */
        write(overload: IPdfPrimitive | number | string | number[]): void;
    }
    
    /**
     * public Enum for `PdfPageOrientation`.
     * @private
     */
    export enum PdfPageOrientation {
        /**
         * Specifies the type of `Portrait`.
         * @private
         */
        Portrait = 0,
        /**
         * Specifies the type of `Landscape`.
         * @private
         */
        Landscape = 1,
    }
    /**
     * public Enum for `PdfPageRotateAngle`.
     * @private
     */
    export enum PdfPageRotateAngle {
        /**
         * Specifies the type of `RotateAngle0`.
         * @private
         */
        RotateAngle0 = 0,
        /**
         * Specifies the type of `RotateAngle90`.
         * @private
         */
        RotateAngle90 = 1,
        /**
         * Specifies the type of `RotateAngle180`.
         * @private
         */
        RotateAngle180 = 2,
        /**
         * Specifies the type of `RotateAngle270`.
         * @private
         */
        RotateAngle270 = 3,
    }
    /**
     * public Enum for `PdfNumberStyle`.
     * @private
     */
    export enum PdfNumberStyle {
        /**
         * Specifies the type of `None`.
         * @private
         */
        None = 0,
        /**
         * Specifies the type of `Numeric`.
         * @private
         */
        Numeric = 1,
        /**
         * Specifies the type of `LowerLatin`.
         * @private
         */
        LowerLatin = 2,
        /**
         * Specifies the type of `LowerRoman`.
         * @private
         */
        LowerRoman = 3,
        /**
         * Specifies the type of `UpperLatin`.
         * @private
         */
        UpperLatin = 4,
        /**
         * Specifies the type of `UpperRoman`.
         * @private
         */
        UpperRoman = 5,
    }
    /**
     * public Enum for `PdfDockStyle`.
     * @private
     */
    export enum PdfDockStyle {
        /**
         * Specifies the type of `None`.
         * @private
         */
        None = 0,
        /**
         * Specifies the type of `Bottom`.
         * @private
         */
        Bottom = 1,
        /**
         * Specifies the type of `Top`.
         * @private
         */
        Top = 2,
        /**
         * Specifies the type of `Left`.
         * @private
         */
        Left = 3,
        /**
         * Specifies the type of `Right`.
         * @private
         */
        Right = 4,
        /**
         * Specifies the type of `Fill`.
         * @private
         */
        Fill = 5,
    }
    /**
     * public Enum for `PdfAlignmentStyle`.
     * @private
     */
    export enum PdfAlignmentStyle {
        /**
         * Specifies the type of `None`.
         * @private
         */
        None = 0,
        /**
         * Specifies the type of `TopLeft`.
         * @private
         */
        TopLeft = 1,
        /**
         * Specifies the type of `TopCenter`.
         * @private
         */
        TopCenter = 2,
        /**
         * Specifies the type of `TopRight`.
         * @private
         */
        TopRight = 3,
        /**
         * Specifies the type of `MiddleLeft`.
         * @private
         */
        MiddleLeft = 4,
        /**
         * Specifies the type of `MiddleCenter`.
         * @private
         */
        MiddleCenter = 5,
        /**
         * Specifies the type of `MiddleRight`.
         * @private
         */
        MiddleRight = 6,
        /**
         * Specifies the type of `BottomLeft`.
         * @private
         */
        BottomLeft = 7,
        /**
         * Specifies the type of `BottomCenter`.
         * @private
         */
        BottomCenter = 8,
        /**
         * Specifies the type of `BottomRight`.
         * @private
         */
        BottomRight = 9,
    }
    /**
     * public Enum for `TemplateType`.
     * @private
     */
    export enum TemplateType {
        /**
         * Specifies the type of `None`.
         * @private
         */
        None = 0,
        /**
         * Specifies the type of `Top`.
         * @private
         */
        Top = 1,
        /**
         * Specifies the type of `Bottom`.
         * @private
         */
        Bottom = 2,
        /**
         * Specifies the type of `Left`.
         * @private
         */
        Left = 3,
        /**
         * Specifies the type of `Right`.
         * @private
         */
        Right = 4,
    }
    
    /**
     * PageAddedEventArguments.ts class for EJ2-PDF
     */
    
    /**
     * Provides data for `PageAddedEventHandler` event.
     * This event raises when adding the new PDF page to the PDF document.
     */
    export class PageAddedEventArgs {
        /**
         * Represents added `page`.
         * @private
         */
        private pdfPage;
        /**
         * Gets the `newly added page`.
         * @private
         */
        readonly page: PdfPage;
        /**
         * Initializes a new instance of the `PageAddedEventArgs` class.
         * @private
         */
        constructor();
        /**
         * Initializes a new instance of the `PageAddedEventArgs` class with 'PdfPage'.
         * @private
         */
        constructor(page: PdfPage);
    }
    
    /**
     * Represents a virtual collection of all the pages in the document.
     * @private
     */
    export class PdfDocumentPageCollection {
        /**
         * Parent `document`.
         * @private
         */
        private document;
        /**
         * It holds the page collection with the `index`.
         * @private
         */
        private pdfPageCollectionIndex;
        /**
         * Stores the previous pages's `orientation`.
         * @default PdfPageOrientation.Portrait
         * @private
         */
        private previousPageOrientation;
        /**
         * Internal variable for `page added event`.
         * @private
         */
        pageAdded: PageAddedEventArgs;
        /**
         * Gets the total `number of the pages`.
         * @private
         */
        readonly count: number;
        /**
         * Gets a `page index` from the document.
         * @private
         */
        readonly pageCollectionIndex: Dictionary<PdfPage, number>;
        /**
         * Initializes a new instance of the `PdfPageCollection` class.
         * @private
         */
        constructor(document: PdfDocument);
        /**
         * Creates a page and `adds` it to the last section in the document.
         * @private
         */
        add(): PdfPage;
        /**
         * Creates a page and `adds` it to the last section in the document.
         * @private
         */
        add(page: PdfPage): void;
        /**
         * Returns `last section` in the document.
         * @private
         */
        private getLastSection();
        /**
         * Called when `new page has been added`.
         * @private
         */
        onPageAdded(args: PageAddedEventArgs): void;
        /**
         * Gets the `total number of pages`.
         * @private
         */
        private countPages();
        /**
         * Gets the `page object` from page index.
         * @private
         */
        getPageByIndex(index: number): PdfPage;
        /**
         * Gets a page by its `index` in the document.
         * @private
         */
        private getPage(index);
        /**
         * Gets the `index of` the page in the document.
         * @private
         */
        indexOf(page: PdfPage): number;
        /**
         * `Removes` the specified page.
         * @private
         */
        remove(page: PdfPage): PdfSection;
    }
    
    /**
     * The abstract base class for all pages,
     * `PdfPageBase` class provides methods and properties to create PDF pages and its elements.
     * @private
     */
    export abstract class PdfPageBase implements IPdfWrapper {
        /**
         * Collection of the `layers` of the page.
         * @private
         */
        private layerCollection;
        /**
         * Stores the instance of `PdfDictionary` class.
         * @private
         */
        private pageDictionary;
        /**
         * `Index` of the default layer.
         * @default -1.
         * @private
         */
        private defLayerIndex;
        /**
         * Local variable to store if page `updated`.
         * @default false.
         * @private
         */
        private modified;
        /**
         * Stores the instance of `PdfResources`.
         * @hidden
         * @private
         */
        private resources;
        /**
         * Instance of `DictionaryProperties` class.
         * @hidden
         * @private
         */
        protected dictionaryProperties: DictionaryProperties;
        /**
         * Specifies the current `section`.
         * @hidden
         * @private
         */
        private pdfSection;
        /**
         * Gets the `section` of a page.
         * @private
         */
        section: PdfSection;
        /**
         * Gets the page `dictionary`.
         * @private
         */
        readonly dictionary: PdfDictionary;
        /**
         * Gets the wrapped `element`.
         * @private
         */
        readonly element: IPdfPrimitive;
        /**
         * Gets the `default layer` of the page (Read only).
         * @private
         */
        readonly defaultLayer: PdfPageLayer;
        /**
         * Gets or sets `index of the default layer`.
         * @private
         */
        /**
         * Gets or sets` index of the default layer`.
         * @private
         */
        defaultLayerIndex: number;
        /**
         * Gets the collection of the page's `layers` (Read only).
         * @private
         */
        readonly layers: PdfPageLayerCollection;
        /**
         * Return an instance of `PdfResources` class.
         * @private
         */
        getResources(): PdfResources;
        /**
         * Gets `array of page's content`.
         * @private
         */
        readonly contents: PdfArray;
        /**
         * Sets the `resources`.
         * @private
         */
        setResources(res: PdfResources): void;
        /**
         * Gets the `size of the page` (Read only).
         * @private
         */
        readonly abstract size: SizeF;
        /**
         * Gets the `origin of the page`.
         * @private
         */
        readonly abstract origin: PointF;
        /**
         * Initializes a new instance of the `PdfPageBase` class.
         * @private
         */
        constructor(dictionary: PdfDictionary);
    }
    
    /**
     * PdfPageLayerCollection.ts class for EJ2-PDF
     */
    
    /**
     * The class provides methods and properties to handle the collections of `PdfPageLayer`.
     */
    export class PdfPageLayerCollection extends PdfCollection {
        /**
         * Parent `page`.
         * @private
         */
        private page;
        /**
         * Stores the `number of first level layers` in the document.
         * @default 0
         * @private
         */
        private parentLayerCount;
        /**
         * Indicates if `Sublayer` is present.
         * @default false
         * @private
         */
        sublayer: boolean;
        /**
         * Stores the `optional content dictionary`.
         * @private
         */
        optionalContent: PdfDictionary;
        /**
         * Return the `PdfLayer` from the layer collection by index.
         * @private
         */
        items(index: number): PdfPageLayer;
        /**
         * Stores the `layer` into layer collection with specified index.
         * @private
         */
        items(index: number, value: PdfPageLayer): void;
        /**
         * Initializes a new instance of the `PdfPageLayerCollection` class
         * @private
         */
        constructor();
        /**
         * Initializes a new instance of the `PdfPageLayerCollection` class
         * @private
         */
        constructor(page: PdfPageBase);
        /**
         * Creates a new `PdfPageLayer` and adds it to the end of the collection.
         * @private
         */
        add(): PdfPageLayer;
        /**
         * Creates a new `PdfPageLayer` and adds it to the end of the collection.
         * @private
         */
        add(layerName: string, visible: boolean): PdfPageLayer;
        /**
         * Creates a new `PdfPageLayer` and adds it to the end of the collection.
         * @private
         */
        add(layerName: string): PdfPageLayer;
        /**
         * Creates a new `PdfPageLayer` and adds it to the end of the collection.
         * @private
         */
        add(layer: PdfPageLayer): number;
        /**
         * Registers `layer` at the page.
         * @private
         */
        private addLayer(index, layer);
        /**
         * Inserts `PdfPageLayer` into the collection at specified index.
         * @private
         */
        insert(index: number, layer: PdfPageLayer): void;
        /**
         * Registers layer at the page.
         * @private
         */
        private insertLayer(index, layer);
        /**
         * `Parses the layers`.
         * @private
         */
        private parseLayers(loadedPage);
        /**
         * Returns `index of` the `PdfPageLayer` in the collection if exists, -1 otherwise.
         * @private
         */
        indexOf(layer: PdfPageLayer): number;
    }
    
    /**
     * PdfPageLayer.ts class for EJ2-PDF
     */
    
    /**
     * The `PdfPageLayer` used to create layers in PDF document.
     * @private
     */
    export class PdfPageLayer implements IPdfWrapper {
        /**
         * Parent `page` of the layer.
         * @private
         */
        private pdfPage;
        /**
         * `Graphics context` of the layer.
         * @private
         */
        private pdfGraphics;
        /**
         * `Content` of the object.
         * @private
         */
        private content;
        /**
         * Indicates whether the layer should `clip page template` dimensions or not.
         * @private
         */
        private clipPageTemplates;
        /**
         * Local Variable to store the `color space` of the document.
         * @private
         */
        private pdfColorSpace;
        /**
         * Local Variable to store the `layer id`.
         * @private
         */
        private layerid;
        /**
         * Local Variable to store the `name`.
         * @private
         */
        private layerName;
        /**
         * Local Variable to set `visibility`.
         * @default true
         * @private
         */
        private isVisible;
        /**
         * Collection of the `layers` of the page.
         * @private
         */
        private layer;
        /**
         * Indicates if `Sublayer` is present.
         * @default false
         * @private
         */
        sublayer: boolean;
        /**
         * Local variable to store `length` of the graphics.
         * @default 0
         * @private
         */
        contentLength: number;
        /**
         * Stores the `print Option` dictionary.
         * @private
         */
        printOption: PdfDictionary;
        /**
         * Stores the `usage` dictionary.
         * @private
         */
        usage: PdfDictionary;
        /**
         * Instance for `PdfDictionaryProperties` Class.
         * @private
         */
        private dictionaryProperties;
        /**
         * Get or set the `color space`.
         * @private
         */
        colorSpace: PdfColorSpace;
        /**
         * Gets parent `page` of the layer.
         * @private
         */
        readonly page: PdfPageBase;
        /**
         * Gets and Sets the `id of the layer`.
         * @private
         */
        layerId: string;
        /**
         * Gets or sets the `name` of the layer.
         * @private
         */
        name: string;
        /**
         * Gets or sets the `visibility` of the layer.
         * @private
         */
        visible: boolean;
        /**
         * Gets `Graphics` context of the layer, used to draw various graphical content on layer.
         * @private
         */
        readonly graphics: PdfGraphics;
        /**
         * Gets the collection of `PdfPageLayer`, this collection handle by the class 'PdfPageLayerCollection'.
         * @private
         */
        readonly layers: PdfPageLayerCollection;
        /**
         * Initializes a new instance of the `PdfPageLayer` class with specified PDF page.
         * @private
         */
        constructor(page: PdfPageBase);
        /**
         * Initializes a new instance of the `PdfPageLayer` class with specified PDF page and PDF stream.
         * @private
         */
        constructor(page: PdfPageBase, stream: PdfStream);
        /**
         * Initializes a new instance of the `PdfPageLayer` class.
         * @private
         */
        constructor(page: PdfPageBase, clipPageTemplates: boolean);
        /**
         * `Adds` a new PDF Page layer.
         * @private
         */
        add(): PdfPageLayer;
        /**
         * Returns a value indicating the `sign` of a single-precision floating-point number.
         * @private
         */
        private sign(number);
        /**
         * `Initializes Graphics context` of the layer.
         * @private
         */
        private initializeGraphics(page);
        /**
         * Gets the wrapped `element`.
         * @private
         */
        readonly element: IPdfPrimitive;
    }
    
    /**
     * PdfPageSettings.ts class for EJ2-PDF
     */
    
    /**
     * The class provides various `setting` related with PDF pages.
     */
    export class PdfPageSettings {
        /**
         * The page `margins`.
         * @private
         */
        private pageMargins;
        /**
         * The page `size`.
         * @default a4
         * @private
         */
        private pageSize;
        /**
         * The page `rotation angle`.
         * @default PdfPageRotateAngle.RotateAngle0
         * @private
         */
        private rotateAngle;
        /**
         * The page `orientation`.
         * @default PdfPageOrientation.Portrait
         * @private
         */
        private pageOrientation;
        /**
         * The page `origin`.
         * @default 0,0
         * @private
         */
        private pageOrigin;
        /**
         * Checks the Whether the `rotation` is applied or not.
         * @default false
         * @private
         */
        isRotation: boolean;
        /**
         * Initializes a new instance of the `PdfPageSettings` class.
         * @private
         */
        constructor();
        /**
         * Initializes a new instance of the `PdfPageSettings` class.
         * @private
         */
        constructor(margins: number);
        /**
         * Gets or sets the `size` of the page.
         * @private
         */
        size: SizeF;
        /**
         * Gets or sets the page `orientation`.
         * @private
         */
        orientation: ej.pdfexport.PdfPageOrientation;
        /**
         * Gets or sets the `margins` of the page.
         * @private
         */
        margins: PdfMargins;
        /**
         * Gets or sets the `width` of the page.
         * @private
         */
        width: number;
        /**
         * Gets or sets the `height` of the page.
         * @private
         */
        height: number;
        /**
         * Gets or sets the `origin` of the page.
         * @private
         */
        origin: PointF;
        /**
         * Gets or sets the number of degrees by which the page should be `rotated` clockwise when displayed or printed.
         * @private
         */
        rotate: PdfPageRotateAngle;
        /**
         * `Update page size` depending on orientation.
         * @private
         */
        private updateSize(orientation);
        /**
         * Creates a `clone` of the object.
         * @private
         */
        clone(): PdfPageSettings;
        /**
         * Returns `size`, shrinked by the margins.
         * @private
         */
        getActualSize(): SizeF;
        /**
         * Sets `size` to the page aaccording to the orientation.
         * @private
         */
        private setSize(size);
    }
    
    /**
     * PdfPageSize.ts class for EJ2-PDF
     */
    
    /**
     * Represents information about various predefined `page sizes`.
     */
    export class PdfPageSize {
        /**
         * Specifies the size of `letter`.
         * @private
         */
        static readonly letter: SizeF;
        /**
         * Specifies the size of `note`.
         * @private
         */
        static readonly note: SizeF;
        /**
         * Specifies the size of `legal`.
         * @private
         */
        static readonly legal: SizeF;
        /**
         * Specifies the size of `a0`.
         * @private
         */
        static readonly a0: SizeF;
        /**
         * Specifies the size of `a1`.
         * @private
         */
        static readonly a1: SizeF;
        /**
         * Specifies the size of `a2`.
         * @private
         */
        static readonly a2: SizeF;
        /**
         * Specifies the size of `a3`.
         * @private
         */
        static readonly a3: SizeF;
        /**
         * Specifies the size of `a4`.
         * @private
         */
        static readonly a4: SizeF;
        /**
         * Specifies the size of `a5`.
         * @private
         */
        static readonly a5: SizeF;
        /**
         * Specifies the size of `a6`.
         * @private
         */
        static readonly a6: SizeF;
        /**
         * Specifies the size of `a7`.
         * @private
         */
        static readonly a7: SizeF;
        /**
         * Specifies the size of `a8`.
         * @private
         */
        static readonly a8: SizeF;
        /**
         * Specifies the size of `a9`.
         * @private
         */
        static readonly a9: SizeF;
        /**
         * Specifies the size of `a10`.
         * @private
         */
        static readonly a10: SizeF;
        /**
         * Specifies the size of `b0`.
         * @private
         */
        static readonly b0: SizeF;
        /**
         * Specifies the size of `b1`.
         * @private
         */
        static readonly b1: SizeF;
        /**
         * Specifies the size of `b2`.
         * @private
         */
        static readonly b2: SizeF;
        /**
         * Specifies the size of `b3`.
         * @private
         */
        static readonly b3: SizeF;
        /**
         * Specifies the size of `b4`.
         * @private
         */
        static readonly b4: SizeF;
        /**
         * Specifies the size of `b5`.
         * @private
         */
        static readonly b5: SizeF;
        /**
         * Specifies the size of `archE`.
         * @private
         */
        static readonly archE: SizeF;
        /**
         * Specifies the size of `archD`.
         * @private
         */
        static readonly archD: SizeF;
        /**
         * Specifies the size of `archC`.
         * @private
         */
        static readonly archC: SizeF;
        /**
         * Specifies the size of `archB`.
         * @private
         */
        static readonly archB: SizeF;
        /**
         * Specifies the size of `archA`.
         * @private
         */
        static readonly archA: SizeF;
        /**
         * Specifies the size of `flsa`.
         * @private
         */
        static readonly flsa: SizeF;
        /**
         * Specifies the size of `halfLetter`.
         * @private
         */
        static readonly halfLetter: SizeF;
        /**
         * Specifies the size of `letter11x17`.
         * @private
         */
        static readonly letter11x17: SizeF;
        /**
         * Specifies the size of `ledger`.
         * @private
         */
        static readonly ledger: SizeF;
        /**
         * Initialize an instance for `PdfPageSize` class.
         * @private
         */
        constructor();
    }
    
    /**
     * PdfPageTemplateElement.ts class for EJ2-Pdf
     */
    
    /**
     * Describes a `page template` object that can be used as header/footer, watermark or stamp.
     */
    export class PdfPageTemplateElement {
        /**
         * `Layer type` of the template.
         * @private
         */
        private isForeground;
        /**
         * `Docking style`.
         * @private
         */
        private dockStyle;
        /**
         * `Alignment style`.
         * @private
         */
        private alignmentStyle;
        /**
         * `PdfTemplate` object.
         * @private
         */
        private pdfTemplate;
        /**
         * Usage `type` of this template.
         * @private
         */
        private templateType;
        /**
         * `Location` of the template on the page.
         * @private
         */
        private currentLocation;
        /**
         * Gets or sets the `dock style` of the page template element.
         * @private
         */
        dock: PdfDockStyle;
        /**
         * Gets or sets `alignment` of the page template element.
         * @private
         */
        alignment: PdfAlignmentStyle;
        /**
         * Indicates whether the page template is located `in front of the page layers or behind of it`.
         * @private
         */
        foreground: boolean;
        /**
         * Indicates whether the page template is located `behind of the page layers or in front of it`.
         * @private
         */
        background: boolean;
        /**
         * Gets or sets `location` of the page template element.
         * @private
         */
        location: PointF;
        /**
         * Gets or sets `X` co-ordinate of the template element on the page.
         * @private
         */
        x: number;
        /**
         * Gets or sets `Y` co-ordinate of the template element on the page.
         * @private
         */
        y: number;
        /**
         * Gets or sets `size` of the page template element.
         * @private
         */
        size: SizeF;
        /**
         * Gets or sets `width` of the page template element.
         * @private
         */
        width: number;
        /**
         * Gets or sets `height` of the page template element.
         * @private
         */
        height: number;
        /**
         * Gets `graphics` context of the page template element.
         * @private
         */
        readonly graphics: PdfGraphics;
        /**
         * Gets Pdf `template` object.
         * @private
         */
        readonly template: PdfTemplate;
        /**
         * Gets or sets `type` of the usage of this page template.
         * @private
         */
        type: TemplateType;
        /**
         * Gets or sets `bounds` of the page template.
         * @public
         */
        bounds: RectangleF;
        /**
         * Creates a new page template.
         * @param bounds Bounds of the template.
         */
        constructor(bounds: RectangleF);
        /**
         * Creates a new page template.
         * @param bounds Bounds of the template.
         * @param page Page of the template.
         */
        constructor(bounds: RectangleF, page: PdfPage);
        /**
         * Creates a new page template.
         * @param location Location of the template.
         * @param size Size of the template.
         */
        constructor(location: PointF, size: SizeF);
        /**
         * Creates a new page template.
         * @param location Location of the template.
         * @param size Size of the template.
         * @param page Page of the template.
         */
        constructor(location: PointF, size: SizeF, page: PdfPage);
        /**
         * Creates a new page template.
         * @param size Size of the template.
         */
        constructor(size: SizeF);
        /**
         * Creates a new page template.
         * @param width Width of the template.
         * @param height Height of the template.
         */
        constructor(width: number, height: number);
        /**
         * Creates a new page template.
         * @param width Width of the template.
         * @param height Height of the template.
         * @param page The Current Page object.
         */
        constructor(width: number, height: number, page: PdfPage);
        /**
         * Creates a new page template.
         * @param x X co-ordinate of the template.
         * @param y Y co-ordinate of the template.
         * @param width Width of the template.
         * @param height Height of the template.
         */
        constructor(x: number, y: number, width: number, height: number);
        /**
         * Creates a new page template.
         * @param x X co-ordinate of the template.
         * @param y Y co-ordinate of the template.
         * @param width Width of the template.
         * @param height Height of the template.
         * @param page The Current Page object.
         */
        constructor(x: number, y: number, width: number, height: number, page: PdfPage);
        /**
         * `Updates Dock` property if template is used as header/footer.
         * @private
         */
        private updateDocking(type);
        /**
         * `Resets alignment` of the template.
         * @private
         */
        private resetAlignment();
        /**
         * `Sets alignment` of the template.
         * @private
         */
        private setAlignment(alignment);
        /**
         * Draws the template.
         * @private
         */
        draw(layer: PdfPageLayer, document: PdfDocument): void;
        /**
         * Calculates bounds of the page template.
         * @private
         */
        private calculateBounds(page, document);
        /**
         * Calculates bounds according to the alignment.
         * @private
         */
        private getAlignmentBounds(page, document);
        /**
         * Calculates bounds according to the alignment.
         * @private
         */
        private getSimpleAlignmentBounds(page, document);
        /**
         * Calculates bounds according to the alignment.
         * @private
         */
        private getTemplateAlignmentBounds(page, document);
        /**
         * Calculates bounds according to the docking.
         * @private
         */
        private getDockBounds(page, document);
        /**
         * Calculates bounds according to the docking.
         * @private
         */
        private getSimpleDockBounds(page, document);
        /**
         * Calculates template bounds basing on docking if template is a page template.
         * @private
         */
        private getTemplateDockBounds(page, document);
    }
    
    /**
     * Provides methods and properties to create pages and its elements.
     * `PdfPage` class inherited from the `PdfPageBase` class.
     * ```typescript
     * // create a new PDF document
     * let document : PdfDocument = new PdfDocument();
     * //
     * // add a new page to the document
     * let page1 : PdfPage = document.pages.add();
     * //
     * // set the font
     * let font : PdfStandardFont = new PdfStandardFont(PdfFontFamily.Helvetica, 20);
     * // create black brush
     * let blackBrush : PdfSolidBrush = new PdfSolidBrush(new PdfColor(0, 0, 0));
     * // draw the text
     * page1.graphics.drawString('Hello World', font, blackBrush, new PointF(0, 0));
     * // save the document
     * document.save('output.pdf');
     * // destroy the document
     * document.destroy();
     * ```
     */
    export class PdfPage extends PdfPageBase {
        /**
         * Checks whether the `progress is on`.
         * @hidden
         * @private
         */
        private isProgressOn;
        /**
         * Stores the instance of `PdfAnnotationCollection` class.
         * @hidden
         * @default null
         * @private
         */
        private annotationCollection;
        /**
         * Stores the instance of `PageBeginSave` event for Page Number Field.
         * @default null
         * @private
         */
        beginSave: Function;
        /**
         * Initialize the new instance for `PdfPage` class.
         * @private
         */
        constructor();
        /**
         * Gets current `document`.
         * @private
         */
        readonly document: PdfDocument;
        /**
         * Get the current `graphics`.
         * ```typescript
         * // create a new PDF document
         * let document : PdfDocument = new PdfDocument();
         * // add a new page to the document
         * let page1 : PdfPage = document.pages.add();
         * //
         * // get graphics
         * let graphics : PdfGraphics = page1.graphics;
         * //
         * // set the font
         * let font : PdfStandardFont = new PdfStandardFont(PdfFontFamily.Helvetica, 20);
         * // create black brush
         * let blackBrush : PdfSolidBrush = new PdfSolidBrush(new PdfColor(0, 0, 0));
         * // draw the text
         * graphics.drawString('Hello World', font, blackBrush, new PointF(0, 0));
         * // save the document
         * document.save('output.pdf');
         * // destroy the document
         * document.destroy();
         * ```
         */
        readonly graphics: PdfGraphics;
        /**
         * Gets the `cross table`.
         * @private
         */
        readonly crossTable: PdfCrossTable;
        /**
         * Gets the size of the PDF page- Read only.
         * @public
         */
        readonly size: SizeF;
        /**
         * Gets the `origin` of the page.
         * @private
         */
        readonly origin: PointF;
        /**
         * Gets a collection of the `annotations` of the page- Read only.
         * @private
         */
        readonly annotations: PdfAnnotationCollection;
        /**
         * `Initializes` a page.
         * @private
         */
        private initialize();
        /**
         * Sets parent `section` to the page.
         * @private
         */
        setSection(section: PdfSection): void;
        /**
         * `Resets the progress`.
         * @private
         */
        resetProgress(): void;
        /**
         * Get the page size reduced by page margins and page template dimensions.
         * ```typescript
         * // create a new PDF document
         * let document : PdfDocument = new PdfDocument();
         * // add a pages to the document
         * let page1 : PdfPage = document.pages.add();
         * // create new standard font
         * let font : PdfStandardFont = new PdfStandardFont(PdfFontFamily.Helvetica, 20);
         * // set brush
         * let blackBrush : PdfSolidBrush = new PdfSolidBrush(new PdfColor(0, 0, 0));
         * //
         * // set the specified point using `getClientSize` method
         * let point : PointF = new PointF(page1.getClientSize().width - 200, page1.getClientSize().height - 200);
         * // draw the text
         * page1.graphics.drawString('Hello World', font, blackBrush, point);
         * //
         * // save the document
         * document.save('output.pdf');
         * // destroy the document
         * document.destroy();
         * ```
         */
        getClientSize(): SizeF;
        /**
         * Helper method to retrive the instance of `PageBeginSave` event for header and footer elements.
         * @private
         */
        pageBeginSave(): void;
        /**
         * Helper method to draw template elements.
         * @private
         */
        private drawPageTemplates(document);
    }
    
    /**
     * PdfSectionCollection.ts class for EJ2-PDF
     */
    
    /**
     * Represents the `collection of the sections`.
     * @private
     */
    export class PdfSectionCollection implements IPdfWrapper {
        /**
         * Rotate factor for page `rotation`.
         * @default 90
         * @private
         */
        static readonly rotateFactor: number;
        /**
         * the current `document`.
         * @private
         */
        private pdfDocument;
        /**
         * `count` of the sections.
         * @private
         */
        private sectionCount;
        /**
         * @hidden
         * @private
         */
        private sections;
        /**
         * @hidden
         * @private
         */
        private sectionCollection;
        /**
         * @hidden
         * @private
         */
        private pages;
        /**
         * @hidden
         * @private
         */
        private dictionaryProperties;
        /**
         * Initializes a new instance of the `PdfSectionCollection` class.
         * @private
         */
        constructor(document: PdfDocument);
        /**
         * Gets the `Section` collection.
         */
        readonly section: PdfSection[];
        /**
         * Gets a parent `document`.
         * @private
         */
        readonly document: PdfDocument;
        /**
         * Gets the `number of sections` in a document.
         * @private
         */
        readonly count: number;
        /**
         * Gets the wrapped `element`.
         * @private
         */
        readonly element: IPdfPrimitive;
        /**
         * `Initializes the object`.
         * @private
         */
        private initialize();
        /**
         * Initializes a new instance of the `PdfSectionCollection` class.
         * @private
         */
        pdfSectionCollection(index: number): PdfSection;
        /**
         * In fills dictionary by the data from `Page settings`.
         * @private
         */
        private setPageSettings(container, pageSettings);
        /**
         * `Adds` the specified section.
         * @private
         */
        add(section?: PdfSection): number | PdfSection;
        /**
         * `Checks` if the section is within the collection.
         * @private
         */
        private checkSection(section);
        /**
         * Catches the Save event of the dictionary to `count the pages`.
         * @private
         */
        countPages(): number;
        /**
         * Catches the Save event of the dictionary to `count the pages`.
         * @hidden
         * @private
         */
        beginSave(): void;
    }
    
    /**
     * PdfSectionPageCollection.ts class for EJ2-PDF
     */
    
    /**
     * Represents the `collection of pages in a section`.
     * @private
     */
    export class PdfSectionPageCollection {
        /**
         * @hidden
         * @private
         */
        private pdfSection;
        /**
         * Gets the `PdfPage` at the specified index.
         * @private
         */
        section: PdfSection;
        /**
         * Initializes a new instance of the `PdfSectionPageCollection` class.
         * @private
         */
        constructor(section: PdfSection);
        /**
         * `Determines` whether the specified page is within the collection.
         * @private
         */
        contains(page: PdfPage): boolean;
        /**
         * `Removes` the specified page from collection.
         * @private
         */
        remove(page: PdfPage): void;
        /**
         * `Adds` a new page from collection.
         * @private
         */
        add(): PdfPage;
    }
    
    /**
     * PdfSectionTemplate.ts class for EJ2-PDF
     */
    
    /**
     * Represents a `page template` for all the pages in the section.
     */
    export class PdfSectionTemplate extends PdfDocumentTemplate {
        /**
         * `Left` settings.
         * @private
         */
        private leftValue;
        /**
         * `Top` settings.
         * @private
         */
        private topValue;
        /**
         * `Right` settings.
         * @private
         */
        private rightValue;
        /**
         * `Bottom` settings.
         * @private
         */
        private bottomValue;
        /**
         * `Other templates settings`.
         * @private
         */
        private stampValue;
        /**
         * Gets or sets value indicating whether parent `Left page template should be used or not`.
         * @private
         */
        applyDocumentLeftTemplate: boolean;
        /**
         * Gets or sets value indicating whether parent `Top page template should be used or not`.
         * @private
         */
        applyDocumentTopTemplate: boolean;
        /**
         * Gets or sets value indicating whether parent `Right page template should be used or not`.
         * @private
         */
        applyDocumentRightTemplate: boolean;
        /**
         * Gets or sets value indicating whether parent `Bottom page template should be used or not`.
         * @private
         */
        applyDocumentBottomTemplate: boolean;
        /**
         * Gets or sets value indicating whether the `stamp value` is true or not.
         * @private
         */
        applyDocumentStamps: boolean;
        /**
         * `Creates a new object`.
         * @private
         */
        constructor();
    }
    
    /**
     * PdfSection.ts class for EJ2-PDF
     */
    
    /**
     * Represents a `section` entity. A section it's a set of the pages with similar page settings.
     */
    export class PdfSection implements IPdfWrapper {
        /**
         * @hidden
         * @private
         */
        private pageAdded;
        /**
         * the parent `document`.
         * @private
         */
        private pdfDocument;
        /**
         * Page `settings` of the pages in the section.
         * @private
         */
        private settings;
        /**
         * Internal variable to store `initial page settings`.
         * @private
         */
        initialSettings: PdfPageSettings;
        /**
         * @hidden
         * @private
         */
        pagesReferences: PdfArray;
        /**
         * @hidden
         * @private
         */
        private section;
        /**
         * @hidden
         * @private
         */
        private pageCount;
        /**
         * @hidden
         * @private
         */
        private sectionCollection;
        /**
         * @hidden
         * @private
         */
        private pdfPages;
        /**
         * Indicates if the `progress is turned on`.
         * @private
         */
        private isProgressOn;
        /**
         * Page `template` for the section.
         * @private
         */
        private pageTemplate;
        /**
         * @hidden
         * @private
         */
        private dictionaryProperties;
        /**
         * A virtual `collection of pages`.
         * @private
         */
        private pagesCollection;
        /**
         * Stores the information about the page settings of the current section.
         * @private
         */
        private state;
        /**
         * Initializes a new instance of the `PdfSection` class.
         * @private
         */
        constructor(document: PdfDocument);
        /**
         * Initializes a new instance of the `PdfSection` class.
         * @private
         */
        constructor(document: PdfDocument, pageSettings: PdfPageSettings);
        /**
         * Gets or sets the `parent`.
         * @private
         */
        parent: PdfSectionCollection;
        /**
         * Gets the `parent document`.
         * @private
         */
        readonly parentDocument: PdfDocumentBase;
        /**
         * Gets or sets the `page settings` of the section.
         * @private
         */
        pageSettings: PdfPageSettings;
        /**
         * Gets the wrapped `element`.
         * @private
         */
        readonly element: IPdfPrimitive;
        /**
         * Gets the `count` of the pages in the section.
         * @private
         */
        readonly count: number;
        /**
         * Gets or sets a `template` for the pages in the section.
         * @private
         */
        template: PdfSectionTemplate;
        /**
         * Gets the `document`.
         * @private
         */
        readonly document: PdfDocument;
        /**
         * Gets the collection of `pages` in a section (Read only)
         * @private
         */
        readonly pages: PdfSectionPageCollection;
        /**
         * `Return the page collection` of current section.
         * @private
         */
        getPages(): PdfPageBase[];
        /**
         * `Translates` point into native coordinates of the page.
         * @private
         */
        pointToNativePdf(page: PdfPage, point: PointF): PointF;
        /**
         * Sets the page setting of the current section.
         * @public
         * @param settings Instance of `PdfPageSettings`
         */
        setPageSettings(settings: PdfPageSettings): void;
        /**
         * `Initializes` the object.
         * @private
         */
        private initialize();
        /**
         * Checks whether any template should be printed on this layer.
         * @private
         * @param document The parent document.
         * @param page The parent page.
         * @param foreground Layer z-order.
         * @returns True - if some content should be printed on the layer, False otherwise.
         */
        containsTemplates(document: PdfDocument, page: PdfPage, foreground: boolean): boolean;
        /**
         * Returns array of the document templates.
         * @private
         * @param document The parent document.
         * @param page The parent page.
         * @param headers If true - return headers/footers, if false - return simple templates.
         * @param foreground If true - return foreground templates, if false - return background templates.
         * @returns Returns array of the document templates.
         */
        private getDocumentTemplates(document, page, headers, foreground);
        /**
         * `Adds` the specified page.
         * @private
         */
        add(page?: PdfPage): void | PdfPage;
        /**
         * `Checks the presence`.
         * @private
         */
        private checkPresence(page);
        /**
         * `Determines` whether the page in within the section.
         * @private
         */
        contains(page: PdfPage): boolean;
        /**
         * Get the `index of` the page.
         * @private
         */
        indexOf(page: PdfPage): number;
        /**
         * Call two event's methods.
         * @hidden
         * @private
         */
        private pageAddedMethod(page);
        /**
         * Called when the page has been added.
         * @hidden
         * @private
         */
        protected onPageAdded(args: PageAddedEventArgs): void;
        /**
         * Calculates actual `bounds` of the page.
         * @private
         */
        getActualBounds(page: PdfPage, includeMargins: boolean): RectangleF;
        /**
         * Calculates actual `bounds` of the page.
         * @private
         */
        getActualBounds(document: PdfDocument, page: PdfPage, includeMargins: boolean): RectangleF;
        /**
         * Calculates width of the `left indent`.
         * @private
         */
        getLeftIndentWidth(document: PdfDocument, page: PdfPage, includeMargins: boolean): number;
        /**
         * Calculates `Height` of the top indent.
         * @private
         */
        getTopIndentHeight(document: PdfDocument, page: PdfPage, includeMargins: boolean): number;
        /**
         * Calculates `width` of the right indent.
         * @private
         */
        getRightIndentWidth(document: PdfDocument, page: PdfPage, includeMargins: boolean): number;
        /**
         * Calculates `Height` of the bottom indent.
         * @private
         */
        getBottomIndentHeight(document: PdfDocument, page: PdfPage, includeMargins: boolean): number;
        /**
         * `Removes` the page from the section.
         * @private
         */
        remove(page: PdfPage): void;
        /**
         * In fills dictionary by the data from `Page settings`.
         * @private
         */
        private applyPageSettings(container, parentSettings, state);
        /**
         * Catches the Save event of the dictionary.
         * @hidden
         * @private
         */
        beginSave(state: PageSettingsState, writer: IPdfWriter): void;
        /**
         * Draws page templates on the page.
         * @private
         */
        drawTemplates(page: PdfPage, layer: PdfPageLayer, document: PdfDocument, foreground: boolean): void;
        /**
         * Draws page templates on the page.
         * @private
         */
        private drawTemplatesHelper(layer, document, templates);
    }
    export class PageSettingsState {
        /**
         * @hidden
         * @private
         */
        private pageOrientation;
        /**
         * @hidden
         * @private
         */
        private pageRotate;
        /**
         * @hidden
         * @private
         */
        private pageSize;
        /**
         * @hidden
         * @private
         */
        private pageOrigin;
        /**
         * @hidden
         * @private
         */
        orientation: ej.pdfexport.PdfPageOrientation;
        /**
         * @hidden
         * @private
         */
        rotate: PdfPageRotateAngle;
        /**
         * @hidden
         * @private
         */
        size: SizeF;
        /**
         * @hidden
         * @private
         */
        origin: PointF;
        /**
         * New instance to store the `PageSettings`.
         * @private
         */
        constructor(document: PdfDocument);
    }
    
    /**
     * PdfArray.ts class for EJ2-PDF
     */
    
    /**
     * `PdfArray` class is used to perform array related primitive operations.
     * @private
     */
    export class PdfArray implements IPdfPrimitive {
        /**
         * `startMark` - '['
         * @private
         */
        startMark: string;
        /**
         * `endMark` - ']'.
         * @private
         */
        endMark: string;
        /**
         * The `elements` of the PDF array.
         * @private
         */
        private internalElements;
        /**
         * Indicates if the array `was changed`.
         * @private
         */
        private bChanged;
        /**
         * Shows the type of object `status` whether it is object registered or other status;
         * @private
         */
        private status9;
        /**
         * Indicates if the object is currently in `saving state` or not.
         * @private
         */
        private isSaving9;
        /**
         * Holds the `index` number of the object.
         * @private
         */
        private index9;
        /**
         * Internal variable to store the `position`.
         * @default -1
         * @private
         */
        private position9;
        /**
         * Internal variable to hold `PdfCrossTable` reference.
         * @private
         */
        private pdfCrossTable;
        /**
         * Internal variable to hold `cloned object`.
         * @default null
         * @private
         */
        private clonedObject9;
        /**
         * Gets the `IPdfSavable` at the specified index.
         * @private
         */
        items(index: number): IPdfPrimitive;
        /**
         * Gets the `count`.
         * @private
         */
        readonly count: number;
        /**
         * Gets or sets the `Status` of the specified object.
         * @private
         */
        status: ObjectStatus;
        /**
         * Gets or sets a value indicating whether this document `is saving` or not.
         * @private
         */
        isSaving: boolean;
        /**
         * Returns `cloned object`.
         * @private
         */
        readonly clonedObject: IPdfPrimitive;
        /**
         * Gets or sets the `position` of the object.
         * @private
         */
        position: number;
        /**
         * Gets or sets the `index` value of the specified object.
         * @private
         */
        objectCollectionIndex: number;
        /**
         * Returns `PdfCrossTable` associated with the object.
         * @private
         */
        readonly CrossTable: PdfCrossTable;
        /**
         * Gets the `elements` of the Pdf Array.
         * @private
         */
        readonly elements: IPdfPrimitive[];
        /**
         * Initializes a new instance of the `PdfArray` class.
         * @private
         */
        constructor();
        /**
         * Initializes a new instance of the `PdfArray` class.
         * @private
         */
        constructor(array: PdfArray | number[]);
        /**
         * `Adds` the specified element to the PDF array.
         * @private
         */
        add(element: IPdfPrimitive): void;
        /**
         * `Marks` the object changed.
         * @private
         */
        private markedChange();
        /**
         * `Determines` whether the specified element is within the array.
         * @private
         */
        contains(element: IPdfPrimitive): boolean;
        /**
         * Returns the `primitive object` of input index.
         * @private
         */
        getItems(index: number): IPdfPrimitive;
        /**
         * `Saves` the object using the specified writer.
         * @private
         */
        save(writer: IPdfWriter): void;
        /**
         * Creates a `copy of PdfArray`.
         * @private
         */
        clone(crossTable: PdfCrossTable): IPdfPrimitive;
        /**
         * Creates filled PDF array `from the rectangle`.
         * @private
         */
        static fromRectangle(bounds: RectangleF): PdfArray;
        /**
         * `Inserts` the element into the array.
         * @private
         */
        insert(index: number, element: IPdfPrimitive): void;
        /**
         * `Checks whether array contains the element`.
         * @private
         */
        indexOf(element: IPdfPrimitive): number;
        /**
         * `Removes` element from the array.
         * @private
         */
        remove(element: IPdfPrimitive): void;
        /**
         * `Remove` the element from the array by its index.
         * @private
         */
        removeAt(index: number): void;
        /**
         * `Clear` the array.
         * @private
         */
        clear(): void;
        /**
         * `Marks` the object changed.
         * @private
         */
        markChanged(): void;
    }
    
    /**
     * PdfBoolean.ts class for EJ2-PDF
     */
    
    /**
     * `PdfBoolean` class is used to perform boolean related primitive operations.
     * @private
     */
    export class PdfBoolean implements IPdfPrimitive {
        /**
         * Shows the type of object `status` whether it is object registered or other status;
         * @private
         */
        private objectStatus;
        /**
         * Indicates if the object `is currently in saving state` or not.
         * @private
         */
        private saving;
        /**
         * Holds the `index` number of the object.
         * @private
         */
        private index;
        /**
         * The `value` of the PDF boolean.
         * @private
         */
        private value;
        /**
         * Internal variable to store the `position`.
         * @default -1
         * @private
         */
        private currentPosition;
        /**
         * Initializes a new instance of the `PdfBoolean` class.
         * @private
         */
        constructor(value: boolean);
        /**
         * Gets or sets the `Status` of the specified object.
         * @private
         */
        status: ObjectStatus;
        /**
         * Gets or sets a value indicating whether this document `is saving` or not.
         * @private
         */
        isSaving: boolean;
        /**
         * Gets or sets the `index` value of the specified object.
         * @private
         */
        objectCollectionIndex: number;
        /**
         * Gets or sets the `position` of the object.
         * @private
         */
        position: number;
        /**
         * Returns `cloned object`.
         * @private
         */
        readonly clonedObject: IPdfPrimitive;
        /**
         * `Saves` the object using the specified writer.
         * @private
         */
        save(writer: IPdfWriter): void;
        /**
         * Creates a `copy of PdfBoolean`.
         * @private
         */
        clone(crossTable: PdfCrossTable): IPdfPrimitive;
        /**
         * Converts `boolean to string` - 0/1 'true'/'false'.
         * @private
         */
        private boolToStr(value);
    }
    
    /**
     * PdfDictionary.ts class for EJ2-PDF
     */
    
    /**
     * `PdfDictionary` class is used to perform primitive operations.
     * @private
     */
    export class PdfDictionary implements IPdfPrimitive {
        /**
         * Indicates if the object was `changed`.
         * @private
         */
        private bChanged;
        /**
         * Internal variable to store the `position`.
         * @default -1
         * @private
         */
        private position7;
        /**
         * Flag is dictionary need to `encrypt`.
         * @private
         */
        private encrypt;
        /**
         * The `IPdfSavable` with the specified key.
         * @private
         */
        private primitiveItems;
        /**
         * `Start marker` for dictionary.
         * @private
         */
        private readonly prefix;
        /**
         * `End marker` for dictionary.
         * @private
         */
        private readonly suffix;
        /**
         * @hidden
         * @private
         */
        private resources;
        /**
         * Shows the type of object `status` whether it is object registered or other status.
         * @private
         */
        private status7;
        /**
         * Indicates if the object `is currently in saving state` or not.
         * @private
         */
        private isSaving7;
        /**
         * Holds the `index` number of the object.
         * @private
         */
        private index7;
        /**
         * Internal variable to hold `cloned object`.
         * @default null
         * @private
         */
        private readonly object;
        /**
         * Flag for PDF file formar 1.5 is dictionary `archiving` needed.
         * @default true
         * @private
         */
        private archive;
        /**
         * @hidden
         * @private
         */
        private tempPageCount;
        /**
         * @hidden
         * @private
         */
        protected dictionaryProperties: DictionaryProperties;
        /**
         * Event. Raise before the object saves.
         * @public
         */
        pageBeginDrawTemplate: SaveTemplateEventHandler;
        /**
         * Event. Raise `before the object saves`.
         * @private
         */
        beginSave: SaveSectionCollectionEventHandler;
        /**
         * Event. Raise `after the object saved`.
         * @private
         */
        endSave: SaveSectionCollectionEventHandler;
        /**
         * @hidden
         * @private
         */
        sectionBeginSave: SaveSectionEventHandler;
        /**
         * @hidden
         * @private
         */
        annotationBeginSave: SaveAnnotationEventHandler;
        /**
         * @hidden
         * @private
         */
        annotationEndSave: SaveAnnotationEventHandler;
        /**
         * Gets or sets the `IPdfSavable` with the specified key.
         * @private
         */
        readonly items: Dictionary<string, IPdfPrimitive>;
        /**
         * Gets or sets the `Status` of the specified object.
         * @private
         */
        status: ObjectStatus;
        /**
         * Gets or sets a value indicating whether this document `is saving` or not.
         * @private
         */
        isSaving: boolean;
        /**
         * Gets or sets the `index` value of the specified object.
         * @private
         */
        objectCollectionIndex: number;
        /**
         * Returns `cloned object`.
         * @private
         */
        readonly clonedObject: IPdfPrimitive;
        /**
         * Gets or sets the `position` of the object.
         * @private
         */
        position: number;
        /**
         * Gets the `count`.
         * @private
         */
        readonly Count: number;
        /**
         * Collection of `items` in the object.
         * @private
         */
        readonly Dictionary: PdfDictionary;
        /**
         * Get flag if need to `archive` dictionary.
         * @private
         */
        getArchive(): boolean;
        /**
         * Set flag if need to `archive` dictionary.
         * @private
         */
        setArchive(value: boolean): void;
        /**
         * Sets flag if `encryption` is needed.
         * @private
         */
        setEncrypt(value: boolean): void;
        /**
         * Gets flag if `encryption` is needed.
         * @private
         */
        getEncrypt(): boolean;
        /**
         * Initializes a new empty instance of the `PdfDictionary` class.
         * @private
         */
        constructor();
        /**
         * Initializes a new empty instance of the `PdfDictionary` class.
         * @private
         */
        constructor(dictionary: PdfDictionary);
        /**
         * `Freezes` the changes.
         * @private
         */
        freezeChanges(freezer: Object): void;
        /**
         * Creates a `copy of PdfDictionary`.
         * @private
         */
        clone(crossTable: PdfCrossTable): IPdfPrimitive;
        /**
         * `Mark` this instance modified.
         * @private
         */
        modify(): void;
        /**
         * `Removes` the specified key.
         * @private
         */
        remove(key: PdfName | string): void;
        /**
         * `Determines` whether the dictionary contains the key.
         * @private
         */
        containsKey(key: string | PdfName): boolean;
        /**
         * Raises event `BeginSave`.
         * @private
         */
        protected onBeginSave(): void;
        /**
         * Raises event 'BeginSave'.
         * @private
         */
        protected onTemplateBeginSave(): void;
        /**
         * Raises event `BeginSave`.
         * @private
         */
        protected onBeginAnnotationSave(): void;
        /**
         * Raises event `BeginSave`.
         * @private
         */
        protected onSectionBeginSave(writer: IPdfWriter): void;
        /**
         * `Saves` the object using the specified writer.
         * @private
         */
        save(writer: IPdfWriter): void;
        /**
         * `Saves` the object using the specified writer.
         * @private
         */
        save(writer: IPdfWriter, bRaiseEvent: boolean): void;
        /**
         * `Save dictionary items`.
         * @private
         */
        private saveItems(writer);
    }
    export class SaveSectionCollectionEventHandler {
        /**
         * @hidden
         * @private
         */
        sender: PdfSectionCollection;
        /**
         * New instance for `save section collection event handler` class.
         * @private
         */
        constructor(sender: PdfSectionCollection);
    }
    export class SaveAnnotationEventHandler {
        /**
         * @hidden
         * @private
         */
        sender: PdfAnnotation;
        /**
         * New instance for `save annotation event handler` class.
         * @private
         */
        constructor(sender: PdfAnnotation);
    }
    export class SaveSectionEventHandler {
        /**
         * @hidden
         * @private
         */
        sender: PdfSection;
        /**
         * @hidden
         * @private
         */
        state: PageSettingsState;
        /**
         * New instance for `save section event handler` class.
         * @private
         */
        constructor(sender: PdfSection, state: PageSettingsState);
    }
    /**
     * SaveTemplateEventHandler class used to store information about template elements.
     * @private
     * @hidden
     */
    export class SaveTemplateEventHandler {
        /**
         * @public
         * @hidden
         */
        sender: PdfPage;
        /**
         * New instance for save section collection event handler class.
         * @public
         */
        constructor(sender: PdfPage);
    }
    
    /**
     * PdfName.ts class for EJ2-PDF
     */
    
    /**
     * `PdfName` class is used to perform name (element names) related primitive operations.
     * @private
     */
    export class PdfName implements IPdfPrimitive {
        /**
         * `Start symbol` of the name object.
         * @default /
         * @private
         */
        readonly stringStartMark: string;
        /**
         * PDF `special characters`.
         * @private
         */
        static delimiters: string;
        /**
         * The symbols that are not allowed in PDF names and `should be replaced`.
         * @private
         */
        private static readonly replacements;
        /**
         * `Value` of the element.
         * @private
         */
        private internalValue;
        /**
         * Shows the type of object `status` whether it is object registered or other status;
         * @private
         */
        private status6;
        /**
         * Indicates if the object is currently in `saving state or not`.
         * @default false
         * @private
         */
        private isSaving6;
        /**
         * Holds the `index` number of the object.
         * @private
         */
        private index6;
        /**
         * Internal variable to store the `position`.
         * @default -1
         * @private
         */
        private position6;
        /**
         * Initializes a new instance of the `PdfName` class.
         * @private
         */
        constructor();
        /**
         * Initializes a new instance of the `PdfName` class.
         * @private
         */
        constructor(value: string);
        /**
         * Gets or sets the `Status` of the specified object.
         * @private
         */
        status: ObjectStatus;
        /**
         * Gets or sets a value indicating whether this document `is saving` or not.
         * @private
         */
        isSaving: boolean;
        /**
         * Gets or sets the `index` value of the specified object.
         * @private
         */
        objectCollectionIndex: number;
        /**
         * Gets or sets the `position` of the object.
         * @private
         */
        position: number;
        /**
         * Returns `cloned object`.
         * @private
         */
        readonly clonedObject: IPdfPrimitive;
        /**
         * Gets or sets the `value` of the object.
         * @private
         */
        value: string;
        /**
         * `Saves` the name using the specified writer.
         * @private
         */
        save(writer: IPdfWriter): void;
        /**
         * Gets `string` representation of the primitive.
         * @private
         */
        toString(): string;
        /**
         * Creates a `copy of PdfName`.
         * @private
         */
        clone(crossTable: PdfCrossTable): IPdfPrimitive;
        /**
         * Replace some characters with its `escape sequences`.
         * @private
         */
        escapeString(stringValue: string): string;
        /**
         * Replace a symbol with its code with the precedence of the `sharp sign`.
         * @private
         */
        private normalizeValue(value, c?);
    }
    
    /**
     * PdfNumber.ts class for EJ2-PDF
     */
    
    /**
     * `PdfNumber` class is used to perform number related primitive operations.
     * @private
     */
    export class PdfNumber implements IPdfPrimitive {
        /**
         * Shows the type of object `status` whether it is object registered or other status;
         * @private
         */
        private status5;
        /**
         * Indicates if the object is currently in `saving state or not`.
         * @private
         */
        private isSaving5;
        /**
         * Holds the `index` number of the object.
         * @private
         */
        private index5;
        /**
         * Stores the `int` value.
         * @private
         */
        private value;
        /**
         * Sotres the `position`.
         * @default -1
         * @private
         */
        private position5;
        /**
         * The `integer` value.
         * @private
         */
        private integer;
        /**
         * Initializes a new instance of the `PdfNumber` class.
         * @private
         */
        constructor(value: number);
        /**
         * Gets or sets the `integer` value.
         * @private
         */
        intValue: number;
        /**
         * Gets or sets a value indicating whether this instance `is integer`.
         * @private
         */
        isInteger: boolean;
        /**
         * Gets or sets the `Status` of the specified object.
         * @private
         */
        status: ObjectStatus;
        /**
         * Gets or sets a value indicating whether this document `is saving` or not.
         * @private
         */
        isSaving: boolean;
        /**
         * Gets or sets the `index` value of the specified object.
         * @private
         */
        objectCollectionIndex: number;
        /**
         * Gets or sets the `position` of the object.
         * @private
         */
        position: number;
        /**
         * Returns `cloned object`.
         * @private
         */
        readonly clonedObject: IPdfPrimitive;
        /**
         * `Saves the object`.
         * @private
         */
        save(writer: IPdfWriter): void;
        /**
         * Creates a `copy of PdfNumber`.
         * @private
         */
        clone(crossTable: PdfCrossTable): IPdfPrimitive;
        /**
         * Converts a `float value to a string` using Adobe PDF rules.
         * @private
         */
        static floatToString(number: number): string;
        /**
         * Determines the `minimum of the three values`.
         * @private
         */
        static min(x: number, y: number, z: number): number;
    }
    
    /**
     * PdfReference.ts and PdfReferenceHolder.ts class for EJ2-PDF
     */
    
    /**
     * `PdfReference` class is used to perform reference related primitive operations.
     * @private
     */
    export class PdfReference implements IPdfPrimitive {
        /**
         * Indicates if the object is currently in `saving stat`e or not.
         * @private
         */
        private isSaving3;
        /**
         * Shows the type of object `status` whether it is object registered or other status;
         * @private
         */
        private status3;
        /**
         * Holds the `index` number of the object.
         * @default -1
         * @private
         */
        private index3;
        /**
         * Internal variable to store the `position`.
         * @default -1
         * @private
         */
        private position3;
        /**
         * Holds the `object number`.
         * @default 0
         * @private
         */
        readonly objNumber: number;
        /**
         * Holds the `generation number` of the object.
         * @default 0
         * @private
         */
        readonly genNumber: number;
        /**
         * Gets or sets the `Status` of the specified object.
         * @private
         */
        status: ObjectStatus;
        /**
         * Gets or sets a value indicating whether this document `is saving` or not.
         * @private
         */
        isSaving: boolean;
        /**
         * Gets or sets the `index` value of the specified object.
         * @private
         */
        objectCollectionIndex: number;
        /**
         * Gets or sets the `position` of the object.
         * @private
         */
        position: number;
        /**
         * Returns `cloned object`.
         * @private
         */
        readonly clonedObject: IPdfPrimitive;
        /**
         * `Saves` the object.
         * @private
         */
        save(writer: IPdfWriter): void;
        /**
         * Initialize the `PdfReference` class.
         * @private
         */
        constructor(objNumber: number, genNumber: number);
        /**
         * Initialize the `PdfReference` class.
         * @private
         */
        constructor(objNumber: string, genNumber: string);
        /**
         * Returns a `string` representing the object.
         * @private
         */
        toString(): string;
        /**
         * Creates a `deep copy` of the IPdfPrimitive object.
         * @private
         */
        clone(crossTable: PdfCrossTable): IPdfPrimitive;
    }
    /**
     * `PdfReferenceHolder` class is used to perform reference holder related primitive operations.
     * @private
     */
    export class PdfReferenceHolder implements IPdfPrimitive, IPdfWrapper {
        /**
         * Indicates if the object is currently in `saving state or not`.
         * @private
         */
        private isSaving4;
        /**
         * Shows the type of object `status` whether it is object registered or other status;
         * @private
         */
        private status4;
        /**
         * Holds the `index` number of the object.
         * @default -1
         * @private
         */
        private index4;
        /**
         * Internal variable to store the `position`.
         * @default -1
         * @private
         */
        private position4;
        /**
         * The `object` which the reference is of.
         * @private
         */
        private primitiveObject;
        /**
         * The `reference` to the object, which was read from the PDF document.
         * @private
         */
        private pdfReference;
        /**
         * The `cross-reference table`, which the object is within.
         * @private
         */
        private crossTable;
        /**
         * The `index` of the object within the object collection.
         * @default -1
         * @private
         */
        private objectIndex;
        /**
         * @hidden
         * @private
         */
        private dictionaryProperties;
        /**
         * Gets or sets the `Status` of the specified object.
         * @private
         */
        status: ObjectStatus;
        /**
         * Gets or sets a value indicating whether this document `is saving` or not.
         * @private
         */
        isSaving: boolean;
        /**
         * Gets or sets the `index` value of the specified object.
         * @private
         */
        objectCollectionIndex: number;
        /**
         * Gets or sets the `position` of the object.
         * @private
         */
        position: number;
        /**
         * Returns `cloned object`.
         * @private
         */
        readonly clonedObject: IPdfPrimitive;
        /**
         * Gets the `object` the reference is of.
         * @private
         */
        readonly object: IPdfPrimitive;
        /**
         * Gets the `reference`.
         * @private
         */
        readonly reference: PdfReference;
        /**
         * Gets the `index` of the object.
         * @private
         */
        readonly index: number;
        /**
         * Gets the `element`.
         * @private
         */
        readonly element: IPdfPrimitive;
        /**
         * Initializes the `PdfReferenceHolder` class instance with an object.
         * @private
         */
        constructor(obj1: IPdfWrapper);
        /**
         * Initializes the `PdfReferenceHolder` class instance with an object.
         * @private
         */
        constructor(obj1: IPdfPrimitive);
        /**
         * Initializes the `PdfReferenceHolder` class instance with an object.
         * @private
         */
        constructor(obj1: PdfReference, obj2: PdfCrossTable);
        /**
         * `Writes` a reference into a PDF document.
         * @private
         */
        save(writer: IPdfWriter): void;
        /**
         * Creates a `copy of PdfReferenceHolder`.
         * @private
         */
        clone(crossTable: PdfCrossTable): IPdfPrimitive;
    }
    
    /**
     * PdfStream.ts class for EJ2-PDF
     */
    
    /**
     * `PdfStream` class is used to perform stream related primitive operations.
     * @private
     */
    export class PdfStream extends PdfDictionary {
        /**
         * @hidden
         * @private
         */
        private readonly dicPrefix;
        /**
         * @hidden
         * @private
         */
        private readonly dicSuffix;
        /**
         * @hidden
         * @private
         */
        private dataStream2;
        /**
         * @hidden
         * @private
         */
        private blockEncryption2;
        /**
         * @hidden
         * @private
         */
        private bDecrypted2;
        /**
         * @hidden
         * @private
         */
        private bCompress2;
        /**
         * @hidden
         * @private
         */
        private bEncrypted2;
        /**
         * Internal variable to hold `cloned object`.
         * @private
         */
        private clonedObject2;
        /**
         * @hidden
         * @private
         */
        private bCompress;
        /**
         * Initialize an instance for `PdfStream` class.
         * @private
         */
        constructor();
        /**
         * Initialize an instance for `PdfStream` class.
         * @private
         */
        constructor(dictionary: PdfDictionary, data: string[]);
        /**
         * Gets the `internal` stream.
         * @private
         */
        internalStream: string[];
        /**
         * Gets or sets `compression` flag.
         * @private
         */
        compress: boolean;
        /**
         * Gets or sets the `data`.
         * @private
         */
        data: string[];
        /**
         * `Clear` the internal stream.
         * @private
         */
        clearStream(): void;
        /**
         * `Writes` the specified string.
         * @private
         */
        write(text: string): void;
        /**
         * `Compresses the content` if it's required.
         * @private
         */
        private compressContent(data, writer);
        /**
         * `Adds a filter` to the filter array.
         * @private
         */
        addFilter(filterName: string): void;
        /**
         * `Saves` the object using the specified writer.
         * @private
         */
        save(writer: IPdfWriter): void;
        /**
         * Converts `bytes to string`.
         * @private
         */
        static bytesToString(byteArray: number[]): string;
    }
    
    /**
     * PdfString.ts class for EJ2-PDF
     */
    
    /**
     * `PdfString` class is used to perform string related primitive operations.
     * @private
     */
    export namespace InternalEnum {
        /**
         * public Enum for `ForceEncoding`.
         * @private
         */
        enum ForceEncoding {
            /**
             * Specifies the type of `None`.
             * @private
             */
            None = 0,
            /**
             * Specifies the type of `Ascii`.
             * @private
             */
            Ascii = 1,
            /**
             * Specifies the type of `Unicode`.
             * @private
             */
            Unicode = 2,
        }
    }
    export class PdfString implements IPdfPrimitive {
        /**
         * `General markers` for string.
         * @private
         */
        static readonly stringMark: string;
        /**
         * `Hex markers` for string.
         * @private
         */
        static readonly hexStringMark: string;
        /**
         * Format of password data.
         * @private
         */
        private static readonly hexFormatPattern;
        /**
         * Value of the object.
         * @private
         */
        private stringValue;
        /**
         * The byte data of the string.
         * @private
         */
        private data;
        /**
         * Value indicating whether the string was converted to hex.
         * @default false
         * @private
         */
        private bHex;
        /**
         * Shows the type of object `status` whether it is object registered or other status;
         * @private
         */
        private status1;
        /**
         * Indicates if the object is currently in `saving state or not`.
         * @private
         */
        private isSaving1;
        /**
         * Internal variable to store the `position`.
         * @default -1
         * @private
         */
        private position1;
        /**
         * Internal variable to hold `PdfCrossTable` reference.
         * @private
         */
        private crossTable;
        /**
         * Internal variable to hold `cloned object`.
         * @default null
         * @private
         */
        private clonedObject1;
        /**
         * Indicates whether to check if the value `has unicode characters`.
         * @private
         */
        private bConverted;
        /**
         * Indicates whether we should convert `data to Unicode`.
         * @private
         */
        private bForceEncoding;
        /**
         * `Shows` if the data of the stream was decrypted.
         * @default false
         * @private
         */
        private bDecrypted;
        /**
         * Holds the `index` number of the object.
         * @private
         */
        private index1;
        /**
         * Shows if the data of the stream `was decrypted`.
         * @default false
         * @private
         */
        private isParentDecrypted;
        /**
         * Gets a value indicating whether the object is `packed or not`.
         * @default false
         * @private
         */
        private isPacked;
        /**
         * @hidden
         * @private
         */
        isFormField: boolean;
        /**
         * @hidden
         * @private
         */
        isColorSpace: boolean;
        /**
         * @hidden
         * @private
         */
        isHexString: boolean;
        /**
         * @hidden
         * @private
         */
        private encodedBytes;
        /**
         * Initializes a new instance of the `PdfString` class.
         * @private
         */
        constructor();
        /**
         * Initializes a new instance of the `PdfString` class.
         * @private
         */
        constructor(value: string);
        /**
         * Gets a value indicating whether string is in `hex`.
         * @private
         */
        readonly hex: boolean;
        /**
         * Gets or sets string `value` of the object.
         * @private
         */
        value: string;
        /**
         * Gets or sets the `Status` of the specified object.
         * @private
         */
        status: ObjectStatus;
        /**
         * Gets or sets a value indicating whether this document `is saving` or not.
         * @private
         */
        isSaving: boolean;
        /**
         * Gets or sets the `index` value of the specified object.
         * @private
         */
        objectCollectionIndex: number;
        /**
         * Returns `cloned object`.
         * @private
         */
        readonly clonedObject: IPdfPrimitive;
        /**
         * Gets or sets the `position` of the object.
         * @private
         */
        position: number;
        /**
         * Returns `PdfCrossTable` associated with the object.
         * @private
         */
        readonly CrossTable: PdfCrossTable;
        /**
         * Converts `bytes to string using hex format` for representing string.
         * @private
         */
        static bytesToHex(bytes: number[]): string;
        /**
         * `Saves` the object using the specified writer.
         * @private
         */
        save(writer: IPdfWriter): void;
        /**
         * Creates a `copy of PdfString`.
         * @private
         */
        clone(crossTable: PdfCrossTable): IPdfPrimitive;
    }
    
    /**
     * `PdfGridCell.ts` class for EJ2-PDF
     */
    
    /**
     * `PdfGridCell` class represents the schema of a cell in a 'PdfGrid'.
     */
    export class PdfGridCell {
        /**
         * The `row span`.
         * @private
         */
        private gridRowSpan;
        /**
         * The `column span`.
         * @private
         */
        private colSpan;
        /**
         * Specifies the current `row`.
         * @private
         */
        private gridRow;
        /**
         * The actual `value` of the cell.
         * @private
         */
        private objectValue;
        /**
         * Current cell `style`.
         * @private
         */
        private cellStyle;
        /**
         * `Width` of the cell.
         * @default 0
         * @private
         */
        private cellWidth;
        /**
         * `Height` of the cell.
         * @default 0
         * @private
         */
        private cellHeight;
        /**
         * The `remaining string`.
         * @private
         */
        private remaining;
        /**
         * Specifies weather the `cell is drawn`.
         * @default true
         * @private
         */
        private finsh;
        /**
         * `StringFormat` of the cell.
         * @private
         */
        private format;
        /**
         * The `remaining height` of row span.
         * @default 0
         * @private
         */
        rowSpanRemainingHeight: number;
        private internalIsCellMergeContinue;
        private internalIsRowMergeContinue;
        private internalIsCellMergeStart;
        private internalIsRowMergeStart;
        /**
         * Initializes a new instance of the `PdfGridCell` class.
         * @private
         */
        constructor();
        /**
         * Initializes a new instance of the `PdfGridCell` class.
         * @private
         */
        constructor(row: PdfGridRow);
        isCellMergeContinue: boolean;
        isRowMergeContinue: boolean;
        isCellMergeStart: boolean;
        isRowMergeStart: boolean;
        /**
         * Gets or sets the `remaining string` after the row split between pages.
         * @private
         */
        remainingString: string;
        /**
         * Gets or sets the `string format`.
         * @private
         */
        stringFormat: PdfStringFormat;
        /**
         * Gets or sets the parent `row`.
         * @private
         */
        row: PdfGridRow;
        /**
         * Gets or sets the `value` of the cell.
         * @private
         */
        value: Object;
        /**
         * Gets or sets a value that indicates the total number of rows that cell `spans` within a PdfGrid.
         * @private
         */
        rowSpan: number;
        /**
         * Gets or sets the cell `style`.
         * @private
         */
        style: PdfGridCellStyle;
        /**
         * Gets the `height` of the PdfGrid cell.[Read-Only].
         * @private
         */
        height: number;
        /**
         * Gets or sets a value that indicates the total number of columns that cell `spans` within a PdfGrid.
         * @private
         */
        columnSpan: number;
        /**
         * Gets the `width` of the PdfGrid cell.[Read-Only].
         * @private
         */
        width: number;
        /**
         * `Calculates the width`.
         * @private
         */
        private measureWidth();
        /**
         * Draw the `cell background`.
         * @private
         */
        drawCellBackground(graphics: PdfGraphics, bounds: RectangleF): void;
        /**
         * `Adjusts the text layout area`.
         * @private
         */
        private adjustContentLayoutArea(bounds);
        /**
         * `Draws` the specified graphics.
         * @private
         */
        draw(graphics: PdfGraphics, bounds: RectangleF, cancelSubsequentSpans: boolean): PdfStringLayoutResult;
        /**
         * Draws the `cell border` constructed by drawing lines.
         * @private
         */
        drawCellBorders(graphics: PdfGraphics, bounds: RectangleF): void;
        /**
         * `Adjusts the outer layout area`.
         * @private
         */
        private adjustOuterLayoutArea(bounds, g);
        /**
         * Gets the `text font`.
         * @private
         */
        private getTextFont();
        /**
         * Gets the `text brush`.
         * @private
         */
        private getTextBrush();
        /**
         * Gets the `text pen`.
         * @private
         */
        private getTextPen();
        /**
         * Gets the `background brush`.
         * @private
         */
        private getBackgroundBrush();
        /**
         * Gets the current `StringFormat`.
         * @private
         */
        private getStringFormat();
        /**
         * Calculates the `height`.
         * @private
         */
        measureHeight(): number;
        /**
         * return the calculated `width` of the cell.
         * @private
         */
        private calculateWidth();
    }
    /**
     * `PdfGridCellCollection` class provides access to an ordered,
     * strongly typed collection of 'PdfGridCell' objects.
     * @private
     */
    export class PdfGridCellCollection {
        /**
         * @hidden
         * @private
         */
        private gridRow;
        /**
         * @hidden
         * @private
         */
        private cells;
        /**
         * Initializes a new instance of the `PdfGridCellCollection` class with the row.
         * @private
         */
        constructor(row: PdfGridRow);
        /**
         * Gets the current `cell`.
         * @private
         */
        getCell(index: number): PdfGridCell;
        /**
         * Gets the cells `count`.[Read-Only].
         * @private
         */
        readonly count: number;
        /**
         * `Adds` this instance.
         * @private
         */
        add(): PdfGridCell;
        /**
         * `Adds` this instance.
         * @private
         */
        add(cell: PdfGridCell): void;
        /**
         * Returns the `index of` a particular cell in the collection.
         * @private
         */
        indexOf(cell: PdfGridCell): number;
    }
    
    /**
     * `PdfGridColumn.ts` class for EJ2-PDF
     */
    
    /**
     * `PdfGridColumn` class represents the schema of a column in a 'PdfGrid'.
     */
    export class PdfGridColumn {
        /**
         * The current `grid`.
         * @private
         */
        private grid;
        /**
         * The `width` of the column.
         * @default 0
         * @private
         */
        columnWidth: number;
        /**
         * Represent the `custom width` of the column.
         * @private
         */
        isCustomWidth: boolean;
        /**
         * The `string format` of the column.
         * @private
         */
        private stringFormat;
        /**
         * Initializes a new instance of the `PdfGridColumn` class with the parent grid.
         * @private
         */
        constructor(grid: PdfGrid);
        /**
         * Gets or sets the `width` of the 'PdfGridColumn'.
         * @private
         */
        width: number;
        /**
         * Gets or sets the information about the text `formatting`.
         * @private
         */
        format: PdfStringFormat;
    }
    /**
     * `PdfGridColumnCollection` class provides access to an ordered,
     * strongly typed collection of 'PdfGridColumn' objects.
     * @private
     */
    export class PdfGridColumnCollection {
        /**
         * @hidden
         * @private
         */
        private grid;
        /**
         * @hidden
         * @private
         */
        private internalColumns;
        /**
         * @hidden
         * @private
         */
        private columnWidth;
        /**
         * Initializes a new instance of the `PdfGridColumnCollection` class with the parent grid.
         * @private
         */
        constructor(grid: PdfGrid);
        /**
         * `Add` a new column to the 'PdfGrid'.
         * @private
         */
        add(count: number): void;
        /**
         * Gets the `number of columns` in the 'PdfGrid'.[Read-Only].
         * @private
         */
        readonly count: number;
        /**
         * Gets the `widths`.
         * @private
         */
        readonly width: number;
        /**
         * Gets the `array of PdfGridColumn`.[Read-Only]
         * @private
         */
        readonly columns: PdfGridColumn[];
        /**
         * Gets the `PdfGridColumn` from the specified index.[Read-Only]
         * @private
         */
        getColumn(index: number): PdfGridColumn;
        /**
         * `Calculates the column widths`.
         * @private
         */
        measureColumnsWidth(): number;
        /**
         * Gets the `widths of the columns`.
         * @private
         */
        getDefaultWidths(totalWidth: number): number[];
    }
    
    /**
     * PdfGridRow.ts class for EJ2-PDF
     */
    
    /**
     * `PdfGridRow` class provides customization of the settings for the particular row.
     */
    export class PdfGridRow {
        /**
         * `Cell collecton` of the current row..
         * @private
         */
        private gridCells;
        /**
         * Stores the current `grid`.
         * @private
         */
        private pdfGrid;
        /**
         * The grid row `style`.
         * @private
         */
        private rowStyle;
        /**
         * Stores the row `break height`.
         * @private
         */
        private gridRowBreakHeight;
        /**
         * Stores the index of the overflowing row.
         * @private
         */
        private gridRowOverflowIndex;
        /**
         * The `height` of the row.
         * @private
         */
        private rowHeight;
        /**
         * Check whether the row height `is set explicitly`.
         * @default false
         * @private
         */
        isRowHeightSet: boolean;
        /**
         * Checks whether the `columns span is exist or not`.
         * @private
         */
        private bColumnSpanExists;
        /**
         * Check weather the row merge `is completed` or not.
         * @default true
         * @private
         */
        private isRowMergeComplete;
        /**
         * Checks whether the `row span is exist or not`.
         * @private
         */
        private bRowSpanExists;
        /**
         * Initializes a new instance of the `PdfGridRow` class with the parent grid.
         * @private
         */
        constructor(grid: PdfGrid);
        /**
         * Gets or sets a value indicating [`row span exists`].
         * @private
         */
        rowSpanExists: boolean;
        /**
         * Gets the `cells` from the selected row.[Read-Only].
         * @private
         */
        readonly cells: PdfGridCellCollection;
        /**
         * Gets or sets the parent `grid`.
         * @private
         */
        grid: PdfGrid;
        /**
         * Gets or sets the row `style`.
         * @private
         */
        style: PdfGridRowStyle;
        /**
         * `Height` of the row yet to be drawn after split.
         * @private
         */
        rowBreakHeight: number;
        rowOverflowIndex: number;
        /**
         * Gets or sets the `height` of the row.
         * @private
         */
        height: number;
        /**
         * Gets or sets a value indicating [`column span exists`].
         * @private
         */
        columnSpanExists: boolean;
        /**
         * Check whether the Row `has row span or row merge continue`.
         * @private
         */
        rowMergeComplete: boolean;
        /**
         * Returns `index` of the row.
         * @private
         */
        readonly rowIndex: number;
        /**
         * `Calculates the height`.
         * @private
         */
        private measureHeight();
    }
    /**
     * `PdfGridRowCollection` class provides access to an ordered, strongly typed collection of 'PdfGridRow' objects.
     * @private
     */
    export class PdfGridRowCollection {
        /**
         * @hidden
         * @private
         */
        private grid;
        /**
         * The row collection of the `grid`.
         * @private
         */
        private rows;
        /**
         * Initializes a new instance of the `PdfGridRowCollection` class with the parent grid.
         * @private
         */
        constructor(grid: PdfGrid);
        /**
         * Gets the number of header in the `PdfGrid`.[Read-Only].
         * @private
         */
        readonly count: number;
        /**
         * Return the row collection of the `grid`.
         * @private
         */
        readonly rowCollection: PdfGridRow[];
        /**
         * `Adds` the specified row.
         * @private
         */
        addRow(): PdfGridRow;
        /**
         * `Adds` the specified row.
         * @private
         */
        addRow(row: PdfGridRow): void;
        /**
         * Return the row by index.
         * @private
         */
        getRow(index: number): PdfGridRow;
    }
    /**
     * `PdfGridHeaderCollection` class provides customization of the settings for the header.
     * @private
     */
    export class PdfGridHeaderCollection {
        /**
         * The `grid`.
         * @private
         */
        private grid;
        /**
         * The array to store the `rows` of the grid header.
         * @private
         */
        private rows;
        /**
         * Initializes a new instance of the `PdfGridHeaderCollection` class with the parent grid.
         * @private
         */
        constructor(grid: PdfGrid);
        /**
         * Gets a 'PdfGridRow' object that represents the `header` row in a 'PdfGridHeaderCollection' control.[Read-Only].
         * @private
         */
        getHeader(index: number): PdfGridRow;
        /**
         * Gets the `number of header` in the 'PdfGrid'.[Read-Only]
         * @private
         */
        readonly count: number;
        /**
         * `Adds` the specified row.
         * @private
         */
        add(row: PdfGridRow): void;
        /**
         * `Adds` the specified row.
         * @private
         */
        add(count: number): PdfGridRow[];
        indexOf(row: PdfGridRow): number;
    }
    
    /**
     * PdfGrid.ts class for EJ2-PDF
     */
    
    /**
     * `PdfGridLayoutFormat` class represents a flexible grid that consists of columns and rows.
     */
    export class PdfGridLayoutFormat extends PdfLayoutFormat {
        /**
         * Initializes a new instance of the `PdfGridLayoutFormat` class.
         * @private
         */
        constructor();
        /**
         * Initializes a new instance of the `PdfGridLayoutFormat` class.
         * @private
         */
        constructor(baseFormat: PdfLayoutFormat);
    }
    export class PdfGrid extends PdfLayoutElement {
        /**
         * @hidden
         * @private
         */
        private gridColumns;
        /**
         * @hidden
         * @private
         */
        private gridRows;
        /**
         * @hidden
         * @private
         */
        private gridHeaders;
        /**
         * @hidden
         * @private
         */
        private gridInitialWidth;
        /**
         * @hidden
         * @private
         */
        isComplete: boolean;
        /**
         * @hidden
         * @private
         */
        private gridSize;
        /**
         * @hidden
         * @private
         */
        private layoutFormat;
        /**
         * @hidden
         * @private
         */
        private gridLocation;
        /**
         * @hidden
         * @private
         */
        private gridStyle;
        /**
         * @hidden
         * @private
         */
        private pageWidth;
        /**
         * Check weather it is `child grid or not`.
         * @private
         */
        private childGrid;
        /**
         * @hidden
         * @private
         */
        rowLayoutBoundsWidth: number;
        /**
         * @hidden
         * @private
         */
        isRearranged: boolean;
        /**
         * @hidden
         * @private
         */
        private bRepeatHeader;
        /**
         * @hidden
         * @private
         */
        private pageBounds;
        /**
         * @hidden
         * @private
         */
        private currentPage;
        /**
         * @hidden
         * @private
         */
        private currentPageBounds;
        /**
         * @hidden
         * @private
         */
        private currentBounds;
        /**
         * @hidden
         * @private
         */
        private currentGraphics;
        /**
         * @hidden
         * @private
         */
        private listOfNavigatePages;
        /**
         * @hidden
         * @private
         */
        private startLocation;
        /**
         * @hidden
         * @private
         */
        private hType;
        /**
         * @hidden
         * @private
         */
        private flag;
        /**
         * @hidden
         * @private
         */
        private columnRanges;
        /**
         * @hidden
         * @private
         */
        private cellStartIndex;
        /**
         * @hidden
         * @private
         */
        private cellEndIndex;
        /**
         * @hidden
         * @private
         */
        private currentRowIndex;
        /**
         * @hidden
         * @private
         */
        static repeatRowIndex: number;
        /**
         * @hidden
         * @private
         */
        private isChanged;
        /**
         * @hidden
         * @private
         */
        private currentLocation;
        /**
         * @hidden
         * @private
         */
        private breakRow;
        /**
         * @hidden
         * @private
         */
        private rowBreakPageHeightCellIndex;
        /**
         * The event raised on `starting cell drawing`.
         * @event
         * @private
         */
        beginCellDraw: Function;
        /**
         * The event raised on `ending cell drawing`.
         * @event
         * @private
         */
        endCellDraw: Function;
        /**
         * The event raised on `begin cell lay outing`.
         * @event
         * @private
         */
        beginPageLayout: Function;
        /**
         * The event raised on `end cell lay outing`.
         * @event
         * @private
         */
        endPageLayout: Function;
        /**
         * Initialize a new instance for `PdfGrid` class.
         * @private
         */
        constructor();
        /**
         * Gets a value indicating whether the `start cell layout event` should be raised.
         * @private
         */
        readonly raiseBeginCellDraw: boolean;
        /**
         * Gets a value indicating whether the `end cell layout event` should be raised.
         * @private
         */
        readonly raiseEndCellDraw: boolean;
        /**
         * Gets a value indicating whether the `start page layout event` should be raised.
         * @private
         */
        readonly raiseBeginPageLayout: boolean;
        /**
         * Gets a value indicating whether the `ending page layout event` should be raised.
         * @private
         */
        readonly raiseEndPageLayout: boolean;
        /**
         * Gets or sets a value indicating whether to `repeat header`.
         * @private
         */
        repeatHeader: boolean;
        /**
         * Gets or sets a value indicating whether to split or cut rows that `overflow a page`.
         * @private
         */
        allowRowBreakAcrossPages: boolean;
        /**
         * Gets the `column` collection of the PdfGrid.[Read-Only]
         * @private
         */
        readonly columns: PdfGridColumnCollection;
        /**
         * Gets the `row` collection from the PdfGrid.[Read-Only]
         * @private
         */
        readonly rows: PdfGridRowCollection;
        /**
         * Gets the `headers` collection from the PdfGrid.[Read-Only]
         * @private
         */
        readonly headers: PdfGridHeaderCollection;
        /**
         * Indicating `initial width` of the page.
         * @private
         */
        initialWidth: number;
        /**
         * Gets or sets the `grid style`.
         * @private
         */
        style: PdfGridStyle;
        /**
         * Gets a value indicating whether the grid column width is considered to be `page width`.
         * @private
         */
        isPageWidth: boolean;
        /**
         * Gets or set if grid `is nested grid`.
         * @private
         */
        isChildGrid: boolean;
        /**
         * Gets the `size`.
         * @private
         */
        size: SizeF;
        /**
         * `Draws` the element on the page with the specified page and 'PointF' class
         * @private
         */
        draw(page: PdfPage, location: PointF): PdfLayoutResult;
        /**
         * `Draws` the element on the page with the specified page and pair of coordinates
         * @private
         */
        draw(page: PdfPage, x: number, y: number): PdfLayoutResult;
        /**
         * `Draws` the element on the page with the specified page and 'RectangleF' class
         * @private
         */
        draw(page: PdfPage, layoutRectangle: RectangleF): PdfLayoutResult;
        /**
         * `Draws` the element on the page with the specified page, 'PointF' class and layout format
         * @private
         */
        draw(page: PdfPage, location: PointF, format: PdfLayoutFormat): PdfLayoutResult;
        /**
         * `Draws` the element on the page with the specified page, pair of coordinates and layout format
         * @private
         */
        draw(page: PdfPage, x: number, y: number, format: PdfLayoutFormat): PdfLayoutResult;
        /**
         * `Draws` the element on the page.
         * @private
         */
        draw(page: PdfPage, layoutRectangle: RectangleF, embedFonts: boolean): PdfLayoutResult;
        /**
         * `Draws` the element on the page with the specified page, 'RectangleF' class and layout format
         * @private
         */
        draw(page: PdfPage, layoutRectangle: RectangleF, format: PdfLayoutFormat): PdfLayoutResult;
        /**
         * `measures` this instance.
         * @private
         */
        private measure();
        /**
         * `Layouts` the specified graphics.
         * @private
         */
        protected layout(param: PdfLayoutParams): PdfLayoutResult;
        /**
         * `Layouts` the specified graphics.
         * @private
         */
        protected layout(param: PdfLayoutParams, isGridLayouter: boolean): PdfLayoutResult;
        setSpan(): void;
        /**
         * Gets the `format`.
         * @private
         */
        private getFormat(format);
        /**
         * `Layouts` the element.
         * @private
         */
        private layoutInternal(param);
        /**
         * Calculates the `width` of the columns.
         * @private
         */
        measureColumnsWidth(): void;
        /**
         * Calculates the `width` of the columns.
         * @private
         */
        measureColumnsWidth(bounds: RectangleF): void;
        /**
         * `Determines the column draw ranges`.
         * @private
         */
        private determineColumnDrawRanges();
        /**
         * `Layouts the on page`.
         * @private
         */
        private layoutOnPage(param);
        /**
         * Gets the `next page`.
         * @private
         */
        getNextPage(format: PdfLayoutFormat): PdfPage;
        /**
         * Gets the `layout result`.
         * @private
         */
        private getLayoutResult();
        /**
         * `Recalculate row height` for the split cell to be drawn.
         * @private
         */
        private ReCalculateHeight(row, height);
        /**
         * `Raises BeforePageLayout event`.
         * @private
         */
        private raiseBeforePageLayout(currentPage, currentBounds, currentRow);
        /**
         * `Raises PageLayout event` if needed.
         * @private
         */
        private raisePageLayouted(result);
        /**
         * `Draws row`
         * @private
         */
        private drawRow(row);
        /**
         * `Draws row`
         * @private
         */
        private drawRow(row, result, height);
        /**
         * Checks if the given format `is default format` or not.
         * @private
         */
        private CheckIfDefaultFormat(format);
        /**
         * `Raises BeforeCellDraw event`.
         * @private
         */
        private RaiseBeforeCellDraw(graphics, rowIndex, cellIndex, bounds, value, style);
        /**
         * `Raises AfterCellDraw event`.
         * @private
         */
        private RaiseAfterCellDraw(graphics, rowIndex, cellIndex, bounds, value, cellstyle);
        /**
         * `Rearranges the pages`.
         * @private
         */
        private reArrangePages(layoutedPages);
    }
    /**
     * `GridCellEventArgs` class is alternate for grid events.
     */
    export abstract class GridCellEventArgs {
        /**
         * @hidden
         * @private
         */
        private gridRowIndex;
        /**
         * @hidden
         * @private
         */
        private gridCellIndex;
        /**
         * @hidden
         * @private
         */
        private internalValue;
        /**
         * @hidden
         * @private
         */
        private gridBounds;
        /**
         * @hidden
         * @private
         */
        private pdfGraphics;
        /**
         * Gets the value of current `row index`.
         * @private
         */
        readonly rowIndex: number;
        /**
         * Gets the value of current `cell index`.
         * @private
         */
        readonly cellIndex: number;
        /**
         * Gets the actual `value` of current cell.
         * @private
         */
        readonly value: string;
        /**
         * Gets the `bounds` of current cell.
         * @private
         */
        readonly bounds: RectangleF;
        /**
         * Gets the instance of `current graphics`.
         * @private
         */
        readonly graphics: PdfGraphics;
        /**
         * Initialize a new instance for `GridCellEventArgs` class.
         * @private
         */
        constructor(graphics: PdfGraphics, rowIndex: number, cellIndex: number, bounds: RectangleF, value: string);
    }
    /**
     * `PdfGridBeginCellDrawEventArgs` class is alternate for begin cell draw events.
     */
    export class PdfGridBeginCellDrawEventArgs extends GridCellEventArgs {
        /**
         * @hidden
         * @private
         */
        private bSkip;
        /**
         * @hidden
         * @private
         */
        private cellStyle;
        /**
         * Gets or sets a value indicating whether the value of this cell should be `skipped`.
         * @private
         */
        skip: boolean;
        /**
         * Gets or sets a `style` value of the cell.
         * @private
         */
        style: PdfGridCellStyle;
        /**
         * Initializes a new instance of the `StartCellLayoutEventArgs` class.
         * @private
         */
        constructor(graphics: PdfGraphics, rowIndex: number, cellIndex: number, bounds: RectangleF, value: string, style: PdfGridCellStyle);
    }
    /**
     * `PdfGridEndCellDrawEventArgs` class is alternate for end cell draw events.
     */
    export class PdfGridEndCellDrawEventArgs extends GridCellEventArgs {
        /**
         * @hidden
         * @private
         */
        private cellStyle;
        /**
         * Get the `PdfGridCellStyle`.
         * @private
         */
        readonly style: PdfGridCellStyle;
        /**
         * Initializes a new instance of the `PdfGridEndCellLayoutEventArgs` class.
         * @private
         */
        constructor(graphics: PdfGraphics, rowIndex: number, cellIndex: number, bounds: RectangleF, value: string, style: PdfGridCellStyle);
    }
    /**
     * `PdfGridCancelEventArgs` class is alternate for cancel events.
     */
    export class PdfCancelEventArgs {
        /**
         * @hidden
         * @private
         */
        private isCancel;
        /**
         * Gets and Sets the value of `cancel`.
         * @private
         */
        cancel: boolean;
    }
    /**
     * `BeginPageLayoutEventArgs` class is alternate for begin page layout events.
     */
    export class BeginPageLayoutEventArgs extends PdfCancelEventArgs {
        /**
         * The `bounds` of the lay outing on the page.
         * @private
         */
        private cellBounds;
        /**
         * `Page` where the lay outing should start.
         * @private
         */
        private pdfPage;
        /**
         * Gets or sets value that indicates the lay outing `bounds` on the page.
         * @private
         */
        bounds: RectangleF;
        /**
         * Gets the `page` where the lay outing should start.
         * @private
         */
        readonly page: PdfPage;
        /**
         * Initializes a new instance of the `BeginPageLayoutEventArgs` class with the specified rectangle and page.
         * @private
         */
        constructor(bounds: RectangleF, page: PdfPage);
    }
    /**
     * `EndPageLayoutEventArgs` class is alternate for end page layout events.
     */
    export class EndPageLayoutEventArgs extends PdfCancelEventArgs {
        /**
         * `Layout result`.
         * @private
         */
        private layoutResult;
        /**
         * The `next page` for lay outing.
         * @private
         */
        private nextPdfPage;
        /**
         * Gets the lay outing `result` of the page.
         * @private
         */
        readonly result: PdfLayoutResult;
        /**
         * Gets or sets a value indicating the `next page` where the element should be layout.
         * @private
         */
        nextPage: PdfPage;
        /**
         * Initializes a new instance of the `EndPageLayoutEventArgs` class. with the specified 'PdfLayoutResult'.
         * @private
         */
        constructor(result: PdfLayoutResult);
    }
    /**
     * `PdfGridBeginPageLayoutEventArgs` class is alternate for begin page layout events.
     */
    export class PdfGridBeginPageLayoutEventArgs extends BeginPageLayoutEventArgs {
        /**
         * @hidden
         * @private
         */
        private startRow;
        /**
         * Gets the `start row index`.
         * @private
         */
        readonly startRowIndex: number;
        /**
         * Initialize a new instance of `PdfGridBeginPageLayoutEventArgs` class.
         * @private
         */
        constructor(bounds: RectangleF, page: PdfPage, startRow: number);
    }
    /**
     * `PdfGridEndPageLayoutEventArgs` class is alternate for begin page layout events.
     */
    export class PdfGridEndPageLayoutEventArgs extends EndPageLayoutEventArgs {
        /**
         * Initialize a new instance of `PdfGridEndPageLayoutEventArgs` class.
         * @private
         */
        constructor(result: PdfLayoutResult);
    }
    /**
     * `RowLayoutResult` class to store layout result of rows.
     */
    export class RowLayoutResult {
        /**
         * @hidden
         * @private
         */
        private bIsFinished;
        /**
         * @hidden
         * @private
         */
        private layoutedBounds;
        /**
         * Gets or sets a value indicating whether this instance `is finish`.
         * @private
         */
        isFinish: boolean;
        /**
         * Gets or sets the `bounds`.
         * @private
         */
        bounds: RectangleF;
        /**
         * Initializes a new instance of the `RowLayoutResult` class.
         * @private
         */
        constructor();
    }
    /**
     * `PdfGridLayoutResult` class represents the results of the PdfGrid including bounds and resultant page.
     */
    export class PdfGridLayoutResult extends PdfLayoutResult {
        /**
         * Initializes a new instance of the `PdfGridLayoutResult` class with the current page and bounds.
         * @private
         */
        constructor(page: PdfPage, bounds: RectangleF);
    }
    
    /**
     * PdfBorders.ts class for EJ2-PDF
     */
    
    /**
     * `PdfBorders` class used represents the cell border of the PDF grid.
     */
    export class PdfBorders {
        /**
         * The `left` border.
         * @private
         */
        private leftPen;
        /**
         * The `right` border.
         * @private
         */
        private rightPen;
        /**
         * The `top` border.
         * @private
         */
        private topPen;
        /**
         * The `bottom` border.
         * @private
         */
        private bottomPen;
        /**
         * Gets or sets the `Left`.
         * @private
         */
        left: PdfPen;
        /**
         * Gets or sets the `Right`.
         * @private
         */
        right: PdfPen;
        /**
         * Gets or sets the `Top`.
         * @private
         */
        top: PdfPen;
        /**
         * Gets or sets the `Bottom`.
         * @private
         */
        bottom: PdfPen;
        /**
         * sets the `All`.
         * @private
         */
        all: PdfPen;
        /**
         * Gets a value indicating whether this instance `is all`.
         * @private
         */
        readonly isAll: boolean;
        /**
         * Gets the `default`.
         * @private
         */
        static readonly default: PdfBorders;
        /**
         * Create a new instance for `PdfBorders` class.
         * @private
         */
        constructor();
    }
    export class PdfPaddings {
        /**
         * The `left` padding.
         * @private
         */
        private leftPad;
        /**
         * The `right` padding.
         * @private
         */
        private rightPad;
        /**
         * The `top` padding.
         * @private
         */
        private topPad;
        /**
         * The `bottom` padding.
         * @private
         */
        private bottomPad;
        /**
         * Gets or sets the `left` value of the edge
         * @private
         */
        left: number;
        /**
         * Gets or sets the `right` value of the edge.
         * @private
         */
        right: number;
        /**
         * Gets or sets the `top` value of the edge
         * @private
         */
        top: number;
        /**
         * Gets or sets the `bottom` value of the edge.
         * @private
         */
        bottom: number;
        /**
         * Sets value to all sides `left,right,top and bottom`.s
         * @private
         */
        all: number;
        /**
         * Initializes a new instance of the `PdfPaddings` class.
         * @private
         */
        constructor();
        /**
         * Initializes a new instance of the `PdfPaddings` class.
         * @private
         */
        constructor(left: number, right: number, top: number, bottom: number);
    }
    
    /**
     * PdfGridStyleBase.ts class for EJ2-PDF
     */
    
    /**
     * Base class for the `grid style`,
     */
    export abstract class PdfGridStyleBase {
        /**
         * @hidden
         * @private
         */
        private gridBackgroundBrush;
        /**
         * @hidden
         * @private
         */
        private gridTextBrush;
        /**
         * @hidden
         * @private
         */
        private gridTextPen;
        /**
         * @hidden
         * @private
         */
        private gridFont;
        /**
         * Gets or sets the `background brush`.
         * @private
         */
        backgroundBrush: PdfBrush;
        /**
         * Gets or sets the `text brush`.
         * @private
         */
        textBrush: PdfBrush;
        /**
         * Gets or sets the `text pen`.
         * @private
         */
        textPen: PdfPen;
        /**
         * Gets or sets the `font`.
         * @private
         */
        font: PdfFont;
    }
    /**
     * `PdfGridStyle` class provides customization of the appearance for the 'PdfGrid'.
     */
    export class PdfGridStyle extends PdfGridStyleBase {
        /**
         * @hidden
         * @private
         */
        private gridBorderOverlapStyle;
        /**
         * @hidden
         * @private
         */
        private gridHorizontalOverflowType;
        /**
         * @hidden
         * @private
         */
        private bAllowHorizontalOverflow;
        /**
         * @hidden
         * @private
         */
        private gridCellPadding;
        /**
         * @hidden
         * @private
         */
        private gridCellSpacing;
        /**
         * Initialize a new instance for `PdfGridStyle` class.
         * @private
         */
        constructor();
        /**
         * Gets or sets the `cell spacing` of the 'PdfGrid'.
         * @private
         */
        cellSpacing: number;
        /**
         * Gets or sets the type of the `horizontal overflow` of the 'PdfGrid'.
         * @private
         */
        horizontalOverflowType: PdfHorizontalOverflowType;
        /**
         * Gets or sets a value indicating whether to `allow horizontal overflow`.
         * @private
         */
        allowHorizontalOverflow: boolean;
        /**
         * Gets or sets the `cell padding`.
         * @private
         */
        cellPadding: PdfPaddings;
        /**
         * Gets or sets the `border overlap style` of the 'PdfGrid'.
         * @private
         */
        borderOverlapStyle: PdfBorderOverlapStyle;
    }
    /**
     * `PdfGridCellStyle` class provides customization of the appearance for the 'PdfGridCell'.
     */
    export class PdfGridCellStyle extends PdfGridStyleBase {
        /**
         * @hidden
         * @private
         */
        private gridCellBorders;
        /**
         * @hidden
         * @private
         */
        private gridCellPadding;
        /**
         * @hidden
         * @private
         */
        private format;
        /**
         * Gets the `string format` of the 'PdfGridCell'.
         * @private
         */
        stringFormat: PdfStringFormat;
        /**
         * Gets or sets the `border` of the 'PdfGridCell'.
         * @private
         */
        borders: PdfBorders;
        /**
         * Gets or sets the `cell padding`.
         * @private
         */
        cellPadding: PdfPaddings;
        /**
         * Initializes a new instance of the `PdfGridCellStyle` class.
         * @private
         */
        constructor();
    }
    /**
     * `PdfGridRowStyle` class provides customization of the appearance for the `PdfGridRow`.
     */
    export class PdfGridRowStyle {
        /**
         * @hidden
         * @private
         */
        private gridRowBackgroundBrush;
        /**
         * @hidden
         * @private
         */
        private gridRowTextBrush;
        /**
         * @hidden
         * @private
         */
        private gridRowTextPen;
        /**
         * @hidden
         * @private
         */
        private gridRowFont;
        /**
         * Specifies the `border` value of the current row.
         * @private
         */
        private gridRowBorder;
        /**
         * Specifies the `parent row` of the current object.
         * @private
         */
        private parent;
        /**
         * Determine the value of the border is changed or not.
         * @private
         */
        /**
         * Gets or sets the `background brush`.
         * @private
         */
        readonly backgroundBrush: PdfBrush;
        setBackgroundBrush(value: PdfBrush): void;
        /**
         * Gets or sets the `text brush`.
         * @private
         */
        readonly textBrush: PdfBrush;
        setTextBrush(value: PdfBrush): void;
        /**
         * Gets or sets the `text pen`.
         * @private
         */
        readonly textPen: PdfPen;
        setTextPen(value: PdfPen): void;
        /**
         * Gets or sets the `font`.
         * @private
         */
        readonly font: PdfFont;
        setFont(value: PdfFont): void;
        /**
         * Gets or sets the `border` of the current row.
         * @private
         */
        readonly border: PdfBorders;
        setBorder(value: PdfBorders): void;
        /**
         * sets the `parent row` of the current object.
         * @private
         */
        setParent(parent: PdfGridRow): void;
        /**
         * Initializes a new instance of the `PdfGridRowStyle` class.
         * @private
         */
        constructor();
    }
    /**
     * public Enum for `PdfHorizontalOverflowType`.
     * @private
     */
    export enum PdfHorizontalOverflowType {
        /**
         * Specifies the type of `NextPage`.
         * @private
         */
        NextPage = 0,
        /**
         * Specifies the type of `LastPage`.
         * @private
         */
        LastPage = 1,
    }
    
    /**
     * public Enum for `PdfBorderOverlapStyle`.
     * @private
     */
    export enum PdfBorderOverlapStyle {
        /**
         * Specifies the type of `Overlap`.
         * @private
         */
        Overlap = 0,
        /**
         * Specifies the type of `Inside`.
         * @private
         */
        Inside = 1,
    }
    
    /**
     * `IPdfCache.ts` interface for EJ2-PDF
     * Interface of the objects that support caching of their internals.
     * @private
     */
    
    export interface IPdfCache {
        /**
         * Checks whether the object `is similar to another object`.
         * @private
         */
        equalsTo(obj: IPdfCache): boolean;
        /**
         * Returns `internals of the object`.
         * @private
         */
        getInternals(): IPdfPrimitive;
        /**
         * Sets `internals of the object`.
         * @private
         */
        setInternals(internals: IPdfPrimitive): void;
    }
    
    /**
     * `IPdfChangable.ts` interface for EJ2-PDF
     * Interface of the objects that support Changable of their internals.
     * @private
     */
    export interface IPdfChangable {
        /**
         * Gets a value indicating whether this 'IPdfChangable' `is changed`.
         * @private
         */
        changed(): boolean;
        /**
         * `Freezes the changes`.
         * @private
         */
        freezeChanges(freezer: Object): void;
    }
    
    /**
     * `IPdfPrimitive.ts` interface for EJ2-PDF
     * Defines the basic interace of the various Primitive.
     * @private
     */
    
    export interface IPdfPrimitive {
        /**
         * Specifies the `status` of the IPdfPrimitive. Status is registered if it has a reference or else none.
         * @private
         */
        status: ObjectStatus;
        /**
         * Gets or sets a value indicating whether this document `is saving` or not.
         * @private
         */
        isSaving: boolean;
        /**
         * Gets or sets the `index` value of the specified object.
         * @private
         */
        objectCollectionIndex: number;
        /**
         * Stores the `cloned object` for future use.
         * @private
         */
        clonedObject: IPdfPrimitive;
        /**
         * `Saves` the object using the specified writer.
         * @private
         */
        save(writer: IPdfWriter): void;
        /**
         * Creates a `deep copy` of the IPdfPrimitive object.
         * @private
         */
        clone(crossTable: PdfCrossTable): IPdfPrimitive;
        /**
         * Gets or sets the `position` of the object.
         * @private
         */
        position: number;
    }
    
    /**
     * `IPdfWrapper.ts` interface for EJ2-PDF
     * Defines the basic interace of the various Wrapper.
     * @private
     */
    
    export interface IPdfWrapper {
        /**
         * Gets the `element`.
         * @private
         */
        element: IPdfPrimitive;
    }
    
    /**
     * `IPdfWriter.ts` interface for EJ2-PDF
     * Defines the basic interace of the various writers.
     * @private
     */
    
    export interface IPdfWriter {
        /**
         * Gets or sets the current `position` within the stream.
         * @private
         */
        position: number;
        /**
         * Stream `length`.
         * @private
         */
        length: number;
        /**
         * The `document` required for saving process.
         * @private
         */
        document: PdfDocumentBase;
        /**
         * `Writes` the specified data.
         * @private
         */
        write(overload: IPdfPrimitive | number | string | GLbyte[]): void;
    }
    
  }
  export namespace popups {
    
    /**
     * Collision module.
     */
    
    export interface CollisionCoordinates {
        X: boolean;
        Y: boolean;
    }
    export function fit(element: HTMLElement, viewPortElement?: HTMLElement, axis?: CollisionCoordinates, position?: OffsetPosition): OffsetPosition;
    export function isCollide(element: HTMLElement, viewPortElement?: HTMLElement, x?: number, y?: number): string[];
    export function flip(element: HTMLElement, target: HTMLElement, offsetX: number, offsetY: number, positionX: string, positionY: string, viewPortElement?: HTMLElement, axis?: CollisionCoordinates, fixedParent?: Boolean): void;
    
    export function calculateRelativeBasedPosition(anchor: HTMLElement, element: HTMLElement): OffsetPosition;
    export function calculatePosition(currentElement: Element, positionX?: string, positionY?: string, parentElement?: Boolean): OffsetPosition;
    export interface OffsetPosition {
        left: number;
        top: number;
    }
    
    /**
     * Interface for a class ButtonProps
     */
    export interface ButtonPropsModel {
    
        /**
         * Specifies the Button component properties to render the Dialog buttons.
         */
        buttonModel?: ej.buttons.ButtonModel;
    
        /**
         * Event triggers when `click` the Dialog button.
         * @event
         */
        click?: ej.base.EmitType<Object>;
    
    }
    
    /**
     * Interface for a class AnimationSettings
     */
    export interface AnimationSettingsModel {
    
        /**
         * Specifies the effect to open and close the Dialog.  
         * If the user sets `Fade` effect then the Dialog will open with 'FadeIn' effect and close with 'FadeOut' effect.
         * Following list of effects will be available, you can use any of this.
         * 1. 'Fade'
         * 2. 'FadeZoom'
         * 3. 'FlipLeftDown'
         * 4. 'FlipLeftUp'
         * 5. 'FlipRightDown'
         * 6. 'FlipRightUp'
         * 7. 'FlipXDown'
         * 8. 'FlipXUp'
         * 9. 'FlipYLeft'
         * 10. 'FlipYRight'
         * 11. 'SlideBottom'
         * 12. 'SlideLeft'
         * 13. 'SlideRight'
         * 14. 'SlideTop'
         * 15. 'Zoom'
         * 16. 'None'
         */
        effect?: DialogEffect;
    
        /**
         * Specifies the animation `duration` to complete with one animation cycle.
         */
        duration?: number;
    
        /**
         * Specifies the `delay` value in milliseconds to wait before animation begins.
         */
        delay?: number;
    
    }
    
    /**
     * Interface for a class Dialog
     */
    export interface DialogModel extends ej.base.ComponentModel{
    
        /**
         * Specifies the `content` to be displayed in Dialog, it can be text or HTML element.
         * @default ''
         */
        content?: string | HTMLElement;
    
        /**
         * Specifies the value to either show or hide the close icon button.
         * @default false
         */
        showCloseIcon?: boolean;
    
        /**
         * Specifies the value to render the Dialog as modal or modeless.
         * @default false
         */
        isModal?: boolean;
    
        /**
         * Specifies the `header` content that defines how the Dialog `header` is rendered. 
         * @default ''
         */
        header?: string;
    
        /**
         * Specifies the value to either Dialog is opened or not.
         * @default false     
         */
        visible?: boolean;
    
        /**
         * Specifies the `height` of the Dialog. 
         * @default 'auto'
         */
        height?: string | number;
    
        /**
         * Specifies the `width` of the Dialog. 
         * @default '100%'
         */
        width?: string | number;
    
        /**
         * Specifies the CSS class name to be added for Dialog element.
         * User can add single or multiple CSS classes.
         * @default ''
         */
        cssClass?: string;
    
        /**
         * Specifies the z-index value for Dialog.
         */
        zIndex?: number;
    
        /**
         * Specifies the `target` element where the Dialog should be displayed.
         * If the user set the specific `target` element for Dialog, it will be positioned based on the `target`.
         * @default null
         */
        target?: HTMLElement | string;
    
        /**
         * Specifies the template content to defines how the Dialog footer is rendered. 
         * @default ''
         */
        footerTemplate?: string;
    
        /**
         * Specifies the value to either enable or disable draggable option in Dialog. 
         * @default false
         */
        allowDragging?: boolean;
    
        /**
         * Specifies the collection of Dialog `buttons` with click action and button component model.     
         * @default [{}]   
         */
        buttons?: ButtonPropsModel[];
    
        /**
         * Specifies the Dialog that is closed when user press the ESC key. 
         * @default true
         */
        closeOnEscape?: boolean;
    
        /**
         * Specifies the Dialog animation settings.
         * @default { effect: 'Fade', duration: 400, delay:0 }
         */
        animationSettings?: AnimationSettingsModel;
    
        /**
         * Specifies to `position` the Dialog on built-in 9 places or any custom location with
         * respect to the associated target elements.
         * For ex: {X:'left', Y:'top'} or { X: 100, Y: 100 }.
         * Following list of positions are available.
         * * for X is: left, center, right (or) any offset value
         * * for Y is: top, center, bottom (or) any offset value
         * @default {X:'center', Y:'center'}
         */
        position?: PositionDataModel;
    
        /**
         * Event triggers when the Dialog is `created`. 
         * @event
         */
        created?: ej.base.EmitType<Object>;
    
        /**
         * Event triggers once Dialog is opened.
         * @event
         */
        open?: ej.base.EmitType<Object>;
    
        /**
         * Event triggers before open the Dialog. 
         * @event
         */
        beforeOpen?: ej.base.EmitType<BeforeOpenEventArgs>;
    
        /**
         * Event triggers once the Dialog is closed.
         * @event
         */
        close?: ej.base.EmitType<Object>;
    
        /**
         * Event triggers before close the Dialog.
         * @event
         */
        beforeClose?: ej.base.EmitType<BeforeCloseEventArgs>;
    
        /**
         * Event triggers when user starts to drag the Dialog. 
         * @event
         */
        dragStart?: ej.base.EmitType<Object>;
    
        /**
         * Event triggers when the user stops dragging the Dialog.
         * @event
         */
        dragStop?: ej.base.EmitType<Object>;
    
        /**
         * Event triggers when the user drags Dialog. 
         * @event
         */
        drag?: ej.base.EmitType<Object>;
    
        /**
         * Event triggers when modal Dialog overlay is clicked. 
         * @event
         */
        overlayClick?: ej.base.EmitType<Object>;
    
    }
    
    export class ButtonProps extends ej.base.ChildProperty<ButtonProps> {
        /**
         * Specifies the Button component properties to render the Dialog buttons.
         */
        buttonModel: ej.buttons.ButtonModel;
        /**
         * Event triggers when `click` the Dialog button.
         * @event
         */
        click: ej.base.EmitType<Object>;
    }
    /**
     * Specifies Dialog open and close animation settings.
     */
    export class AnimationSettings extends ej.base.ChildProperty<AnimationSettings> {
        /**
         * Specifies the effect to open and close the Dialog.
         * If the user sets `Fade` effect then the Dialog will open with 'FadeIn' effect and close with 'FadeOut' effect.
         * Following list of effects will be available, you can use any of this.
         * 1. 'Fade'
         * 2. 'FadeZoom'
         * 3. 'FlipLeftDown'
         * 4. 'FlipLeftUp'
         * 5. 'FlipRightDown'
         * 6. 'FlipRightUp'
         * 7. 'FlipXDown'
         * 8. 'FlipXUp'
         * 9. 'FlipYLeft'
         * 10. 'FlipYRight'
         * 11. 'SlideBottom'
         * 12. 'SlideLeft'
         * 13. 'SlideRight'
         * 14. 'SlideTop'
         * 15. 'Zoom'
         * 16. 'None'
         */
        effect: DialogEffect;
        /**
         * Specifies the animation `duration` to complete with one animation cycle.
         */
        duration: number;
        /**
         * Specifies the `delay` value in milliseconds to wait before animation begins.
         */
        delay: number;
    }
    /**
     * Specifies the Dialog animation effects.
     */
    export type DialogEffect = 'Fade' | 'FadeZoom' | 'FlipLeftDown' | 'FlipLeftUp' | 'FlipRightDown' | 'FlipRightUp' | 'FlipXDown' | 'FlipXUp' | 'FlipYLeft' | 'FlipYRight' | 'SlideBottom' | 'SlideLeft' | 'SlideRight' | 'SlideTop' | 'Zoom' | 'None';
    export interface BeforeOpenEventArgs {
        cancel: boolean;
        container: HTMLElement;
    }
    export interface BeforeCloseEventArgs {
        cancel: boolean;
        container: HTMLElement;
    }
    /**
     * Represents the Dialog component that displays information to the user, and used to get the user input.
     * ```html
     * <div id="dialog"></div>
     * ```
     * ```typescript
     * <script>
     *   var dialogObj = new Dialog({ header: 'Dialog' });
     *   dialogObj.appendTo("#dialog");
     * </script>
     * ```
     */
    export class Dialog extends ej.base.Component<HTMLElement> implements ej.base.INotifyPropertyChanged {
        private closeIconClickEventHandler;
        private dlgOverlayClickEventHandler;
        private createEventHandler;
        private contentEle;
        private dlgOverlay;
        private dlgContainer;
        private headerEle;
        private buttonContent;
        private ftrTemplateContent;
        private headerContent;
        private closeIcon;
        private popupObj;
        private btnObj;
        private closeIconBtnObj;
        private dragObj;
        private primaryButtonEle;
        private targetEle;
        private dialogOpen;
        private storeActiveElement;
        private focusElements;
        private focusIndex;
        private closedFrom;
        private l10n;
        /**
         * Specifies the `content` to be displayed in Dialog, it can be text or HTML element.
         * @default ''
         */
        content: string | HTMLElement;
        /**
         * Specifies the value to either show or hide the close icon button.
         * @default false
         */
        showCloseIcon: boolean;
        /**
         * Specifies the value to render the Dialog as modal or modeless.
         * @default false
         */
        isModal: boolean;
        /**
         * Specifies the `header` content that defines how the Dialog `header` is rendered.
         * @default ''
         */
        header: string;
        /**
         * Specifies the value to either Dialog is opened or not.
         * @default false
         */
        visible: boolean;
        /**
         * Specifies the `height` of the Dialog.
         * @default 'auto'
         */
        height: string | number;
        /**
         * Specifies the `width` of the Dialog.
         * @default '100%'
         */
        width: string | number;
        /**
         * Specifies the CSS class name to be added for Dialog element.
         * User can add single or multiple CSS classes.
         * @default ''
         */
        cssClass: string;
        /**
         * Specifies the z-index value for Dialog.
         */
        zIndex: number;
        /**
         * Specifies the `target` element where the Dialog should be displayed.
         * If the user set the specific `target` element for Dialog, it will be positioned based on the `target`.
         * @default null
         */
        target: HTMLElement | string;
        /**
         * Specifies the template content to defines how the Dialog footer is rendered.
         * @default ''
         */
        footerTemplate: string;
        /**
         * Specifies the value to either enable or disable draggable option in Dialog.
         * @default false
         */
        allowDragging: boolean;
        /**
         * Specifies the collection of Dialog `buttons` with click action and button component model.
         * @default [{}]
         */
        buttons: ButtonPropsModel[];
        /**
         * Specifies the Dialog that is closed when user press the ESC key.
         * @default true
         */
        closeOnEscape: boolean;
        /**
         * Specifies the Dialog animation settings.
         * @default { effect: 'Fade', duration: 400, delay:0 }
         */
        animationSettings: AnimationSettingsModel;
        /**
         * Specifies to `position` the Dialog on built-in 9 places or any custom location with
         * respect to the associated target elements.
         * For ex: {X:'left', Y:'top'} or { X: 100, Y: 100 }.
         * Following list of positions are available.
         * * for X is: left, center, right (or) any offset value
         * * for Y is: top, center, bottom (or) any offset value
         * @default {X:'center', Y:'center'}
         */
        position: PositionDataModel;
        /**
         * Event triggers when the Dialog is `created`.
         * @event
         */
        created: ej.base.EmitType<Object>;
        /**
         * Event triggers once Dialog is opened.
         * @event
         */
        open: ej.base.EmitType<Object>;
        /**
         * Event triggers before open the Dialog.
         * @event
         */
        beforeOpen: ej.base.EmitType<BeforeOpenEventArgs>;
        /**
         * Event triggers once the Dialog is closed.
         * @event
         */
        close: ej.base.EmitType<Object>;
        /**
         * Event triggers before close the Dialog.
         * @event
         */
        beforeClose: ej.base.EmitType<BeforeCloseEventArgs>;
        /**
         * Event triggers when user starts to drag the Dialog.
         * @event
         */
        dragStart: ej.base.EmitType<Object>;
        /**
         * Event triggers when the user stops dragging the Dialog.
         * @event
         */
        dragStop: ej.base.EmitType<Object>;
        /**
         * Event triggers when the user drags Dialog.
         * @event
         */
        drag: ej.base.EmitType<Object>;
        /**
         * Event triggers when modal Dialog overlay is clicked.
         * @event
         */
        overlayClick: ej.base.EmitType<Object>;
        /**
         * Constructor for creating the widget
         * @hidden
         */
        constructor(options?: DialogModel, element?: string | HTMLElement);
        /**
         * Initialize the control rendering
         * @private
         */
        render(): void;
        /**
         * Initialize the event handler
         * @private
         */
        protected preRender(): void;
        private keyDown(event);
        /**
         * Initialize the control rendering
         * @private
         */
        private initialize();
        /**
         * Initialize the rendering
         * @private
         */
        private initRender();
        private positionChange();
        private setAllowDragging();
        private setButton();
        private setContent();
        private setMaxHeight();
        private setEnableRTL();
        private setTargetContent();
        private setHeader();
        private setFooterTemplate();
        private createHeaderContent();
        private renderCloseIcon();
        private closeIconTitle();
        private setCSSClass(oldCSSClass?);
        private setIsModal();
        private getValidFocusNode(items);
        private focusableElements(content);
        private getAutoFocusNode(container);
        private disableElement(element, t);
        private focusContent();
        private bindEvent(element);
        private unBindEvent(element);
        /**
         * Module required function
         * @private
         */
        protected getModuleName(): string;
        /**
         * Called internally if any of the property value changed
         * @private
         */
        onPropertyChanged(newProp: DialogModel, oldProp: DialogModel): void;
        /**
         * Get the properties to be maintained in the persisted state.
         * @private
         */
        protected getPersistData(): string;
        /**
         * To destroy the widget
         * @method destroy
         * @return {void}
         * @private
         * @memberof dialog
         */
        destroy(): void;
        /**
         * Binding event to the element while widget creation
         * @hidden
         */
        private wireEvents();
        /**
         * Unbinding event to the element while widget destroy
         * @hidden
         */
        private unWireEvents();
        /**
         * Specifies dialog offset x and y position changed dynamically or
         * change the header,footer height or width dynamically, reposition the dialog as per the new changes.
         * @return {void}
         */
        refreshPosition(): void;
        /**
         * To show the Dialog element on screen.
         * To enable the fullScreen Dialog pass the parameter to 'true'.
         * @param { boolean } isFullScreen - Enable the fullScreen Dialog.
         * @return {void}
         */
        show(isFullScreen?: boolean): void;
        /**
         * To hide the Dialog element on screen.
         * @return {void}
         */
        hide(): void;
        /**
         * Specifies to view the Full screen Dialog.
         * @private
         */
        private fullScreen(args);
    }
    
    /**
     * Interface for a class PositionData
     */
    export interface PositionDataModel {
    
        /**
         * specify the offset left value
         */
        X?: string | number;
    
        /**
         * specify the offset top value.
         */
        Y?: string | number;
    
    }
    
    /**
     * Interface for a class Popup
     */
    export interface PopupModel extends ej.base.ComponentModel{
    
        /**
         * Specifies the height of the popup element. 
         * @default 'auto'
         */
        height?: string | number;
    
        /**
         * Specifies the height of the popup element.
         * @default 'auto'
         */
        width?: string | number;
    
        /**
         * Specifies the content of the popup element, it can be string or HTMLElement.
         * @default null
         */
        content?: string | HTMLElement;
    
        /**
         * Specifies the relative element type of the component.
         * @default 'container'
         */
        targetType?: TargetType;
    
        /**
         * Specifies the collision detectable container element of the component.
         * @default null
         */
        viewPortElement?: HTMLElement;
    
        /**
         * Specifies the collision handler settings of the component.
         * @default { X: 'none',Y: 'none' } 
         */
        collision?: CollisionAxis;
    
        /**
         * Specifies the relative container element of the popup element.Based on the relative element, popup element will be positioned.
         * 
         * @default 'body'
         */
        relateTo?: HTMLElement | string;
    
        /**
         * Specifies the popup element position, respective to the relative element.
         * @default {X:"left", Y:"top"}
         */
        position?: PositionDataModel;
    
        /**
         * specifies the popup element offset-x value, respective to the relative element.
         * @default 0
         */
        offsetX?: number;
    
        /**
         * specifies the popup element offset-y value, respective to the relative element.
         * @default 0
         */
        offsetY?: number;
    
        /**
         * specifies the z-index value of the popup element.
         * @default 1000
         */
        zIndex?: number;
    
        /**
         * specifies the rtl direction state of the popup element.
         * @default false
         */
        enableRtl?: boolean;
    
        /**
         * specifies the action that should happen when scroll the target-parent container.
         * This property should define either `reposition` or `hide`. 
         * when set `reposition` to this property, the popup position will refresh when scroll any parent container.
         * when set `hide` to this property, the popup will be closed when scroll any parent container. 
         * @default 'reposition'
         */
        actionOnScroll?: ActionOnScrollType;
    
        /**
         * specifies the animation that should happen when popup open.
         * @default 'null'
         */
        showAnimation?: AnimationModel;
    
        /**
         * specifies the animation that should happen when popup closes.
         * @default 'null'
         */
        hideAnimation?: AnimationModel;
    
        /**
         * Triggers the event once opened the popup.
         * @event
         */
        open?: ej.base.EmitType<Object>;
    
        /**
         * Trigger the event once closed the popup.
         * @event
         */
        close?: ej.base.EmitType<Object>;
    
        /**
         * Triggers the event when target element hide from view port on scroll.
         * @event
         */
        targetExitViewport?: ej.base.EmitType<Object>;
    
    }
    
    /**
     * Specifies the offset position values.
     */
    export class PositionData extends ej.base.ChildProperty<PositionData> {
        /**
         * specify the offset left value
         */
        X: string | number;
        /**
         * specify the offset top value.
         */
        Y: string | number;
    }
    export interface CollisionAxis {
        /**
         * specify the collision handler for a X-Axis.
         * @default : "none"
         */
        X?: CollisionType;
        /**
         * specify the collision handler for a Y-Axis.
         * @default : "none"
         */
        Y?: CollisionType;
    }
    /**
     * Collision type.
     */
    export type CollisionType = 'none' | 'flip' | 'fit';
    /**
     * action on scroll type.
     */
    export type ActionOnScrollType = 'reposition' | 'hide' | 'none';
    /**
     * Target element type.
     */
    export type TargetType = 'relative' | 'container';
    /**
     * Represents the Popup Component
     * ```html
     * <div id="popup" style="position:absolute;height:100px;width:100px;">
     * <div style="margin:35px 25px;">Popup Content</div></div>
     * ```
     * ```typescript
     * <script>
     *   var popupObj = new Popup();
     *   popupObj.appendTo("#popup");
     * </script>
     * ```
     */
    export class Popup extends ej.base.Component<HTMLElement> implements ej.base.INotifyPropertyChanged {
        private fixedParent;
        /**
         * Specifies the height of the popup element.
         * @default 'auto'
         */
        height: string | number;
        /**
         * Specifies the height of the popup element.
         * @default 'auto'
         */
        width: string | number;
        /**
         * Specifies the content of the popup element, it can be string or HTMLElement.
         * @default null
         */
        content: string | HTMLElement;
        /**
         * Specifies the relative element type of the component.
         * @default 'container'
         */
        targetType: TargetType;
        /**
         * Specifies the collision detectable container element of the component.
         * @default null
         */
        viewPortElement: HTMLElement;
        /**
         * Specifies the collision handler settings of the component.
         * @default { X: 'none',Y: 'none' }
         */
        collision: CollisionAxis;
        /**
         * Specifies the relative container element of the popup element.Based on the relative element, popup element will be positioned.
         *
         * @default 'body'
         */
        relateTo: HTMLElement | string;
        /**
         * Specifies the popup element position, respective to the relative element.
         * @default {X:"left", Y:"top"}
         */
        position: PositionDataModel;
        /**
         * specifies the popup element offset-x value, respective to the relative element.
         * @default 0
         */
        offsetX: number;
        /**
         * specifies the popup element offset-y value, respective to the relative element.
         * @default 0
         */
        offsetY: number;
        /**
         * specifies the z-index value of the popup element.
         * @default 1000
         */
        zIndex: number;
        /**
         * specifies the rtl direction state of the popup element.
         * @default false
         */
        enableRtl: boolean;
        /**
         * specifies the action that should happen when scroll the target-parent container.
         * This property should define either `reposition` or `hide`.
         * when set `reposition` to this property, the popup position will refresh when scroll any parent container.
         * when set `hide` to this property, the popup will be closed when scroll any parent container.
         * @default 'reposition'
         */
        actionOnScroll: ActionOnScrollType;
        /**
         * specifies the animation that should happen when popup open.
         * @default 'null'
         */
        showAnimation: AnimationModel;
        /**
         * specifies the animation that should happen when popup closes.
         * @default 'null'
         */
        hideAnimation: AnimationModel;
        /**
         * Triggers the event once opened the popup.
         * @event
         */
        open: ej.base.EmitType<Object>;
        /**
         * Trigger the event once closed the popup.
         * @event
         */
        close: ej.base.EmitType<Object>;
        /**
         * * Constructor for creating the widget
         */
        /**
         * Triggers the event when target element hide from view port on scroll.
         * @event
         */
        targetExitViewport: ej.base.EmitType<Object>;
        private targetInvisibleStatus;
        constructor(element?: HTMLElement, options?: PopupModel);
        /**
         * Called internally if any of the property value changed.
         * @private
         */
        onPropertyChanged(newProp: PopupModel, oldProp: PopupModel): void;
        /**
         * gets the Component module name.
         * @private
         */
        getModuleName(): string;
        /**
         * gets the persisted state properties of the Component.
         */
        protected getPersistData(): string;
        /**
         * To destroy the control.
         */
        destroy(): void;
        /**
         * To Initialize the control rendering
         * @private
         */
        render(): void;
        private wireEvents();
        private wireScrollEvents();
        private unwireEvents();
        private unwireScrollEvents();
        private getRelateToElement();
        private scrollRefresh(e);
        /**
         * This method is to get the element visibility on viewport when scroll
         * the page. This method will returns true even though 1 px of element
         * part is in visible.
         */
        private isElementOnViewport(relateToElement, scrollElement);
        private isElementVisible(relateToElement, scrollElement);
        /**
         * Initialize the event handler
         * @private
         */
        protected preRender(): void;
        private setEnableRtl();
        private setContent();
        private orientationOnChange();
        /**
         * Based on the `relative` element and `offset` values, `Popup` element position will refreshed.
         */
        refreshPosition(target?: HTMLElement): void;
        private reposition();
        private getAnchorPosition(anchorEle, ele, position, offsetX, offsetY);
        private callFlip(param);
        private callFit(param);
        private checkCollision();
        /**
         * Shows the popup element from screen.
         * @param { AnimationModel | Function } collisionOrAnimationOptions? - To pass animation options or collision function.
         * @param { Function } collision? - To pass the collision function.
         */
        show(animationOptions?: AnimationModel): void;
        /**
         * Hides the popup element from screen.
         * @param { AnimationModel } animationOptions? - To give the animation options.
         */
        hide(animationOptions?: AnimationModel): void;
        /**
         * Gets scrollable parent elements for the given element.
         * @param { HTMLElement } element - Specify the element to get the scrollable parents of it.
         */
        getScrollableParent(element: HTMLElement): HTMLElement[];
        private checkFixedParent(element);
    }
    /**
     * Gets scrollable parent elements for the given element.
     * @param { HTMLElement } element - Specify the element to get the scrollable parents of it.
     * @private
     */
    export function getScrollableParent(element: HTMLElement, fixedParent?: Boolean): HTMLElement[];
    /**
     * Gets the maximum z-index of the given element.
     * @param { HTMLElement } element - Specify the element to get the maximum z-index of it.
     * @private
     */
    export function getZindexPartial(element: HTMLElement): number;
    
    /**
     * Defines the type of spinner.
     */
    export type SpinnerType = 'Material' | 'Fabric' | 'Bootstrap' | 'HighContrast';
    /**
     * Create a spinner for the specified target element.
     * ```
     * E.g : createSpinner({ target: targetElement, width: '34px', label: 'Loading..' });
     * ```
     * @param args
     * @private
     */
    export function createSpinner(args: SpinnerArgs): void;
    /**
     * Function to show the Spinner.
     * @param container - Specify the target of the Spinner.
     * @private
     */
    export function showSpinner(container: HTMLElement): void;
    /**
     * Function to hide the Spinner.
     * @param container - Specify the target of the Spinner.
     * @private
     */
    export function hideSpinner(container: HTMLElement): void;
    /**
     * Function to change the Spinners in a page globally from application end.
     * ```
     * E.g : setSpinner({ cssClass: 'custom-css'; type: 'Material' });
     * ```
     * @param args
     * @private
     */
    export function setSpinner(args: SetSpinnerArgs): void;
    /**
     * Arguments to create a spinner for the target.These properties are optional.
     */
    export interface SpinnerArgs {
        /**
         * Target element to the Spinner.
         * ```
         * E.g : createSpinner({ target: element });
         * ```
         */
        target: HTMLElement;
        /**
         *  To set the width of the Spinner.
         */
        width?: string | number;
        /**
         *  To set the label to the Spinner element.
         */
        label?: string;
        /**
         *  Sets the CSS classes to root element of the Spinner which helps to customize the complete UI styles.
         */
        cssClass?: string;
        /**
         *  Specify the template content to be displayed in the Spinner.
         */
        template?: string;
        /**
         *  Specify the type of the Spinner.
         */
        type?: SpinnerType;
    }
    /**
     * Arguments to change the Spinners in a page globally from application end.
     */
    export interface SetSpinnerArgs {
        /**
         *  Specify the template content to be displayed in the Spinner.
         */
        template?: string;
        /**
         *  Sets the CSS classes to root element of the Spinner which helps to customize the complete UI styles.
         */
        cssClass?: string;
        /**
         *  Specify the type of the Spinner.
         */
        type?: SpinnerType;
    }
    
    /**
     * Interface for a class Animation
     */
    export interface AnimationModel {
    
        /**
         * Animation settings to be applied on the Tooltip, while it is being shown over the target.
         */
        open?: TooltipAnimationSettings;
    
        /**
         * Animation settings to be applied on the Tooltip, when it is closed.
         */
        close?: TooltipAnimationSettings;
    
    }
    
    /**
     * Interface for a class Tooltip
     */
    export interface TooltipModel extends ej.base.ComponentModel{
    
        /**
         * It is used to set the width of Tooltip component which accepts both string and number values.
         * When set to auto, the Tooltip width gets auto adjusted to display its content within the viewable screen.
         * @default 'auto'
         */
        width?: string | number;
    
        /**
         * It is used to set the height of Tooltip component which accepts both string and number values.
         * When Tooltip content gets overflow due to height value then the scroll mode will be enabled.     
         * Refer the documentation {@link http://ej2.syncfusion.com/documentation/tooltip/setting-dimension.html?lang=typescript here} 
         *  to know more about this property with demo.
         * @default 'auto'
         */
        height?: string | number;
    
        /**
         * It is used to display the content of Tooltip which can be both string and HTML Elements.
         * Refer the documentation {@link http://ej2.syncfusion.com/documentation/tooltip/content.html?lang=typescript here} 
         *  to know more about this property with demo.
         */
        content?: string | HTMLElement;
    
        /**
         * It is used to denote the target selector where the Tooltip need to be displayed. 
         * The target element is considered as parent container.
         */
        target?: string;
    
        /**
         * It is used to set the position of Tooltip element, with respect to Target element.
         * @default 'TopCenter'
         */
        position?: Position;
    
        /**
         * It sets the space between the target and Tooltip element in X axis.
         * @default 0
         */
        offsetX?: number;
    
        /**
         * It sets the space between the target and Tooltip element in Y axis.
         * @default 0
         */
        offsetY?: number;
    
        /**
         * It is used to show or hide the tip pointer of Tooltip.
         * @default true
         */
        showTipPointer?: boolean;
    
        /**
         * It is used to set the position of tip pointer on tooltip.
         * When it sets to auto, the tip pointer auto adjusts within the space of target's length
         *  and does not point outside.     
         * Refer the documentation 
         *  {@link http://ej2.syncfusion.com/documentation/tooltip/position.html?lang=typescript#tip-pointer-positioning here} 
         *  to know more about this property with demo.
         * @default 'Auto'
         */
        tipPointerPosition?: TipPointerPosition;
    
        /**
         * It is used to determine the device mode to display the Tooltip content.
         * If it is in desktop, it will show the Tooltip content when hovering on the target element.
         * If it is in touch device, it will show the Tooltip content when tap and holding on the target element.
         * @default 'Auto'
         */
        opensOn?: string;
    
        /**
         * It allows the Tooltip to follow the mouse pointer movement over the specified target element.     
         * Refer the documentation {@link http://ej2.syncfusion.com/documentation/tooltip/position.html?lang=typescript#mouse-trailing here} 
         *  to know more about this property with demo.
         * @default false
         */
        mouseTrail?: boolean;
    
        /**
         * It is used to display the Tooltip in an open state until closed by manually.     
         * Refer the documentation {@link http://ej2.syncfusion.com/documentation/tooltip/open-mode.html?lang=typescript#sticky-mode here} 
         *  to know more about this property with demo.
         * @default false
         */
        isSticky?: Boolean;
    
        /**
         * We can set the same or different animation option to Tooltip while it is in open or close state.     
         * Refer the documentation {@link http://ej2.syncfusion.com/documentation/tooltip/animation.html?lang=typescript here} 
         *  to know more about this property with demo.
         * @default { open: { effect: 'FadeIn', duration: 150, delay: 0 }, close: { effect: 'FadeOut', duration: 150, delay: 0 } }
         */
        animation?: AnimationModel;
    
        /**
         * It is used to open the Tooltip after the specified delay in milliseconds.
         * @default 0
         */
        openDelay?: number;
    
        /**
         * It is used to close the Tooltip after a specified delay in milliseconds.
         * @default 0
         */
        closeDelay?: number;
    
        /**
         * It is used to customize the Tooltip which accepts custom CSS class names that
         *  defines specific user-defined styles and themes to be applied on the Tooltip element.
         * @default null
         */
        cssClass?: string;
    
        /**
         * It is used to display the Tooltip and content of Tooltip from right to left direction.
         * @default false
         */
        enableRtl?: boolean;
    
        /**
         * We can trigger `beforeRender` event before the Tooltip and its contents are added to the DOM.
         * When one of its arguments `cancel` is set to true, the Tooltip can be prevented from rendering on the page.
         * This event is mainly used for the purpose of customizing the Tooltip before it shows up on the screen.
         * For example, to load the AJAX content or to set new animation effects on the Tooltip, this event can be opted.
         * Refer the documentation 
         *  {@link http://ej2.syncfusion.com/documentation/tooltip/content.html?lang=typescript#dynamic-content-via-ajax here} 
         *  to know more about this property with demo.
         * @event
         */
        beforeRender?: ej.base.EmitType<TooltipEventArgs>;
    
        /**
         * We can trigger `beforeOpen` event before the Tooltip is displayed over the target element. 
         * When one of its arguments `cancel` is set to true, the Tooltip display can be prevented.
         * This event is mainly used for the purpose of refreshing the Tooltip positions dynamically or to
         *  set customized styles in it and so on.
         * @event
         */
        beforeOpen?: ej.base.EmitType<TooltipEventArgs>;
    
        /**
         * We can trigger `afterOpen` event after the Tooltip Component gets opened.
         * @event
         */
        afterOpen?: ej.base.EmitType<TooltipEventArgs>;
    
        /**
         * We can trigger `beforeClose` event before the Tooltip hides from the screen. If returned false, then the Tooltip is no more hidden.
         * @event
         */
        beforeClose?: ej.base.EmitType<TooltipEventArgs>;
    
        /**
         * We can trigger `afterClose` event when the Tooltip Component gets closed.
         * @event
         */
        afterClose?: ej.base.EmitType<TooltipEventArgs>;
    
        /**
         * We can trigger `beforeCollision` event for every collision fit calculation.
         * @event
         */
        beforeCollision?: ej.base.EmitType<TooltipEventArgs>;
    
        /**
         * We can trigger `created` event after the Tooltip component is created.
         * @event
         */
        created?: ej.base.EmitType<Object>;
    
        /**
         * We can trigger `destroyed` event when the Tooltip component is destroyed.
         * @event
         */
        destroyed?: ej.base.EmitType<Object>;
    
    }
    
    /**
     * Set of open modes available for Tooltip.
     */
    export type OpenMode = 'Auto' | 'Hover' | 'Click' | 'Focus' | 'Custom';
    /**
     * Applicable positions where the Tooltip can be displayed over specific target elements.
     */
    export type Position = 'TopLeft' | 'TopCenter' | 'TopRight' | 'BottomLeft' | 'BottomCenter' | 'BottomRight' | 'LeftTop' | 'LeftCenter' | 'LeftBottom' | 'RightTop' | 'RightCenter' | 'RightBottom';
    /**
     * Applicable tip positions attached to the Tooltip.
     */
    export type TipPointerPosition = 'Auto' | 'Start' | 'Middle' | 'End';
    /**
     * Animation effects that are applicable for Tooltip.
     */
    export type Effect = 'FadeIn' | 'FadeOut' | 'FadeZoomIn' | 'FadeZoomOut' | 'FlipXDownIn' | 'FlipXDownOut' | 'FlipXUpIn' | 'FlipXUpOut' | 'FlipYLeftIn' | 'FlipYLeftOut' | 'FlipYRightIn' | 'FlipYRightOut' | 'ZoomIn' | 'ZoomOut' | 'None';
    /**
     * Interface for Tooltip event arguments.
     */
    export interface TooltipEventArgs extends ej.base.BaseEventArgs {
        /**
         * It is used to denote the type of the triggered event.
         */
        type: String;
        /**
         * It illustrates whether the current action needs to be prevented or not.
         */
        cancel: Boolean;
        /**
         * It is used to specify the current event object.
         */
        event: Event;
        /**
         * It is used to denote the current target element where the Tooltip is to be displayed.
         */
        target: HTMLElement;
        /**
         * It is used to denote the Tooltip element
         */
        element: HTMLElement;
        /**
         * It is used to denote the Collided Tooltip position
         */
        collidedPosition?: string;
    }
    /**
     * Animation options that are common for both open and close actions of the Tooltip.
     */
    export interface TooltipAnimationSettings {
        /**
         * It is used to apply the Animation effect on the Tooltip, during open and close actions.
         */
        effect?: ej.base.Effect;
        /**
         * It is used to denote the duration of the animation that is completed per animation cycle.
         */
        duration?: number;
        /**
         * It is used to denote the delay value in milliseconds and indicating the waiting time before animation begins.
         */
        delay?: number;
    }
    export class Animation extends ej.base.ChildProperty<Animation> {
        /**
         * Animation settings to be applied on the Tooltip, while it is being shown over the target.
         */
        open: TooltipAnimationSettings;
        /**
         * Animation settings to be applied on the Tooltip, when it is closed.
         */
        close: TooltipAnimationSettings;
    }
    /**
     * Represents the Tooltip component that displays a piece of information about the target element on mouse hover.
     * ```html
     * <div id="tooltip">Show Tooltip</div>
     * ```
     * ```typescript
     * <script>
     *   var tooltipObj = new Tooltip({ content: 'Tooltip text' });
     *   tooltipObj.appendTo("#tooltip");
     * </script>
     * ```
     */
    export class Tooltip extends ej.base.Component<HTMLElement> implements ej.base.INotifyPropertyChanged {
        private popupObj;
        private tooltipEle;
        private ctrlId;
        private tipClass;
        private tooltipPositionX;
        private tooltipPositionY;
        private tooltipEventArgs;
        private isHidden;
        private showTimer;
        private hideTimer;
        private tipWidth;
        private tipHeight;
        private touchModule;
        private autoCloseTimer;
        /**
         * It is used to set the width of Tooltip component which accepts both string and number values.
         * When set to auto, the Tooltip width gets auto adjusted to display its content within the viewable screen.
         * @default 'auto'
         */
        width: string | number;
        /**
         * It is used to set the height of Tooltip component which accepts both string and number values.
         * When Tooltip content gets overflow due to height value then the scroll mode will be enabled.
         * Refer the documentation {@link http://ej2.syncfusion.com/documentation/tooltip/setting-dimension.html?lang=typescript here}
         *  to know more about this property with demo.
         * @default 'auto'
         */
        height: string | number;
        /**
         * It is used to display the content of Tooltip which can be both string and HTML Elements.
         * Refer the documentation {@link http://ej2.syncfusion.com/documentation/tooltip/content.html?lang=typescript here}
         *  to know more about this property with demo.
         */
        content: string | HTMLElement;
        /**
         * It is used to denote the target selector where the Tooltip need to be displayed.
         * The target element is considered as parent container.
         */
        target: string;
        /**
         * It is used to set the position of Tooltip element, with respect to Target element.
         * @default 'TopCenter'
         */
        position: Position;
        /**
         * It sets the space between the target and Tooltip element in X axis.
         * @default 0
         */
        offsetX: number;
        /**
         * It sets the space between the target and Tooltip element in Y axis.
         * @default 0
         */
        offsetY: number;
        /**
         * It is used to show or hide the tip pointer of Tooltip.
         * @default true
         */
        showTipPointer: boolean;
        /**
         * It is used to set the position of tip pointer on tooltip.
         * When it sets to auto, the tip pointer auto adjusts within the space of target's length
         *  and does not point outside.
         * Refer the documentation
         *  {@link http://ej2.syncfusion.com/documentation/tooltip/position.html?lang=typescript#tip-pointer-positioning here}
         *  to know more about this property with demo.
         * @default 'Auto'
         */
        tipPointerPosition: TipPointerPosition;
        /**
         * It is used to determine the device mode to display the Tooltip content.
         * If it is in desktop, it will show the Tooltip content when hovering on the target element.
         * If it is in touch device, it will show the Tooltip content when tap and holding on the target element.
         * @default 'Auto'
         */
        opensOn: string;
        /**
         * It allows the Tooltip to follow the mouse pointer movement over the specified target element.
         * Refer the documentation {@link http://ej2.syncfusion.com/documentation/tooltip/position.html?lang=typescript#mouse-trailing here}
         *  to know more about this property with demo.
         * @default false
         */
        mouseTrail: boolean;
        /**
         * It is used to display the Tooltip in an open state until closed by manually.
         * Refer the documentation {@link http://ej2.syncfusion.com/documentation/tooltip/open-mode.html?lang=typescript#sticky-mode here}
         *  to know more about this property with demo.
         * @default false
         */
        isSticky: Boolean;
        /**
         * We can set the same or different animation option to Tooltip while it is in open or close state.
         * Refer the documentation {@link http://ej2.syncfusion.com/documentation/tooltip/animation.html?lang=typescript here}
         *  to know more about this property with demo.
         * @default { open: { effect: 'FadeIn', duration: 150, delay: 0 }, close: { effect: 'FadeOut', duration: 150, delay: 0 } }
         */
        animation: AnimationModel;
        /**
         * It is used to open the Tooltip after the specified delay in milliseconds.
         * @default 0
         */
        openDelay: number;
        /**
         * It is used to close the Tooltip after a specified delay in milliseconds.
         * @default 0
         */
        closeDelay: number;
        /**
         * It is used to customize the Tooltip which accepts custom CSS class names that
         *  defines specific user-defined styles and themes to be applied on the Tooltip element.
         * @default null
         */
        cssClass: string;
        /**
         * It is used to display the Tooltip and content of Tooltip from right to left direction.
         * @default false
         */
        enableRtl: boolean;
        /**
         * We can trigger `beforeRender` event before the Tooltip and its contents are added to the DOM.
         * When one of its arguments `cancel` is set to true, the Tooltip can be prevented from rendering on the page.
         * This event is mainly used for the purpose of customizing the Tooltip before it shows up on the screen.
         * For example, to load the AJAX content or to set new animation effects on the Tooltip, this event can be opted.
         * Refer the documentation
         *  {@link http://ej2.syncfusion.com/documentation/tooltip/content.html?lang=typescript#dynamic-content-via-ajax here}
         *  to know more about this property with demo.
         * @event
         */
        beforeRender: ej.base.EmitType<TooltipEventArgs>;
        /**
         * We can trigger `beforeOpen` event before the Tooltip is displayed over the target element.
         * When one of its arguments `cancel` is set to true, the Tooltip display can be prevented.
         * This event is mainly used for the purpose of refreshing the Tooltip positions dynamically or to
         *  set customized styles in it and so on.
         * @event
         */
        beforeOpen: ej.base.EmitType<TooltipEventArgs>;
        /**
         * We can trigger `afterOpen` event after the Tooltip Component gets opened.
         * @event
         */
        afterOpen: ej.base.EmitType<TooltipEventArgs>;
        /**
         * We can trigger `beforeClose` event before the Tooltip hides from the screen. If returned false, then the Tooltip is no more hidden.
         * @event
         */
        beforeClose: ej.base.EmitType<TooltipEventArgs>;
        /**
         * We can trigger `afterClose` event when the Tooltip Component gets closed.
         * @event
         */
        afterClose: ej.base.EmitType<TooltipEventArgs>;
        /**
         * We can trigger `beforeCollision` event for every collision fit calculation.
         * @event
         */
        beforeCollision: ej.base.EmitType<TooltipEventArgs>;
        /**
         * We can trigger `created` event after the Tooltip component is created.
         * @event
         */
        created: ej.base.EmitType<Object>;
        /**
         * We can trigger `destroyed` event when the Tooltip component is destroyed.
         * @event
         */
        destroyed: ej.base.EmitType<Object>;
        /**
         * Constructor for creating the Tooltip Component
         */
        constructor(options?: TooltipModel, element?: string | HTMLElement);
        private initialize();
        private formatPosition();
        private renderArrow();
        private setTipClass(position);
        private renderPopup(target);
        private getTooltipPosition(target);
        private reposition(target);
        private openPopupHandler();
        private closePopupHandler();
        private calculateTooltipOffset(position);
        private updateTipPosition(position);
        private adjustArrow(target, position, tooltipPositionX, tooltipPositionY);
        private renderContent(target?);
        private renderCloseIcon();
        private addDescribedBy(target, id);
        private removeDescribedBy(target);
        private tapHoldHandler(evt);
        private touchEndHandler(e);
        private targetClick(e);
        private targetHover(e);
        private showTooltip(target, showAnimation, e?);
        private checkCollision(target, x, y);
        private collisionFlipFit(target, x, y);
        private hideTooltip(hideAnimation, e?, targetElement?);
        private restoreElement(target);
        private clear();
        private onMouseOut(e);
        private onStickyClose(e);
        private onMouseMove(event);
        private keyDown(event);
        private touchEnd(e);
        private scrollHandler(e);
        /**
         * Core method that initializes the control rendering.
         * @private
         */
        render(): void;
        /**
         * Initializes the values of private members.
         * @private
         */
        protected preRender(): void;
        /**
         * Binding events to the Tooltip element.
         * @hidden
         */
        private wireEvents(trigger);
        private getTriggerList(trigger);
        private wireFocusEvents();
        private wireMouseEvents(e, target);
        /**
         * Unbinding events from the element on widget destroy.
         * @hidden
         */
        private unwireEvents(trigger);
        private unwireFocusEvents();
        private unwireMouseEvents(target);
        /**
         * Core method to return the component name.
         * @private
         */
        getModuleName(): string;
        /**
         * Returns the properties to be maintained in the persisted state.
         * @private
         */
        protected getPersistData(): string;
        /**
         * Called internally, if any of the property value changed.
         * @private
         */
        onPropertyChanged(newProp: TooltipModel, oldProp: TooltipModel): void;
        /**
         * It is used to show the Tooltip on the specified target with specific animation settings.
         * @param element Target element where the Tooltip is to be displayed.
         * @param animation Sets the specific animation, while showing the Tooltip on the screen.
         * @return {void}
         */
        open(element: HTMLElement, animation?: TooltipAnimationSettings): void;
        /**
         * It is used to hide the Tooltip with specific animation effect.
         * @param animation Sets the specific animation when hiding Tooltip from the screen.
         * @return {void}
         */
        close(animation?: TooltipAnimationSettings): void;
        /**
         * It is used to refresh the Tooltip content and its position.
         * @param target Target element where the Tooltip content or position needs to be refreshed.
         * @return {void}
         */
        refresh(target?: HTMLElement): void;
        /**
         * It is used to destroy the Tooltip component.
         * @method destroy
         * @return {void}
         * @memberof Tooltip
         */
        destroy(): void;
    }
    
  }
  export namespace schedule {
    
    /**
     * Date Generator from Recurrence Rule
     */
    export function generateSummary(rule: string, localeObject: ej.base.L10n, locale: string): string;
    export function generate(startDate: Date, rule: string, excludeDate: string, startDayOfWeek: number, maximumCount?: number, viewDate?: Date): number[];
    export function extractObjectFromRule(rules: String): RecRule;
    export interface RecRule {
        freq: FreqType;
        interval: number;
        count: Number;
        until: Date;
        day: string[];
        month: number[];
        weekNo: number[];
        monthDay: number[];
        yearDay: number[];
        setPosition: number;
        validRules: string[];
    }
    export type FreqType = 'DAILY' | 'WEEKLY' | 'MONTHLY' | 'YEARLY';
    export function getRecurrenceStringFromDate(date: Date): string;
    
    /**
     * Interface for a class RecurrenceEditor
     */
    export interface RecurrenceEditorModel extends ej.base.ComponentModel{
    
        /**
         * Sets the recurrence pattern on the editor.
         * @default ['none', 'daily', 'weekly', 'monthly', 'yearly']
         */
        frequencies?: RepeatType[];
    
        /**
         * Sets the first day of the week.
         * @default 0
         */
        firstDayOfWeek?: number;
    
        /**
         * Sets the start date on recurrence editor.
         * @default new Date()
         */
        startDate?: Date;
    
        /**
         * Sets the user specific date format on recurrence editor.
         * @default null
         */
        dateFormat?: string;
    
        /**
         * Sets the locale to be applied on recurrence editor.
         * @default true
         */
        locale?: string;
    
        /**
         * Allows styling with custom class names.
         * @default ''
         */
        cssClass?: string;
    
        /**
         * Allows recurrence editor to render in RTL mode.
         * @default false
         */
        enableRtl?: boolean;
    
        /**
         * Sets the recurrence rule as its output values.
         * @default ''
         */
        value?: String;
    
        /**
         * Sets the minimum date on recurrence editor.
         * @default new Date(1900, 1, 1)
         */
        minDate?: Date;
    
        /**
         * Sets the maximum date on recurrence editor.
         * @default new Date(2099, 12, 31)
         */
        maxDate?: Date;
    
        /**
         * Sets the current repeat type to be set on the recurrence editor.
         * @default 0
         */
        selectedType?: Number;
    
        /**
         * Triggers for value changes on every sub-controls rendered within the recurrence editor.
         * @event
         */
        change?: ej.base.EmitType<RecurrenceEditorChangeEventArgs>;
    
    }
    
    /**
     * Represents the RecurrenceEditor component.
     * ```html
     * <div id="recurrence"></div>
     * ```
     * ```typescript
     * <script>
     *   var recObj = new RecurrenceEditor();
     *   recObj.appendTo("#recurrence");
     * </script>
     * ```
     */
    export class RecurrenceEditor extends ej.base.Component<HTMLElement> implements ej.base.INotifyPropertyChanged {
        /**
         * Sets the recurrence pattern on the editor.
         * @default ['none', 'daily', 'weekly', 'monthly', 'yearly']
         */
        frequencies: RepeatType[];
        /**
         * Sets the first day of the week.
         * @default 0
         */
        firstDayOfWeek: number;
        /**
         * Sets the start date on recurrence editor.
         * @default new Date()
         */
        startDate: Date;
        /**
         * Sets the user specific date format on recurrence editor.
         * @default null
         */
        dateFormat: string;
        /**
         * Sets the locale to be applied on recurrence editor.
         * @default true
         */
        locale: string;
        /**
         * Allows styling with custom class names.
         * @default ''
         */
        cssClass: string;
        /**
         * Allows recurrence editor to render in RTL mode.
         * @default false
         */
        enableRtl: boolean;
        /**
         * Sets the recurrence rule as its output values.
         * @default ''
         */
        value: String;
        /**
         * Sets the minimum date on recurrence editor.
         * @default new Date(1900, 1, 1)
         */
        minDate: Date;
        /**
         * Sets the maximum date on recurrence editor.
         * @default new Date(2099, 12, 31)
         */
        maxDate: Date;
        /**
         * Sets the current repeat type to be set on the recurrence editor.
         * @default 0
         */
        selectedType: Number;
        /**
         * Triggers for value changes on every sub-controls rendered within the recurrence editor.
         * @event
         */
        change: ej.base.EmitType<RecurrenceEditorChangeEventArgs>;
        /**
         * Constructor for creating the widget
         * @param  {object} options?
         */
        constructor(options?: RecurrenceEditorModel, element?: string | HTMLButtonElement);
        localeObj:  ej.base.L10n;
        private defaultLocale;
        private renderStatus;
        private destroyStatus;
        private ruleObject;
        private recurrenceCount;
        private monthDate;
        private repeatInterval;
        private untilDateObj;
        private repeatType;
        private endType;
        private monthWeekPos;
        private monthWeekDays;
        private monthValue;
        private onMonthDay;
        private onWeekDay;
        private dayButtons;
        private monthButtons;
        private startState(freq, endOn, startDate);
        protected preRender(): void;
        private applyCustomClass(cssClass);
        private initialize();
        private triggerChangeEvent();
        private resetDayButton();
        private daySelection(dayIndex);
        private rtlClass(status);
        private updateUntilDate(date);
        private selectMonthDay(date);
        private updateForm(state);
        private updateEndOnForm(state);
        private freshOnEndForm();
        private showFormElement();
        private renderDropdowns();
        private setDefaultValue();
        private resetFormValues();
        private getPopupWidth();
        private monthDayRendering();
        private renderDatePickers();
        private dayButtonRender();
        private radioButtonRender();
        private numericTextboxRender();
        private renderComponent();
        private rotateArray(data, count);
        private getEndData();
        private getDayPosition(date);
        private getRepeatData();
        private getMonthPosData();
        private getDayData(format);
        private getMonthData();
        private setTemplate();
        private getSelectedDaysData();
        private getSelectedMonthData();
        private getIntervalData();
        private getEndOnCount();
        private getYearMonthRuleData();
        private updateWeekButton(keys);
        private updateMonthUI();
        private updateUI(repeat, state);
        private getUntilData();
        private destroyComponents();
        resetFields(): void;
        getRuleSummary(rule?: string): string;
        getRecurrenceDates(startDate: Date, rule: string, excludeDate?: string, maximumCount?: number, viewDate?: Date): number[];
        getRecurrenceRule(): string;
        setRecurrenceRule(rule: string, startDate?: Date): void;
        /**
         * Destroys the widget.
         * @returns void
         */
        destroy(): void;
        /**
         * Get component name.
         * @returns string
         * @private
         */
        getModuleName(): string;
        /**
         * Get the properties to be maintained in the persisted state.
         * @returns string
         */
        getPersistData(): string;
        /**
         * Initialize the control rendering
         * @returns void
         * @private
         */
        render(): void;
        /**
         * Called internally, if any of the property value changed.
         * @private
         */
        onPropertyChanged(newProp: RecurrenceEditorModel, oldProp: RecurrenceEditorModel): void;
    }
    export interface RecurrenceEditorChangeEventArgs {
        value: string;
    }
    export type RepeatType = 'none' | 'daily' | 'weekly' | 'monthly' | 'yearly';
    
    /**
     * Schedule CRUD operations
     */
    export class Crud {
        parent: Schedule;
        timezone: Timezone;
        constructor(parent: Schedule);
        private getQuery();
        private refreshData(args);
        addEvent(eventData: Object | Object[]): void;
        saveEvent(event: {
            [key: string]: Object;
        } | {
            [key: string]: Object;
        }[], action?: CurrentAction): void;
        deleteEvent(id: string | number | {
            [key: string]: Object;
        } | {
            [key: string]: Object;
        }[], action?: CurrentAction): void;
        private processCrudTimezone(events);
        private excludeDateCheck(eventStartTime, exceptionDateList);
    }
    
    /**
     * data module is used to generate query and data source.
     * @hidden
     */
    export class Data {
        dataManager: ej.data.DataManager;
        private query;
        /**
         * Constructor for data module
         * @private
         */
        constructor(dataSource?: Object | ej.data.DataManager, query?: ej.data.Query);
        /**
         * The function used to initialize dataManager and query
         * @return {void}
         * @private
         */
        initDataManager(dataSource: Object | ej.data.DataManager, query: ej.data.Query): void;
        /**
         * The function used to generate updated Query from schedule model
         * @return {void}
         * @private
         */
        generateQuery(startDate?: Date, endDate?: Date): ej.data.Query;
        /**
         * The function used to get dataSource by executing given Query
         * @param  {Query} query - A Query that specifies to generate dataSource
         * @return {void}
         * @private
         */
        getData(query: ej.data.Query): Promise<Object>;
    }
    
    /**
     * Keyboard interaction
     */
    export class KeyboardInteraction {
        /**
         * Constructor
         */
        private parent;
        private initialTarget;
        private selectedCells;
        private selectedEvents;
        private keyConfigs;
        private keyboardModule;
        constructor(parent: Schedule);
        private keyActionHandler(e);
        private addEventListener();
        private removeEventListener();
        private onCellMouseDown(e);
        onMouseSelection(e: Event): void;
        onAppointmentSelection(e: Event): void;
        private onMoveup(e);
        private processEnter(e);
        private getCells(isInverseTable, start, end);
        private focusFirstCell();
        private isInverseTableSelect();
        /** @hidden */
        selectCells(isMultiple: boolean, target: HTMLTableCellElement): void;
        private selectAppointments(isReverse, target, isMoreEvent);
        private getNextAppointment(isReverse, target, isMoreEvent);
        private getAppointmentSeriesElements(isMoreEvent);
        private getSelectedSeriesElement(target, isReverse, isMoreEvent);
        private getSelectedSeriesCell(target);
        private getAllDayCells(cells);
        private processViewNavigation(e);
        private processUp(e, isMultiple);
        private processDown(e, isMultiple);
        private processLeftRight(target, isMultiple);
        private isCancelLeftRightAction(isMultiple);
        private processRight(e, isMultiple);
        private processLeft(e, isMultiple);
        private processTab(e, isReverse);
        private processDelete(e);
        private processEscape();
        /**
         * Get module name.
         */
        protected getModuleName(): string;
        /**
         * To destroy the keyboard module.
         * @return {void}
         * @private
         */
        destroy(): void;
    }
    
    /**
     * `Scroll` module
     */
    export class Scroll {
        private parent;
        /**
         * Constructor for the scrolling.
         * @hidden
         */
        constructor(parent?: Schedule);
        /**
         * For internal use only - Get the module name.
         * @private
         */
        protected getModuleName(): string;
        /**
         * @hidden
         */
        setWidth(): void;
        /**
         * @hidden
         */
        setHeight(): void;
        /**
         * @hidden
         */
        addEventListener(): void;
        /**
         * @hidden
         */
        removeEventListener(): void;
        private setDimensions();
        /**
         * @hidden
         */
        private getCssProperties(enableRtl);
        private onPropertyChanged(e);
        /**
         * @hidden
         */
        destroy(): void;
    }
    
    /**
     * `touch` module is used to handle touch interactions.
     */
    export class ScheduleTouch {
        private element;
        private currentPanel;
        private previousPanel;
        private nextPanel;
        private parent;
        private touchObj;
        private timeStampStart;
        private isScrollTriggered;
        private touchLeftDirection;
        private touchRightDirection;
        constructor(parent: Schedule);
        private scrollHandler(e);
        private swipeHandler(e);
        private tapHoldHandler(e);
        private renderPanel(clsName, nextPrevType);
        private swapPanels(direction);
        private confirmSwipe(swipeDirection);
        private cancelSwipe();
        private onTransitionEnd();
        private getTranslateX(element);
        private setDimensions(element);
        resetValues(): void;
        /**
         * @hidden
         */
        destroy(): void;
    }
    
    /**
     * Work cell interactions
     */
    export class WorkCellInteraction {
        private parent;
        constructor(parent: Schedule);
        cellMouseDown(e: Event): void;
        cellClick(e: Event & MouseEvent): void;
        cellDblClick(e: Event): void;
    }
    
    /**
     * Constants
     */
    /** @hidden */
    export const cellClick: string;
    /** @hidden */
    export const cellDoubleClick: string;
    /** @hidden */
    export const actionBegin: string;
    /** @hidden */
    export const actionComplete: string;
    /** @hidden */
    export const actionFailure: string;
    /** @hidden */
    export const navigating: string;
    /** @hidden */
    export const renderCell: string;
    /** @hidden */
    export const eventClick: string;
    /** @hidden */
    export const eventRendered: string;
    /** @hidden */
    export const dataBinding: string;
    /** @hidden */
    export const dataBound: string;
    /** @hidden */
    export const popupOpen: string;
    /**
     * Specifies schedule internal events
     */
    /** @hidden */
    export const initialLoad: string;
    /** @hidden */
    export const initialEnd: string;
    /** @hidden */
    export const dataReady: string;
    /** @hidden */
    export const contentReady: string;
    /** @hidden */
    export const scroll: string;
    /** @hidden */
    export const scrollUiUpdate: string;
    /** @hidden */
    export const uiUpdate: string;
    /** @hidden */
    export const documentClick: string;
    /** @hidden */
    export const cellMouseDown: string;
    
    /**
     * CSS Constants
     */
    /** @hidden */
    export const ROOT: string;
    /** @hidden */
    export const RTL: string;
    /** @hidden */
    export const DEVICE: string;
    /** @hidden */
    export const ICON: string;
    /** @hidden */
    export const ENABLE_CLASS: string;
    /** @hidden */
    export const DISABLE_CLASS: string;
    /** @hidden */
    export const TABLE_CONTAINER_CLASS: string;
    /** @hidden */
    export const SCHEDULE_TABLE_CLASS: string;
    /** @hidden */
    export const ALLDAY_CELLS_CLASS: string;
    /** @hidden */
    export const HEADER_POPUP_CLASS: string;
    /** @hidden */
    export const HEADER_CALENDAR_CLASS: string;
    /** @hidden */
    export const ALLDAY_ROW_CLASS: string;
    /** @hidden */
    export const CONTENT_TABLE_CLASS: string;
    /** @hidden */
    export const WORK_CELLS_CLASS: string;
    /** @hidden */
    export const WORK_HOURS_CLASS: string;
    /** @hidden */
    export const POPUP_OPEN: string;
    /** @hidden */
    export const DATE_HEADER_WRAP_CLASS: string;
    /** @hidden */
    export const DATE_HEADER_CONTAINER_CLASS: string;
    /** @hidden */
    export const HEADER_CELLS_CLASS: string;
    /** @hidden */
    export const WORKDAY_CLASS: string;
    /** @hidden */
    export const OTHERMONTH_CLASS: string;
    /** @hidden */
    export const CURRENT_DAY_CLASS: string;
    /** @hidden */
    export const CURRENTDATE_CLASS: string;
    /** @hidden */
    export const EXPANDED_CELL_CLASS: string;
    /** @hidden */
    export const APPOINTMENT_ROW_CLASS: string;
    /** @hidden */
    export const APPOINTMENT_CELL_CLASS: string;
    /** @hidden */
    export const CURRENT_PANEL_CLASS: string;
    /** @hidden */
    export const PREVIOUS_PANEL_CLASS: string;
    /** @hidden */
    export const NEXT_PANEL_CLASS: string;
    /** @hidden */
    export const TRANSLATE_CLASS: string;
    /** @hidden */
    export const LEFT_INDENT_CLASS: string;
    /** @hidden */
    export const LEFT_INDENT_WRAP_CLASS: string;
    /** @hidden */
    export const TIME_CELLS_WRAP_CLASS: string;
    /** @hidden */
    export const TIME_CELLS_CLASS: string;
    /** @hidden */
    export const ALTERNATE_CELLS_CLASS: string;
    /** @hidden */
    export const CURRENT_TIME_CLASS: string;
    /** @hidden */
    export const CURRENT_TIMELINE_CLASS: string;
    /** @hidden */
    export const PREVIOUS_TIMELINE_CLASS: string;
    /** @hidden */
    export const HIDE_CHILDS_CLASS: string;
    /** @hidden */
    export const SCROLL_CONTAINER_CLASS: string;
    /** @hidden */
    export const WRAPPER_CLASS: string;
    /** @hidden */
    export const TIMELINE_WRAPPER_CLASS: string;
    /** @hidden */
    export const APPOINTMENT_WRAPPER_CLASS: string;
    /** @hidden */
    export const DAY_WRAPPER_CLASS: string;
    /** @hidden */
    export const TOOLBAR_CONTAINER: string;
    /** @hidden */
    export const HEADER_TOOLBAR: string;
    /** @hidden */
    export const SELECTED_CELL_CLASS: string;
    /** @hidden */
    export const APPOINTMENT_WRAP_CLASS: string;
    /** @hidden */
    export const APPOINTMENT_CONTAINER_CLASS: string;
    /** @hidden */
    export const APPOINTMENT_CLASS: string;
    /** @hidden */
    export const APPOINTMENT_BORDER: string;
    /** @hidden */
    export const APPOINTMENT_DETAILS: string;
    /** @hidden */
    export const APPOINTMENT_SUBJECT_WRAP: string;
    /** @hidden */
    export const APPOINTMENT_SUBJECT: string;
    /** @hidden */
    export const APPOINTMENT_TIME: string;
    /** @hidden */
    export const APPOINTMENT_LOCATION: string;
    /** @hidden */
    export const TABLE_WRAP_CLASS: string;
    /** @hidden */
    export const OUTER_TABLE_CLASS: string;
    /** @hidden */
    export const CONTENT_WRAP_CLASS: string;
    /** @hidden */
    export const AGENDA_CELLS_CLASS: string;
    /** @hidden */
    export const AGENDA_CURRENT_DAY_CLASS: string;
    /** @hidden */
    export const AGENDA_HEADER_CLASS: string;
    /** @hidden */
    export const NAVIGATE_CLASS: string;
    /** @hidden */
    export const DATE_HEADER_CLASS: string;
    /** @hidden */
    export const DAY_HEADER_CLASS: string;
    /** @hidden */
    export const AGENDA_HIDDEN_CLASS: string;
    /** @hidden */
    export const AGENDA_ALIGN_CLASS: string;
    /** @hidden */
    export const AGENDA_DAY_BORDER_CLASS: string;
    /** @hidden */
    export const AGENDA_DATETIME_CLASS: string;
    /** @hidden */
    export const AGENDA_EMPTY_EVENT_CLASS: string;
    /** @hidden */
    export const AGENDA_NO_EVENT_CLASS: string;
    /** @hidden */
    export const APPOINTMENT_INDICATOR_CLASS: string;
    /** @hidden */
    export const EVENT_INDICATOR_CLASS: string;
    /** @hidden */
    export const EVENT_ICON_UP_CLASS: string;
    /** @hidden */
    export const EVENT_ICON_DOWN_CLASS: string;
    /** @hidden */
    export const EVENT_ICON_LEFT_CLASS: string;
    /** @hidden */
    export const EVENT_ICON_RIGHT_CLASS: string;
    /** @hidden */
    export const EVENT_RECURRENCE_ICON_CLASS: string;
    /** @hidden */
    export const EVENT_RECURRENCE_EDIT_ICON_CLASS: string;
    /** @hidden */
    export const HEADER_ROW_CLASS: string;
    /** @hidden */
    export const ALLDAY_APPOINTMENT_WRAPPER_CLASS: string;
    /** @hidden */
    export const ALLDAY_APPOINTMENT_CLASS: string;
    /** @hidden */
    export const ALLDAY_WRAPPER_CLASS: string;
    /** @hidden */
    export const EVENT_COUNT_CLASS: string;
    /** @hidden */
    export const ROW_COUNT_WRAPPER_CLASS: string;
    /** @hidden */
    export const APPOINTMENT_COUNT_CLASS: string;
    /** @hidden */
    export const ALLDAY_APPOINTMENT_SECTION_CLASS: string;
    /** @hidden */
    export const APPOINTMENT_ROW_EXPAND_CLASS: string;
    /** @hidden */
    export const APPOINTMENT_ROW_COLLAPSE_CLASS: string;
    /** @hidden */
    export const MORE_INDICATOR_CLASS: string;
    /** @hidden */
    export const APPOINTMENT_SELECTION_CLASS: string;
    /** @hidden */
    export const APPOINTMENT_CELL_SELECT_CLASS: string;
    /** @hidden */
    export const SCHEDULE_INNER_CLASS: string;
    /** @hidden */
    export const QUICK_POPUP_ROOT_CLASS: string;
    /** @hidden */
    export const QUICK_POPUP_CLASS: string;
    /** @hidden */
    export const QUICK_POPUP_SUBJECT_CLASS: string;
    /** @hidden */
    export const QUICK_POPUP_TABLE_CLASS: string;
    /** @hidden */
    export const QUICK_POPUP_ICON_CLASS: string;
    /** @hidden */
    export const QUICK_POPUP_CLOSE_ICON_CLASS: string;
    /** @hidden */
    export const QUICK_POPUP_EDIT_ICON_CLASS: string;
    /** @hidden */
    export const QUICK_POPUP_CONTENT_CLASS: string;
    /** @hidden */
    export const QUICK_POPUP_RIGHT_FIELDS_CLASS: string;
    /** @hidden */
    export const QUICK_POPUP_DATE_TIME_DETAILS_CLASS: string;
    /** @hidden */
    export const DEVICE_DATE_TIME_DETAILS_CLASS: string;
    /** @hidden */
    export const DEVICE_RECURRENCE_SUMMARY_CLASS: string;
    /** @hidden */
    export const QUICK_POPUP_LOCATION_DETAILS_CLASS: string;
    /** @hidden */
    export const QUICK_POPUP_FOOTER_CLASS: string;
    /** @hidden */
    export const QUICK_POPUP_EVENT_DETAILS_CLASS: string;
    /** @hidden */
    export const QUICK_POPUP_EVENT_TITLE_CLASS: string;
    /** @hidden */
    export const QUICK_POPUP_EVENT_CREATE_CLASS: string;
    /** @hidden */
    export const QUICK_POPUP_EDIT_EVENT_CLASS: string;
    /** @hidden */
    export const TOOLTIP_CLOSE_CLASS: string;
    /** @hidden */
    export const QUICK_POPUP_DELETE_EVENT_CLASS: string;
    /** @hidden */
    export const QUICK_POPUP_TEXT_ALIGN_CLASS: string;
    /** @hidden */
    export const MORE_POPUP_WRAPPER_CLASS: string;
    /** @hidden */
    export const SELECT_POPUP_WRAPPER_CLASS: string;
    /** @hidden */
    export const MORE_EVENT_POPUP_CLASS: string;
    /** @hidden */
    export const MORE_EVENT_HEADER_CLASS: string;
    /** @hidden */
    export const MORE_EVENT_DATE_HEADER_CLASS: string;
    /** @hidden */
    export const MORE_EVENT_HEADER_DAY_CLASS: string;
    /** @hidden */
    export const MORE_EVENT_HEADER_DATE_CLASS: string;
    /** @hidden */
    export const MORE_EVENT_CLOSE_CLASS: string;
    /** @hidden */
    export const MORE_EVENT_CLOSE_ICON_CLASS: string;
    /** @hidden */
    export const MORE_EVENT_CONTENT_CLASS: string;
    /** @hidden */
    export const MORE_EVENT_WRAPPER_CLASS: string;
    /** @hidden */
    export const QUICK_DIALOG_CLASS: string;
    /** @hidden */
    export const DIALOG_FOOTER_CONTENT_CLASS: string;
    /** @hidden */
    export const QUICK_DIALOG_EDIT_EVENT_CLASS: string;
    /** @hidden */
    export const QUICK_DIALOG_EDIT_SERIES_CLASS: string;
    /** @hidden */
    export const QUICK_DIALOG_DELETE_CLASS: string;
    /** @hidden */
    export const QUICK_DIALOG_CANCEL_CLASS: string;
    /** @hidden */
    export const QUICK_DIALOG_ALERT_BTN_CLASS: string;
    /** @hidden */
    export const QUICK_DIALOG_HIDE_BTN_CLASS: string;
    /** @hidden */
    export const EVENT_WINDOW_DIALOG_CLASS: string;
    /** @hidden */
    export const EVENT_WINDOW_DEVICE_CLASS: string;
    /** @hidden */
    export const EVENT_WINDOW_FORM_DIV_CLASS: string;
    /** @hidden */
    export const EVENT_WINDOW_FORM_CLASS: string;
    /** @hidden */
    export const EVENT_WINDOW_ALLDAY_TZ_DIV_CLASS: string;
    /** @hidden */
    export const EVENT_WINDOW_ALL_DAY_CLASS: string;
    /** @hidden */
    export const EVENT_WINDOW_TZ_CLASS: string;
    /** @hidden */
    export const EVENT_WINDOW_REPEAT_DIV_CLASS: string;
    /** @hidden */
    export const EVENT_WINDOW_REPEAT_CLASS: string;
    /** @hidden */
    export const EVENT_WINDOW_TITLE_LOCATION_DIV_CLASS: string;
    /** @hidden */
    export const EVENT_WINDOW_TITLE_CLASS: string;
    /** @hidden */
    export const EVENT_WINDOW_LOCATION_CLASS: string;
    /** @hidden */
    export const EVENT_WINDOW_START_END_DIV_CLASS: string;
    /** @hidden */
    export const EVENT_WINDOW_START_CLASS: string;
    /** @hidden */
    export const EVENT_WINDOW_END_CLASS: string;
    /** @hidden */
    export const EVENT_WINDOW_DESCRIPTION_CLASS: string;
    /** @hidden */
    export const EVENT_WINDOW_TIME_ZONE_DIV_CLASS: string;
    /** @hidden */
    export const EVENT_WINDOW_START_TZ_CLASS: string;
    /** @hidden */
    export const EVENT_WINDOW_END_TZ_CLASS: string;
    /** @hidden */
    export const EVENT_WINDOW_BACK_ICON_CLASS: string;
    /** @hidden */
    export const EVENT_WINDOW_SAVE_ICON_CLASS: string;
    /** @hidden */
    export const EVENT_WINDOW_DELETE_BUTTON_CLASS: string;
    /** @hidden */
    export const EVENT_WINDOW_CANCEL_BUTTON_CLASS: string;
    /** @hidden */
    export const EVENT_WINDOW_SAVE_BUTTON_CLASS: string;
    /** @hidden */
    export const EVENT_WINDOW_DIALOG_PARENT_CLASS: string;
    /** @hidden */
    export const EVENT_WINDOW_TITLE_TEXT_CLASS: string;
    /** @hidden */
    export const EVENT_WINDOW_ICON_DISABLE_CLASS: string;
    /** @hidden */
    export const SELECTED_EVENT_EDIT_CLASS: string;
    /** @hidden */
    export const SELECTED_EVENT_DELETE_CLASS: string;
    /** @hidden */
    export const SELECTED_DATE_TIME_CLASS: string;
    /** @hidden */
    export const SELECTED_CALENDER_CLASS: string;
    /** @hidden */
    export const SELECTED_EVENT_TITLE_CLASS: string;
    /** @hidden */
    export const SELECTED_EVENT_CONTAINER_CLASS: string;
    /** @hidden */
    export const SELECTED_EVENT_CLOSE_CLASS: string;
    /** @hidden */
    export const EVENT_TIME_ZONE_CLASS: string;
    /** @hidden */
    export const EVENT_ZONE_DETAILS_CLASS: string;
    /** @hidden */
    export const EVENT_DETAILS_CLASS: string;
    /** @hidden */
    export const EVENT_NOTE_CLASS: string;
    /** @hidden */
    export const EVENT_NOTE_DETAILS_CLASS: string;
    /** @hidden */
    export const EVENT_DISABLE_CLASS: string;
    /** @hidden */
    export const EVENT_EDIT_DISABLE_CLASS: string;
    /** @hidden */
    export const ERROR_VALIDATION_CLASS: string;
    /** @hidden */
    export const EVENT_TOOLTIP_ROOT_CLASS: string;
    /** @hidden */
    export const ALLDAY_ROW_ANIMATE_CLASS: string;
    
    /**
     * Interface
     */
    export interface TdData {
        date?: Date;
        className?: string[];
        colSpan?: number;
        rowSpan?: number;
        type: string;
        text?: string;
    }
    export interface TimeSlotData extends TdData {
        first: boolean;
        middle: boolean;
        last: boolean;
    }
    export interface ActionEventArgs extends ej.base.BaseEventArgs {
        requestType: string;
        event?: Event;
        cancel: boolean;
        data?: object;
    }
    export interface ToolbarActionArgs extends ej.base.BaseEventArgs {
        requestType: string;
        items: ej.navigations.ItemModel[];
    }
    export interface CellClickEventArgs extends ej.base.BaseEventArgs {
        startTime: Date;
        endTime: Date;
        isAllDay: boolean;
        element?: HTMLElement | HTMLElement[];
        cancel?: boolean;
        event?: Event;
    }
    export interface EventClickArgs extends ej.base.BaseEventArgs {
        date?: Date;
        event: {
            [key: string]: Object;
        } | {
            [key: string]: Object;
        }[];
        element: HTMLElement | HTMLElement[];
        cancel?: boolean;
    }
    export interface EventRenderedArgs extends ej.base.BaseEventArgs {
        data: {
            [key: string]: Object;
        };
        element: HTMLElement;
    }
    export interface PopupOpenEventArgs extends ej.base.BaseEventArgs {
        type: PopupType;
        data: Object;
        target?: Element;
        element: Element;
        cancel: boolean;
    }
    export interface KeyEventArgs {
        element: HTMLTableElement;
        rowIndex: number;
        columnIndex: number;
        maxIndex: number;
    }
    export interface NavigatingEventArgs extends ej.base.BaseEventArgs {
        action: string;
        cancel: boolean;
        previousDate?: Date;
        currentDate?: Date;
        previousView?: string;
        currentView?: string;
    }
    export interface RenderCellEventArgs extends ej.base.BaseEventArgs {
        elementType: string;
        element?: Element;
        date?: Date;
    }
    export interface CellTemplateArgs {
        date: Date;
        type: string;
    }
    /** @hidden */
    export interface CrudArgs extends ActionEventArgs {
        promise?: Promise<Object>;
    }
    /** @hidden */
    export interface IRenderer {
        element: HTMLElement;
        renderDates: Date[];
        viewClass: string;
        isInverseTableSelect: boolean;
        startDate(): Date;
        endDate(): Date;
        scrollToHour?(hour: string): void;
        highlightCurrentTime?(): void;
        getStartHour(): Date;
        getEndHour(): Date;
        getLabelText(view: string): string;
        getDateRangeText(): string;
        getEndDateFromStartDate?(date: Date): Date;
        addEventListener?(): void;
        removeEventListener?(): void;
        getRenderDates?(): void;
        getNextPreviousDate?(type: string): Date;
        renderLayout(type: string): void;
        setPanel(panel: HTMLElement): void;
        getPanel(): HTMLElement;
        adjustEventWrapper(): void;
        destroy(): void;
    }
    /** @hidden */
    export interface EJ2Instance extends HTMLElement {
        ej2_instances: Object[];
    }
    /** @hidden */
    export interface ScrollCss {
        padding?: string;
        border?: string;
    }
    /** @hidden */
    export interface NotifyEventArgs {
        module?: string;
        cssProperties?: ScrollCss;
        processedData?: Object[];
    }
    /** @hidden */
    export interface LayoutData {
        element: HTMLElement;
        selectedDate: Date;
    }
    /** @hidden */
    export interface PopupEventArgs {
        classList?: string[];
        data?: string[] | {
            [key: string]: Object;
        }[];
        fields?: EventFieldsMapping;
        id?: string;
        l10n?: {
            [key: string]: Object;
        };
    }
    export interface EventFieldsMapping {
        id?: string;
        subject?: string;
        startTime?: string;
        endTime?: string;
        startTimezone?: string;
        endTimezone?: string;
        location?: string;
        description?: string;
        isAllDay?: string;
        recurrenceID?: string;
        recurrenceRule?: string;
        recurrenceException?: string;
    }
    export interface ElementData {
        index: number;
        left: string;
        width: string;
        day: number;
        record: {
            [key: string]: Object;
        };
    }
    export interface SaveChanges {
        addedRecords: Object[];
        changedRecords: Object[];
        deletedRecords: Object[];
    }
    export interface UIStateArgs {
        expand?: boolean;
        isInitial?: boolean;
        left?: number;
        top?: number;
    }
    
    /**
     * Interface for a class Schedule
     */
    export interface ScheduleModel extends ej.base.ComponentModel{
    
        /**
         * Sets the `width` of the Schedule, accepting both string and number values.
         * When set to `auto`, the Schedule width gets auto-adjusted to display its content related to the viewable screen size.
         * @default 'auto'
         */
        width?: string | number;
    
        /**
         * Sets the `height` of the Schedule, accepting both string and number values.
         * When `height` is specified with certain pixel value and if the tooltip content overflows,
         * then the scrolling mode gets enabled on the tooltip.
         * @default 'auto'
         */
        height?: string | number;
    
        /**
         * When set to `false`, disables the header bar of the schedule.
         * @default false
         */
        showHeaderBar?: boolean;
    
        /**
         * When set to `false`, disables the current time indicator of the schedule.
         * @default true
         */
        showTimeIndicator?: boolean;
    
        /**
         * Current view of the schedule.
         * @default 'Week'
         */
        currentView?: View;
    
        /**
         * Views collection of the schedule.
         * @default '['Day', 'Week', 'WorkWeek', 'Month', 'Agenda']'
         */
        views?: View[] | ViewsModel[];
    
        /**
         * Current date of the schedule.
         * @default 'new Date()'
         */
        selectedDate?: Date;
    
        /**
         * Date format of the Schedule.
         * @default null
         */
        dateFormat?: string;
    
        /**
         * show week ends of schedule.
         * @default true
         */
        showWeekend?: boolean;
    
        /**
         * first day of the schedule.
         * @default '0'
         */
        firstDayOfWeek?: number;
    
        /**
         * work days of the schedule.
         * @default '0'
         */
        workDays?: number[];
    
        /**
         * Start Hour of the Schedule.
         * @default '00:00'
         */
        startHour?: string;
    
        /**
         * End Hour of the Schedule.
         * @default '24:00'
         */
        endHour?: string;
    
        /**
         * Specifies the work hours
         * @default WorkHours{ Highlight: true, start: '09:00', end: '18:00' }
         */
        workHours?: WorkHoursModel;
    
        /**
         * allow keyboard interaction
         * @default true
         */
        allowKeyboardInteraction?: boolean;
    
        /**
         * date header template for the Schedule.
         * @default null
         */
        dateHeaderTemplate?: string;
    
        /**
         * cell template for the Schedule.
         * @default null
         */
        cellTemplate?: string;
    
        /**
         * When set to `true`, makes the Scheduler to render in a read only mode. No CRUD actions will be allowed.
         * @default false
         */
        readonly?: boolean;
    
        /**
         * When set to `true`, on single clicking over the cells or on events,
         * displays the quick access pop up showing information of a clicked cell or an event.
         * @default true
         */
        showQuickInfo?: boolean;
    
        /**
         * Event window template for the Schedule.
         * @default null
         */
        editorTemplate?: string;
    
        /**
         * Sets the number of days to be displayed by default in Agenda View.
         * @default '7'
         */
        agendaDaysCount?: number;
    
        /**
         * The days that contains no single event will be hidden from the UI of Agenda View
         * @default true
         */
        hideEmptyAgendaDays?: boolean;
    
        /**
         * Accepts the timezone to Schedule.
         * @default null
         */
        timezone?: string;
    
        /**
         * To set the appointment related settings on Scheduler.
         * @default null
         */
        eventSettings?: EventSettingsModel;
    
        /**
         * Accepts the CSS class name to be applied for the Schedule.
         * @default null
         */
        cssClass?: string;
    
        /**
         * When set to `true`, enables the RTL mode on the Schedule, the schedule and its content displays in the direction from right to left.
         * @default false
         */
        enableRtl?: boolean;
    
        /**
         * Triggers after the Schedule control is created.
         * @event
         */
        created?: ej.base.EmitType<Object>;
    
        /**
         * Triggers when the Schedule control is destroyed.
         * @event
         */
        destroyed?: ej.base.EmitType<Object>;
    
        /**
         * Triggers when click the work cell.
         * @event
         */
        cellClick?: ej.base.EmitType<CellClickEventArgs>;
    
        /**
         * Triggers when double click the work cell.
         * @event
         */
        cellDoubleClick?: ej.base.EmitType<CellClickEventArgs>;
    
        /**
         * Triggers when the action begin.
         * @event
         */
        actionBegin?: ej.base.EmitType<ActionEventArgs>;
    
        /**
         * Triggers when the action completed.
         * @event
         */
        actionComplete?: ej.base.EmitType<ActionEventArgs>;
    
        /**
         * Triggers when the action failure.
         * @event
         */
        actionFailure?: ej.base.EmitType<ActionEventArgs>;
    
        /**
         * Triggers when date or view navigation occurs.
         * @event
         */
        navigating?: ej.base.EmitType<NavigatingEventArgs>;
    
        /**
         * Triggers when the element before render to DOM.
         * @event
         */
        renderCell?: ej.base.EmitType<RenderCellEventArgs>;
    
        /**
         * Triggers when the appointments are single clicked or on single touch on the mobile devices.
         * @event
         */
        eventClick?: ej.base.EmitType<EventClickArgs>;
    
        /**
         * Triggers after each of the appointment is getting rendered on the Scheduler.
         * @event
         */
        eventRendered?: ej.base.EmitType<EventRenderedArgs>;
    
        /**
         * Triggers before the data binds to the Scheduler.
         * @event
         */
        dataBinding?: ej.base.EmitType<ReturnType>;
    
        /**
         * Triggers before the Schedule popups open.
         * @event
         */
        popupOpen?: ej.base.EmitType<PopupOpenEventArgs>;
    
        /**
         * Triggers once the appointment data is bound to the Scheduler.
         * @event
         */
        dataBound?: ej.base.EmitType<ReturnType>;
    
    }
    
    /**
     * Represents the Schedule component.
     * ```html
     * <div id="schedule"></div>
     * ```
     * ```typescript
     * <script>
     *   var scheduleObj = new Schedule();
     *   scheduleObj.appendTo("#schedule");
     * </script>
     * ```
     */
    export class Schedule extends ej.base.Component<HTMLElement> implements ej.base.INotifyPropertyChanged {
        globalize: ej.base.Internationalization;
        localeObj:  ej.base.L10n;
        isAdaptive: Boolean;
        dataModule: Data;
        eventTooltip: EventTooltip;
        eventWindow: EventWindow;
        renderModule: Render;
        headerModule: HeaderRenderer;
        scrollModule: Scroll;
        crudModule: Crud;
        scheduleTouchModule: ScheduleTouch;
        keyboardInteractionModule: KeyboardInteraction;
        activeView: IRenderer;
        activeCellsData: CellClickEventArgs;
        activeEventData: EventClickArgs;
        eventBase: EventBase;
        private cellTemplateFn;
        private dateHeaderTemplateFn;
        private appointmentTemplateFn;
        private eventTooltipTemplateFn;
        private editorTemplateFn;
        private defaultLocale;
        dayModule: Day;
        weekModule: Week;
        workWeekModule: WorkWeek;
        monthAgendaModule: MonthAgenda;
        monthModule: Month;
        agendaModule: Agenda;
        viewOptions: {
            [key: string]: ViewsModel;
        };
        activeViewOptions: ViewsModel;
        eventFields: EventFieldsMapping;
        eventsData: Object[];
        eventsProcessed: Object[];
        currentAction: CurrentAction;
        quickPopup: QuickPopups;
        selectedElements: Element[];
        uiStateValues: UIStateArgs;
        /**
         * Sets the `width` of the Schedule, accepting both string and number values.
         * When set to `auto`, the Schedule width gets auto-adjusted to display its content related to the viewable screen size.
         * @default 'auto'
         */
        width: string | number;
        /**
         * Sets the `height` of the Schedule, accepting both string and number values.
         * When `height` is specified with certain pixel value and if the tooltip content overflows,
         * then the scrolling mode gets enabled on the tooltip.
         * @default 'auto'
         */
        height: string | number;
        /**
         * When set to `false`, disables the header bar of the schedule.
         * @default false
         */
        showHeaderBar: boolean;
        /**
         * When set to `false`, disables the current time indicator of the schedule.
         * @default true
         */
        showTimeIndicator: boolean;
        /**
         * Current view of the schedule.
         * @default 'Week'
         */
        currentView: View;
        /**
         * Views collection of the schedule.
         * @default '['Day', 'Week', 'WorkWeek', 'Month', 'Agenda']'
         */
        views: View[] | ViewsModel[];
        /**
         * Current date of the schedule.
         * @default 'new Date()'
         */
        selectedDate: Date;
        /**
         * Date format of the Schedule.
         * @default null
         */
        dateFormat: string;
        /**
         * show week ends of schedule.
         * @default true
         */
        showWeekend: boolean;
        /**
         * first day of the schedule.
         * @default '0'
         */
        firstDayOfWeek: number;
        /**
         * work days of the schedule.
         * @default '0'
         */
        workDays: number[];
        /**
         * Start Hour of the Schedule.
         * @default '00:00'
         */
        startHour: string;
        /**
         * End Hour of the Schedule.
         * @default '24:00'
         */
        endHour: string;
        /**
         * Specifies the work hours
         * @default WorkHours{ Highlight: true, start: '09:00', end: '18:00' }
         */
        workHours: WorkHoursModel;
        /**
         * allow keyboard interaction
         * @default true
         */
        allowKeyboardInteraction: boolean;
        /**
         * date header template for the Schedule.
         * @default null
         */
        dateHeaderTemplate: string;
        /**
         * cell template for the Schedule.
         * @default null
         */
        cellTemplate: string;
        /**
         * When set to `true`, makes the Scheduler to render in a read only mode. No CRUD actions will be allowed.
         * @default false
         */
        readonly: boolean;
        /**
         * When set to `true`, on single clicking over the cells or on events,
         * displays the quick access pop up showing information of a clicked cell or an event.
         * @default true
         */
        showQuickInfo: boolean;
        /**
         * Event window template for the Schedule.
         * @default null
         */
        editorTemplate: string;
        /**
         * Sets the number of days to be displayed by default in Agenda View.
         * @default '7'
         */
        agendaDaysCount: number;
        /**
         * The days that contains no single event will be hidden from the UI of Agenda View
         * @default true
         */
        hideEmptyAgendaDays: boolean;
        /**
         * Accepts the timezone to Schedule.
         * @default null
         */
        timezone: string;
        /**
         * To set the appointment related settings on Scheduler.
         * @default null
         */
        eventSettings: EventSettingsModel;
        /**
         * Accepts the CSS class name to be applied for the Schedule.
         * @default null
         */
        cssClass: string;
        /**
         * When set to `true`, enables the RTL mode on the Schedule, the schedule and its content displays in the direction from right to left.
         * @default false
         */
        enableRtl: boolean;
        /**
         * Triggers after the Schedule control is created.
         * @event
         */
        created: ej.base.EmitType<Object>;
        /**
         * Triggers when the Schedule control is destroyed.
         * @event
         */
        destroyed: ej.base.EmitType<Object>;
        /**
         * Triggers when click the work cell.
         * @event
         */
        cellClick: ej.base.EmitType<CellClickEventArgs>;
        /**
         * Triggers when double click the work cell.
         * @event
         */
        cellDoubleClick: ej.base.EmitType<CellClickEventArgs>;
        /**
         * Triggers when the action begin.
         * @event
         */
        actionBegin: ej.base.EmitType<ActionEventArgs>;
        /**
         * Triggers when the action completed.
         * @event
         */
        actionComplete: ej.base.EmitType<ActionEventArgs>;
        /**
         * Triggers when the action failure.
         * @event
         */
        actionFailure: ej.base.EmitType<ActionEventArgs>;
        /**
         * Triggers when date or view navigation occurs.
         * @event
         */
        navigating: ej.base.EmitType<NavigatingEventArgs>;
        /**
         * Triggers when the element before render to DOM.
         * @event
         */
        renderCell: ej.base.EmitType<RenderCellEventArgs>;
        /**
         * Triggers when the appointments are single clicked or on single touch on the mobile devices.
         * @event
         */
        eventClick: ej.base.EmitType<EventClickArgs>;
        /**
         * Triggers after each of the appointment is getting rendered on the Scheduler.
         * @event
         */
        eventRendered: ej.base.EmitType<EventRenderedArgs>;
        /**
         * Triggers before the data binds to the Scheduler.
         * @event
         */
        dataBinding: ej.base.EmitType<ReturnType>;
        /**
         * Triggers before the Schedule popups open.
         * @event
         */
        popupOpen: ej.base.EmitType<PopupOpenEventArgs>;
        /**
         * Triggers once the appointment data is bound to the Scheduler.
         * @event
         */
        dataBound: ej.base.EmitType<ReturnType>;
        /**
         * Constructor for creating the Schedule widget
         * @hidden
         */
        constructor(options?: ScheduleModel, element?: string | HTMLElement);
        /**
         * Core method that initializes the control rendering.
         * @private
         */
        render(): void;
        private validateDate();
        private setViewOptions(isModuleLoad?);
        private getActiveViewOptions(viewName);
        private initializeDataModule();
        private initializeView(viewName);
        private initializeTemplates();
        private initializePopups();
        getDayNames(type: string): string[];
        changeView(view: View, event?: Event, muteOnChange?: boolean): void;
        changeDate(selectedDate: Date, event?: Event): void;
        isSelectedDate(date: Date): boolean;
        private animateLayout();
        /**
         * To provide the array of modules needed for control rendering
         * @return {ej.base.ModuleDeclaration[]}
         * @hidden
         */
        requiredModules(): ej.base.ModuleDeclaration[];
        /**
         * Initializes the values of private members.
         * @private
         */
        protected preRender(): void;
        /**
         * Binding events to the Schedule element.
         * @hidden
         */
        private wireEvents();
        removeSelectedClass(): void;
        addSelectedClass(cells: HTMLTableCellElement[], focusCell: HTMLTableCellElement): void;
        selectCell(element: HTMLElement & HTMLTableCellElement): void;
        getSelectedElements(): Element[];
        getAllDayRow(): Element;
        getContentTable(): HTMLElement;
        getWorkCellElements(): Element[];
        getIndexOfDate(collection: Date[], date: Date): number;
        isAllDayCell(td: Element): boolean;
        getDateFromElement(td: Element): Date;
        getCellTemplate(): Function;
        getDateHeaderTemplate(): Function;
        getAppointmentTemplate(): Function;
        getEventTooltipTemplate(): Function;
        getEditorTemplate(): Function;
        private onDocumentClick(args);
        private onScheduleResize(args);
        private templateParser(template);
        /**
         * Unbinding events from the element on widget destroy.
         * @hidden
         */
        private unwireEvents();
        /**
         * Core method to return the component name.
         * @private
         */
        getModuleName(): string;
        /**
         * Returns the properties to be maintained in the persisted state.
         * @private
         */
        protected getPersistData(): string;
        /**
         * Called internally, if any of the property value changed.
         * @private
         */
        onPropertyChanged(newProp: ScheduleModel, oldProp: ScheduleModel): void;
        private extendedPropertyChange(prop, newProp, oldProp);
        private onEventSettingsPropertyChanged(newProp, oldProp);
        /**
         * To set dynamic work hours on different days
         * @method getCellDetails
         * @param {dates} dates dates collection
         * @param {string} start work start hour
         * @param {string} end work end hour
         * @returns {void}
         */
        setWorkHours(dates: Date[], start: string, end: string): void;
        /**
         * Get cell details
         * @method getCellDetails
         * @param  {Element} td Element to get details
         * @returns {CellClickArgs} Element start and end Time has provided
         */
        getCellDetails(td: Element): CellClickEventArgs;
        /**
         * Scrolls the Schedule content area to specified hour.
         * @method scrollTo
         * @param { string} hour Hour accept the skeleton 'Hm'
         * @return {void}
         */
        scrollTo(hour: string): void;
        /**
         * Record will be added through addEvent
         */
        addEvent(data: Object | Object[]): void;
        /**
         * Record will be updated through saveEvent
         */
        saveEvent(data: {
            [key: string]: Object;
        } | {
            [key: string]: Object;
        }[], currentAction?: CurrentAction): void;
        /**
         * Record will be updated through deleteEvent
         */
        deleteEvent(id: string | number | {
            [key: string]: Object;
        } | {
            [key: string]: Object;
        }[], currentAction?: CurrentAction): void;
        /**
         * Get the collections of appointments bound to Scheduler.
         */
        getEvents(): Object[];
        /**
         * Occurrences will be collected based on the Event Id
         */
        getOccurrencesByID(eventID: number): Object[];
        /**
         * Occurrences will be collected based on the specific start and end range
         */
        getOccurrencesByRange(startTime: Date, endTime: Date): Object[];
        /**
         * Get the current view appointments from Scheduler.
         */
        getCurrentViewEvents(): Object[];
        /**
         * To Refresh the appointments.
         */
        refreshEvents(): void;
        /**
         *  To get the appointment object from element.
         * @param element Appointment element to get data
         */
        getEventDetails(element: Element): Object;
        /**
         * To get the availability of appointment creation from given time difference
         * @param startTime Start range value
         * @param endTime End range value
         */
        isSlotAvailable(startTime: Date, endTime: Date): boolean;
        /**
         * To Open the editor window manually
         * @param data Event data or cell details
         * @param action CurrentAction
         */
        openEditor(data: Object, action: CurrentAction): void;
        /**
         * To adjust the events wrapper based on cells width
         */
        adjustEventWrapper(): void;
        /**
         * Destroys the Schedule widget.
         * @method destroy
         * @return {void}
         */
        destroy(): void;
    }
    
    /**
     * types
     */
    export type View = 'Day' | 'Week' | 'WorkWeek' | 'Month' | 'Agenda' | 'MonthAgenda';
    export type CurrentAction = 'Add' | 'Save' | 'Delete' | 'DeleteOccurrence' | 'DeleteSeries' | 'EditOccurrence' | 'EditSeries';
    export type ReturnType = {
        result: Object[];
        count: number;
        aggregates?: Object;
    };
    export type PopupType = 'Editor' | 'EventContainer' | 'QuickInfo' | 'RecurrenceAlert' | 'DeleteAlert' | 'ViewEventInfo' | 'EditEventInfo' | 'ValidationAlert';
    
    /**
     * Schedule common utilities
     */
    export const WEEK_LENGTH: number;
    export const MS_PER_DAY: number;
    export const MS_PER_MINUTE: number;
    export function getWeekFirstDate(date1: Date, firstDayOfWeek: number): Date;
    export function firstDateOfMonth(date: Date): Date;
    export function lastDateOfMonth(dt: Date): Date;
    export function getWeekNumber(dt: Date): number;
    export function setTime(date: Date, time: number): Date;
    export function resetTime(date: Date): Date;
    export function getDateInMs(date: Date): number;
    export function addDays(date: Date, i: number): Date;
    export function addMonths(date: Date, i: number): Date;
    export function addYears(date: Date, i: number): Date;
    export function getStartEndHours(date: Date, startHour: Date, endHour: Date): {
        [key: string]: Date;
    };
    export function getMaxDays(d: Date): number;
    export function getDaysCount(startDate: number, endDate: number): number;
    /** @hidden */
    export function getScrollBarWidth(): number;
    
    /**
     * AgendaBase for event rendering
     */
    export class AgendaBase {
        parent: Schedule;
        l10n:  ej.base.L10n;
        /**
         * Constructor for AgendaBase
         */
        constructor(parent: Schedule);
        createAgendaContentElement(type: string, listData: {
            [key: string]: Object;
        }[], aTd: Element): Element;
        createAppointment(event: {
            [key: string]: Object;
        }): HTMLElement[];
        processAgendaEvents(events: Object[]): Object[];
        wireEventActions(): void;
    }
    
    /**
     * EventBase for appointment rendering
     */
    export class EventBase {
        parent: Schedule;
        timezone: Timezone;
        /**
         * Constructor for EventBase
         */
        constructor(parent: Schedule);
        processData(events: {
            [key: string]: Object;
        }[], timeZonePropChanged?: boolean, oldTimezone?: string): Object[];
        /**
         * To handle the timezone property change
         */
        timezonePropertyChange(oldTimezone: string): void;
        private processTimezoneChange(event, oldTimezone);
        private processTimezone(event);
        filterEvents(startDate: Date, endDate: Date, collection?: Object[]): Object[];
        sortByTime(appointments: Object[]): Object[];
        sortByDateTime(appointments: Object[]): Object[];
        getSmallestMissingNumber(array: Object[]): number;
        splitEventByDay(event: {
            [key: string]: Object;
        }): Object[];
        getSelectedEventElements(target: Element): Element[];
        getSelectedEvents(): EventClickArgs;
        removeSelectedAppointmentClass(): void;
        addSelectedAppointments(cells: Element[], focusCell: Element): void;
        getSelectedAppointments(): Element[];
        focusElement(): void;
        selectWorkCellByTime(eventsData: Object[]): void;
        isAllDayAppointment(event: {
            [key: string]: Object;
        }): boolean;
        addEventListener(): void;
        private appointmentBorderRemove(event);
        wireAppointmentEvents(element: Element): void;
        private eventClick(eventData);
        eventDoubleClick(e: Event): void;
        getEventByGuid(guid: string): Object;
        generateGuid(): string;
        getEventMaxId(): number;
        private activeEventData(eventData);
        generateOccurrence(event: {
            [key: string]: Object;
        }, viewDate?: Date): Object[];
        getRecurrenceEvent(eventData: {
            [key: string]: Object;
        }): {
            [key: string]: Object;
        };
        getOccurrencesByID(id: number): Object[];
        getOccurrencesByRange(startTime: Date, endTime: Date): Object[];
    }
    
    /**
     * Month view events render
     */
    export class MonthEvent extends EventBase {
        private element;
        private fields;
        private dateRender;
        private renderedEvents;
        private eventHeight;
        private monthHeaderHeight;
        private slots;
        private workCells;
        private cellWidth;
        private cellHeight;
        /**
         * Constructor for month events
         */
        constructor(parent: Schedule);
        renderAppointments(): void;
        private splitEvent(event);
        private cloneEventObject(event, start, end, count, isLeft, isRight);
        private dateInRange(date, start, end);
        private getElementHeightFromClass(container, elementClass);
        private getOuterHeight(element);
        private createAppointmentElement(record);
        private renderAppointmentMonth(event);
        private getIndex(record, date);
        private moreIndicatorClick(event);
    }
    
    /**
     * Vertical view appointment rendering
     */
    export class AppointmentRendering extends EventBase {
        private dateRender;
        private renderedEvents;
        private renderedAllDayEvents;
        private overlapEvents;
        private moreEvents;
        private overlapList;
        private minorSlotCount;
        private majorSlot;
        private allDayLevel;
        private startHour;
        private endHour;
        private element;
        private allDayElement;
        private animation;
        /**
         * Constructor for vertical view
         */
        constructor(parent: Schedule);
        renderAppointments(): void;
        private createAppointmentElement(record, isAllDay, data);
        private createMoreIndicator(allDayRow, count, currentDay);
        private renderSpannedIcon(element, spanEvent, isAllDay);
        private isSpannedEvent(record, day, isAllDay);
        private getAllDayCounts(record, eStart, eEnd, day);
        private renderAllDayEvents(event);
        private renderVerticalEvents(eventObj, day);
        private getTopValue(date, day);
        private getAppointmentHeight(cellHeight, startDate, endDate);
        private getOverlapIndex(record, day, isAllDay);
        private adjustOverlapElements(args);
        private setAllDayRowHeight(height);
        private addOrRemoveClass();
        private getEventHeight();
        private isRowExpand();
        private isRowCollapse();
        private rowExpandCollapse(event);
        private animationUiUpdate();
    }
    
    /**
     * Interface for a class EventSettings
     */
    export interface EventSettingsModel {
    
        /**
         * Defines the appointment template
         * @default null
         */
        template?: string;
    
        /**
         * It is used to render appointments in schedule.
         * If the `dataSource` is an array of JavaScript objects, 
         * then Schedule will create instance of [`DataManager`](http://ej2.syncfusion.com/documentation/data/api-dataManager.html) 
         * from this `dataSource`. 
         * If the `dataSource` is an existing [`DataManager`](http://ej2.syncfusion.com/documentation/data/api-dataManager.html),
         *  the Schedule will not initialize a new one. 
         * @default []    
         */
        dataSource?: Object[] | ej.data.DataManager;
    
        /**
         * Defines the external [`Query`](http://ej2.syncfusion.com/documentation/data/api-query.html) 
         * which will execute along with data processing.    
         * @default null    
         */
        query?: ej.data.Query;
    
        /**
         * Mapper fields for appointments
         * @default null    
         */
        fields?: FieldModel;
    
        /**
         * Displays normal tooltip over the appointments.
         * @default false
         */
        enableTooltip?: boolean;
    
        /**
         * To apply customizations on the appointments tooltip design.
         * @default null
         */
        tooltipTemplate?: string;
    
    }
    
    /**
     * Configures the event options of Schedule.
     */
    export class EventSettings extends ej.base.ChildProperty<EventSettings> {
        /**
         * Defines the appointment template
         * @default null
         */
        template: string;
        /**
         * It is used to render appointments in schedule.
         * If the `dataSource` is an array of JavaScript objects,
         * then Schedule will create instance of [`DataManager`](http://ej2.syncfusion.com/documentation/data/api-dataManager.html)
         * from this `dataSource`.
         * If the `dataSource` is an existing [`DataManager`](http://ej2.syncfusion.com/documentation/data/api-dataManager.html),
         *  the Schedule will not initialize a new one.
         * @default []
         */
        dataSource: Object[] | ej.data.DataManager;
        /**
         * Defines the external [`Query`](http://ej2.syncfusion.com/documentation/data/api-query.html)
         * which will execute along with data processing.
         * @default null
         */
        query: ej.data.Query;
        /**
         * Mapper fields for appointments
         * @default null
         */
        fields: FieldModel;
        /**
         * Displays normal tooltip over the appointments.
         * @default false
         */
        enableTooltip: boolean;
        /**
         * To apply customizations on the appointments tooltip design.
         * @default null
         */
        tooltipTemplate: string;
    }
    
    /**
     * Interface for a class FieldOptions
     */
    export interface FieldOptionsModel {
    
        /**
         * Field name to be mapped from database
         * @default null
         */
        name?: string;
    
        /**
         * To assign some default value to the fields, when no specific value is assigned.
         * @default null
         */
        default?: string;
    
        /**
         * Validation to be applied on appointment fields of appointment window.
         * @default {}
         */
        validation?: Object;
    
    }
    /**
     * Configures the field mapping options of Schedule.
     */
    export class FieldOptions {
        /**
         * Field name to be mapped from database
         * @default null
         */
        name: string;
        /**
         * To assign some default value to the fields, when no specific value is assigned.
         * @default null
         */
        default: string;
        /**
         * Validation to be applied on appointment fields of appointment window.
         * @default {}
         */
        validation: Object;
    }
    
    /**
     * Interface for a class Field
     */
    export interface FieldModel {
    
        /**
         * id field to be mapped from database
         * @default null
         */
        id?: FieldOptionsModel;
    
        /**
         * subject field to be mapped from database
         * @default null
         */
        subject?: FieldOptionsModel;
    
        /**
         * startTime field to be mapped from database
         * @default null
         */
        startTime?: FieldOptionsModel;
    
        /**
         * endTime field to be mapped from database
         * @default null
         */
        endTime?: FieldOptionsModel;
    
        /**
         * startTimezone field to be mapped from database
         * @default null
         */
        startTimezone?: FieldOptionsModel;
    
        /**
         * endTimezone field to be mapped from database
         * @default null
         */
        endTimezone?: FieldOptionsModel;
    
        /**
         * location field to be mapped from database
         * @default null
         */
        location?: FieldOptionsModel;
    
        /**
         * description field to be mapped from database
         * @default null
         */
        description?: FieldOptionsModel;
    
        /**
         * isAllDay field to be mapped from database
         * @default null
         */
        isAllDay?: FieldOptionsModel;
    
        /**
         * recurrenceID field to be mapped from database
         * @default null
         */
        recurrenceID?: FieldOptionsModel;
    
        /**
         * recurrenceRule field to be mapped from database
         * @default null
         */
        recurrenceRule?: FieldOptionsModel;
    
        /**
         * recurrenceException field to be mapped from database
         * @default null
         */
        recurrenceException?: FieldOptionsModel;
    
    }
    
    /**
     * Configures the field options of Schedule.
     */
    export class Field extends ej.base.ChildProperty<Field> {
        /**
         * id field to be mapped from database
         * @default null
         */
        id: FieldOptionsModel;
        /**
         * subject field to be mapped from database
         * @default null
         */
        subject: FieldOptionsModel;
        /**
         * startTime field to be mapped from database
         * @default null
         */
        startTime: FieldOptionsModel;
        /**
         * endTime field to be mapped from database
         * @default null
         */
        endTime: FieldOptionsModel;
        /**
         * startTimezone field to be mapped from database
         * @default null
         */
        startTimezone: FieldOptionsModel;
        /**
         * endTimezone field to be mapped from database
         * @default null
         */
        endTimezone: FieldOptionsModel;
        /**
         * location field to be mapped from database
         * @default null
         */
        location: FieldOptionsModel;
        /**
         * description field to be mapped from database
         * @default null
         */
        description: FieldOptionsModel;
        /**
         * isAllDay field to be mapped from database
         * @default null
         */
        isAllDay: FieldOptionsModel;
        /**
         * recurrenceID field to be mapped from database
         * @default null
         */
        recurrenceID: FieldOptionsModel;
        /**
         * recurrenceRule field to be mapped from database
         * @default null
         */
        recurrenceRule: FieldOptionsModel;
        /**
         * recurrenceException field to be mapped from database
         * @default null
         */
        recurrenceException: FieldOptionsModel;
    }
    
    /**
     * Export model files
     */
    
    /**
     * Interface for a class Views
     */
    export interface ViewsModel {
    
        /**
         * Defines view name
         * @default null
         */
        option?: View;
    
        /**
         * Defines the view selected
         * @default false
         */
        isSelected?: boolean;
    
        /**
         * Defines the date format.
         * @default null
         */
        dateFormat?: string;
    
        /**
         * Defines the read only
         * @default false
         */
        readonly?: boolean;
    
        /**
         * Defines start hour.
         * @default '00:00'
         */
        startHour?: string;
    
        /**
         * Defines end hour.
         * @default '24:00'
         */
        endHour?: string;
    
        /**
         * Defines allowVirtualScrolling.
         * @default true
         */
        allowVirtualScrolling?: boolean;
    
        /**
         * Defines dateHeaderTemplate.
         * @default null
         */
        dateHeaderTemplate?: string;
    
        /**
         * Defines cellTemplate.
         * @default null
         */
        cellTemplate?: string;
    
        /**
         * Defines eventTemplate.
         * @default null
         */
        eventTemplate?: string;
    
        /**
         * show week ends of schedule.
         * @default true
         */
        showWeekend?: boolean;
    
        /**
         * work days of the schedule.
         * @default '0'
         */
        workDays?: number[];
    
    }
    
    /**
     * Configures the view options of Schedule.
     */
    export class Views extends ej.base.ChildProperty<Views> {
        /**
         * Defines view name
         * @default null
         */
        option: View;
        /**
         * Defines the view selected
         * @default false
         */
        isSelected: boolean;
        /**
         * Defines the date format.
         * @default null
         */
        dateFormat: string;
        /**
         * Defines the read only
         * @default false
         */
        readonly: boolean;
        /**
         * Defines start hour.
         * @default '00:00'
         */
        startHour: string;
        /**
         * Defines end hour.
         * @default '24:00'
         */
        endHour: string;
        /**
         * Defines allowVirtualScrolling.
         * @default true
         */
        allowVirtualScrolling: boolean;
        /**
         * Defines dateHeaderTemplate.
         * @default null
         */
        dateHeaderTemplate: string;
        /**
         * Defines cellTemplate.
         * @default null
         */
        cellTemplate: string;
        /**
         * Defines eventTemplate.
         * @default null
         */
        eventTemplate: string;
        /**
         * show week ends of schedule.
         * @default true
         */
        showWeekend: boolean;
        /**
         * work days of the schedule.
         * @default '0'
         */
        workDays: number[];
    }
    
    /**
     * Interface for a class WorkHours
     */
    export interface WorkHoursModel {
    
        /**
         * Enable or disable business hours.
         * @default true
         */
        highlight?: boolean;
    
        /**
         * Defines the business start hour.  
         * @default '09:00'
         */
        start?: string;
    
        /**
         * Defines the business end hour.
         * @default '18:00'
         */
        end?: string;
    
    }
    
    /**
     * Configures the work hours behavior of Schedule.
     */
    export class WorkHours extends ej.base.ChildProperty<WorkHours> {
        /**
         * Enable or disable business hours.
         * @default true
         */
        highlight: boolean;
        /**
         * Defines the business start hour.
         * @default '09:00'
         */
        start: string;
        /**
         * Defines the business end hour.
         * @default '18:00'
         */
        end: string;
    }
    
    /**
     * Tooltip on appointments in Schedule
     */
    export class EventTooltip {
        private parent;
        private tooltipObj;
        private l10n;
        constructor(parent: Schedule);
        private onBeforeRender(args);
        close(): void;
        /**
         * To destroy the event tooltip.
         * @return {void}
         * @private
         */
        destroy(): void;
    }
    
    /**
     * Event editor window
     */
    export class EventWindow {
        parent: Schedule;
        dialogObject: ej.popups.Dialog;
        private element;
        private fields;
        private l10n;
        private eventData;
        private fieldValidator;
        private recurrenceEditor;
        private repeatDialogObject;
        private repeatTempRule;
        private repeatRule;
        private repeatStatus;
        private repeatStartDate;
        private cellClickAction;
        private timezone;
        /**
         * Constructor for event window
         */
        constructor(parent: Schedule);
        private renderEventWindow();
        openEditor(data: Object, type: CurrentAction): void;
        setDialogContent(): void;
        private onBeforeOpen(args);
        private onBeforeClose(args);
        private getEventWindowContent();
        private getDefaultEventWindowContent();
        private createRecurrenceEditor(parentDiv);
        private createDivElement(className);
        private createInputElement(className, fieldName, type?);
        private renderDateTimePicker(value);
        private onTimeChange(args);
        private renderDropDown(value);
        private onTimezoneChange();
        private renderCheckBox(value);
        private renderTextBox(value);
        private getFieldName(name);
        private onChange(args);
        private renderRepeatDialog();
        private loadRecurrenceEditor();
        private onRepeatChange(state);
        private repeatSaveDialog();
        private closeRepeatDialog();
        private repeatCancelDialog();
        private repeatOpenDialog();
        private onCellDetailsUpdate(args);
        private applyFormValidation();
        private showDetails(eventData);
        private onAllDayChange(allDayStatus);
        private updateDateTime(allDayStatus, startObj, endObj);
        private getFormat(formatType);
        private onEventDetailsUpdate(eventObj);
        private renderRecurrenceEditor();
        private updateRepeatLabel(repeatRule);
        private dialogClose(args);
        private timezoneChangeStyle(value);
        private resetFormFields();
        private eventSave();
        private getEventIdFromForm();
        private getFormElements();
        private getValueFromElement(element);
        private setValueToElement(element, value);
        private setDefaultValueToElement(element);
        private getInstance(className);
        private eventDelete(args);
        getRecurrenceEditorInstance(): RecurrenceEditor;
        /**
         * To destroy the event window.
         * @return {void}
         * @private
         */
        destroy(): void;
    }
    
    /**
     * Appointment window field validation
     */
    export class FieldValidator {
        private parent;
        formObj: ej.inputs.FormValidator;
        constructor(parent: Schedule);
        renderFormValidator(form: HTMLFormElement, rules: {
            [key: string]: Object;
        }): void;
        private validationComplete(args);
        private errorPlacement(inputElement, error);
        private createTooltip(element, error, name, display);
        destroyToolTip(): void;
        /**
         * @hidden
         */
        destroyForm(): void;
    }
    
    /**
     * Quick Popups interactions
     */
    export class QuickPopups {
        private l10n;
        private flatButton;
        private primaryButton;
        private parent;
        private crudAction;
        private selectedEventPopup;
        private multipleEventPopup;
        private isMultipleEventSelect;
        quickDialog: ej.popups.Dialog;
        quickPopup: ej.popups.Tooltip;
        morePopup: ej.popups.Popup;
        eventPopup: ej.popups.Popup;
        private fieldValidator;
        /**
         * Constructor for QuickPopups
         */
        constructor(parent: Schedule);
        render(): void;
        private renderQuickPopup();
        private renderQuickDialog();
        private renderMoreEventPopup();
        private dayNavigationClick(e);
        renderEventPopup(): void;
        openRecurrenceAlert(): void;
        openDeleteAlert(): void;
        openValidationError(type: string): void;
        private showQuickDialog(popupType);
        private createMoreEventList(events);
        eventHold(args: Event): void;
        private cellClick(args);
        private applyFormValidation();
        private eventClick(events);
        private deviceEventClick(events);
        private showEventPopup(popupType);
        private getFormattedString(eventData, type);
        moreEventClick(data: EventClickArgs): void;
        private saveClick();
        private detailsClick();
        private editClick(event);
        deleteClick(): void;
        private closeClick();
        private dialogButtonClick(event);
        private selectedEventDialog(target);
        private getTimezone(event);
        private getTimeDetails(event);
        private getDateFormat(date, formatString);
        private afterQuickPopupOpen(args);
        private beforeQuickPopupOpen(args);
        private getDataFromTarget(target);
        private beforeQuickPopupClose(args);
        private beforeQuickDialogClose(args);
        private keyPress(event);
        private afterMorePopupOpen(event);
        private afterMorePopupClose(event);
        private afterQuickPopupClose(args);
        private quickDialogClass(action);
        private documentClick(e);
        onClosePopup(): void;
        addEventListener(): void;
        /**
         * Destroys the Quick Popups.
         * @method destroy
         * @return {void}
         */
        destroy(): void;
    }
    
    /**
     * agenda view
     */
    export class Agenda extends ViewBase implements IRenderer {
        viewClass: string;
        isInverseTableSelect: boolean;
        agendaDates: {
            [key: string]: Date;
        };
        virtualScrollTop: number;
        minDate: Date;
        maxDate: Date;
        agendaBase: AgendaBase;
        /**
         * Constructor for agenda view
         */
        constructor(parent: Schedule);
        /**
         * Get module name.
         */
        protected getModuleName(): string;
        renderLayout(): void;
        private eventLoad(args);
        private refreshEvent(refreshDate);
        renderContent(tBody: Element, agendaDate: Date): void;
        private renderEmptyContent(tBody, agendaDate);
        private createTableRowElement(date, type);
        private createDateHeaderElement(date);
        private agendaScrolling(event);
        private virtualScrolling(event);
        private getElementFromScrollerPosition(event, direction?);
        private updateHeaderText(date?);
        private getPreviousNextDate(date, type);
        private appointmentFiltering(startDate?, endDate?);
        getStartDateFromEndDate(endDate: Date): Date;
        getEndDateFromStartDate(startDate: Date): Date;
        getNextPreviousDate(type: string): Date;
        startDate(): Date;
        endDate(): Date;
        getDateRangeText(date?: Date): string;
        dayNavigationClick(e: Event): void;
        private wireEvents();
        private unWireEvents();
        addEventListener(): void;
        removeEventListener(): void;
        private onAgendaScrollUiUpdate(args);
        /**
         * To destroy the agenda.
         * @return {void}
         * @private
         */
        destroy(): void;
    }
    
    /**
     * day view
     */
    export class Day extends VerticalView {
        viewClass: string;
        /**
         * Constructor for day view
         */
        constructor(parent: Schedule);
        getNextPreviousDate(type: string): Date;
        getDateRangeText(): string;
        /**
         * Get module name.
         */
        protected getModuleName(): string;
    }
    
    /**
     * Header module
     */
    export class HeaderRenderer {
        element: HTMLElement;
        private parent;
        private l10n;
        private toolbarObj;
        private headerPopup;
        private headerCalendar;
        /**
         * Constructor for render module
         */
        constructor(parent: Schedule);
        addEventListener(): void;
        removeEventListener(): void;
        private closeHeaderPopup(e);
        /** @hidden */
        hideHeaderPopup(): void;
        renderHeader(): void;
        private renderToolbar();
        updateItems(): void;
        getPopUpRelativeElement(): HTMLElement;
        setDayOfWeek(index: number): void;
        setCalendarDate(date: Date): void;
        getCalendarView(): ej.calendars.CalendarView;
        setCalendarView(): void;
        setRtl(isRtl: boolean): void;
        updateActiveView(): void;
        updateDateRange(text?: string): void;
        private getDateRangeText();
        private getItems();
        private getItemObject(viewName);
        private renderHeaderPopup();
        private calendarChange(args);
        private toolbarClickHandler(args);
        getHeaderElement(): HTMLElement;
        /**
         * Get module name.
         */
        protected getModuleName(): string;
        /**
         * To destroy the headerbar.
         * @return {void}
         * @private
         */
        destroy(): void;
    }
    
    /**
     * month agenda view
     */
    export class MonthAgenda extends Month {
        dayNameFormat: string;
        viewClass: string;
        agendaDates: {
            [key: string]: Date;
        };
        agendaBase: AgendaBase;
        /**
         * Constructor
         */
        constructor(parent: Schedule);
        renderAppointmentContainer(): void;
        getDayNameFormat(): string;
        onDataReady(args: NotifyEventArgs): void;
        onCellClick(event: CellClickEventArgs): void;
        private onEventRender(events);
        private appointmentFiltering(date);
        private appendAppContainer(appWrap);
        /**
         * Get module name.
         */
        protected getModuleName(): string;
    }
    
    /**
     * month view
     */
    export class Month extends ViewBase implements IRenderer {
        colLevels: TdData[][];
        dayNameFormat: string;
        viewClass: string;
        isInverseTableSelect: boolean;
        private workCellAction;
        /**
         * Constructor for month view
         */
        constructor(parent: Schedule);
        addEventListener(): void;
        removeEventListener(): void;
        onDataReady(args: NotifyEventArgs): void;
        onCellClick(event: CellClickEventArgs): void;
        private onContentScroll(e);
        private onScrollUiUpdate(args);
        private generateColLevels();
        getDayNameFormat(): string;
        renderLayout(type: string): void;
        private wireCellEvents(element);
        renderHeader(): void;
        renderContent(): void;
        renderAppointmentContainer(): void;
        private renderDatesHeader();
        private createHeaderCell(td);
        private isOtherMonth(date);
        private renderContentArea();
        getDatesHeaderElement(): HTMLElement;
        getContentAreaElement(): HTMLElement;
        private renderDateHeaderElement(data, ntd);
        getRenderDates(): void;
        getNextPreviousDate(type: string): Date;
        getEndDateFromStartDate(start: Date): Date;
        getDateRangeText(): string;
        getLabelText(view: string): string;
        /**
         * Get module name.
         */
        protected getModuleName(): string;
        /**
         * To destroy the month.
         * @return {void}
         * @private
         */
        destroy(): void;
    }
    
    /**
     * Schedule DOM rendering
     */
    export class Render {
        parent: Schedule;
        /**
         * Constructor for render
         */
        constructor(parent: Schedule);
        render(viewName: View): void;
        private initializeLayout(viewName);
        updateLabelText(view: string): void;
        refreshDataManager(): void;
        private dataManagerSuccess(e);
        private dataManagerFailure(e);
    }
    
    /**
     * vertical view
     */
    export class VerticalView extends ViewBase implements IRenderer {
        colLevels: TdData[][];
        currentTimeIndicatorTimer: number;
        currentDateIndex: number;
        minorSlotCount: number;
        majorSlot: number;
        viewClass: string;
        isInverseTableSelect: boolean;
        private workCellAction;
        /**
         * Constructor for vertical view
         */
        constructor(parent: Schedule);
        addEventListener(): void;
        removeEventListener(): void;
        private renderEvents();
        private onContentScroll(e);
        private scrollUiUpdate(args);
        private scrollToWorkHour();
        scrollToHour(hour: string): void;
        private generateColLevels();
        private isWorkHourRange(date);
        highlightCurrentTime(): void;
        private clearCurrentTimeIndicatorTimer();
        private removeCurrentTimeIndicatorElements();
        private changeCurrentTimePosition();
        private getTopFromDateTime(date);
        private getWorkCellHeight();
        private getTdContent(date, type);
        renderLayout(type: string): void;
        renderHeader(): void;
        renderContent(): void;
        private renderLeftIndent();
        private renderDatesHeader();
        createTd(td: TdData): Element;
        private wireCellEvents(element);
        private renderTimeCells();
        private renderContentArea();
        private getScrollableElement();
        getDatesHeaderElement(): HTMLElement;
        getTimeCellsElement(): HTMLElement;
        getContentAreaElement(): HTMLElement;
        getEndDateFromStartDate(start: Date): Date;
        adjustEventWrapper(): void;
        private getTimeSlotRows(handler?);
        /**
         * Get module name.
         */
        protected getModuleName(): string;
        /**
         * To destroy the vertical view.
         * @return {void}
         * @private
         */
        destroy(): void;
    }
    
    /**
     * view base
     */
    export class ViewBase {
        element: HTMLElement;
        parent: Schedule;
        l10n: ej.base.L10n;
        renderDates: Date[];
        customHelper: Object;
        /**
         * Constructor
         */
        constructor(parent: Schedule);
        createTableLayout(className?: string): Element;
        renderPanel(type: string): void;
        setPanel(panel: HTMLElement): void;
        getPanel(): HTMLElement;
        adjustEventWrapper(): void;
        startDate(): Date;
        endDate(): Date;
        getStartHour(): Date;
        getEndHour(): Date;
        isCurrentDate(date: Date): boolean;
        isCurrentMonth(date: Date): boolean;
        isWorkDay(date: Date): boolean;
        isWorkHour(date: Date): boolean;
        getRenderDates(): void;
        getNextPreviousDate(type: string): Date;
        getLabelText(view: string): string;
        getDateRangeText(): string;
        formatDateRange(startDate: Date, endDate?: Date): string;
        getMobileDateElement(date: Date, className?: string): Element;
    }
    
    /**
     * week view
     */
    export class Week extends VerticalView {
        viewClass: string;
        /**
         * Constructor
         */
        constructor(parent: Schedule);
        getRenderDates(): void;
        /**
         * Get module name.
         */
        protected getModuleName(): string;
    }
    
    /**
     * work week view
     */
    export class WorkWeek extends VerticalView {
        viewClass: string;
        /**
         * Constructor
         */
        constructor(par: Schedule);
        getRenderDates(): void;
        /**
         * Get module name.
         */
        protected getModuleName(): string;
    }
    
    /**
     * Time zone
     */
    export class Timezone {
        offset(date: Date, timezone: string): number;
        convert(date: Date, fromOffset: number & string, toOffset: number & string): Date;
        add(date: Date, timezone: string): Date;
        remove(date: Date, timezone: string): Date;
        removeLocalOffset(date: Date): Date;
    }
    export let localTimezoneName: string;
    export let timezoneData: {
        [key: string]: Object;
    }[];
    
  }
  export namespace splitbuttons {
    
    export type SplitButtonIconPosition = 'Left' | 'Top';
    /**
     * @param props
     * @param model
     */
    export function getModel(props: Object, model: string[]): Object;
    
    /**
     * Interface for a class Item
     */
    export interface ItemModel {
    
        /**
         * Defines class/multiple classes separated by a space for the item that is used to include an icon.
         * Action item can include font icon and sprite image.
         * @default ''
         */
        iconCss?: string;
    
        /**
         * Specifies the id for item.
         * @default ''
         */
        id?: string;
    
        /**
         * Specifies separator between the items. Separator are horizontal lines used to group action items.
         * @default false
         */
        separator?: boolean;
    
        /**
         * Specifies text for item.
         * @default ''
         */
        text?: string;
    
        /**
         * Specifies url for item that creates the anchor link to navigate to the url provided.
         * @default ''
         */
        url?: string;
    
    }
    
    /**
     * Interface for a class DropDownButton
     */
    export interface DropDownButtonModel extends ej.base.ComponentModel{
    
        /**
         * Defines class/multiple classes separated by a space for the Button that is used to include an icon.
         * Buttons can also include font icon and sprite image.
         * @default ""
         */
        iconCss?: string;
    
        /**
         * Specifies a value that indicates whether the Button is `disabled` or not.
         * @default false.
         */
        disabled?: boolean;
    
        /**
         * Defines class/multiple classes separated by a space in the Button element. The Button types, styles, and
         * size can be defined by using this.
         * @default ""
         */
        cssClass?: string;
    
        /**
         * Defines the `content` of the Button element that can either be a text or HTML elements.
         * @default ""
         */
        content?: string;
    
        /**
         * Positions the icon before/after the text content in the DropDownButton.
         * The possible values are:
         * * Left: The icon will be positioned to the left of the text content.
         * * Top: The icon will be positioned to the top of the text content.
         * @default "Left"
         */
        iconPosition?: SplitButtonIconPosition;
    
        /**
         * Allows to specify the drop-down item element.
         * @default ""
         */
        target?: string | Element;
    
        /**
         * Specifies action items with its properties which will be rendered as drop-down for DropDownButton.
         * @default []
         */
        items?: ej.navigations.ItemModel[];
    
        /**
         * Triggers while rendering each item.
         * @event
         */
        beforeItemRender?: ej.base.EmitType<ej.navigations.MenuEventArgs>;
    
        /**
         * Triggers before opening the drop-down item.
         * @event
         */
        beforeOpen?: ej.base.EmitType<ej.navigations.BeforeOpenCloseMenuEventArgs>;
    
        /**
         * Triggers while opening the drop-down item.
         * @event
         */
        open?: ej.base.EmitType<OpenCloseMenuEventArgs>;
    
        /**
         * Triggers before closing the drop-down item.
         * @event
         */
        beforeClose?: ej.base.EmitType<ej.navigations.BeforeOpenCloseMenuEventArgs>;
    
        /**
         * Triggers while closing the drop-down.
         * @event
         */
        close?: ej.base.EmitType<OpenCloseMenuEventArgs>;
    
        /**
         * Triggers while selecting action item.
         * @event
         */
        select?: ej.base.EmitType<ej.navigations.MenuEventArgs>;
    
    }
    
    export class Item extends ej.base.ChildProperty<Item> {
        /**
         * Defines class/multiple classes separated by a space for the item that is used to include an icon.
         * Action item can include font icon and sprite image.
         * @default ''
         */
        iconCss: string;
        /**
         * Specifies the id for item.
         * @default ''
         */
        id: string;
        /**
         * Specifies separator between the items. Separator are horizontal lines used to group action items.
         * @default false
         */
        separator: boolean;
        /**
         * Specifies text for item.
         * @default ''
         */
        text: string;
        /**
         * Specifies url for item that creates the anchor link to navigate to the url provided.
         * @default ''
         */
        url: string;
    }
    /**
     * DropDownButton component is used to toggle contextual overlays for displaying list of
     * links that containing action items. It can contain both text and images.
     * ``````html
     * <button id="button">DropDownButton</button>
     * ```
     * ```typescript
     * <script>
     * var dropDownButtonObj = new DropDownButton({items: [{ text: 'Action1' }, { text: 'Action2' },{ text: 'Action3' }]);
     * dropDownButtonObj.appendTo("#button");
     * </script>
     * ```
     */
    export class DropDownButton extends ej.base.Component<HTMLButtonElement> implements ej.base.INotifyPropertyChanged {
        protected dropDown: ej.popups.Popup;
        protected button: ej.buttons.Button;
        protected activeElem: HTMLElement;
        /**
         * Defines class/multiple classes separated by a space for the Button that is used to include an icon.
         * Buttons can also include font icon and sprite image.
         * @default ""
         */
        iconCss: string;
        /**
         * Specifies a value that indicates whether the Button is `disabled` or not.
         * @default false.
         */
        disabled: boolean;
        /**
         * Defines class/multiple classes separated by a space in the Button element. The Button types, styles, and
         * size can be defined by using this.
         * @default ""
         */
        cssClass: string;
        /**
         * Defines the `content` of the Button element that can either be a text or HTML elements.
         * @default ""
         */
        content: string;
        /**
         * Positions the icon before/after the text content in the DropDownButton.
         * The possible values are:
         * * Left: The icon will be positioned to the left of the text content.
         * * Top: The icon will be positioned to the top of the text content.
         * @default "Left"
         */
        iconPosition: SplitButtonIconPosition;
        /**
         * Allows to specify the drop-down item element.
         * @default ""
         */
        target: string | Element;
        /**
         * Specifies action items with its properties which will be rendered as drop-down for DropDownButton.
         * @default []
         */
        items: ej.navigations.ItemModel[];
        /**
         * Triggers while rendering each item.
         * @event
         */
        beforeItemRender: ej.base.EmitType<ej.navigations.MenuEventArgs>;
        /**
         * Triggers before opening the drop-down item.
         * @event
         */
        beforeOpen: ej.base.EmitType<ej.navigations.BeforeOpenCloseMenuEventArgs>;
        /**
         * Triggers while opening the drop-down item.
         * @event
         */
        open: ej.base.EmitType<OpenCloseMenuEventArgs>;
        /**
         * Triggers before closing the drop-down item.
         * @event
         */
        beforeClose: ej.base.EmitType<ej.navigations.BeforeOpenCloseMenuEventArgs>;
        /**
         * Triggers while closing the drop-down.
         * @event
         */
        close: ej.base.EmitType<OpenCloseMenuEventArgs>;
        /**
         * Triggers while selecting action item.
         * @event
         */
        select: ej.base.EmitType<ej.navigations.MenuEventArgs>;
        /**
         * Constructor for creating the widget
         * @param  {DropDownButtonModel} options?
         * @param  {string|HTMLButtonElement} element?
         */
        constructor(options?: DropDownButtonModel, element?: string | HTMLButtonElement);
        protected preRender(): void;
        /**
         * Get the properties to be maintained in the persisted state.
         * @returns string
         */
        getPersistData(): string;
        /**
         * To manually open/close DropDownButton.
         * true: To open the drop down Element
         * false: To close the drop down Element
         * @param {boolean} open
         * @returns void
         */
        toggle(open: boolean): void;
        /**
         * Initialize the Component rendering
         * @returns void
         * @private
         */
        render(): void;
        private createPopup();
        private getTargetElement();
        private createItems(items);
        private hasIcon(items, field);
        private createAnchor(item);
        private initialize();
        protected setIconPositionTop(): void;
        private appendArrowSpan();
        protected setActiveElem(): void;
        /**
         * Get component name.
         * @returns string
         * @private
         */
        getModuleName(): string;
        private canOpen();
        /**
         * Destroys the widget.
         * @returns void
         */
        destroy(): void;
        protected getPopUpElement(): HTMLElement;
        protected getULElement(): HTMLElement;
        protected wireEvents(): void;
        protected keyBoardHandler(e: ej.base.KeyboardEventArgs): void;
        protected upDownKeyHandler(e: ej.base.KeyboardEventArgs): void;
        private isValidLI(li, index, keyCode, count?);
        private keyEventHandler(e);
        private getLI(elem);
        private getZIndex();
        protected clickHandler(e: MouseEvent | ej.base.KeyboardEventArgs): void;
        private openPopUp(e?);
        private closePopup(e?);
        protected unWireEvents(): void;
        /**
         * Called internally if any of the property value changed.
         * @param  {DropDownButtonModel} newProp
         * @param  {DropDownButtonModel} oldProp
         * @returns void
         * @private
         */
        onPropertyChanged(newProp: DropDownButtonModel, oldProp: DropDownButtonModel): void;
    }
    /**
     * Interface for before item render / select event.
     * @private
     */
    export interface MenuEventArgs extends ej.base.BaseEventArgs {
        element: HTMLElement;
        item: ItemModel;
    }
    /**
     * Interface for before open / close event.
     * @private
     */
    export interface BeforeOpenCloseMenuEventArgs extends ej.base.BaseEventArgs {
        element: HTMLElement;
        items: ej.navigations.ItemModel[];
        event: Event;
        cancel?: boolean;
    }
    /**
     * Interface for open/close event.
     */
    export interface OpenCloseMenuEventArgs extends ej.base.BaseEventArgs {
        element: HTMLElement;
        items: ej.navigations.ItemModel[];
        parentItem?: ItemModel;
    }
    
    /**
     * Interface for a class SplitButton
     */
    export interface SplitButtonModel extends DropDownButtonModel{
    
        /**
         * Triggers when the primary button has been clicked.
         * @event
         */
        click?: ej.base.EmitType<ClickEventArgs>;
    
    }
    
    /**
     * SplitButton component has primary and secondary button.
     * Primary button is used to select default action and secondary button is used to
     * toggle contextual overlays for displaying list of links that containing action items.
     * It can contain both text and images.
     * ```html
     * <button id="splitBtnObj"></button>
     * ```
     * ```typescript
     * <script>
     * var splitBtnObj = new SplitButton({content: 'SplitButton'});
     * splitBtnObj.appendTo("#splitBtnObj");
     * </script>
     * ```
     */
    export class SplitButton extends DropDownButton implements ej.base.INotifyPropertyChanged {
        private wrapper;
        private primaryBtnObj;
        private secondaryBtnObj;
        /**
         * Triggers when the primary button has been clicked.
         * @event
         */
        click: ej.base.EmitType<ClickEventArgs>;
        /**
         * Constructor for creating the widget
         * @param  {SplitButtonModel} options?
         * @param  {string|HTMLButtonElement} element?
         */
        constructor(options?: SplitButtonModel, element?: string | HTMLButtonElement);
        /**
         * Initialize Angular support.
         * @private
         */
        protected preRender(): void;
        render(): void;
        private initWrapper();
        private createPrimaryButton();
        private createSecondaryButton();
        private setAria();
        /**
         * Get component name.
         * @returns string
         * @private
         */
        getModuleName(): string;
        /**
         * To switch(open/close) the suggestion list of the split button.
         * @returns void
         */
        toggle(open: boolean): void;
        destroy(): void;
        protected wireEvents(): void;
        protected unWireEvents(): void;
        private primaryBtnClickHandler();
        private btnKeyBoardHandler(e);
        /**
         * Called internally if any of the property value changed.
         * @param  {SplitButtonModel} newProp
         * @param  {SplitButtonModel} oldProp
         * @returns void
         */
        onPropertyChanged(newProp: SplitButton, oldProp: SplitButton): void;
    }
    export interface ClickEventArgs extends ej.base.BaseEventArgs {
        element: Element;
    }
    
  }
}